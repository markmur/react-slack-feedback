/******/ (function(modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/ var installedModules = {}; // The require function
  /******/
  /******/ /******/ function __webpack_require__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/ if (installedModules[moduleId]) {
      /******/ return installedModules[moduleId].exports;
      /******/
    } // Create a new module (and put it into the cache)
    /******/ /******/ var module = (installedModules[moduleId] = {
      /******/ i: moduleId,
      /******/ l: false,
      /******/ exports: {}
      /******/
    }); // Execute the module function
    /******/
    /******/ /******/ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    ); // Flag the module as loaded
    /******/
    /******/ /******/ module.l = true; // Return the exports of the module
    /******/
    /******/ /******/ return module.exports;
    /******/
  } // expose the modules object (__webpack_modules__)
  /******/
  /******/
  /******/ /******/ __webpack_require__.m = modules; // expose the module cache
  /******/
  /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
  /******/
  /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
    /******/ if (!__webpack_require__.o(exports, name)) {
      /******/ Object.defineProperty(exports, name, {
        /******/ configurable: false,
        /******/ enumerable: true,
        /******/ get: getter
        /******/
      });
      /******/
    }
    /******/
  }; // define __esModule on exports
  /******/
  /******/ /******/ __webpack_require__.r = function(exports) {
    /******/ Object.defineProperty(exports, '__esModule', { value: true });
    /******/
  }; // getDefaultExport function for compatibility with non-harmony modules
  /******/
  /******/ /******/ __webpack_require__.n = function(module) {
    /******/ var getter =
      module && module.__esModule
        ? /******/ function getDefault() {
            return module['default'];
          }
        : /******/ function getModuleExports() {
            return module;
          };
    /******/ __webpack_require__.d(getter, 'a', getter);
    /******/ return getter;
    /******/
  }; // Object.prototype.hasOwnProperty.call
  /******/
  /******/ /******/ __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }; // __webpack_public_path__
  /******/
  /******/ /******/ __webpack_require__.p = ''; // Load entry module and return exports
  /******/
  /******/
  /******/ /******/ return __webpack_require__(
    (__webpack_require__.s = './src/index.js')
  );
  /******/
})(
  /************************************************************************/
  /******/ {
    /***/ './node_modules/classnames/index.js':
      /*!******************************************!*\
  !*** ./node_modules/classnames/index.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

        function _typeof(obj) {
          if (
            typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === 'function' &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        /*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/

        /* global define */
        (function() {
          'use strict';

          var hasOwn = {}.hasOwnProperty;

          function classNames() {
            var classes = [];

            for (var i = 0; i < arguments.length; i++) {
              var arg = arguments[i];
              if (!arg) continue;

              var argType = _typeof(arg);

              if (argType === 'string' || argType === 'number') {
                classes.push(arg);
              } else if (Array.isArray(arg)) {
                classes.push(classNames.apply(null, arg));
              } else if (argType === 'object') {
                for (var key in arg) {
                  if (hasOwn.call(arg, key) && arg[key]) {
                    classes.push(key);
                  }
                }
              }
            }

            return classes.join(' ');
          }

          if (typeof module !== 'undefined' && module.exports) {
            module.exports = classNames;
          } else if (
            'function' === 'function' &&
            _typeof(
              __webpack_require__(
                /*! !webpack amd options */ './node_modules/webpack/buildin/amd-options.js'
              )
            ) === 'object' &&
            __webpack_require__(
              /*! !webpack amd options */ './node_modules/webpack/buildin/amd-options.js'
            )
          ) {
            // register as 'classnames', consistent with npm package name
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
            (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
              return classNames;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
            window.classNames = classNames;
          }
        })();

        /***/
      },

    /***/ './node_modules/fbjs/lib/EventListener.js':
      /*!************************************************!*\
  !*** ./node_modules/fbjs/lib/EventListener.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var emptyFunction = __webpack_require__(
            /*! ./emptyFunction */ './node_modules/fbjs/lib/emptyFunction.js'
          );
          /**
           * Upstream version of event listener. Does not take into account specific
           * nature of platform.
           */

          var EventListener = {
            /**
             * Listen to DOM events during the bubble phase.
             *
             * @param {DOMEventTarget} target DOM element to register listener on.
             * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
             * @param {function} callback Callback function.
             * @return {object} Object with a `remove` method.
             */
            listen: function listen(target, eventType, callback) {
              if (target.addEventListener) {
                target.addEventListener(eventType, callback, false);
                return {
                  remove: function remove() {
                    target.removeEventListener(eventType, callback, false);
                  }
                };
              } else if (target.attachEvent) {
                target.attachEvent('on' + eventType, callback);
                return {
                  remove: function remove() {
                    target.detachEvent('on' + eventType, callback);
                  }
                };
              }
            },

            /**
             * Listen to DOM events during the capture phase.
             *
             * @param {DOMEventTarget} target DOM element to register listener on.
             * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
             * @param {function} callback Callback function.
             * @return {object} Object with a `remove` method.
             */
            capture: function capture(target, eventType, callback) {
              if (target.addEventListener) {
                target.addEventListener(eventType, callback, true);
                return {
                  remove: function remove() {
                    target.removeEventListener(eventType, callback, true);
                  }
                };
              } else {
                if (true) {
                  console.error(
                    'Attempted to listen to events during the capture phase on a ' +
                      'browser that does not support the capture phase. Your application ' +
                      'will not receive some events.'
                  );
                }

                return {
                  remove: emptyFunction
                };
              }
            },
            registerDefault: function registerDefault() {}
          };
          module.exports = EventListener;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              EventListener,
              'EventListener',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/EventListener.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/ExecutionEnvironment.js':
      /*!*******************************************************!*\
  !*** ./node_modules/fbjs/lib/ExecutionEnvironment.js ***!
  \*******************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var canUseDOM = !!(
            typeof window !== 'undefined' &&
            window.document &&
            window.document.createElement
          );
          /**
           * Simple, lightweight module assisting with the detection and context of
           * Worker. Helps avoid circular dependencies and allows code to reason about
           * whether or not they are in a Worker, even if they never include the main
           * `ReactWorker` dependency.
           */

          var ExecutionEnvironment = {
            canUseDOM: canUseDOM,
            canUseWorkers: typeof Worker !== 'undefined',
            canUseEventListeners:
              canUseDOM && !!(window.addEventListener || window.attachEvent),
            canUseViewport: canUseDOM && !!window.screen,
            isInWorker: !canUseDOM // For now, this is true - might change in the future.
          };
          module.exports = ExecutionEnvironment;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              canUseDOM,
              'canUseDOM',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/ExecutionEnvironment.js'
            );
            reactHotLoader.register(
              ExecutionEnvironment,
              'ExecutionEnvironment',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/ExecutionEnvironment.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/camelize.js':
      /*!*******************************************!*\
  !*** ./node_modules/fbjs/lib/camelize.js ***!
  \*******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var _hyphenPattern = /-(.)/g;
          /**
           * Camelcases a hyphenated string, for example:
           *
           *   > camelize('background-color')
           *   < "backgroundColor"
           *
           * @param {string} string
           * @return {string}
           */

          function camelize(string) {
            return string.replace(_hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          }

          module.exports = camelize;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              _hyphenPattern,
              '_hyphenPattern',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/camelize.js'
            );
            reactHotLoader.register(
              camelize,
              'camelize',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/camelize.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/camelizeStyleName.js':
      /*!****************************************************!*\
  !*** ./node_modules/fbjs/lib/camelizeStyleName.js ***!
  \****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var camelize = __webpack_require__(
            /*! ./camelize */ './node_modules/fbjs/lib/camelize.js'
          );

          var msPattern = /^-ms-/;
          /**
           * Camelcases a hyphenated CSS property name, for example:
           *
           *   > camelizeStyleName('background-color')
           *   < "backgroundColor"
           *   > camelizeStyleName('-moz-transition')
           *   < "MozTransition"
           *   > camelizeStyleName('-ms-transition')
           *   < "msTransition"
           *
           * As Andi Smith suggests
           * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
           * is converted to lowercase `ms`.
           *
           * @param {string} string
           * @return {string}
           */

          function camelizeStyleName(string) {
            return camelize(string.replace(msPattern, 'ms-'));
          }

          module.exports = camelizeStyleName;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              msPattern,
              'msPattern',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/camelizeStyleName.js'
            );
            reactHotLoader.register(
              camelizeStyleName,
              'camelizeStyleName',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/camelizeStyleName.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/containsNode.js':
      /*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/containsNode.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           *
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var isTextNode = __webpack_require__(
            /*! ./isTextNode */ './node_modules/fbjs/lib/isTextNode.js'
          );
          /*eslint-disable no-bitwise */

          /**
           * Checks if a given DOM node contains or is another DOM node.
           */

          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ('contains' in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }

          module.exports = containsNode;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              containsNode,
              'containsNode',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/containsNode.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/emptyFunction.js':
      /*!************************************************!*\
  !*** ./node_modules/fbjs/lib/emptyFunction.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           *
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function makeEmptyFunction(arg) {
            return function() {
              return arg;
            };
          }
          /**
           * This function accepts and discards inputs; it has no side effects. This is
           * primarily useful idiomatically for overridable function endpoints which
           * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
           */

          var emptyFunction = function emptyFunction() {};

          emptyFunction.thatReturns = makeEmptyFunction;
          emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
          emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
          emptyFunction.thatReturnsNull = makeEmptyFunction(null);

          emptyFunction.thatReturnsThis = function() {
            return this;
          };

          emptyFunction.thatReturnsArgument = function(arg) {
            return arg;
          };

          module.exports = emptyFunction;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              makeEmptyFunction,
              'makeEmptyFunction',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/emptyFunction.js'
            );
            reactHotLoader.register(
              emptyFunction,
              'emptyFunction',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/emptyFunction.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/emptyObject.js':
      /*!**********************************************!*\
  !*** ./node_modules/fbjs/lib/emptyObject.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var emptyObject = {};

          if (true) {
            Object.freeze(emptyObject);
          }

          module.exports = emptyObject;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              emptyObject,
              'emptyObject',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/emptyObject.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/focusNode.js':
      /*!********************************************!*\
  !*** ./node_modules/fbjs/lib/focusNode.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           */

          /**
           * @param {DOMElement} node input/textarea to focus
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function focusNode(node) {
            // IE8 can throw "Can't move focus to the control because it is invisible,
            // not enabled, or of a type that does not accept the focus." for all kinds of
            // reasons that are too expensive and fragile to test.
            try {
              node.focus();
            } catch (e) {}
          }

          module.exports = focusNode;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              focusNode,
              'focusNode',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/focusNode.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/getActiveElement.js':
      /*!***************************************************!*\
  !*** ./node_modules/fbjs/lib/getActiveElement.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */

          /* eslint-disable fb-www/typeof-undefined */

          /**
           * Same as document.activeElement but wraps in a try-catch block. In IE it is
           * not safe to call document.activeElement if there is nothing focused.
           *
           * The activeElement will be null only if the document or document body is not
           * yet defined.
           *
           * @param {?DOMDocument} doc Defaults to current document.
           * @return {?DOMElement}
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function getActiveElement(doc /*?DOMElement*/) {
            doc =
              doc || (typeof document !== 'undefined' ? document : undefined);

            if (typeof doc === 'undefined') {
              return null;
            }

            try {
              return doc.activeElement || doc.body;
            } catch (e) {
              return doc.body;
            }
          }

          module.exports = getActiveElement;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              getActiveElement,
              'getActiveElement',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/getActiveElement.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/hyphenate.js':
      /*!********************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenate.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var _uppercasePattern = /([A-Z])/g;
          /**
           * Hyphenates a camelcased string, for example:
           *
           *   > hyphenate('backgroundColor')
           *   < "background-color"
           *
           * For CSS style names, use `hyphenateStyleName` instead which works properly
           * with all vendor prefixes, including `ms`.
           *
           * @param {string} string
           * @return {string}
           */

          function hyphenate(string) {
            return string.replace(_uppercasePattern, '-$1').toLowerCase();
          }

          module.exports = hyphenate;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              _uppercasePattern,
              '_uppercasePattern',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/hyphenate.js'
            );
            reactHotLoader.register(
              hyphenate,
              'hyphenate',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/hyphenate.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/hyphenateStyleName.js':
      /*!*****************************************************!*\
  !*** ./node_modules/fbjs/lib/hyphenateStyleName.js ***!
  \*****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var hyphenate = __webpack_require__(
            /*! ./hyphenate */ './node_modules/fbjs/lib/hyphenate.js'
          );

          var msPattern = /^ms-/;
          /**
           * Hyphenates a camelcased CSS property name, for example:
           *
           *   > hyphenateStyleName('backgroundColor')
           *   < "background-color"
           *   > hyphenateStyleName('MozTransition')
           *   < "-moz-transition"
           *   > hyphenateStyleName('msTransition')
           *   < "-ms-transition"
           *
           * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
           * is converted to `-ms-`.
           *
           * @param {string} string
           * @return {string}
           */

          function hyphenateStyleName(string) {
            return hyphenate(string).replace(msPattern, '-ms-');
          }

          module.exports = hyphenateStyleName;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              msPattern,
              'msPattern',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/hyphenateStyleName.js'
            );
            reactHotLoader.register(
              hyphenateStyleName,
              'hyphenateStyleName',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/hyphenateStyleName.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/invariant.js':
      /*!********************************************!*\
  !*** ./node_modules/fbjs/lib/invariant.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           */

          /**
           * Use invariant() to assert state which your program assumes to be true.
           *
           * Provide sprintf-style format (only %s is supported) and arguments
           * to provide information about what broke and what you were
           * expecting.
           *
           * The invariant message will be stripped in production, but the invariant
           * will remain to ensure logic does not differ in production.
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var validateFormat = function validateFormat(format) {};

          if (true) {
            validateFormat = function validateFormat(format) {
              if (format === undefined) {
                throw new Error('invariant requires an error message argument');
              }
            };
          }

          function invariant(condition, format, a, b, c, d, e, f) {
            validateFormat(format);

            if (!condition) {
              var error;

              if (format === undefined) {
                error = new Error(
                  'Minified exception occurred; use the non-minified dev environment ' +
                    'for the full error message and additional helpful warnings.'
                );
              } else {
                var args = [a, b, c, d, e, f];
                var argIndex = 0;
                error = new Error(
                  format.replace(/%s/g, function() {
                    return args[argIndex++];
                  })
                );
                error.name = 'Invariant Violation';
              }

              error.framesToPop = 1; // we don't care about invariant's own frame

              throw error;
            }
          }

          module.exports = invariant;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              validateFormat,
              'validateFormat',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/invariant.js'
            );
            reactHotLoader.register(
              invariant,
              'invariant',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/invariant.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/isNode.js':
      /*!*****************************************!*\
  !*** ./node_modules/fbjs/lib/isNode.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */

          /**
           * @param {*} object The object to check.
           * @return {boolean} Whether or not the object is a DOM node.
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          function isNode(object) {
            var doc = object ? object.ownerDocument || object : document;
            var defaultView = doc.defaultView || window;
            return !!(
              object &&
              (typeof defaultView.Node === 'function'
                ? object instanceof defaultView.Node
                : _typeof(object) === 'object' &&
                  typeof object.nodeType === 'number' &&
                  typeof object.nodeName === 'string')
            );
          }

          module.exports = isNode;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              isNode,
              'isNode',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/isNode.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/isTextNode.js':
      /*!*********************************************!*\
  !*** ./node_modules/fbjs/lib/isTextNode.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var isNode = __webpack_require__(
            /*! ./isNode */ './node_modules/fbjs/lib/isNode.js'
          );
          /**
           * @param {*} object The object to check.
           * @return {boolean} Whether or not the object is a DOM text node.
           */

          function isTextNode(object) {
            return isNode(object) && object.nodeType == 3;
          }

          module.exports = isTextNode;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              isTextNode,
              'isTextNode',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/isTextNode.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/shallowEqual.js':
      /*!***********************************************!*\
  !*** ./node_modules/fbjs/lib/shallowEqual.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           *
           */

          /*eslint-disable no-self-compare */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          var hasOwnProperty = Object.prototype.hasOwnProperty;
          /**
           * inlined Object.is polyfill to avoid requiring consumers ship their own
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
           */

          function is(x, y) {
            // SameValue algorithm
            if (x === y) {
              // Steps 1-5, 7-10
              // Steps 6.b-6.e: +0 != -0
              // Added the nonzero y check to make Flow happy, but it is redundant
              return x !== 0 || y !== 0 || 1 / x === 1 / y;
            } else {
              // Step 6.a: NaN == NaN
              return x !== x && y !== y;
            }
          }
          /**
           * Performs equality by iterating through keys on an object and returning false
           * when any key has values which are not strictly equal between the arguments.
           * Returns true when the values of all keys are strictly equal.
           */

          function shallowEqual(objA, objB) {
            if (is(objA, objB)) {
              return true;
            }

            if (
              _typeof(objA) !== 'object' ||
              objA === null ||
              _typeof(objB) !== 'object' ||
              objB === null
            ) {
              return false;
            }

            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);

            if (keysA.length !== keysB.length) {
              return false;
            } // Test for A's keys different from B.

            for (var i = 0; i < keysA.length; i++) {
              if (
                !hasOwnProperty.call(objB, keysA[i]) ||
                !is(objA[keysA[i]], objB[keysA[i]])
              ) {
                return false;
              }
            }

            return true;
          }

          module.exports = shallowEqual;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              hasOwnProperty,
              'hasOwnProperty',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/shallowEqual.js'
            );
            reactHotLoader.register(
              is,
              'is',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/shallowEqual.js'
            );
            reactHotLoader.register(
              shallowEqual,
              'shallowEqual',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/shallowEqual.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/fbjs/lib/warning.js':
      /*!******************************************!*\
  !*** ./node_modules/fbjs/lib/warning.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2014-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var emptyFunction = __webpack_require__(
            /*! ./emptyFunction */ './node_modules/fbjs/lib/emptyFunction.js'
          );
          /**
           * Similar to invariant but only logs a warning if the condition is not met.
           * This can be used to log issues in development environments in critical
           * paths. Removing the logging code for production environments will keep the
           * same logic and follow the same code paths.
           */

          var warning = emptyFunction;

          if (true) {
            var printWarning = function printWarning(format) {
              for (
                var _len = arguments.length,
                  args = Array(_len > 1 ? _len - 1 : 0),
                  _key = 1;
                _key < _len;
                _key++
              ) {
                args[_key - 1] = arguments[_key];
              }

              var argIndex = 0;
              var message =
                'Warning: ' +
                format.replace(/%s/g, function() {
                  return args[argIndex++];
                });

              if (typeof console !== 'undefined') {
                console.error(message);
              }

              try {
                // --- Welcome to debugging React ---
                // This error was thrown as a convenience so that you can use this stack
                // to find the callsite that caused this warning to fire.
                throw new Error(message);
              } catch (x) {}
            };

            warning = function warning(condition, format) {
              if (format === undefined) {
                throw new Error(
                  '`warning(condition, format, ...args)` requires a warning ' +
                    'message argument'
                );
              }

              if (format.indexOf('Failed Composite propType: ') === 0) {
                return; // Ignore CompositeComponent proptype check.
              }

              if (!condition) {
                for (
                  var _len2 = arguments.length,
                    args = Array(_len2 > 2 ? _len2 - 2 : 0),
                    _key2 = 2;
                  _key2 < _len2;
                  _key2++
                ) {
                  args[_key2 - 2] = arguments[_key2];
                }

                printWarning.apply(undefined, [format].concat(args));
              }
            };
          }

          module.exports = warning;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              warning,
              'warning',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/warning.js'
            );
            reactHotLoader.register(
              printWarning,
              'printWarning',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/fbjs/lib/warning.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/is-plain-object/index.js':
      /*!***********************************************!*\
  !*** ./node_modules/is-plain-object/index.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var isObject = __webpack_require__(
            /*! isobject */ './node_modules/isobject/index.js'
          );

          function isObjectObject(o) {
            return (
              isObject(o) === true &&
              Object.prototype.toString.call(o) === '[object Object]'
            );
          }

          module.exports = function isPlainObject(o) {
            var ctor, prot;
            if (isObjectObject(o) === false) return false; // If has modified constructor

            ctor = o.constructor;
            if (typeof ctor !== 'function') return false; // If has modified prototype

            prot = ctor.prototype;
            if (isObjectObject(prot) === false) return false; // If constructor does not have an Object-specific method

            if (prot.hasOwnProperty('isPrototypeOf') === false) {
              return false;
            } // Most likely a plain Object

            return true;
          };

          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              isObjectObject,
              'isObjectObject',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/is-plain-object/index.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/isobject/index.js':
      /*!****************************************!*\
  !*** ./node_modules/isobject/index.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

        function _typeof(obj) {
          if (
            typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === 'function' &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        module.exports = function isObject(val) {
          return (
            val != null &&
            _typeof(val) === 'object' &&
            Array.isArray(val) === false
          );
        };

        /***/
      },

    /***/ './node_modules/isomorphic-fetch/fetch-npm-browserify.js':
      /*!***************************************************************!*\
  !*** ./node_modules/isomorphic-fetch/fetch-npm-browserify.js ***!
  \***************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';

        // the whatwg-fetch polyfill installs the fetch() function
        // on the global object (window or self)
        //
        // Return that as the export for use in Webpack, Browserify etc.
        __webpack_require__(
          /*! whatwg-fetch */ './node_modules/whatwg-fetch/fetch.js'
        );

        module.exports = self.fetch.bind(self);

        /***/
      },

    /***/ './node_modules/object-assign/index.js':
      /*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /*
object-assign
(c) Sindre Sorhus
@license MIT
*/

          /* eslint-disable no-unused-vars */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var getOwnPropertySymbols = Object.getOwnPropertySymbols;
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var propIsEnumerable = Object.prototype.propertyIsEnumerable;

          function toObject(val) {
            if (val === null || val === undefined) {
              throw new TypeError(
                'Object.assign cannot be called with null or undefined'
              );
            }

            return Object(val);
          }

          function shouldUseNative() {
            try {
              if (!Object.assign) {
                return false;
              } // Detect buggy property enumeration order in older V8 versions.
              // https://bugs.chromium.org/p/v8/issues/detail?id=4118

              var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

              test1[5] = 'de';

              if (Object.getOwnPropertyNames(test1)[0] === '5') {
                return false;
              } // https://bugs.chromium.org/p/v8/issues/detail?id=3056

              var test2 = {};

              for (var i = 0; i < 10; i++) {
                test2['_' + String.fromCharCode(i)] = i;
              }

              var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                return test2[n];
              });

              if (order2.join('') !== '0123456789') {
                return false;
              } // https://bugs.chromium.org/p/v8/issues/detail?id=3056

              var test3 = {};
              'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
                test3[letter] = letter;
              });

              if (
                Object.keys(Object.assign({}, test3)).join('') !==
                'abcdefghijklmnopqrst'
              ) {
                return false;
              }

              return true;
            } catch (err) {
              // We don't expect any of the above to throw, but better to be safe.
              return false;
            }
          }

          module.exports = shouldUseNative()
            ? Object.assign
            : function(target, source) {
                var from;
                var to = toObject(target);
                var symbols;

                for (var s = 1; s < arguments.length; s++) {
                  from = Object(arguments[s]);

                  for (var key in from) {
                    if (hasOwnProperty.call(from, key)) {
                      to[key] = from[key];
                    }
                  }

                  if (getOwnPropertySymbols) {
                    symbols = getOwnPropertySymbols(from);

                    for (var i = 0; i < symbols.length; i++) {
                      if (propIsEnumerable.call(from, symbols[i])) {
                        to[symbols[i]] = from[symbols[i]];
                      }
                    }
                  }
                }

                return to;
              };
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              getOwnPropertySymbols,
              'getOwnPropertySymbols',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/object-assign/index.js'
            );
            reactHotLoader.register(
              hasOwnProperty,
              'hasOwnProperty',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/object-assign/index.js'
            );
            reactHotLoader.register(
              propIsEnumerable,
              'propIsEnumerable',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/object-assign/index.js'
            );
            reactHotLoader.register(
              toObject,
              'toObject',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/object-assign/index.js'
            );
            reactHotLoader.register(
              shouldUseNative,
              'shouldUseNative',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/object-assign/index.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/prop-types/checkPropTypes.js':
      /*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          if (true) {
            var invariant = __webpack_require__(
              /*! fbjs/lib/invariant */ './node_modules/fbjs/lib/invariant.js'
            );

            var warning = __webpack_require__(
              /*! fbjs/lib/warning */ './node_modules/fbjs/lib/warning.js'
            );

            var ReactPropTypesSecret = __webpack_require__(
              /*! ./lib/ReactPropTypesSecret */ './node_modules/prop-types/lib/ReactPropTypesSecret.js'
            );

            var loggedTypeFailures = {};
          }
          /**
           * Assert that the values match with the type specs.
           * Error messages are memorized and will only be shown once.
           *
           * @param {object} typeSpecs Map of name to a ReactPropType
           * @param {object} values Runtime values that need to be type-checked
           * @param {string} location e.g. "prop", "context", "child context"
           * @param {string} componentName Name of the component for error messages.
           * @param {?Function} getStack Returns the component stack.
           * @private
           */

          function checkPropTypes(
            typeSpecs,
            values,
            location,
            componentName,
            getStack
          ) {
            if (true) {
              for (var typeSpecName in typeSpecs) {
                if (typeSpecs.hasOwnProperty(typeSpecName)) {
                  var error; // Prop type validation may throw. In case they do, we don't want to
                  // fail the render phase where it didn't fail before. So we log it.
                  // After these have been cleaned up, we'll let them throw.

                  try {
                    // This is intentionally an invariant that gets caught. It's the same
                    // behavior as without this statement except with a better message.
                    invariant(
                      typeof typeSpecs[typeSpecName] === 'function',
                      '%s: %s type `%s` is invalid; it must be a function, usually from ' +
                        'the `prop-types` package, but received `%s`.',
                      componentName || 'React class',
                      location,
                      typeSpecName,
                      _typeof(typeSpecs[typeSpecName])
                    );
                    error = typeSpecs[typeSpecName](
                      values,
                      typeSpecName,
                      componentName,
                      location,
                      null,
                      ReactPropTypesSecret
                    );
                  } catch (ex) {
                    error = ex;
                  }

                  warning(
                    !error || error instanceof Error,
                    '%s: type specification of %s `%s` is invalid; the type checker ' +
                      'function must return `null` or an `Error` but returned a %s. ' +
                      'You may have forgotten to pass an argument to the type checker ' +
                      'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
                      'shape all require an argument).',
                    componentName || 'React class',
                    location,
                    typeSpecName,
                    _typeof(error)
                  );

                  if (
                    error instanceof Error &&
                    !(error.message in loggedTypeFailures)
                  ) {
                    // Only monitor this failure once because there tends to be a lot of the
                    // same error.
                    loggedTypeFailures[error.message] = true;
                    var stack = getStack ? getStack() : '';
                    warning(
                      false,
                      'Failed %s type: %s%s',
                      location,
                      error.message,
                      stack != null ? stack : ''
                    );
                  }
                }
              }
            }
          }

          module.exports = checkPropTypes;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              loggedTypeFailures,
              'loggedTypeFailures',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/prop-types/checkPropTypes.js'
            );
            reactHotLoader.register(
              checkPropTypes,
              'checkPropTypes',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/prop-types/checkPropTypes.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/prop-types/factoryWithTypeCheckers.js':
      /*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /**
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        function _typeof(obj) {
          if (
            typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === 'function' &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        var emptyFunction = __webpack_require__(
          /*! fbjs/lib/emptyFunction */ './node_modules/fbjs/lib/emptyFunction.js'
        );

        var invariant = __webpack_require__(
          /*! fbjs/lib/invariant */ './node_modules/fbjs/lib/invariant.js'
        );

        var warning = __webpack_require__(
          /*! fbjs/lib/warning */ './node_modules/fbjs/lib/warning.js'
        );

        var assign = __webpack_require__(
          /*! object-assign */ './node_modules/object-assign/index.js'
        );

        var ReactPropTypesSecret = __webpack_require__(
          /*! ./lib/ReactPropTypesSecret */ './node_modules/prop-types/lib/ReactPropTypesSecret.js'
        );

        var checkPropTypes = __webpack_require__(
          /*! ./checkPropTypes */ './node_modules/prop-types/checkPropTypes.js'
        );

        module.exports = function(isValidElement, throwOnDirectAccess) {
          /* global Symbol */
          var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

          /**
           * Returns the iterator method function contained on the iterable object.
           *
           * Be sure to invoke the function with the iterable as context:
           *
           *     var iteratorFn = getIteratorFn(myIterable);
           *     if (iteratorFn) {
           *       var iterator = iteratorFn.call(myIterable);
           *       ...
           *     }
           *
           * @param {?object} maybeIterable
           * @return {?function}
           */

          function getIteratorFn(maybeIterable) {
            var iteratorFn =
              maybeIterable &&
              ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
                maybeIterable[FAUX_ITERATOR_SYMBOL]);

            if (typeof iteratorFn === 'function') {
              return iteratorFn;
            }
          }
          /**
           * Collection of methods that allow declaration and validation of props that are
           * supplied to React components. Example usage:
           *
           *   var Props = require('ReactPropTypes');
           *   var MyArticle = React.createClass({
           *     propTypes: {
           *       // An optional string prop named "description".
           *       description: Props.string,
           *
           *       // A required enum prop named "category".
           *       category: Props.oneOf(['News','Photos']).isRequired,
           *
           *       // A prop named "dialog" that requires an instance of Dialog.
           *       dialog: Props.instanceOf(Dialog).isRequired
           *     },
           *     render: function() { ... }
           *   });
           *
           * A more formal specification of how these methods are used:
           *
           *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
           *   decl := ReactPropTypes.{type}(.isRequired)?
           *
           * Each and every declaration produces a function with the same signature. This
           * allows the creation of custom validation functions. For example:
           *
           *  var MyLink = React.createClass({
           *    propTypes: {
           *      // An optional string or URI prop named "href".
           *      href: function(props, propName, componentName) {
           *        var propValue = props[propName];
           *        if (propValue != null && typeof propValue !== 'string' &&
           *            !(propValue instanceof URI)) {
           *          return new Error(
           *            'Expected a string or an URI for ' + propName + ' in ' +
           *            componentName
           *          );
           *        }
           *      }
           *    },
           *    render: function() {...}
           *  });
           *
           * @internal
           */

          var ANONYMOUS = '<<anonymous>>'; // Important!
          // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.

          var ReactPropTypes = {
            array: createPrimitiveTypeChecker('array'),
            bool: createPrimitiveTypeChecker('boolean'),
            func: createPrimitiveTypeChecker('function'),
            number: createPrimitiveTypeChecker('number'),
            object: createPrimitiveTypeChecker('object'),
            string: createPrimitiveTypeChecker('string'),
            symbol: createPrimitiveTypeChecker('symbol'),
            any: createAnyTypeChecker(),
            arrayOf: createArrayOfTypeChecker,
            element: createElementTypeChecker(),
            instanceOf: createInstanceTypeChecker,
            node: createNodeChecker(),
            objectOf: createObjectOfTypeChecker,
            oneOf: createEnumTypeChecker,
            oneOfType: createUnionTypeChecker,
            shape: createShapeTypeChecker,
            exact: createStrictShapeTypeChecker
          };
          /**
           * inlined Object.is polyfill to avoid requiring consumers ship their own
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
           */

          /*eslint-disable no-self-compare*/

          function is(x, y) {
            // SameValue algorithm
            if (x === y) {
              // Steps 1-5, 7-10
              // Steps 6.b-6.e: +0 != -0
              return x !== 0 || 1 / x === 1 / y;
            } else {
              // Step 6.a: NaN == NaN
              return x !== x && y !== y;
            }
          }
          /*eslint-enable no-self-compare*/

          /**
           * We use an Error-like object for backward compatibility as people may call
           * PropTypes directly and inspect their output. However, we don't use real
           * Errors anymore. We don't inspect their stack anyway, and creating them
           * is prohibitively expensive if they are created too often, such as what
           * happens in oneOfType() for any type before the one that matched.
           */

          function PropTypeError(message) {
            this.message = message;
            this.stack = '';
          } // Make `instanceof Error` still work for returned errors.

          PropTypeError.prototype = Error.prototype;

          function createChainableTypeChecker(validate) {
            if (true) {
              var manualPropTypeCallCache = {};
              var manualPropTypeWarningCount = 0;
            }

            function checkType(
              isRequired,
              props,
              propName,
              componentName,
              location,
              propFullName,
              secret
            ) {
              componentName = componentName || ANONYMOUS;
              propFullName = propFullName || propName;

              if (secret !== ReactPropTypesSecret) {
                if (throwOnDirectAccess) {
                  // New behavior only for users of `prop-types` package
                  invariant(
                    false,
                    'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                      'Use `PropTypes.checkPropTypes()` to call them. ' +
                      'Read more at http://fb.me/use-check-prop-types'
                  );
                } else if (
                  'development' !== 'production' &&
                  typeof console !== 'undefined'
                ) {
                  // Old behavior for people using React.PropTypes
                  var cacheKey = componentName + ':' + propName;

                  if (
                    !manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3
                  ) {
                    warning(
                      false,
                      'You are manually calling a React.PropTypes validation ' +
                        'function for the `%s` prop on `%s`. This is deprecated ' +
                        'and will throw in the standalone `prop-types` package. ' +
                        'You may be seeing this warning due to a third-party PropTypes ' +
                        'library. See https://fb.me/react-warning-dont-call-proptypes ' +
                        'for details.',
                      propFullName,
                      componentName
                    );
                    manualPropTypeCallCache[cacheKey] = true;
                    manualPropTypeWarningCount++;
                  }
                }
              }

              if (props[propName] == null) {
                if (isRequired) {
                  if (props[propName] === null) {
                    return new PropTypeError(
                      'The ' +
                        location +
                        ' `' +
                        propFullName +
                        '` is marked as required ' +
                        ('in `' + componentName + '`, but its value is `null`.')
                    );
                  }

                  return new PropTypeError(
                    'The ' +
                      location +
                      ' `' +
                      propFullName +
                      '` is marked as required in ' +
                      ('`' + componentName + '`, but its value is `undefined`.')
                  );
                }

                return null;
              } else {
                return validate(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName
                );
              }
            }

            var chainedCheckType = checkType.bind(null, false);
            chainedCheckType.isRequired = checkType.bind(null, true);
            return chainedCheckType;
          }

          function createPrimitiveTypeChecker(expectedType) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName,
              secret
            ) {
              var propValue = props[propName];
              var propType = getPropType(propValue);

              if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);
                return new PropTypeError(
                  'Invalid ' +
                    location +
                    ' `' +
                    propFullName +
                    '` of type ' +
                    ('`' +
                      preciseType +
                      '` supplied to `' +
                      componentName +
                      '`, expected ') +
                    ('`' + expectedType + '`.')
                );
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createAnyTypeChecker() {
            return createChainableTypeChecker(emptyFunction.thatReturnsNull);
          }

          function createArrayOfTypeChecker(typeChecker) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              if (typeof typeChecker !== 'function') {
                return new PropTypeError(
                  'Property `' +
                    propFullName +
                    '` of component `' +
                    componentName +
                    '` has invalid PropType notation inside arrayOf.'
                );
              }

              var propValue = props[propName];

              if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError(
                  'Invalid ' +
                    location +
                    ' `' +
                    propFullName +
                    '` of type ' +
                    ('`' +
                      propType +
                      '` supplied to `' +
                      componentName +
                      '`, expected an array.')
                );
              }

              for (var i = 0; i < propValue.length; i++) {
                var error = typeChecker(
                  propValue,
                  i,
                  componentName,
                  location,
                  propFullName + '[' + i + ']',
                  ReactPropTypesSecret
                );

                if (error instanceof Error) {
                  return error;
                }
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createElementTypeChecker() {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              var propValue = props[propName];

              if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError(
                  'Invalid ' +
                    location +
                    ' `' +
                    propFullName +
                    '` of type ' +
                    ('`' +
                      propType +
                      '` supplied to `' +
                      componentName +
                      '`, expected a single ReactElement.')
                );
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createInstanceTypeChecker(expectedClass) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError(
                  'Invalid ' +
                    location +
                    ' `' +
                    propFullName +
                    '` of type ' +
                    ('`' +
                      actualClassName +
                      '` supplied to `' +
                      componentName +
                      '`, expected ') +
                    ('instance of `' + expectedClassName + '`.')
                );
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createEnumTypeChecker(expectedValues) {
            if (!Array.isArray(expectedValues)) {
              true
                ? warning(
                    false,
                    'Invalid argument supplied to oneOf, expected an instance of array.'
                  )
                : undefined;
              return emptyFunction.thatReturnsNull;
            }

            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              var propValue = props[propName];

              for (var i = 0; i < expectedValues.length; i++) {
                if (is(propValue, expectedValues[i])) {
                  return null;
                }
              }

              var valuesString = JSON.stringify(expectedValues);
              return new PropTypeError(
                'Invalid ' +
                  location +
                  ' `' +
                  propFullName +
                  '` of value `' +
                  propValue +
                  '` ' +
                  ('supplied to `' +
                    componentName +
                    '`, expected one of ' +
                    valuesString +
                    '.')
              );
            }

            return createChainableTypeChecker(validate);
          }

          function createObjectOfTypeChecker(typeChecker) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              if (typeof typeChecker !== 'function') {
                return new PropTypeError(
                  'Property `' +
                    propFullName +
                    '` of component `' +
                    componentName +
                    '` has invalid PropType notation inside objectOf.'
                );
              }

              var propValue = props[propName];
              var propType = getPropType(propValue);

              if (propType !== 'object') {
                return new PropTypeError(
                  'Invalid ' +
                    location +
                    ' `' +
                    propFullName +
                    '` of type ' +
                    ('`' +
                      propType +
                      '` supplied to `' +
                      componentName +
                      '`, expected an object.')
                );
              }

              for (var key in propValue) {
                if (propValue.hasOwnProperty(key)) {
                  var error = typeChecker(
                    propValue,
                    key,
                    componentName,
                    location,
                    propFullName + '.' + key,
                    ReactPropTypesSecret
                  );

                  if (error instanceof Error) {
                    return error;
                  }
                }
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createUnionTypeChecker(arrayOfTypeCheckers) {
            if (!Array.isArray(arrayOfTypeCheckers)) {
              true
                ? warning(
                    false,
                    'Invalid argument supplied to oneOfType, expected an instance of array.'
                  )
                : undefined;
              return emptyFunction.thatReturnsNull;
            }

            for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
              var checker = arrayOfTypeCheckers[i];

              if (typeof checker !== 'function') {
                warning(
                  false,
                  'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
                    'received %s at index %s.',
                  getPostfixForTypeWarning(checker),
                  i
                );
                return emptyFunction.thatReturnsNull;
              }
            }

            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                var checker = arrayOfTypeCheckers[i];

                if (
                  checker(
                    props,
                    propName,
                    componentName,
                    location,
                    propFullName,
                    ReactPropTypesSecret
                  ) == null
                ) {
                  return null;
                }
              }

              return new PropTypeError(
                'Invalid ' +
                  location +
                  ' `' +
                  propFullName +
                  '` supplied to ' +
                  ('`' + componentName + '`.')
              );
            }

            return createChainableTypeChecker(validate);
          }

          function createNodeChecker() {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              if (!isNode(props[propName])) {
                return new PropTypeError(
                  'Invalid ' +
                    location +
                    ' `' +
                    propFullName +
                    '` supplied to ' +
                    ('`' + componentName + '`, expected a ReactNode.')
                );
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createShapeTypeChecker(shapeTypes) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              var propValue = props[propName];
              var propType = getPropType(propValue);

              if (propType !== 'object') {
                return new PropTypeError(
                  'Invalid ' +
                    location +
                    ' `' +
                    propFullName +
                    '` of type `' +
                    propType +
                    '` ' +
                    ('supplied to `' + componentName + '`, expected `object`.')
                );
              }

              for (var key in shapeTypes) {
                var checker = shapeTypes[key];

                if (!checker) {
                  continue;
                }

                var error = checker(
                  propValue,
                  key,
                  componentName,
                  location,
                  propFullName + '.' + key,
                  ReactPropTypesSecret
                );

                if (error) {
                  return error;
                }
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function createStrictShapeTypeChecker(shapeTypes) {
            function validate(
              props,
              propName,
              componentName,
              location,
              propFullName
            ) {
              var propValue = props[propName];
              var propType = getPropType(propValue);

              if (propType !== 'object') {
                return new PropTypeError(
                  'Invalid ' +
                    location +
                    ' `' +
                    propFullName +
                    '` of type `' +
                    propType +
                    '` ' +
                    ('supplied to `' + componentName + '`, expected `object`.')
                );
              } // We need to check all keys in case some are required but missing from
              // props.

              var allKeys = assign({}, props[propName], shapeTypes);

              for (var key in allKeys) {
                var checker = shapeTypes[key];

                if (!checker) {
                  return new PropTypeError(
                    'Invalid ' +
                      location +
                      ' `' +
                      propFullName +
                      '` key `' +
                      key +
                      '` supplied to `' +
                      componentName +
                      '`.' +
                      '\nBad object: ' +
                      JSON.stringify(props[propName], null, '  ') +
                      '\nValid keys: ' +
                      JSON.stringify(Object.keys(shapeTypes), null, '  ')
                  );
                }

                var error = checker(
                  propValue,
                  key,
                  componentName,
                  location,
                  propFullName + '.' + key,
                  ReactPropTypesSecret
                );

                if (error) {
                  return error;
                }
              }

              return null;
            }

            return createChainableTypeChecker(validate);
          }

          function isNode(propValue) {
            switch (_typeof(propValue)) {
              case 'number':
              case 'string':
              case 'undefined':
                return true;

              case 'boolean':
                return !propValue;

              case 'object':
                if (Array.isArray(propValue)) {
                  return propValue.every(isNode);
                }

                if (propValue === null || isValidElement(propValue)) {
                  return true;
                }

                var iteratorFn = getIteratorFn(propValue);

                if (iteratorFn) {
                  var iterator = iteratorFn.call(propValue);
                  var step;

                  if (iteratorFn !== propValue.entries) {
                    while (!(step = iterator.next()).done) {
                      if (!isNode(step.value)) {
                        return false;
                      }
                    }
                  } else {
                    // Iterator will provide entry [k,v] tuples rather than values.
                    while (!(step = iterator.next()).done) {
                      var entry = step.value;

                      if (entry) {
                        if (!isNode(entry[1])) {
                          return false;
                        }
                      }
                    }
                  }
                } else {
                  return false;
                }

                return true;

              default:
                return false;
            }
          }

          function isSymbol(propType, propValue) {
            // Native Symbol.
            if (propType === 'symbol') {
              return true;
            } // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'

            if (propValue['@@toStringTag'] === 'Symbol') {
              return true;
            } // Fallback for non-spec compliant Symbols which are polyfilled.

            if (typeof Symbol === 'function' && propValue instanceof Symbol) {
              return true;
            }

            return false;
          } // Equivalent of `typeof` but with special handling for array and regexp.

          function getPropType(propValue) {
            var propType = _typeof(propValue);

            if (Array.isArray(propValue)) {
              return 'array';
            }

            if (propValue instanceof RegExp) {
              // Old webkits (at least until Android 4.0) return 'function' rather than
              // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
              // passes PropTypes.object.
              return 'object';
            }

            if (isSymbol(propType, propValue)) {
              return 'symbol';
            }

            return propType;
          } // This handles more types than `getPropType`. Only used for error messages.
          // See `createPrimitiveTypeChecker`.

          function getPreciseType(propValue) {
            if (typeof propValue === 'undefined' || propValue === null) {
              return '' + propValue;
            }

            var propType = getPropType(propValue);

            if (propType === 'object') {
              if (propValue instanceof Date) {
                return 'date';
              } else if (propValue instanceof RegExp) {
                return 'regexp';
              }
            }

            return propType;
          } // Returns a string that is postfixed to a warning about an invalid type.
          // For example, "undefined" or "of type array"

          function getPostfixForTypeWarning(value) {
            var type = getPreciseType(value);

            switch (type) {
              case 'array':
              case 'object':
                return 'an ' + type;

              case 'boolean':
              case 'date':
              case 'regexp':
                return 'a ' + type;

              default:
                return type;
            }
          } // Returns class name of the object, if any.

          function getClassName(propValue) {
            if (!propValue.constructor || !propValue.constructor.name) {
              return ANONYMOUS;
            }

            return propValue.constructor.name;
          }

          ReactPropTypes.checkPropTypes = checkPropTypes;
          ReactPropTypes.PropTypes = ReactPropTypes;
          return ReactPropTypes;
        };

        /***/
      },

    /***/ './node_modules/prop-types/index.js':
      /*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           */
          if (true) {
            var REACT_ELEMENT_TYPE =
              (typeof Symbol === 'function' &&
                Symbol.for &&
                Symbol.for('react.element')) ||
              0xeac7;

            var isValidElement = function isValidElement(object) {
              return (
                _typeof(object) === 'object' &&
                object !== null &&
                object.$$typeof === REACT_ELEMENT_TYPE
              );
            }; // By explicitly using `prop-types` you are opting into new development behavior.
            // http://fb.me/prop-types-in-prod

            var throwOnDirectAccess = true;
            module.exports = __webpack_require__(
              /*! ./factoryWithTypeCheckers */ './node_modules/prop-types/factoryWithTypeCheckers.js'
            )(isValidElement, throwOnDirectAccess);
          } else {
          }

          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              REACT_ELEMENT_TYPE,
              'REACT_ELEMENT_TYPE',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/prop-types/index.js'
            );
            reactHotLoader.register(
              isValidElement,
              'isValidElement',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/prop-types/index.js'
            );
            reactHotLoader.register(
              throwOnDirectAccess,
              'throwOnDirectAccess',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/prop-types/index.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/prop-types/lib/ReactPropTypesSecret.js':
      /*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var ReactPropTypesSecret =
            'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
          module.exports = ReactPropTypesSecret;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              ReactPropTypesSecret,
              'ReactPropTypesSecret',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/prop-types/lib/ReactPropTypesSecret.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/react-dom/cjs/react-dom.development.js':
      /*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /** @license React v16.2.0
         * react-dom.development.js
         *
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */ function _typeof(obj) {
          if (
            typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === 'function' &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj;
            };
          }
          return _typeof(obj);
        }
        if (true) {
          (function() {
            'use strict';
            var React = __webpack_require__(
              /*! react */ './node_modules/react/index.js'
            );
            var invariant = __webpack_require__(
              /*! fbjs/lib/invariant */ './node_modules/fbjs/lib/invariant.js'
            );
            var warning = __webpack_require__(
              /*! fbjs/lib/warning */ './node_modules/fbjs/lib/warning.js'
            );
            var ExecutionEnvironment = __webpack_require__(
              /*! fbjs/lib/ExecutionEnvironment */ './node_modules/fbjs/lib/ExecutionEnvironment.js'
            );
            var _assign = __webpack_require__(
              /*! object-assign */ './node_modules/object-assign/index.js'
            );
            var emptyFunction = __webpack_require__(
              /*! fbjs/lib/emptyFunction */ './node_modules/fbjs/lib/emptyFunction.js'
            );
            var EventListener = __webpack_require__(
              /*! fbjs/lib/EventListener */ './node_modules/fbjs/lib/EventListener.js'
            );
            var getActiveElement = __webpack_require__(
              /*! fbjs/lib/getActiveElement */ './node_modules/fbjs/lib/getActiveElement.js'
            );
            var shallowEqual = __webpack_require__(
              /*! fbjs/lib/shallowEqual */ './node_modules/fbjs/lib/shallowEqual.js'
            );
            var containsNode = __webpack_require__(
              /*! fbjs/lib/containsNode */ './node_modules/fbjs/lib/containsNode.js'
            );
            var focusNode = __webpack_require__(
              /*! fbjs/lib/focusNode */ './node_modules/fbjs/lib/focusNode.js'
            );
            var emptyObject = __webpack_require__(
              /*! fbjs/lib/emptyObject */ './node_modules/fbjs/lib/emptyObject.js'
            );
            var checkPropTypes = __webpack_require__(
              /*! prop-types/checkPropTypes */ './node_modules/prop-types/checkPropTypes.js'
            );
            var hyphenateStyleName = __webpack_require__(
              /*! fbjs/lib/hyphenateStyleName */ './node_modules/fbjs/lib/hyphenateStyleName.js'
            );
            var camelizeStyleName = __webpack_require__(
              /*! fbjs/lib/camelizeStyleName */ './node_modules/fbjs/lib/camelizeStyleName.js'
            );
            /**
             * WARNING: DO NOT manually require this module.
             * This is a replacement for `invariant(...)` used by the error code system
             * and will _only_ be required by the corresponding babel pass.
             * It always throws.
             */ !React
              ? invariant(
                  false,
                  'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'
                )
              : void 0; // These attributes should be all lowercase to allow for
            // case insensitive checks
            var RESERVED_PROPS = {
              children: true,
              dangerouslySetInnerHTML: true,
              defaultValue: true,
              defaultChecked: true,
              innerHTML: true,
              suppressContentEditableWarning: true,
              suppressHydrationWarning: true,
              style: true
            };
            function checkMask(value, bitmask) {
              return (value & bitmask) === bitmask;
            }
            var DOMPropertyInjection = {
              /**
               * Mapping from normalized, camelcased property names to a configuration that
               * specifies how the associated DOM property should be accessed or rendered.
               */ MUST_USE_PROPERTY: 0x1,
              HAS_BOOLEAN_VALUE: 0x4,
              HAS_NUMERIC_VALUE: 0x8,
              HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
              HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
              HAS_STRING_BOOLEAN_VALUE: 0x40,
              /**
               * Inject some specialized knowledge about the DOM. This takes a config object
               * with the following properties:
               *
               * Properties: object mapping DOM property name to one of the
               * DOMPropertyInjection constants or null. If your attribute isn't in here,
               * it won't get written to the DOM.
               *
               * DOMAttributeNames: object mapping React attribute name to the DOM
               * attribute name. Attribute names not specified use the **lowercase**
               * normalized name.
               *
               * DOMAttributeNamespaces: object mapping React attribute name to the DOM
               * attribute namespace URL. (Attribute names not specified use no namespace.)
               *
               * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
               * Property names not specified use the normalized name.
               *
               * DOMMutationMethods: Properties that require special mutation methods. If
               * `value` is undefined, the mutation method should unset the property.
               *
               * @param {object} domPropertyConfig the config as described above.
               */ injectDOMPropertyConfig: function injectDOMPropertyConfig(
                domPropertyConfig
              ) {
                var Injection = DOMPropertyInjection;
                var Properties = domPropertyConfig.Properties || {};
                var DOMAttributeNamespaces =
                  domPropertyConfig.DOMAttributeNamespaces || {};
                var DOMAttributeNames =
                  domPropertyConfig.DOMAttributeNames || {};
                var DOMMutationMethods =
                  domPropertyConfig.DOMMutationMethods || {};
                for (var propName in Properties) {
                  !!properties.hasOwnProperty(propName)
                    ? invariant(
                        false,
                        "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.",
                        propName
                      )
                    : void 0;
                  var lowerCased = propName.toLowerCase();
                  var propConfig = Properties[propName];
                  var propertyInfo = {
                    attributeName: lowerCased,
                    attributeNamespace: null,
                    propertyName: propName,
                    mutationMethod: null,
                    mustUseProperty: checkMask(
                      propConfig,
                      Injection.MUST_USE_PROPERTY
                    ),
                    hasBooleanValue: checkMask(
                      propConfig,
                      Injection.HAS_BOOLEAN_VALUE
                    ),
                    hasNumericValue: checkMask(
                      propConfig,
                      Injection.HAS_NUMERIC_VALUE
                    ),
                    hasPositiveNumericValue: checkMask(
                      propConfig,
                      Injection.HAS_POSITIVE_NUMERIC_VALUE
                    ),
                    hasOverloadedBooleanValue: checkMask(
                      propConfig,
                      Injection.HAS_OVERLOADED_BOOLEAN_VALUE
                    ),
                    hasStringBooleanValue: checkMask(
                      propConfig,
                      Injection.HAS_STRING_BOOLEAN_VALUE
                    )
                  };
                  !(
                    propertyInfo.hasBooleanValue +
                      propertyInfo.hasNumericValue +
                      propertyInfo.hasOverloadedBooleanValue <=
                    1
                  )
                    ? invariant(
                        false,
                        'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s',
                        propName
                      )
                    : void 0;
                  if (DOMAttributeNames.hasOwnProperty(propName)) {
                    var attributeName = DOMAttributeNames[propName];
                    propertyInfo.attributeName = attributeName;
                  }
                  if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
                    propertyInfo.attributeNamespace =
                      DOMAttributeNamespaces[propName];
                  }
                  if (DOMMutationMethods.hasOwnProperty(propName)) {
                    propertyInfo.mutationMethod = DOMMutationMethods[propName];
                  } // Downcase references to whitelist properties to check for membership
                  // without case-sensitivity. This allows the whitelist to pick up
                  // `allowfullscreen`, which should be written using the property configuration
                  // for `allowFullscreen`
                  properties[propName] = propertyInfo;
                }
              }
            };
            /* eslint-disable max-len */ var ATTRIBUTE_NAME_START_CHAR =
              ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
            /* eslint-enable max-len */ var ATTRIBUTE_NAME_CHAR =
              ATTRIBUTE_NAME_START_CHAR +
              '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
            var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
            /**
             * Map from property "standard name" to an object with info about how to set
             * the property in the DOM. Each object contains:
             *
             * attributeName:
             *   Used when rendering markup or with `*Attribute()`.
             * attributeNamespace
             * propertyName:
             *   Used on DOM node instances. (This includes properties that mutate due to
             *   external factors.)
             * mutationMethod:
             *   If non-null, used instead of the property or `setAttribute()` after
             *   initial render.
             * mustUseProperty:
             *   Whether the property must be accessed and mutated as an object property.
             * hasBooleanValue:
             *   Whether the property should be removed when set to a falsey value.
             * hasNumericValue:
             *   Whether the property must be numeric or parse as a numeric and should be
             *   removed when set to a falsey value.
             * hasPositiveNumericValue:
             *   Whether the property must be positive numeric or parse as a positive
             *   numeric and should be removed when set to a falsey value.
             * hasOverloadedBooleanValue:
             *   Whether the property can be used as a flag as well as with a value.
             *   Removed when strictly equal to false; present without a value when
             *   strictly equal to true; present with a value otherwise.
             */ var properties = {};
            /**
             * Checks whether a property name is a writeable attribute.
             * @method
             */ function shouldSetAttribute(name, value) {
              if (isReservedProp(name)) {
                return false;
              }
              if (
                name.length > 2 &&
                (name[0] === 'o' || name[0] === 'O') &&
                (name[1] === 'n' || name[1] === 'N')
              ) {
                return false;
              }
              if (value === null) {
                return true;
              }
              switch (_typeof(value)) {
                case 'boolean':
                  return shouldAttributeAcceptBooleanValue(name);
                case 'undefined':
                case 'number':
                case 'string':
                case 'object':
                  return true;
                default:
                  // function, symbol
                  return false;
              }
            }
            function getPropertyInfo(name) {
              return properties.hasOwnProperty(name) ? properties[name] : null;
            }
            function shouldAttributeAcceptBooleanValue(name) {
              if (isReservedProp(name)) {
                return true;
              }
              var propertyInfo = getPropertyInfo(name);
              if (propertyInfo) {
                return (
                  propertyInfo.hasBooleanValue ||
                  propertyInfo.hasStringBooleanValue ||
                  propertyInfo.hasOverloadedBooleanValue
                );
              }
              var prefix = name.toLowerCase().slice(0, 5);
              return prefix === 'data-' || prefix === 'aria-';
            }
            /**
             * Checks to see if a property name is within the list of properties
             * reserved for internal React operations. These properties should
             * not be set on an HTML element.
             *
             * @private
             * @param {string} name
             * @return {boolean} If the name is within reserved props
             */ function isReservedProp(name) {
              return RESERVED_PROPS.hasOwnProperty(name);
            }
            var injection = DOMPropertyInjection;
            var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;
            var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;
            var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;
            var HAS_POSITIVE_NUMERIC_VALUE =
              injection.HAS_POSITIVE_NUMERIC_VALUE;
            var HAS_OVERLOADED_BOOLEAN_VALUE =
              injection.HAS_OVERLOADED_BOOLEAN_VALUE;
            var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;
            var HTMLDOMPropertyConfig = {
              // When adding attributes to this list, be sure to also add them to
              // the `possibleStandardNames` module to ensure casing and incorrect
              // name warnings.
              Properties: {
                allowFullScreen: HAS_BOOLEAN_VALUE, // specifies target context for links with `preload` type
                async: HAS_BOOLEAN_VALUE, // Note: there is a special case that prevents it from being written to the DOM
                // on the client side because the browsers are inconsistent. Instead we call focus().
                autoFocus: HAS_BOOLEAN_VALUE,
                autoPlay: HAS_BOOLEAN_VALUE,
                capture: HAS_OVERLOADED_BOOLEAN_VALUE,
                checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                cols: HAS_POSITIVE_NUMERIC_VALUE,
                contentEditable: HAS_STRING_BOOLEAN_VALUE,
                controls: HAS_BOOLEAN_VALUE,
                default: HAS_BOOLEAN_VALUE,
                defer: HAS_BOOLEAN_VALUE,
                disabled: HAS_BOOLEAN_VALUE,
                download: HAS_OVERLOADED_BOOLEAN_VALUE,
                draggable: HAS_STRING_BOOLEAN_VALUE,
                formNoValidate: HAS_BOOLEAN_VALUE,
                hidden: HAS_BOOLEAN_VALUE,
                loop: HAS_BOOLEAN_VALUE, // Caution; `option.selected` is not updated if `select.multiple` is
                // disabled with `removeAttribute`.
                multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                noValidate: HAS_BOOLEAN_VALUE,
                open: HAS_BOOLEAN_VALUE,
                playsInline: HAS_BOOLEAN_VALUE,
                readOnly: HAS_BOOLEAN_VALUE,
                required: HAS_BOOLEAN_VALUE,
                reversed: HAS_BOOLEAN_VALUE,
                rows: HAS_POSITIVE_NUMERIC_VALUE,
                rowSpan: HAS_NUMERIC_VALUE,
                scoped: HAS_BOOLEAN_VALUE,
                seamless: HAS_BOOLEAN_VALUE,
                selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
                size: HAS_POSITIVE_NUMERIC_VALUE,
                start: HAS_NUMERIC_VALUE, // support for projecting regular DOM Elements via V1 named slots ( shadow dom )
                span: HAS_POSITIVE_NUMERIC_VALUE,
                spellCheck: HAS_STRING_BOOLEAN_VALUE, // Style must be explicitly set in the attribute list. React components
                // expect a style object
                style: 0, // Keep it in the whitelist because it is case-sensitive for SVG.
                tabIndex: 0, // itemScope is for for Microdata support.
                // See http://schema.org/docs/gs.html
                itemScope: HAS_BOOLEAN_VALUE, // These attributes must stay in the white-list because they have
                // different attribute names (see DOMAttributeNames below)
                acceptCharset: 0,
                className: 0,
                htmlFor: 0,
                httpEquiv: 0, // Attributes with mutation methods must be specified in the whitelist
                // Set the string boolean flag to allow the behavior
                value: HAS_STRING_BOOLEAN_VALUE
              },
              DOMAttributeNames: {
                acceptCharset: 'accept-charset',
                className: 'class',
                htmlFor: 'for',
                httpEquiv: 'http-equiv'
              },
              DOMMutationMethods: {
                value: function value(node, _value) {
                  if (_value == null) {
                    return node.removeAttribute('value');
                  } // Number inputs get special treatment due to some edge cases in
                  // Chrome. Let everything else assign the value attribute as normal.
                  // https://github.com/facebook/react/issues/7253#issuecomment-236074326
                  if (
                    node.type !== 'number' ||
                    node.hasAttribute('value') === false
                  ) {
                    node.setAttribute('value', '' + _value);
                  } else if (
                    node.validity &&
                    !node.validity.badInput &&
                    node.ownerDocument.activeElement !== node
                  ) {
                    // Don't assign an attribute if validation reports bad
                    // input. Chrome will clear the value. Additionally, don't
                    // operate on inputs that have focus, otherwise Chrome might
                    // strip off trailing decimal places and cause the user's
                    // cursor position to jump to the beginning of the input.
                    //
                    // In ReactDOMInput, we have an onBlur event that will trigger
                    // this function again when focus is lost.
                    node.setAttribute('value', '' + _value);
                  }
                }
              }
            };
            var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;
            var NS = {
              xlink: 'http://www.w3.org/1999/xlink',
              xml: 'http://www.w3.org/XML/1998/namespace'
            };
            /**
             * This is a list of all SVG attributes that need special casing,
             * namespacing, or boolean value assignment.
             *
             * When adding attributes to this list, be sure to also add them to
             * the `possibleStandardNames` module to ensure casing and incorrect
             * name warnings.
             *
             * SVG Attributes List:
             * https://www.w3.org/TR/SVG/attindex.html
             * SMIL Spec:
             * https://www.w3.org/TR/smil
             */ var ATTRS = [
              'accent-height',
              'alignment-baseline',
              'arabic-form',
              'baseline-shift',
              'cap-height',
              'clip-path',
              'clip-rule',
              'color-interpolation',
              'color-interpolation-filters',
              'color-profile',
              'color-rendering',
              'dominant-baseline',
              'enable-background',
              'fill-opacity',
              'fill-rule',
              'flood-color',
              'flood-opacity',
              'font-family',
              'font-size',
              'font-size-adjust',
              'font-stretch',
              'font-style',
              'font-variant',
              'font-weight',
              'glyph-name',
              'glyph-orientation-horizontal',
              'glyph-orientation-vertical',
              'horiz-adv-x',
              'horiz-origin-x',
              'image-rendering',
              'letter-spacing',
              'lighting-color',
              'marker-end',
              'marker-mid',
              'marker-start',
              'overline-position',
              'overline-thickness',
              'paint-order',
              'panose-1',
              'pointer-events',
              'rendering-intent',
              'shape-rendering',
              'stop-color',
              'stop-opacity',
              'strikethrough-position',
              'strikethrough-thickness',
              'stroke-dasharray',
              'stroke-dashoffset',
              'stroke-linecap',
              'stroke-linejoin',
              'stroke-miterlimit',
              'stroke-opacity',
              'stroke-width',
              'text-anchor',
              'text-decoration',
              'text-rendering',
              'underline-position',
              'underline-thickness',
              'unicode-bidi',
              'unicode-range',
              'units-per-em',
              'v-alphabetic',
              'v-hanging',
              'v-ideographic',
              'v-mathematical',
              'vector-effect',
              'vert-adv-y',
              'vert-origin-x',
              'vert-origin-y',
              'word-spacing',
              'writing-mode',
              'x-height',
              'xlink:actuate',
              'xlink:arcrole',
              'xlink:href',
              'xlink:role',
              'xlink:show',
              'xlink:title',
              'xlink:type',
              'xml:base',
              'xmlns:xlink',
              'xml:lang',
              'xml:space'
            ];
            var SVGDOMPropertyConfig = {
              Properties: {
                autoReverse: HAS_STRING_BOOLEAN_VALUE$1,
                externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,
                preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1
              },
              DOMAttributeNames: {
                autoReverse: 'autoReverse',
                externalResourcesRequired: 'externalResourcesRequired',
                preserveAlpha: 'preserveAlpha'
              },
              DOMAttributeNamespaces: {
                xlinkActuate: NS.xlink,
                xlinkArcrole: NS.xlink,
                xlinkHref: NS.xlink,
                xlinkRole: NS.xlink,
                xlinkShow: NS.xlink,
                xlinkTitle: NS.xlink,
                xlinkType: NS.xlink,
                xmlBase: NS.xml,
                xmlLang: NS.xml,
                xmlSpace: NS.xml
              }
            };
            var CAMELIZE = /[\-\:]([a-z])/g;
            var capitalize = function capitalize(token) {
              return token[1].toUpperCase();
            };
            ATTRS.forEach(function(original) {
              var reactName = original.replace(CAMELIZE, capitalize);
              SVGDOMPropertyConfig.Properties[reactName] = 0;
              SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;
            });
            injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
            injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);
            var ReactErrorUtils = {
              // Used by Fiber to simulate a try-catch.
              _caughtError: null,
              _hasCaughtError: false, // Used by event system to capture/rethrow the first error.
              _rethrowError: null,
              _hasRethrowError: false,
              injection: {
                injectErrorUtils: function injectErrorUtils(
                  injectedErrorUtils
                ) {
                  !(
                    typeof injectedErrorUtils.invokeGuardedCallback ===
                    'function'
                  )
                    ? invariant(
                        false,
                        'Injected invokeGuardedCallback() must be a function.'
                      )
                    : void 0;
                  _invokeGuardedCallback =
                    injectedErrorUtils.invokeGuardedCallback;
                }
              },
              /**
               * Call a function while guarding against errors that happens within it.
               * Returns an error if it throws, otherwise null.
               *
               * In production, this is implemented using a try-catch. The reason we don't
               * use a try-catch directly is so that we can swap out a different
               * implementation in DEV mode.
               *
               * @param {String} name of the guard to use for logging or debugging
               * @param {Function} func The function to invoke
               * @param {*} context The context to use when calling the function
               * @param {...*} args Arguments for function
               */ invokeGuardedCallback: function invokeGuardedCallback(
                name,
                func,
                context,
                a,
                b,
                c,
                d,
                e,
                f
              ) {
                _invokeGuardedCallback.apply(ReactErrorUtils, arguments);
              },
              /**
               * Same as invokeGuardedCallback, but instead of returning an error, it stores
               * it in a global so it can be rethrown by `rethrowCaughtError` later.
               * TODO: See if _caughtError and _rethrowError can be unified.
               *
               * @param {String} name of the guard to use for logging or debugging
               * @param {Function} func The function to invoke
               * @param {*} context The context to use when calling the function
               * @param {...*} args Arguments for function
               */ invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(
                name,
                func,
                context,
                a,
                b,
                c,
                d,
                e,
                f
              ) {
                ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
                if (ReactErrorUtils.hasCaughtError()) {
                  var error = ReactErrorUtils.clearCaughtError();
                  if (!ReactErrorUtils._hasRethrowError) {
                    ReactErrorUtils._hasRethrowError = true;
                    ReactErrorUtils._rethrowError = error;
                  }
                }
              },
              /**
               * During execution of guarded functions we will capture the first error which
               * we will rethrow to be handled by the top level error handler.
               */ rethrowCaughtError: function rethrowCaughtError() {
                return _rethrowCaughtError.apply(ReactErrorUtils, arguments);
              },
              hasCaughtError: function hasCaughtError() {
                return ReactErrorUtils._hasCaughtError;
              },
              clearCaughtError: function clearCaughtError() {
                if (ReactErrorUtils._hasCaughtError) {
                  var error = ReactErrorUtils._caughtError;
                  ReactErrorUtils._caughtError = null;
                  ReactErrorUtils._hasCaughtError = false;
                  return error;
                } else {
                  invariant(
                    false,
                    'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.'
                  );
                }
              }
            };
            var _invokeGuardedCallback = function _invokeGuardedCallback(
              name,
              func,
              context,
              a,
              b,
              c,
              d,
              e,
              f
            ) {
              ReactErrorUtils._hasCaughtError = false;
              ReactErrorUtils._caughtError = null;
              var funcArgs = Array.prototype.slice.call(arguments, 3);
              try {
                func.apply(context, funcArgs);
              } catch (error) {
                ReactErrorUtils._caughtError = error;
                ReactErrorUtils._hasCaughtError = true;
              }
            };
            {
              // In DEV mode, we swap out invokeGuardedCallback for a special version
              // that plays more nicely with the browser's DevTools. The idea is to preserve
              // "Pause on exceptions" behavior. Because React wraps all user-provided
              // functions in invokeGuardedCallback, and the production version of
              // invokeGuardedCallback uses a try-catch, all user exceptions are treated
              // like caught exceptions, and the DevTools won't pause unless the developer
              // takes the extra step of enabling pause on caught exceptions. This is
              // untintuitive, though, because even though React has caught the error, from
              // the developer's perspective, the error is uncaught.
              //
              // To preserve the expected "Pause on exceptions" behavior, we don't use a
              // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
              // DOM node, and call the user-provided callback from inside an event handler
              // for that fake event. If the callback throws, the error is "captured" using
              // a global event handler. But because the error happens in a different
              // event loop context, it does not interrupt the normal program flow.
              // Effectively, this gives us try-catch behavior without actually using
              // try-catch. Neat!
              // Check that the browser supports the APIs we need to implement our special
              // DEV version of invokeGuardedCallback
              if (
                typeof window !== 'undefined' &&
                typeof window.dispatchEvent === 'function' &&
                typeof document !== 'undefined' &&
                typeof document.createEvent === 'function'
              ) {
                var fakeNode = document.createElement('react');
                var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(
                  name,
                  func,
                  context,
                  a,
                  b,
                  c,
                  d,
                  e,
                  f
                ) {
                  // Keeps track of whether the user-provided callback threw an error. We
                  // set this to true at the beginning, then set it to false right after
                  // calling the function. If the function errors, `didError` will never be
                  // set to false. This strategy works even if the browser is flaky and
                  // fails to call our global error handler, because it doesn't rely on
                  // the error event at all.
                  var didError = true; // Create an event handler for our fake event. We will synchronously
                  // dispatch our fake event using `dispatchEvent`. Inside the handler, we
                  // call the user-provided callback.
                  var funcArgs = Array.prototype.slice.call(arguments, 3);
                  function callCallback() {
                    // We immediately remove the callback from event listeners so that
                    // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
                    // nested call would trigger the fake event handlers of any call higher
                    // in the stack.
                    fakeNode.removeEventListener(evtType, callCallback, false);
                    func.apply(context, funcArgs);
                    didError = false;
                  } // Create a global error event handler. We use this to capture the value
                  // that was thrown. It's possible that this error handler will fire more
                  // than once; for example, if non-React code also calls `dispatchEvent`
                  // and a handler for that event throws. We should be resilient to most of
                  // those cases. Even if our error event handler fires more than once, the
                  // last error event is always used. If the callback actually does error,
                  // we know that the last error event is the correct one, because it's not
                  // possible for anything else to have happened in between our callback
                  // erroring and the code that follows the `dispatchEvent` call below. If
                  // the callback doesn't error, but the error event was fired, we know to
                  // ignore it because `didError` will be false, as described above.
                  var error = void 0; // Use this to track whether the error event is ever called.
                  var didSetError = false;
                  var isCrossOriginError = false;
                  function onError(event) {
                    error = event.error;
                    didSetError = true;
                    if (
                      error === null &&
                      event.colno === 0 &&
                      event.lineno === 0
                    ) {
                      isCrossOriginError = true;
                    }
                  } // Create a fake event type.
                  var evtType =
                    'react-' + (name ? name : 'invokeguardedcallback'); // Attach our event handlers
                  window.addEventListener('error', onError);
                  fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
                  // errors, it will trigger our global error handler.
                  var evt = document.createEvent('Event');
                  evt.initEvent(evtType, false, false);
                  fakeNode.dispatchEvent(evt);
                  if (didError) {
                    if (!didSetError) {
                      // The callback errored, but the error event never fired.
                      error = new Error(
                        'An error was thrown inside one of your components, but React ' +
                          "doesn't know what it was. This is likely due to browser " +
                          'flakiness. React does its best to preserve the "Pause on ' +
                          'exceptions" behavior of the DevTools, which requires some ' +
                          "DEV-mode only tricks. It's possible that these don't work in " +
                          'your browser. Try triggering the error in production mode, ' +
                          'or switching to a modern browser. If you suspect that this is ' +
                          'actually an issue with React, please file an issue.'
                      );
                    } else if (isCrossOriginError) {
                      error = new Error(
                        "A cross-origin error was thrown. React doesn't have access to " +
                          'the actual error object in development. ' +
                          'See https://fb.me/react-crossorigin-error for more information.'
                      );
                    }
                    ReactErrorUtils._hasCaughtError = true;
                    ReactErrorUtils._caughtError = error;
                  } else {
                    ReactErrorUtils._hasCaughtError = false;
                    ReactErrorUtils._caughtError = null;
                  } // Remove our event listeners
                  window.removeEventListener('error', onError);
                };
                _invokeGuardedCallback = invokeGuardedCallbackDev;
              }
            }
            var _rethrowCaughtError = function _rethrowCaughtError() {
              if (ReactErrorUtils._hasRethrowError) {
                var error = ReactErrorUtils._rethrowError;
                ReactErrorUtils._rethrowError = null;
                ReactErrorUtils._hasRethrowError = false;
                throw error;
              }
            };
            /**
             * Injectable ordering of event plugins.
             */ var eventPluginOrder = null;
            /**
             * Injectable mapping from names to event plugin modules.
             */ var namesToPlugins = {};
            /**
             * Recomputes the plugin list using the injected plugins and plugin ordering.
             *
             * @private
             */ function recomputePluginOrdering() {
              if (!eventPluginOrder) {
                // Wait until an `eventPluginOrder` is injected.
                return;
              }
              for (var pluginName in namesToPlugins) {
                var pluginModule = namesToPlugins[pluginName];
                var pluginIndex = eventPluginOrder.indexOf(pluginName);
                !(pluginIndex > -1)
                  ? invariant(
                      false,
                      'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',
                      pluginName
                    )
                  : void 0;
                if (plugins[pluginIndex]) {
                  continue;
                }
                !pluginModule.extractEvents
                  ? invariant(
                      false,
                      'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',
                      pluginName
                    )
                  : void 0;
                plugins[pluginIndex] = pluginModule;
                var publishedEvents = pluginModule.eventTypes;
                for (var eventName in publishedEvents) {
                  !publishEventForPlugin(
                    publishedEvents[eventName],
                    pluginModule,
                    eventName
                  )
                    ? invariant(
                        false,
                        'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',
                        eventName,
                        pluginName
                      )
                    : void 0;
                }
              }
            }
            /**
             * Publishes an event so that it can be dispatched by the supplied plugin.
             *
             * @param {object} dispatchConfig Dispatch configuration for the event.
             * @param {object} PluginModule Plugin publishing the event.
             * @return {boolean} True if the event was successfully published.
             * @private
             */ function publishEventForPlugin(
              dispatchConfig,
              pluginModule,
              eventName
            ) {
              !!eventNameDispatchConfigs.hasOwnProperty(eventName)
                ? invariant(
                    false,
                    'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',
                    eventName
                  )
                : void 0;
              eventNameDispatchConfigs[eventName] = dispatchConfig;
              var phasedRegistrationNames =
                dispatchConfig.phasedRegistrationNames;
              if (phasedRegistrationNames) {
                for (var phaseName in phasedRegistrationNames) {
                  if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
                    var phasedRegistrationName =
                      phasedRegistrationNames[phaseName];
                    publishRegistrationName(
                      phasedRegistrationName,
                      pluginModule,
                      eventName
                    );
                  }
                }
                return true;
              } else if (dispatchConfig.registrationName) {
                publishRegistrationName(
                  dispatchConfig.registrationName,
                  pluginModule,
                  eventName
                );
                return true;
              }
              return false;
            }
            /**
             * Publishes a registration name that is used to identify dispatched events.
             *
             * @param {string} registrationName Registration name to add.
             * @param {object} PluginModule Plugin publishing the event.
             * @private
             */ function publishRegistrationName(
              registrationName,
              pluginModule,
              eventName
            ) {
              !!registrationNameModules[registrationName]
                ? invariant(
                    false,
                    'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',
                    registrationName
                  )
                : void 0;
              registrationNameModules[registrationName] = pluginModule;
              registrationNameDependencies[registrationName] =
                pluginModule.eventTypes[eventName].dependencies;
              {
                var lowerCasedName = registrationName.toLowerCase();
                possibleRegistrationNames[lowerCasedName] = registrationName;
                if (registrationName === 'onDoubleClick') {
                  possibleRegistrationNames.ondblclick = registrationName;
                }
              }
            }
            /**
             * Registers plugins so that they can extract and dispatch events.
             *
             * @see {EventPluginHub}
             */ /**
             * Ordered list of injected plugins.
             */ var plugins = [];
            /**
             * Mapping from event name to dispatch config
             */ var eventNameDispatchConfigs = {};
            /**
             * Mapping from registration name to plugin module
             */ var registrationNameModules = {};
            /**
             * Mapping from registration name to event name
             */ var registrationNameDependencies = {};
            /**
             * Mapping from lowercase registration names to the properly cased version,
             * used to warn in the case of missing event handlers. Available
             * only in true.
             * @type {Object}
             */ var possibleRegistrationNames = {}; // Trust the developer to only use possibleRegistrationNames in true
            /**
             * Injects an ordering of plugins (by plugin name). This allows the ordering
             * to be decoupled from injection of the actual plugins so that ordering is
             * always deterministic regardless of packaging, on-the-fly injection, etc.
             *
             * @param {array} InjectedEventPluginOrder
             * @internal
             * @see {EventPluginHub.injection.injectEventPluginOrder}
             */ function injectEventPluginOrder(injectedEventPluginOrder) {
              !!eventPluginOrder
                ? invariant(
                    false,
                    'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'
                  )
                : void 0; // Clone the ordering so it cannot be dynamically mutated.
              eventPluginOrder = Array.prototype.slice.call(
                injectedEventPluginOrder
              );
              recomputePluginOrdering();
            }
            /**
             * Injects plugins to be used by `EventPluginHub`. The plugin names must be
             * in the ordering injected by `injectEventPluginOrder`.
             *
             * Plugins can be injected as part of page initialization or on-the-fly.
             *
             * @param {object} injectedNamesToPlugins Map from names to plugin modules.
             * @internal
             * @see {EventPluginHub.injection.injectEventPluginsByName}
             */ function injectEventPluginsByName(injectedNamesToPlugins) {
              var isOrderingDirty = false;
              for (var pluginName in injectedNamesToPlugins) {
                if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
                  continue;
                }
                var pluginModule = injectedNamesToPlugins[pluginName];
                if (
                  !namesToPlugins.hasOwnProperty(pluginName) ||
                  namesToPlugins[pluginName] !== pluginModule
                ) {
                  !!namesToPlugins[pluginName]
                    ? invariant(
                        false,
                        'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',
                        pluginName
                      )
                    : void 0;
                  namesToPlugins[pluginName] = pluginModule;
                  isOrderingDirty = true;
                }
              }
              if (isOrderingDirty) {
                recomputePluginOrdering();
              }
            }
            var EventPluginRegistry = Object.freeze({
              plugins: plugins,
              eventNameDispatchConfigs: eventNameDispatchConfigs,
              registrationNameModules: registrationNameModules,
              registrationNameDependencies: registrationNameDependencies,
              possibleRegistrationNames: possibleRegistrationNames,
              injectEventPluginOrder: injectEventPluginOrder,
              injectEventPluginsByName: injectEventPluginsByName
            });
            var getFiberCurrentPropsFromNode = null;
            var getInstanceFromNode = null;
            var getNodeFromInstance = null;
            var injection$2 = {
              injectComponentTree: function injectComponentTree(Injected) {
                getFiberCurrentPropsFromNode =
                  Injected.getFiberCurrentPropsFromNode;
                getInstanceFromNode = Injected.getInstanceFromNode;
                getNodeFromInstance = Injected.getNodeFromInstance;
                {
                  warning(
                    getNodeFromInstance && getInstanceFromNode,
                    'EventPluginUtils.injection.injectComponentTree(...): Injected ' +
                      'module is missing getNodeFromInstance or getInstanceFromNode.'
                  );
                }
              }
            };
            var validateEventDispatches;
            {
              validateEventDispatches = function validateEventDispatches(
                event
              ) {
                var dispatchListeners = event._dispatchListeners;
                var dispatchInstances = event._dispatchInstances;
                var listenersIsArr = Array.isArray(dispatchListeners);
                var listenersLen = listenersIsArr
                  ? dispatchListeners.length
                  : dispatchListeners ? 1 : 0;
                var instancesIsArr = Array.isArray(dispatchInstances);
                var instancesLen = instancesIsArr
                  ? dispatchInstances.length
                  : dispatchInstances ? 1 : 0;
                warning(
                  instancesIsArr === listenersIsArr &&
                    instancesLen === listenersLen,
                  'EventPluginUtils: Invalid `event`.'
                );
              };
            }
            /**
             * Dispatch the event to the listener.
             * @param {SyntheticEvent} event SyntheticEvent to handle
             * @param {boolean} simulated If the event is simulated (changes exn behavior)
             * @param {function} listener Application-level callback
             * @param {*} inst Internal component instance
             */ function executeDispatch(event, simulated, listener, inst) {
              var type = event.type || 'unknown-event';
              event.currentTarget = getNodeFromInstance(inst);
              ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(
                type,
                listener,
                undefined,
                event
              );
              event.currentTarget = null;
            }
            /**
             * Standard/simple iteration through an event's collected dispatches.
             */ function executeDispatchesInOrder(event, simulated) {
              var dispatchListeners = event._dispatchListeners;
              var dispatchInstances = event._dispatchInstances;
              {
                validateEventDispatches(event);
              }
              if (Array.isArray(dispatchListeners)) {
                for (var i = 0; i < dispatchListeners.length; i++) {
                  if (event.isPropagationStopped()) {
                    break;
                  } // Listeners and Instances are two parallel arrays that are always in sync.
                  executeDispatch(
                    event,
                    simulated,
                    dispatchListeners[i],
                    dispatchInstances[i]
                  );
                }
              } else if (dispatchListeners) {
                executeDispatch(
                  event,
                  simulated,
                  dispatchListeners,
                  dispatchInstances
                );
              }
              event._dispatchListeners = null;
              event._dispatchInstances = null;
            }
            /**
             * @see executeDispatchesInOrderStopAtTrueImpl
             */ /**
             * Execution of a "direct" dispatch - there must be at most one dispatch
             * accumulated on the event or it is considered an error. It doesn't really make
             * sense for an event with multiple dispatches (bubbled) to keep track of the
             * return values at each dispatch execution, but it does tend to make sense when
             * dealing with "direct" dispatches.
             *
             * @return {*} The return value of executing the single dispatch.
             */ /**
             * @param {SyntheticEvent} event
             * @return {boolean} True iff number of dispatches accumulated is greater than 0.
             */ /**
             * Accumulates items that must not be null or undefined into the first one. This
             * is used to conserve memory by avoiding array allocations, and thus sacrifices
             * API cleanness. Since `current` can be null before being passed in and not
             * null after this function, make sure to assign it back to `current`:
             *
             * `a = accumulateInto(a, b);`
             *
             * This API should be sparingly used. Try `accumulate` for something cleaner.
             *
             * @return {*|array<*>} An accumulation of items.
             */ function accumulateInto(current, next) {
              !(next != null)
                ? invariant(
                    false,
                    'accumulateInto(...): Accumulated items must not be null or undefined.'
                  )
                : void 0;
              if (current == null) {
                return next;
              } // Both are not empty. Warning: Never call x.concat(y) when you are not
              // certain that x is an Array (x could be a string with concat method).
              if (Array.isArray(current)) {
                if (Array.isArray(next)) {
                  current.push.apply(current, next);
                  return current;
                }
                current.push(next);
                return current;
              }
              if (Array.isArray(next)) {
                // A bit too dangerous to mutate `next`.
                return [current].concat(next);
              }
              return [current, next];
            }
            /**
             * @param {array} arr an "accumulation" of items which is either an Array or
             * a single item. Useful when paired with the `accumulate` module. This is a
             * simple utility that allows us to reason about a collection of items, but
             * handling the case when there is exactly one item (and we do not need to
             * allocate an array).
             * @param {function} cb Callback invoked with each element or a collection.
             * @param {?} [scope] Scope used as `this` in a callback.
             */ function forEachAccumulated(arr, cb, scope) {
              if (Array.isArray(arr)) {
                arr.forEach(cb, scope);
              } else if (arr) {
                cb.call(scope, arr);
              }
            }
            /**
             * Internal queue of events that have accumulated their dispatches and are
             * waiting to have their dispatches executed.
             */ var eventQueue = null;
            /**
             * Dispatches an event and releases it back into the pool, unless persistent.
             *
             * @param {?object} event Synthetic event to be dispatched.
             * @param {boolean} simulated If the event is simulated (changes exn behavior)
             * @private
             */ var executeDispatchesAndRelease = function executeDispatchesAndRelease(
              event,
              simulated
            ) {
              if (event) {
                executeDispatchesInOrder(event, simulated);
                if (!event.isPersistent()) {
                  event.constructor.release(event);
                }
              }
            };
            var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(
              e
            ) {
              return executeDispatchesAndRelease(e, true);
            };
            var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(
              e
            ) {
              return executeDispatchesAndRelease(e, false);
            };
            function isInteractive(tag) {
              return (
                tag === 'button' ||
                tag === 'input' ||
                tag === 'select' ||
                tag === 'textarea'
              );
            }
            function shouldPreventMouseEvent(name, type, props) {
              switch (name) {
                case 'onClick':
                case 'onClickCapture':
                case 'onDoubleClick':
                case 'onDoubleClickCapture':
                case 'onMouseDown':
                case 'onMouseDownCapture':
                case 'onMouseMove':
                case 'onMouseMoveCapture':
                case 'onMouseUp':
                case 'onMouseUpCapture':
                  return !!(props.disabled && isInteractive(type));
                default:
                  return false;
              }
            }
            /**
             * This is a unified interface for event plugins to be installed and configured.
             *
             * Event plugins can implement the following properties:
             *
             *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
             *     Required. When a top-level event is fired, this method is expected to
             *     extract synthetic events that will in turn be queued and dispatched.
             *
             *   `eventTypes` {object}
             *     Optional, plugins that fire events must publish a mapping of registration
             *     names that are used to register listeners. Values of this mapping must
             *     be objects that contain `registrationName` or `phasedRegistrationNames`.
             *
             *   `executeDispatch` {function(object, function, string)}
             *     Optional, allows plugins to override how an event gets dispatched. By
             *     default, the listener is simply invoked.
             *
             * Each plugin that is injected into `EventsPluginHub` is immediately operable.
             *
             * @public
             */ /**
             * Methods for injecting dependencies.
             */ var injection$1 = {
              /**
               * @param {array} InjectedEventPluginOrder
               * @public
               */ injectEventPluginOrder: injectEventPluginOrder,
              /**
               * @param {object} injectedNamesToPlugins Map from names to plugin modules.
               */ injectEventPluginsByName: injectEventPluginsByName
            };
            /**
             * @param {object} inst The instance, which is the source of events.
             * @param {string} registrationName Name of listener (e.g. `onClick`).
             * @return {?function} The stored callback.
             */ function getListener(inst, registrationName) {
              var listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
              // live here; needs to be moved to a better place soon
              var stateNode = inst.stateNode;
              if (!stateNode) {
                // Work in progress (ex: onload events in incremental mode).
                return null;
              }
              var props = getFiberCurrentPropsFromNode(stateNode);
              if (!props) {
                // Work in progress.
                return null;
              }
              listener = props[registrationName];
              if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
                return null;
              }
              !(!listener || typeof listener === 'function')
                ? invariant(
                    false,
                    'Expected `%s` listener to be a function, instead got a value of `%s` type.',
                    registrationName,
                    _typeof(listener)
                  )
                : void 0;
              return listener;
            }
            /**
             * Allows registered plugins an opportunity to extract events from top-level
             * native browser events.
             *
             * @return {*} An accumulation of synthetic events.
             * @internal
             */ function extractEvents(
              topLevelType,
              targetInst,
              nativeEvent,
              nativeEventTarget
            ) {
              var events;
              for (var i = 0; i < plugins.length; i++) {
                // Not every plugin in the ordering may be loaded at runtime.
                var possiblePlugin = plugins[i];
                if (possiblePlugin) {
                  var extractedEvents = possiblePlugin.extractEvents(
                    topLevelType,
                    targetInst,
                    nativeEvent,
                    nativeEventTarget
                  );
                  if (extractedEvents) {
                    events = accumulateInto(events, extractedEvents);
                  }
                }
              }
              return events;
            }
            /**
             * Enqueues a synthetic event that should be dispatched when
             * `processEventQueue` is invoked.
             *
             * @param {*} events An accumulation of synthetic events.
             * @internal
             */ function enqueueEvents(events) {
              if (events) {
                eventQueue = accumulateInto(eventQueue, events);
              }
            }
            /**
             * Dispatches all synthetic events on the event queue.
             *
             * @internal
             */ function processEventQueue(simulated) {
              // Set `eventQueue` to null before processing it so that we can tell if more
              // events get enqueued while processing.
              var processingEventQueue = eventQueue;
              eventQueue = null;
              if (!processingEventQueue) {
                return;
              }
              if (simulated) {
                forEachAccumulated(
                  processingEventQueue,
                  executeDispatchesAndReleaseSimulated
                );
              } else {
                forEachAccumulated(
                  processingEventQueue,
                  executeDispatchesAndReleaseTopLevel
                );
              }
              !!eventQueue
                ? invariant(
                    false,
                    'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'
                  )
                : void 0; // This would be a good time to rethrow if any of the event handlers threw.
              ReactErrorUtils.rethrowCaughtError();
            }
            var EventPluginHub = Object.freeze({
              injection: injection$1,
              getListener: getListener,
              extractEvents: extractEvents,
              enqueueEvents: enqueueEvents,
              processEventQueue: processEventQueue
            });
            var IndeterminateComponent = 0; // Before we know whether it is functional or class
            var FunctionalComponent = 1;
            var ClassComponent = 2;
            var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
            var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
            var HostComponent = 5;
            var HostText = 6;
            var CallComponent = 7;
            var CallHandlerPhase = 8;
            var ReturnComponent = 9;
            var Fragment = 10;
            var randomKey = Math.random()
              .toString(36)
              .slice(2);
            var internalInstanceKey = '__reactInternalInstance$' + randomKey;
            var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;
            function precacheFiberNode$1(hostInst, node) {
              node[internalInstanceKey] = hostInst;
            }
            /**
             * Given a DOM node, return the closest ReactDOMComponent or
             * ReactDOMTextComponent instance ancestor.
             */ function getClosestInstanceFromNode(node) {
              if (node[internalInstanceKey]) {
                return node[internalInstanceKey];
              } // Walk up the tree until we find an ancestor whose instance we have cached.
              var parents = [];
              while (!node[internalInstanceKey]) {
                parents.push(node);
                if (node.parentNode) {
                  node = node.parentNode;
                } else {
                  // Top of the tree. This node must not be part of a React tree (or is
                  // unmounted, potentially).
                  return null;
                }
              }
              var closest = void 0;
              var inst = node[internalInstanceKey];
              if (inst.tag === HostComponent || inst.tag === HostText) {
                // In Fiber, this will always be the deepest root.
                return inst;
              }
              for (
                ;
                node && (inst = node[internalInstanceKey]);
                node = parents.pop()
              ) {
                closest = inst;
              }
              return closest;
            }
            /**
             * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
             * instance, or null if the node was not rendered by this React.
             */ function getInstanceFromNode$1(node) {
              var inst = node[internalInstanceKey];
              if (inst) {
                if (inst.tag === HostComponent || inst.tag === HostText) {
                  return inst;
                } else {
                  return null;
                }
              }
              return null;
            }
            /**
             * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
             * DOM node.
             */ function getNodeFromInstance$1(inst) {
              if (inst.tag === HostComponent || inst.tag === HostText) {
                // In Fiber this, is just the state node right now. We assume it will be
                // a host component or host text.
                return inst.stateNode;
              } // Without this first invariant, passing a non-DOM-component triggers the next
              // invariant for a missing parent, which is super confusing.
              invariant(false, 'getNodeFromInstance: Invalid argument.');
            }
            function getFiberCurrentPropsFromNode$1(node) {
              return node[internalEventHandlersKey] || null;
            }
            function updateFiberProps$1(node, props) {
              node[internalEventHandlersKey] = props;
            }
            var ReactDOMComponentTree = Object.freeze({
              precacheFiberNode: precacheFiberNode$1,
              getClosestInstanceFromNode: getClosestInstanceFromNode,
              getInstanceFromNode: getInstanceFromNode$1,
              getNodeFromInstance: getNodeFromInstance$1,
              getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
              updateFiberProps: updateFiberProps$1
            });
            function getParent(inst) {
              do {
                inst = inst['return']; // TODO: If this is a HostRoot we might want to bail out.
                // That is depending on if we want nested subtrees (layers) to bubble
                // events to their parent. We could also go through parentNode on the
                // host node but that wouldn't work for React Native and doesn't let us
                // do the portal feature.
              } while (inst && inst.tag !== HostComponent);
              if (inst) {
                return inst;
              }
              return null;
            }
            /**
             * Return the lowest common ancestor of A and B, or null if they are in
             * different trees.
             */ function getLowestCommonAncestor(instA, instB) {
              var depthA = 0;
              for (var tempA = instA; tempA; tempA = getParent(tempA)) {
                depthA++;
              }
              var depthB = 0;
              for (var tempB = instB; tempB; tempB = getParent(tempB)) {
                depthB++;
              } // If A is deeper, crawl up.
              while (depthA - depthB > 0) {
                instA = getParent(instA);
                depthA--;
              } // If B is deeper, crawl up.
              while (depthB - depthA > 0) {
                instB = getParent(instB);
                depthB--;
              } // Walk in lockstep until we find a match.
              var depth = depthA;
              while (depth--) {
                if (instA === instB || instA === instB.alternate) {
                  return instA;
                }
                instA = getParent(instA);
                instB = getParent(instB);
              }
              return null;
            }
            /**
             * Return if A is an ancestor of B.
             */ /**
             * Return the parent instance of the passed-in instance.
             */ function getParentInstance(inst) {
              return getParent(inst);
            }
            /**
             * Simulates the traversal of a two-phase, capture/bubble event dispatch.
             */ function traverseTwoPhase(inst, fn, arg) {
              var path = [];
              while (inst) {
                path.push(inst);
                inst = getParent(inst);
              }
              var i;
              for (i = path.length; i-- > 0; ) {
                fn(path[i], 'captured', arg);
              }
              for (i = 0; i < path.length; i++) {
                fn(path[i], 'bubbled', arg);
              }
            }
            /**
             * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
             * should would receive a `mouseEnter` or `mouseLeave` event.
             *
             * Does not invoke the callback on the nearest common ancestor because nothing
             * "entered" or "left" that element.
             */ function traverseEnterLeave(from, to, fn, argFrom, argTo) {
              var common =
                from && to ? getLowestCommonAncestor(from, to) : null;
              var pathFrom = [];
              while (true) {
                if (!from) {
                  break;
                }
                if (from === common) {
                  break;
                }
                var alternate = from.alternate;
                if (alternate !== null && alternate === common) {
                  break;
                }
                pathFrom.push(from);
                from = getParent(from);
              }
              var pathTo = [];
              while (true) {
                if (!to) {
                  break;
                }
                if (to === common) {
                  break;
                }
                var _alternate = to.alternate;
                if (_alternate !== null && _alternate === common) {
                  break;
                }
                pathTo.push(to);
                to = getParent(to);
              }
              for (var i = 0; i < pathFrom.length; i++) {
                fn(pathFrom[i], 'bubbled', argFrom);
              }
              for (var _i = pathTo.length; _i-- > 0; ) {
                fn(pathTo[_i], 'captured', argTo);
              }
            }
            /**
             * Some event types have a notion of different registration names for different
             * "phases" of propagation. This finds listeners by a given phase.
             */ function listenerAtPhase(inst, event, propagationPhase) {
              var registrationName =
                event.dispatchConfig.phasedRegistrationNames[propagationPhase];
              return getListener(inst, registrationName);
            }
            /**
             * A small set of propagation patterns, each of which will accept a small amount
             * of information, and generate a set of "dispatch ready event objects" - which
             * are sets of events that have already been annotated with a set of dispatched
             * listener functions/ids. The API is designed this way to discourage these
             * propagation strategies from actually executing the dispatches, since we
             * always want to collect the entire set of dispatches before executing even a
             * single one.
             */ /**
             * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
             * here, allows us to not have to bind or create functions for each event.
             * Mutating the event's members allows us to not have to create a wrapping
             * "dispatch" object that pairs the event with the listener.
             */ function accumulateDirectionalDispatches(inst, phase, event) {
              {
                warning(inst, 'Dispatching inst must not be null');
              }
              var listener = listenerAtPhase(inst, event, phase);
              if (listener) {
                event._dispatchListeners = accumulateInto(
                  event._dispatchListeners,
                  listener
                );
                event._dispatchInstances = accumulateInto(
                  event._dispatchInstances,
                  inst
                );
              }
            }
            /**
             * Collect dispatches (must be entirely collected before dispatching - see unit
             * tests). Lazily allocate the array to conserve memory.  We must loop through
             * each event and perform the traversal for each one. We cannot perform a
             * single traversal for the entire collection of events because each event may
             * have a different target.
             */ function accumulateTwoPhaseDispatchesSingle(event) {
              if (event && event.dispatchConfig.phasedRegistrationNames) {
                traverseTwoPhase(
                  event._targetInst,
                  accumulateDirectionalDispatches,
                  event
                );
              }
            }
            /**
             * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
             */ function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
              if (event && event.dispatchConfig.phasedRegistrationNames) {
                var targetInst = event._targetInst;
                var parentInst = targetInst
                  ? getParentInstance(targetInst)
                  : null;
                traverseTwoPhase(
                  parentInst,
                  accumulateDirectionalDispatches,
                  event
                );
              }
            }
            /**
             * Accumulates without regard to direction, does not look for phased
             * registration names. Same as `accumulateDirectDispatchesSingle` but without
             * requiring that the `dispatchMarker` be the same as the dispatched ID.
             */ function accumulateDispatches(inst, ignoredDirection, event) {
              if (inst && event && event.dispatchConfig.registrationName) {
                var registrationName = event.dispatchConfig.registrationName;
                var listener = getListener(inst, registrationName);
                if (listener) {
                  event._dispatchListeners = accumulateInto(
                    event._dispatchListeners,
                    listener
                  );
                  event._dispatchInstances = accumulateInto(
                    event._dispatchInstances,
                    inst
                  );
                }
              }
            }
            /**
             * Accumulates dispatches on an `SyntheticEvent`, but only for the
             * `dispatchMarker`.
             * @param {SyntheticEvent} event
             */ function accumulateDirectDispatchesSingle(event) {
              if (event && event.dispatchConfig.registrationName) {
                accumulateDispatches(event._targetInst, null, event);
              }
            }
            function accumulateTwoPhaseDispatches(events) {
              forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
            }
            function accumulateTwoPhaseDispatchesSkipTarget(events) {
              forEachAccumulated(
                events,
                accumulateTwoPhaseDispatchesSingleSkipTarget
              );
            }
            function accumulateEnterLeaveDispatches(leave, enter, from, to) {
              traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
            }
            function accumulateDirectDispatches(events) {
              forEachAccumulated(events, accumulateDirectDispatchesSingle);
            }
            var EventPropagators = Object.freeze({
              accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
              accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
              accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
              accumulateDirectDispatches: accumulateDirectDispatches
            });
            var contentKey = null;
            /**
             * Gets the key used to access text content on a DOM node.
             *
             * @return {?string} Key used to access text content.
             * @internal
             */ function getTextContentAccessor() {
              if (!contentKey && ExecutionEnvironment.canUseDOM) {
                // Prefer textContent to innerText because many browsers support both but
                // SVG <text> elements don't support innerText even when <div> does.
                contentKey =
                  'textContent' in document.documentElement
                    ? 'textContent'
                    : 'innerText';
              }
              return contentKey;
            }
            /**
             * This helper object stores information about text content of a target node,
             * allowing comparison of content before and after a given event.
             *
             * Identify the node where selection currently begins, then observe
             * both its text content and its current position in the DOM. Since the
             * browser may natively replace the target node during composition, we can
             * use its position to find its replacement.
             *
             *
             */ var compositionState = {
              _root: null,
              _startText: null,
              _fallbackText: null
            };
            function initialize(nativeEventTarget) {
              compositionState._root = nativeEventTarget;
              compositionState._startText = getText();
              return true;
            }
            function reset() {
              compositionState._root = null;
              compositionState._startText = null;
              compositionState._fallbackText = null;
            }
            function getData() {
              if (compositionState._fallbackText) {
                return compositionState._fallbackText;
              }
              var start;
              var startValue = compositionState._startText;
              var startLength = startValue.length;
              var end;
              var endValue = getText();
              var endLength = endValue.length;
              for (start = 0; start < startLength; start++) {
                if (startValue[start] !== endValue[start]) {
                  break;
                }
              }
              var minEnd = startLength - start;
              for (end = 1; end <= minEnd; end++) {
                if (
                  startValue[startLength - end] !== endValue[endLength - end]
                ) {
                  break;
                }
              }
              var sliceTail = end > 1 ? 1 - end : undefined;
              compositionState._fallbackText = endValue.slice(start, sliceTail);
              return compositionState._fallbackText;
            }
            function getText() {
              if ('value' in compositionState._root) {
                return compositionState._root.value;
              }
              return compositionState._root[getTextContentAccessor()];
            }
            /* eslint valid-typeof: 0 */ var didWarnForAddedNewProperty = false;
            var isProxySupported = typeof Proxy === 'function';
            var EVENT_POOL_SIZE = 10;
            var shouldBeReleasedProperties = [
              'dispatchConfig',
              '_targetInst',
              'nativeEvent',
              'isDefaultPrevented',
              'isPropagationStopped',
              '_dispatchListeners',
              '_dispatchInstances'
            ];
            /**
             * @interface Event
             * @see http://www.w3.org/TR/DOM-Level-3-Events/
             */ var EventInterface = {
              type: null,
              target: null, // currentTarget is set when dispatching; no use in copying it here
              currentTarget: emptyFunction.thatReturnsNull,
              eventPhase: null,
              bubbles: null,
              cancelable: null,
              timeStamp: function timeStamp(event) {
                return event.timeStamp || Date.now();
              },
              defaultPrevented: null,
              isTrusted: null
            };
            /**
             * Synthetic events are dispatched by event plugins, typically in response to a
             * top-level event delegation handler.
             *
             * These systems should generally use pooling to reduce the frequency of garbage
             * collection. The system should check `isPersistent` to determine whether the
             * event should be released into the pool after being dispatched. Users that
             * need a persisted event should invoke `persist`.
             *
             * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
             * normalizing browser quirks. Subclasses do not necessarily have to implement a
             * DOM interface; custom application-specific events can also subclass this.
             *
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {*} targetInst Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @param {DOMEventTarget} nativeEventTarget Target node.
             */ function SyntheticEvent(
              dispatchConfig,
              targetInst,
              nativeEvent,
              nativeEventTarget
            ) {
              {
                // these have a getter/setter for warnings
                delete this.nativeEvent;
                delete this.preventDefault;
                delete this.stopPropagation;
              }
              this.dispatchConfig = dispatchConfig;
              this._targetInst = targetInst;
              this.nativeEvent = nativeEvent;
              var Interface = this.constructor.Interface;
              for (var propName in Interface) {
                if (!Interface.hasOwnProperty(propName)) {
                  continue;
                }
                {
                  delete this[propName]; // this has a getter/setter for warnings
                }
                var normalize = Interface[propName];
                if (normalize) {
                  this[propName] = normalize(nativeEvent);
                } else {
                  if (propName === 'target') {
                    this.target = nativeEventTarget;
                  } else {
                    this[propName] = nativeEvent[propName];
                  }
                }
              }
              var defaultPrevented =
                nativeEvent.defaultPrevented != null
                  ? nativeEvent.defaultPrevented
                  : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
              } else {
                this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
              }
              this.isPropagationStopped = emptyFunction.thatReturnsFalse;
              return this;
            }
            _assign(SyntheticEvent.prototype, {
              preventDefault: function preventDefault() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== 'unknown') {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
              },
              stopPropagation: function stopPropagation() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== 'unknown') {
                  // The ChangeEventPlugin registers a "propertychange" event for
                  // IE. This event does not support bubbling or cancelling, and
                  // any references to cancelBubble throw "Member not found".  A
                  // typeof check of "unknown" circumvents this issue (and is also
                  // IE specific).
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = emptyFunction.thatReturnsTrue;
              },
              /**
               * We release all dispatched `SyntheticEvent`s after each event loop, adding
               * them back into the pool. This allows a way to hold onto a reference that
               * won't be added back into the pool.
               */ persist: function persist() {
                this.isPersistent = emptyFunction.thatReturnsTrue;
              },
              /**
               * Checks if this event should be released back into the pool.
               *
               * @return {boolean} True if this should not be released, false otherwise.
               */ isPersistent: emptyFunction.thatReturnsFalse,
              /**
               * `PooledClass` looks for `destructor` on each instance it releases.
               */ destructor: function destructor() {
                var Interface = this.constructor.Interface;
                for (var propName in Interface) {
                  {
                    Object.defineProperty(
                      this,
                      propName,
                      getPooledWarningPropertyDefinition(
                        propName,
                        Interface[propName]
                      )
                    );
                  }
                }
                for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
                  this[shouldBeReleasedProperties[i]] = null;
                }
                {
                  Object.defineProperty(
                    this,
                    'nativeEvent',
                    getPooledWarningPropertyDefinition('nativeEvent', null)
                  );
                  Object.defineProperty(
                    this,
                    'preventDefault',
                    getPooledWarningPropertyDefinition(
                      'preventDefault',
                      emptyFunction
                    )
                  );
                  Object.defineProperty(
                    this,
                    'stopPropagation',
                    getPooledWarningPropertyDefinition(
                      'stopPropagation',
                      emptyFunction
                    )
                  );
                }
              }
            });
            SyntheticEvent.Interface = EventInterface;
            /**
             * Helper to reduce boilerplate when creating subclasses.
             *
             * @param {function} Class
             * @param {?object} Interface
             */ SyntheticEvent.augmentClass = function(Class, Interface) {
              var Super = this;
              var E = function E() {};
              E.prototype = Super.prototype;
              var prototype = new E();
              _assign(prototype, Class.prototype);
              Class.prototype = prototype;
              Class.prototype.constructor = Class;
              Class.Interface = _assign({}, Super.Interface, Interface);
              Class.augmentClass = Super.augmentClass;
              addEventPoolingTo(Class);
            };
            /** Proxying after everything set on SyntheticEvent
             * to resolve Proxy issue on some WebKit browsers
             * in which some Event properties are set to undefined (GH#10010)
             */ {
              if (isProxySupported) {
                /*eslint-disable no-func-assign */ SyntheticEvent = new Proxy(
                  SyntheticEvent,
                  {
                    construct: function construct(target, args) {
                      return this.apply(
                        target,
                        Object.create(target.prototype),
                        args
                      );
                    },
                    apply: function apply(constructor, that, args) {
                      return new Proxy(constructor.apply(that, args), {
                        set: function set(target, prop, value) {
                          if (
                            prop !== 'isPersistent' &&
                            !target.constructor.Interface.hasOwnProperty(
                              prop
                            ) &&
                            shouldBeReleasedProperties.indexOf(prop) === -1
                          ) {
                            warning(
                              didWarnForAddedNewProperty ||
                                target.isPersistent(),
                              "This synthetic event is reused for performance reasons. If you're " +
                                "seeing this, you're adding a new property in the synthetic event object. " +
                                'The property is never released. See ' +
                                'https://fb.me/react-event-pooling for more information.'
                            );
                            didWarnForAddedNewProperty = true;
                          }
                          target[prop] = value;
                          return true;
                        }
                      });
                    }
                  }
                ); /*eslint-enable no-func-assign */
              }
            }
            addEventPoolingTo(SyntheticEvent);
            /**
             * Helper to nullify syntheticEvent instance properties when destructing
             *
             * @param {String} propName
             * @param {?object} getVal
             * @return {object} defineProperty object
             */ function getPooledWarningPropertyDefinition(propName, getVal) {
              var isFunction = typeof getVal === 'function';
              return { configurable: true, set: set, get: get };
              function set(val) {
                var action = isFunction
                  ? 'setting the method'
                  : 'setting the property';
                warn(action, 'This is effectively a no-op');
                return val;
              }
              function get() {
                var action = isFunction
                  ? 'accessing the method'
                  : 'accessing the property';
                var result = isFunction
                  ? 'This is a no-op function'
                  : 'This is set to null';
                warn(action, result);
                return getVal;
              }
              function warn(action, result) {
                var warningCondition = false;
                warning(
                  warningCondition,
                  "This synthetic event is reused for performance reasons. If you're seeing this, " +
                    "you're %s `%s` on a released/nullified synthetic event. %s. " +
                    'If you must keep the original synthetic event around, use event.persist(). ' +
                    'See https://fb.me/react-event-pooling for more information.',
                  action,
                  propName,
                  result
                );
              }
            }
            function getPooledEvent(
              dispatchConfig,
              targetInst,
              nativeEvent,
              nativeInst
            ) {
              var EventConstructor = this;
              if (EventConstructor.eventPool.length) {
                var instance = EventConstructor.eventPool.pop();
                EventConstructor.call(
                  instance,
                  dispatchConfig,
                  targetInst,
                  nativeEvent,
                  nativeInst
                );
                return instance;
              }
              return new EventConstructor(
                dispatchConfig,
                targetInst,
                nativeEvent,
                nativeInst
              );
            }
            function releasePooledEvent(event) {
              var EventConstructor = this;
              !(event instanceof EventConstructor)
                ? invariant(
                    false,
                    'Trying to release an event instance  into a pool of a different type.'
                  )
                : void 0;
              event.destructor();
              if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
                EventConstructor.eventPool.push(event);
              }
            }
            function addEventPoolingTo(EventConstructor) {
              EventConstructor.eventPool = [];
              EventConstructor.getPooled = getPooledEvent;
              EventConstructor.release = releasePooledEvent;
            }
            var SyntheticEvent$1 = SyntheticEvent;
            /**
             * @interface Event
             * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
             */ var CompositionEventInterface = { data: null };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticEvent}
             */ function SyntheticCompositionEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticEvent$1.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticEvent$1.augmentClass(
              SyntheticCompositionEvent,
              CompositionEventInterface
            );
            /**
             * @interface Event
             * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
             *      /#events-inputevents
             */ var InputEventInterface = { data: null };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticEvent}
             */ function SyntheticInputEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticEvent$1.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticEvent$1.augmentClass(
              SyntheticInputEvent,
              InputEventInterface
            );
            var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
            var START_KEYCODE = 229;
            var canUseCompositionEvent =
              ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
            var documentMode = null;
            if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
              documentMode = document.documentMode;
            } // Webkit offers a very useful `textInput` event that can be used to
            // directly represent `beforeInput`. The IE `textinput` event is not as
            // useful, so we don't use it.
            var canUseTextInputEvent =
              ExecutionEnvironment.canUseDOM &&
              'TextEvent' in window &&
              !documentMode &&
              !isPresto(); // In IE9+, we have access to composition events, but the data supplied
            // by the native compositionend event may be incorrect. Japanese ideographic
            // spaces, for instance (\u3000) are not recorded correctly.
            var useFallbackCompositionData =
              ExecutionEnvironment.canUseDOM &&
              (!canUseCompositionEvent ||
                (documentMode && documentMode > 8 && documentMode <= 11));
            /**
             * Opera <= 12 includes TextEvent in window, but does not fire
             * text input events. Rely on keypress instead.
             */ function isPresto() {
              var opera = window.opera;
              return (
                _typeof(opera) === 'object' &&
                typeof opera.version === 'function' &&
                parseInt(opera.version(), 10) <= 12
              );
            }
            var SPACEBAR_CODE = 32;
            var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE); // Events and their corresponding property names.
            var eventTypes = {
              beforeInput: {
                phasedRegistrationNames: {
                  bubbled: 'onBeforeInput',
                  captured: 'onBeforeInputCapture'
                },
                dependencies: [
                  'topCompositionEnd',
                  'topKeyPress',
                  'topTextInput',
                  'topPaste'
                ]
              },
              compositionEnd: {
                phasedRegistrationNames: {
                  bubbled: 'onCompositionEnd',
                  captured: 'onCompositionEndCapture'
                },
                dependencies: [
                  'topBlur',
                  'topCompositionEnd',
                  'topKeyDown',
                  'topKeyPress',
                  'topKeyUp',
                  'topMouseDown'
                ]
              },
              compositionStart: {
                phasedRegistrationNames: {
                  bubbled: 'onCompositionStart',
                  captured: 'onCompositionStartCapture'
                },
                dependencies: [
                  'topBlur',
                  'topCompositionStart',
                  'topKeyDown',
                  'topKeyPress',
                  'topKeyUp',
                  'topMouseDown'
                ]
              },
              compositionUpdate: {
                phasedRegistrationNames: {
                  bubbled: 'onCompositionUpdate',
                  captured: 'onCompositionUpdateCapture'
                },
                dependencies: [
                  'topBlur',
                  'topCompositionUpdate',
                  'topKeyDown',
                  'topKeyPress',
                  'topKeyUp',
                  'topMouseDown'
                ]
              }
            }; // Track whether we've ever handled a keypress on the space key.
            var hasSpaceKeypress = false;
            /**
             * Return whether a native keypress event is assumed to be a command.
             * This is required because Firefox fires `keypress` events for key commands
             * (cut, copy, select-all, etc.) even though no character is inserted.
             */ function isKeypressCommand(nativeEvent) {
              return (
                (nativeEvent.ctrlKey ||
                  nativeEvent.altKey ||
                  nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
                !(nativeEvent.ctrlKey && nativeEvent.altKey)
              );
            }
            /**
             * Translate native top level events into event types.
             *
             * @param {string} topLevelType
             * @return {object}
             */ function getCompositionEventType(topLevelType) {
              switch (topLevelType) {
                case 'topCompositionStart':
                  return eventTypes.compositionStart;
                case 'topCompositionEnd':
                  return eventTypes.compositionEnd;
                case 'topCompositionUpdate':
                  return eventTypes.compositionUpdate;
              }
            }
            /**
             * Does our fallback best-guess model think this event signifies that
             * composition has begun?
             *
             * @param {string} topLevelType
             * @param {object} nativeEvent
             * @return {boolean}
             */ function isFallbackCompositionStart(topLevelType, nativeEvent) {
              return (
                topLevelType === 'topKeyDown' &&
                nativeEvent.keyCode === START_KEYCODE
              );
            }
            /**
             * Does our fallback mode think that this event is the end of composition?
             *
             * @param {string} topLevelType
             * @param {object} nativeEvent
             * @return {boolean}
             */ function isFallbackCompositionEnd(topLevelType, nativeEvent) {
              switch (topLevelType) {
                case 'topKeyUp': // Command keys insert or clear IME input.
                  return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
                case 'topKeyDown': // Expect IME keyCode on each keydown. If we get any other
                  // code we must have exited earlier.
                  return nativeEvent.keyCode !== START_KEYCODE;
                case 'topKeyPress':
                case 'topMouseDown':
                case 'topBlur': // Events are not possible without cancelling IME.
                  return true;
                default:
                  return false;
              }
            }
            /**
             * Google Input Tools provides composition data via a CustomEvent,
             * with the `data` property populated in the `detail` object. If this
             * is available on the event object, use it. If not, this is a plain
             * composition event and we have nothing special to extract.
             *
             * @param {object} nativeEvent
             * @return {?string}
             */ function getDataFromCustomEvent(nativeEvent) {
              var detail = nativeEvent.detail;
              if (_typeof(detail) === 'object' && 'data' in detail) {
                return detail.data;
              }
              return null;
            } // Track the current IME composition status, if any.
            var isComposing = false;
            /**
             * @return {?object} A SyntheticCompositionEvent.
             */ function extractCompositionEvent(
              topLevelType,
              targetInst,
              nativeEvent,
              nativeEventTarget
            ) {
              var eventType;
              var fallbackData;
              if (canUseCompositionEvent) {
                eventType = getCompositionEventType(topLevelType);
              } else if (!isComposing) {
                if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
                  eventType = eventTypes.compositionStart;
                }
              } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
                eventType = eventTypes.compositionEnd;
              }
              if (!eventType) {
                return null;
              }
              if (useFallbackCompositionData) {
                // The current composition is stored statically and must not be
                // overwritten while composition continues.
                if (!isComposing && eventType === eventTypes.compositionStart) {
                  isComposing = initialize(nativeEventTarget);
                } else if (eventType === eventTypes.compositionEnd) {
                  if (isComposing) {
                    fallbackData = getData();
                  }
                }
              }
              var event = SyntheticCompositionEvent.getPooled(
                eventType,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
              if (fallbackData) {
                // Inject data generated from fallback path into the synthetic event.
                // This matches the property of native CompositionEventInterface.
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
              accumulateTwoPhaseDispatches(event);
              return event;
            }
            /**
             * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
             * @param {object} nativeEvent Native browser event.
             * @return {?string} The string corresponding to this `beforeInput` event.
             */ function getNativeBeforeInputChars(topLevelType, nativeEvent) {
              switch (topLevelType) {
                case 'topCompositionEnd':
                  return getDataFromCustomEvent(nativeEvent);
                case 'topKeyPress':
                  /**
                   * If native `textInput` events are available, our goal is to make
                   * use of them. However, there is a special case: the spacebar key.
                   * In Webkit, preventing default on a spacebar `textInput` event
                   * cancels character insertion, but it *also* causes the browser
                   * to fall back to its default spacebar behavior of scrolling the
                   * page.
                   *
                   * Tracking at:
                   * https://code.google.com/p/chromium/issues/detail?id=355103
                   *
                   * To avoid this issue, use the keypress event as if no `textInput`
                   * event is available.
                   */ var which = nativeEvent.which;
                  if (which !== SPACEBAR_CODE) {
                    return null;
                  }
                  hasSpaceKeypress = true;
                  return SPACEBAR_CHAR;
                case 'topTextInput': // Record the characters to be added to the DOM.
                  var chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled
                  // it at the keypress level and bail immediately. Android Chrome
                  // doesn't give us keycodes, so we need to blacklist it.
                  if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                    return null;
                  }
                  return chars;
                default:
                  // For other native event types, do nothing.
                  return null;
              }
            }
            /**
             * For browsers that do not provide the `textInput` event, extract the
             * appropriate string to use for SyntheticInputEvent.
             *
             * @param {string} topLevelType Record from `BrowserEventConstants`.
             * @param {object} nativeEvent Native browser event.
             * @return {?string} The fallback string for this `beforeInput` event.
             */ function getFallbackBeforeInputChars(
              topLevelType,
              nativeEvent
            ) {
              // If we are currently composing (IME) and using a fallback to do so,
              // try to extract the composed characters from the fallback object.
              // If composition event is available, we extract a string only at
              // compositionevent, otherwise extract it at fallback events.
              if (isComposing) {
                if (
                  topLevelType === 'topCompositionEnd' ||
                  (!canUseCompositionEvent &&
                    isFallbackCompositionEnd(topLevelType, nativeEvent))
                ) {
                  var chars = getData();
                  reset();
                  isComposing = false;
                  return chars;
                }
                return null;
              }
              switch (topLevelType) {
                case 'topPaste': // If a paste event occurs after a keypress, throw out the input
                  // chars. Paste events should not lead to BeforeInput events.
                  return null;
                case 'topKeyPress':
                  /**
                   * As of v27, Firefox may fire keypress events even when no character
                   * will be inserted. A few possibilities:
                   *
                   * - `which` is `0`. Arrow keys, Esc key, etc.
                   *
                   * - `which` is the pressed key code, but no char is available.
                   *   Ex: 'AltGr + d` in Polish. There is no modified character for
                   *   this key combination and no character is inserted into the
                   *   document, but FF fires the keypress for char code `100` anyway.
                   *   No `input` event will occur.
                   *
                   * - `which` is the pressed key code, but a command combination is
                   *   being used. Ex: `Cmd+C`. No character is inserted, and no
                   *   `input` event will occur.
                   */ if (!isKeypressCommand(nativeEvent)) {
                    // IE fires the `keypress` event when a user types an emoji via
                    // Touch keyboard of Windows.  In such a case, the `char` property
                    // holds an emoji character like `\uD83D\uDE0A`.  Because its length
                    // is 2, the property `which` does not represent an emoji correctly.
                    // In such a case, we directly return the `char` property instead of
                    // using `which`.
                    if (nativeEvent.char && nativeEvent.char.length > 1) {
                      return nativeEvent.char;
                    } else if (nativeEvent.which) {
                      return String.fromCharCode(nativeEvent.which);
                    }
                  }
                  return null;
                case 'topCompositionEnd':
                  return useFallbackCompositionData ? null : nativeEvent.data;
                default:
                  return null;
              }
            }
            /**
             * Extract a SyntheticInputEvent for `beforeInput`, based on either native
             * `textInput` or fallback behavior.
             *
             * @return {?object} A SyntheticInputEvent.
             */ function extractBeforeInputEvent(
              topLevelType,
              targetInst,
              nativeEvent,
              nativeEventTarget
            ) {
              var chars;
              if (canUseTextInputEvent) {
                chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
              } else {
                chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
              } // If no characters are being inserted, no BeforeInput event should
              // be fired.
              if (!chars) {
                return null;
              }
              var event = SyntheticInputEvent.getPooled(
                eventTypes.beforeInput,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
              event.data = chars;
              accumulateTwoPhaseDispatches(event);
              return event;
            }
            /**
             * Create an `onBeforeInput` event to match
             * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
             *
             * This event plugin is based on the native `textInput` event
             * available in Chrome, Safari, Opera, and IE. This event fires after
             * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
             *
             * `beforeInput` is spec'd but not implemented in any browsers, and
             * the `input` event does not provide any useful information about what has
             * actually been added, contrary to the spec. Thus, `textInput` is the best
             * available event to identify the characters that have actually been inserted
             * into the target node.
             *
             * This plugin is also responsible for emitting `composition` events, thus
             * allowing us to share composition fallback code for both `beforeInput` and
             * `composition` event types.
             */ var BeforeInputEventPlugin = {
              eventTypes: eventTypes,
              extractEvents: function extractEvents(
                topLevelType,
                targetInst,
                nativeEvent,
                nativeEventTarget
              ) {
                return [
                  extractCompositionEvent(
                    topLevelType,
                    targetInst,
                    nativeEvent,
                    nativeEventTarget
                  ),
                  extractBeforeInputEvent(
                    topLevelType,
                    targetInst,
                    nativeEvent,
                    nativeEventTarget
                  )
                ];
              }
            }; // Use to restore controlled state after a change event has fired.
            var fiberHostComponent = null;
            var ReactControlledComponentInjection = {
              injectFiberControlledHostComponent: function injectFiberControlledHostComponent(
                hostComponentImpl
              ) {
                // The fiber implementation doesn't use dynamic dispatch so we need to
                // inject the implementation.
                fiberHostComponent = hostComponentImpl;
              }
            };
            var restoreTarget = null;
            var restoreQueue = null;
            function restoreStateOfTarget(target) {
              // We perform this translation at the end of the event loop so that we
              // always receive the correct fiber here
              var internalInstance = getInstanceFromNode(target);
              if (!internalInstance) {
                // Unmounted
                return;
              }
              !(
                fiberHostComponent &&
                typeof fiberHostComponent.restoreControlledState === 'function'
              )
                ? invariant(
                    false,
                    'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.'
                  )
                : void 0;
              var props = getFiberCurrentPropsFromNode(
                internalInstance.stateNode
              );
              fiberHostComponent.restoreControlledState(
                internalInstance.stateNode,
                internalInstance.type,
                props
              );
            }
            var injection$3 = ReactControlledComponentInjection;
            function enqueueStateRestore(target) {
              if (restoreTarget) {
                if (restoreQueue) {
                  restoreQueue.push(target);
                } else {
                  restoreQueue = [target];
                }
              } else {
                restoreTarget = target;
              }
            }
            function restoreStateIfNeeded() {
              if (!restoreTarget) {
                return;
              }
              var target = restoreTarget;
              var queuedTargets = restoreQueue;
              restoreTarget = null;
              restoreQueue = null;
              restoreStateOfTarget(target);
              if (queuedTargets) {
                for (var i = 0; i < queuedTargets.length; i++) {
                  restoreStateOfTarget(queuedTargets[i]);
                }
              }
            }
            var ReactControlledComponent = Object.freeze({
              injection: injection$3,
              enqueueStateRestore: enqueueStateRestore,
              restoreStateIfNeeded: restoreStateIfNeeded
            }); // Used as a way to call batchedUpdates when we don't have a reference to
            // the renderer. Such as when we're dispatching events or if third party
            // libraries need to call batchedUpdates. Eventually, this API will go away when
            // everything is batched by default. We'll then have a similar API to opt-out of
            // scheduled work and instead do synchronous work.
            // Defaults
            var fiberBatchedUpdates = function fiberBatchedUpdates(
              fn,
              bookkeeping
            ) {
              return fn(bookkeeping);
            };
            var isNestingBatched = false;
            function batchedUpdates(fn, bookkeeping) {
              if (isNestingBatched) {
                // If we are currently inside another batch, we need to wait until it
                // fully completes before restoring state. Therefore, we add the target to
                // a queue of work.
                return fiberBatchedUpdates(fn, bookkeeping);
              }
              isNestingBatched = true;
              try {
                return fiberBatchedUpdates(fn, bookkeeping);
              } finally {
                // Here we wait until all updates have propagated, which is important
                // when using controlled components within layers:
                // https://github.com/facebook/react/issues/1698
                // Then we restore state of any controlled component.
                isNestingBatched = false;
                restoreStateIfNeeded();
              }
            }
            var ReactGenericBatchingInjection = {
              injectFiberBatchedUpdates: function injectFiberBatchedUpdates(
                _batchedUpdates
              ) {
                fiberBatchedUpdates = _batchedUpdates;
              }
            };
            var injection$4 = ReactGenericBatchingInjection;
            /**
             * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
             */ var supportedInputTypes = {
              color: true,
              date: true,
              datetime: true,
              'datetime-local': true,
              email: true,
              month: true,
              number: true,
              password: true,
              range: true,
              search: true,
              tel: true,
              text: true,
              time: true,
              url: true,
              week: true
            };
            function isTextInputElement(elem) {
              var nodeName =
                elem && elem.nodeName && elem.nodeName.toLowerCase();
              if (nodeName === 'input') {
                return !!supportedInputTypes[elem.type];
              }
              if (nodeName === 'textarea') {
                return true;
              }
              return false;
            }
            /**
             * HTML nodeType values that represent the type of the node
             */ var ELEMENT_NODE = 1;
            var TEXT_NODE = 3;
            var COMMENT_NODE = 8;
            var DOCUMENT_NODE = 9;
            var DOCUMENT_FRAGMENT_NODE = 11;
            /**
             * Gets the target node from a native browser event by accounting for
             * inconsistencies in browser DOM APIs.
             *
             * @param {object} nativeEvent Native browser event.
             * @return {DOMEventTarget} Target node.
             */ function getEventTarget(nativeEvent) {
              var target =
                nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963
              if (target.correspondingUseElement) {
                target = target.correspondingUseElement;
              } // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
              // @see http://www.quirksmode.org/js/events_properties.html
              return target.nodeType === TEXT_NODE ? target.parentNode : target;
            }
            var useHasFeature;
            if (ExecutionEnvironment.canUseDOM) {
              useHasFeature =
                document.implementation &&
                document.implementation.hasFeature && // always returns true in newer browsers as per the standard.
                // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
                document.implementation.hasFeature('', '') !== true;
            }
            /**
             * Checks if an event is supported in the current execution environment.
             *
             * NOTE: This will not work correctly for non-generic events such as `change`,
             * `reset`, `load`, `error`, and `select`.
             *
             * Borrows from Modernizr.
             *
             * @param {string} eventNameSuffix Event name, e.g. "click".
             * @param {?boolean} capture Check if the capture phase is supported.
             * @return {boolean} True if the event is supported.
             * @internal
             * @license Modernizr 3.0.0pre (Custom Build) | MIT
             */ function isEventSupported(eventNameSuffix, capture) {
              if (
                !ExecutionEnvironment.canUseDOM ||
                (capture && !('addEventListener' in document))
              ) {
                return false;
              }
              var eventName = 'on' + eventNameSuffix;
              var isSupported = eventName in document;
              if (!isSupported) {
                var element = document.createElement('div');
                element.setAttribute(eventName, 'return;');
                isSupported = typeof element[eventName] === 'function';
              }
              if (
                !isSupported &&
                useHasFeature &&
                eventNameSuffix === 'wheel'
              ) {
                // This is the only way to test support for the `wheel` event in IE9+.
                isSupported = document.implementation.hasFeature(
                  'Events.wheel',
                  '3.0'
                );
              }
              return isSupported;
            }
            function isCheckable(elem) {
              var type = elem.type;
              var nodeName = elem.nodeName;
              return (
                nodeName &&
                nodeName.toLowerCase() === 'input' &&
                (type === 'checkbox' || type === 'radio')
              );
            }
            function getTracker(node) {
              return node._valueTracker;
            }
            function detachTracker(node) {
              node._valueTracker = null;
            }
            function getValueFromNode(node) {
              var value = '';
              if (!node) {
                return value;
              }
              if (isCheckable(node)) {
                value = node.checked ? 'true' : 'false';
              } else {
                value = node.value;
              }
              return value;
            }
            function trackValueOnNode(node) {
              var valueField = isCheckable(node) ? 'checked' : 'value';
              var descriptor = Object.getOwnPropertyDescriptor(
                node.constructor.prototype,
                valueField
              );
              var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail
              // and don't track value will cause over reporting of changes,
              // but it's better then a hard failure
              // (needed for certain tests that spyOn input values and Safari)
              if (
                node.hasOwnProperty(valueField) ||
                typeof descriptor.get !== 'function' ||
                typeof descriptor.set !== 'function'
              ) {
                return;
              }
              Object.defineProperty(node, valueField, {
                enumerable: descriptor.enumerable,
                configurable: true,
                get: function get() {
                  return descriptor.get.call(this);
                },
                set: function set(value) {
                  currentValue = '' + value;
                  descriptor.set.call(this, value);
                }
              });
              var tracker = {
                getValue: function getValue() {
                  return currentValue;
                },
                setValue: function setValue(value) {
                  currentValue = '' + value;
                },
                stopTracking: function stopTracking() {
                  detachTracker(node);
                  delete node[valueField];
                }
              };
              return tracker;
            }
            function track(node) {
              if (getTracker(node)) {
                return;
              } // TODO: Once it's just Fiber we can move this to node._wrapperState
              node._valueTracker = trackValueOnNode(node);
            }
            function updateValueIfChanged(node) {
              if (!node) {
                return false;
              }
              var tracker = getTracker(node); // if there is no tracker at this point it's unlikely
              // that trying again will succeed
              if (!tracker) {
                return true;
              }
              var lastValue = tracker.getValue();
              var nextValue = getValueFromNode(node);
              if (nextValue !== lastValue) {
                tracker.setValue(nextValue);
                return true;
              }
              return false;
            }
            var eventTypes$1 = {
              change: {
                phasedRegistrationNames: {
                  bubbled: 'onChange',
                  captured: 'onChangeCapture'
                },
                dependencies: [
                  'topBlur',
                  'topChange',
                  'topClick',
                  'topFocus',
                  'topInput',
                  'topKeyDown',
                  'topKeyUp',
                  'topSelectionChange'
                ]
              }
            };
            function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
              var event = SyntheticEvent$1.getPooled(
                eventTypes$1.change,
                inst,
                nativeEvent,
                target
              );
              event.type = 'change'; // Flag this event loop as needing state restore.
              enqueueStateRestore(target);
              accumulateTwoPhaseDispatches(event);
              return event;
            }
            /**
             * For IE shims
             */ var activeElement = null;
            var activeElementInst = null;
            /**
             * SECTION: handle `change` event
             */ function shouldUseChangeEvent(elem) {
              var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
              return (
                nodeName === 'select' ||
                (nodeName === 'input' && elem.type === 'file')
              );
            }
            function manualDispatchChangeEvent(nativeEvent) {
              var event = createAndAccumulateChangeEvent(
                activeElementInst,
                nativeEvent,
                getEventTarget(nativeEvent)
              ); // If change and propertychange bubbled, we'd just bind to it like all the
              // other events and have it go through ReactBrowserEventEmitter. Since it
              // doesn't, we manually listen for the events and so we have to enqueue and
              // process the abstract event manually.
              //
              // Batching is necessary here in order to ensure that all event handlers run
              // before the next rerender (including event handlers attached to ancestor
              // elements instead of directly on the input). Without this, controlled
              // components don't work properly in conjunction with event bubbling because
              // the component is rerendered and the value reverted before all the event
              // handlers can run. See https://github.com/facebook/react/issues/708.
              batchedUpdates(runEventInBatch, event);
            }
            function runEventInBatch(event) {
              enqueueEvents(event);
              processEventQueue(false);
            }
            function getInstIfValueChanged(targetInst) {
              var targetNode = getNodeFromInstance$1(targetInst);
              if (updateValueIfChanged(targetNode)) {
                return targetInst;
              }
            }
            function getTargetInstForChangeEvent(topLevelType, targetInst) {
              if (topLevelType === 'topChange') {
                return targetInst;
              }
            }
            /**
             * SECTION: handle `input` event
             */ var isInputEventSupported = false;
            if (ExecutionEnvironment.canUseDOM) {
              // IE9 claims to support the input event but fails to trigger it when
              // deleting text, so we ignore its input events.
              isInputEventSupported =
                isEventSupported('input') &&
                (!document.documentMode || document.documentMode > 9);
            }
            /**
             * (For IE <=9) Starts tracking propertychange events on the passed-in element
             * and override the value property so that we can distinguish user events from
             * value changes in JS.
             */ function startWatchingForValueChange(target, targetInst) {
              activeElement = target;
              activeElementInst = targetInst;
              activeElement.attachEvent(
                'onpropertychange',
                handlePropertyChange
              );
            }
            /**
             * (For IE <=9) Removes the event listeners from the currently-tracked element,
             * if any exists.
             */ function stopWatchingForValueChange() {
              if (!activeElement) {
                return;
              }
              activeElement.detachEvent(
                'onpropertychange',
                handlePropertyChange
              );
              activeElement = null;
              activeElementInst = null;
            }
            /**
             * (For IE <=9) Handles a propertychange event, sending a `change` event if
             * the value of the active element has changed.
             */ function handlePropertyChange(nativeEvent) {
              if (nativeEvent.propertyName !== 'value') {
                return;
              }
              if (getInstIfValueChanged(activeElementInst)) {
                manualDispatchChangeEvent(nativeEvent);
              }
            }
            function handleEventsForInputEventPolyfill(
              topLevelType,
              target,
              targetInst
            ) {
              if (topLevelType === 'topFocus') {
                // In IE9, propertychange fires for most input events but is buggy and
                // doesn't fire when text is deleted, but conveniently, selectionchange
                // appears to fire in all of the remaining cases so we catch those and
                // forward the event if the value has changed
                // In either case, we don't want to call the event handler if the value
                // is changed from JS so we redefine a setter for `.value` that updates
                // our activeElementValue variable, allowing us to ignore those changes
                //
                // stopWatching() should be a noop here but we call it just in case we
                // missed a blur event somehow.
                stopWatchingForValueChange();
                startWatchingForValueChange(target, targetInst);
              } else if (topLevelType === 'topBlur') {
                stopWatchingForValueChange();
              }
            } // For IE8 and IE9.
            function getTargetInstForInputEventPolyfill(
              topLevelType,
              targetInst
            ) {
              if (
                topLevelType === 'topSelectionChange' ||
                topLevelType === 'topKeyUp' ||
                topLevelType === 'topKeyDown'
              ) {
                // On the selectionchange event, the target is just document which isn't
                // helpful for us so just check activeElement instead.
                //
                // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
                // propertychange on the first input event after setting `value` from a
                // script and fires only keydown, keypress, keyup. Catching keyup usually
                // gets it and catching keydown lets us fire an event for the first
                // keystroke if user does a key repeat (it'll be a little delayed: right
                // before the second keystroke). Other input methods (e.g., paste) seem to
                // fire selectionchange normally.
                return getInstIfValueChanged(activeElementInst);
              }
            }
            /**
             * SECTION: handle `click` event
             */ function shouldUseClickEvent(elem) {
              // Use the `click` event to detect changes to checkbox and radio inputs.
              // This approach works across all browsers, whereas `change` does not fire
              // until `blur` in IE8.
              var nodeName = elem.nodeName;
              return (
                nodeName &&
                nodeName.toLowerCase() === 'input' &&
                (elem.type === 'checkbox' || elem.type === 'radio')
              );
            }
            function getTargetInstForClickEvent(topLevelType, targetInst) {
              if (topLevelType === 'topClick') {
                return getInstIfValueChanged(targetInst);
              }
            }
            function getTargetInstForInputOrChangeEvent(
              topLevelType,
              targetInst
            ) {
              if (topLevelType === 'topInput' || topLevelType === 'topChange') {
                return getInstIfValueChanged(targetInst);
              }
            }
            function handleControlledInputBlur(inst, node) {
              // TODO: In IE, inst is occasionally null. Why?
              if (inst == null) {
                return;
              } // Fiber and ReactDOM keep wrapper state in separate places
              var state = inst._wrapperState || node._wrapperState;
              if (!state || !state.controlled || node.type !== 'number') {
                return;
              } // If controlled, assign the value attribute to the current value on blur
              var value = '' + node.value;
              if (node.getAttribute('value') !== value) {
                node.setAttribute('value', value);
              }
            }
            /**
             * This plugin creates an `onChange` event that normalizes change events
             * across form elements. This event fires at a time when it's possible to
             * change the element's value without seeing a flicker.
             *
             * Supported elements are:
             * - input (see `isTextInputElement`)
             * - textarea
             * - select
             */ var ChangeEventPlugin = {
              eventTypes: eventTypes$1,
              _isInputEventSupported: isInputEventSupported,
              extractEvents: function extractEvents(
                topLevelType,
                targetInst,
                nativeEvent,
                nativeEventTarget
              ) {
                var targetNode = targetInst
                  ? getNodeFromInstance$1(targetInst)
                  : window;
                var getTargetInstFunc, handleEventFunc;
                if (shouldUseChangeEvent(targetNode)) {
                  getTargetInstFunc = getTargetInstForChangeEvent;
                } else if (isTextInputElement(targetNode)) {
                  if (isInputEventSupported) {
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  } else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                } else if (shouldUseClickEvent(targetNode)) {
                  getTargetInstFunc = getTargetInstForClickEvent;
                }
                if (getTargetInstFunc) {
                  var inst = getTargetInstFunc(topLevelType, targetInst);
                  if (inst) {
                    var event = createAndAccumulateChangeEvent(
                      inst,
                      nativeEvent,
                      nativeEventTarget
                    );
                    return event;
                  }
                }
                if (handleEventFunc) {
                  handleEventFunc(topLevelType, targetNode, targetInst);
                } // When blurring, set the value attribute for number inputs
                if (topLevelType === 'topBlur') {
                  handleControlledInputBlur(targetInst, targetNode);
                }
              }
            };
            /**
             * Module that is injectable into `EventPluginHub`, that specifies a
             * deterministic ordering of `EventPlugin`s. A convenient way to reason about
             * plugins, without having to package every one of them. This is better than
             * having plugins be ordered in the same order that they are injected because
             * that ordering would be influenced by the packaging order.
             * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
             * preventing default on events is convenient in `SimpleEventPlugin` handlers.
             */ var DOMEventPluginOrder = [
              'ResponderEventPlugin',
              'SimpleEventPlugin',
              'TapEventPlugin',
              'EnterLeaveEventPlugin',
              'ChangeEventPlugin',
              'SelectEventPlugin',
              'BeforeInputEventPlugin'
            ];
            /**
             * @interface UIEvent
             * @see http://www.w3.org/TR/DOM-Level-3-Events/
             */ var UIEventInterface = { view: null, detail: null };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticEvent}
             */ function SyntheticUIEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticEvent$1.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);
            /**
             * Translation from modifier key to the associated property in the event.
             * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
             */ var modifierKeyToProp = {
              Alt: 'altKey',
              Control: 'ctrlKey',
              Meta: 'metaKey',
              Shift: 'shiftKey'
            }; // IE8 does not implement getModifierState so we simply map it to the only
            // modifier keys exposed by the event itself, does not support Lock-keys.
            // Currently, all major browsers except Chrome seems to support Lock-keys.
            function modifierStateGetter(keyArg) {
              var syntheticEvent = this;
              var nativeEvent = syntheticEvent.nativeEvent;
              if (nativeEvent.getModifierState) {
                return nativeEvent.getModifierState(keyArg);
              }
              var keyProp = modifierKeyToProp[keyArg];
              return keyProp ? !!nativeEvent[keyProp] : false;
            }
            function getEventModifierState(nativeEvent) {
              return modifierStateGetter;
            }
            /**
             * @interface MouseEvent
             * @see http://www.w3.org/TR/DOM-Level-3-Events/
             */ var MouseEventInterface = {
              screenX: null,
              screenY: null,
              clientX: null,
              clientY: null,
              pageX: null,
              pageY: null,
              ctrlKey: null,
              shiftKey: null,
              altKey: null,
              metaKey: null,
              getModifierState: getEventModifierState,
              button: null,
              buttons: null,
              relatedTarget: function relatedTarget(event) {
                return (
                  event.relatedTarget ||
                  (event.fromElement === event.srcElement
                    ? event.toElement
                    : event.fromElement)
                );
              }
            };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticUIEvent}
             */ function SyntheticMouseEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticUIEvent.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticUIEvent.augmentClass(
              SyntheticMouseEvent,
              MouseEventInterface
            );
            var eventTypes$2 = {
              mouseEnter: {
                registrationName: 'onMouseEnter',
                dependencies: ['topMouseOut', 'topMouseOver']
              },
              mouseLeave: {
                registrationName: 'onMouseLeave',
                dependencies: ['topMouseOut', 'topMouseOver']
              }
            };
            var EnterLeaveEventPlugin = {
              eventTypes: eventTypes$2,
              /**
               * For almost every interaction we care about, there will be both a top-level
               * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
               * we do not extract duplicate events. However, moving the mouse into the
               * browser from outside will not fire a `mouseout` event. In this case, we use
               * the `mouseover` top-level event.
               */ extractEvents: function extractEvents(
                topLevelType,
                targetInst,
                nativeEvent,
                nativeEventTarget
              ) {
                if (
                  topLevelType === 'topMouseOver' &&
                  (nativeEvent.relatedTarget || nativeEvent.fromElement)
                ) {
                  return null;
                }
                if (
                  topLevelType !== 'topMouseOut' &&
                  topLevelType !== 'topMouseOver'
                ) {
                  // Must not be a mouse in or mouse out - ignoring.
                  return null;
                }
                var win;
                if (nativeEventTarget.window === nativeEventTarget) {
                  // `nativeEventTarget` is probably a window object.
                  win = nativeEventTarget;
                } else {
                  // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
                  var doc = nativeEventTarget.ownerDocument;
                  if (doc) {
                    win = doc.defaultView || doc.parentWindow;
                  } else {
                    win = window;
                  }
                }
                var from;
                var to;
                if (topLevelType === 'topMouseOut') {
                  from = targetInst;
                  var related =
                    nativeEvent.relatedTarget || nativeEvent.toElement;
                  to = related ? getClosestInstanceFromNode(related) : null;
                } else {
                  // Moving to a node from outside the window.
                  from = null;
                  to = targetInst;
                }
                if (from === to) {
                  // Nothing pertains to our managed components.
                  return null;
                }
                var fromNode = from == null ? win : getNodeFromInstance$1(from);
                var toNode = to == null ? win : getNodeFromInstance$1(to);
                var leave = SyntheticMouseEvent.getPooled(
                  eventTypes$2.mouseLeave,
                  from,
                  nativeEvent,
                  nativeEventTarget
                );
                leave.type = 'mouseleave';
                leave.target = fromNode;
                leave.relatedTarget = toNode;
                var enter = SyntheticMouseEvent.getPooled(
                  eventTypes$2.mouseEnter,
                  to,
                  nativeEvent,
                  nativeEventTarget
                );
                enter.type = 'mouseenter';
                enter.target = toNode;
                enter.relatedTarget = fromNode;
                accumulateEnterLeaveDispatches(leave, enter, from, to);
                return [leave, enter];
              }
            };
            /**
             * `ReactInstanceMap` maintains a mapping from a public facing stateful
             * instance (key) and the internal representation (value). This allows public
             * methods to accept the user facing instance as an argument and map them back
             * to internal methods.
             *
             * Note that this module is currently shared and assumed to be stateless.
             * If this becomes an actual Map, that will break.
             */ /**
             * This API should be called `delete` but we'd have to make sure to always
             * transform these to strings for IE support. When this transform is fully
             * supported we can rename it.
             */ function get(key) {
              return key._reactInternalFiber;
            }
            function has(key) {
              return key._reactInternalFiber !== undefined;
            }
            function set(key, value) {
              key._reactInternalFiber = value;
            }
            var ReactInternals =
              React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
            var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
            var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;
            function getComponentName(fiber) {
              var type = fiber.type;
              if (typeof type === 'string') {
                return type;
              }
              if (typeof type === 'function') {
                return type.displayName || type.name;
              }
              return null;
            } // Don't change these two values:
            var NoEffect = 0; //           0b00000000
            var PerformedWork = 1; //      0b00000001
            // You can change the rest (and add more).
            var Placement = 2; //          0b00000010
            var Update = 4; //             0b00000100
            var PlacementAndUpdate = 6; // 0b00000110
            var Deletion = 8; //           0b00001000
            var ContentReset = 16; //      0b00010000
            var Callback = 32; //          0b00100000
            var Err = 64; //               0b01000000
            var Ref = 128; //              0b10000000
            var MOUNTING = 1;
            var MOUNTED = 2;
            var UNMOUNTED = 3;
            function isFiberMountedImpl(fiber) {
              var node = fiber;
              if (!fiber.alternate) {
                // If there is no alternate, this might be a new tree that isn't inserted
                // yet. If it is, then it will have a pending insertion effect on it.
                if ((node.effectTag & Placement) !== NoEffect) {
                  return MOUNTING;
                }
                while (node['return']) {
                  node = node['return'];
                  if ((node.effectTag & Placement) !== NoEffect) {
                    return MOUNTING;
                  }
                }
              } else {
                while (node['return']) {
                  node = node['return'];
                }
              }
              if (node.tag === HostRoot) {
                // TODO: Check if this was a nested HostRoot when used with
                // renderContainerIntoSubtree.
                return MOUNTED;
              } // If we didn't hit the root, that means that we're in an disconnected tree
              // that has been unmounted.
              return UNMOUNTED;
            }
            function isFiberMounted(fiber) {
              return isFiberMountedImpl(fiber) === MOUNTED;
            }
            function isMounted(component) {
              {
                var owner = ReactCurrentOwner.current;
                if (owner !== null && owner.tag === ClassComponent) {
                  var ownerFiber = owner;
                  var instance = ownerFiber.stateNode;
                  warning(
                    instance._warnedAboutRefsInRender,
                    '%s is accessing isMounted inside its render() function. ' +
                      'render() should be a pure function of props and state. It should ' +
                      'never access something that requires stale data from the previous ' +
                      'render, such as refs. Move this logic to componentDidMount and ' +
                      'componentDidUpdate instead.',
                    getComponentName(ownerFiber) || 'A component'
                  );
                  instance._warnedAboutRefsInRender = true;
                }
              }
              var fiber = get(component);
              if (!fiber) {
                return false;
              }
              return isFiberMountedImpl(fiber) === MOUNTED;
            }
            function assertIsMounted(fiber) {
              !(isFiberMountedImpl(fiber) === MOUNTED)
                ? invariant(
                    false,
                    'Unable to find node on an unmounted component.'
                  )
                : void 0;
            }
            function findCurrentFiberUsingSlowPath(fiber) {
              var alternate = fiber.alternate;
              if (!alternate) {
                // If there is no alternate, then we only need to check if it is mounted.
                var state = isFiberMountedImpl(fiber);
                !(state !== UNMOUNTED)
                  ? invariant(
                      false,
                      'Unable to find node on an unmounted component.'
                    )
                  : void 0;
                if (state === MOUNTING) {
                  return null;
                }
                return fiber;
              } // If we have two possible branches, we'll walk backwards up to the root
              // to see what path the root points to. On the way we may hit one of the
              // special cases and we'll deal with them.
              var a = fiber;
              var b = alternate;
              while (true) {
                var parentA = a['return'];
                var parentB = parentA ? parentA.alternate : null;
                if (!parentA || !parentB) {
                  // We're at the root.
                  break;
                } // If both copies of the parent fiber point to the same child, we can
                // assume that the child is current. This happens when we bailout on low
                // priority: the bailed out fiber's child reuses the current child.
                if (parentA.child === parentB.child) {
                  var child = parentA.child;
                  while (child) {
                    if (child === a) {
                      // We've determined that A is the current branch.
                      assertIsMounted(parentA);
                      return fiber;
                    }
                    if (child === b) {
                      // We've determined that B is the current branch.
                      assertIsMounted(parentA);
                      return alternate;
                    }
                    child = child.sibling;
                  } // We should never have an alternate for any mounting node. So the only
                  // way this could possibly happen is if this was unmounted, if at all.
                  invariant(
                    false,
                    'Unable to find node on an unmounted component.'
                  );
                }
                if (a['return'] !== b['return']) {
                  // The return pointer of A and the return pointer of B point to different
                  // fibers. We assume that return pointers never criss-cross, so A must
                  // belong to the child set of A.return, and B must belong to the child
                  // set of B.return.
                  a = parentA;
                  b = parentB;
                } else {
                  // The return pointers point to the same fiber. We'll have to use the
                  // default, slow path: scan the child sets of each parent alternate to see
                  // which child belongs to which set.
                  //
                  // Search parent A's child set
                  var didFindChild = false;
                  var _child = parentA.child;
                  while (_child) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentA;
                      b = parentB;
                      break;
                    }
                    if (_child === b) {
                      didFindChild = true;
                      b = parentA;
                      a = parentB;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    // Search parent B's child set
                    _child = parentB.child;
                    while (_child) {
                      if (_child === a) {
                        didFindChild = true;
                        a = parentB;
                        b = parentA;
                        break;
                      }
                      if (_child === b) {
                        didFindChild = true;
                        b = parentB;
                        a = parentA;
                        break;
                      }
                      _child = _child.sibling;
                    }
                    !didFindChild
                      ? invariant(
                          false,
                          'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'
                        )
                      : void 0;
                  }
                }
                !(a.alternate === b)
                  ? invariant(
                      false,
                      "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
                    )
                  : void 0;
              } // If the root is not a host container, we're in a disconnected tree. I.e.
              // unmounted.
              !(a.tag === HostRoot)
                ? invariant(
                    false,
                    'Unable to find node on an unmounted component.'
                  )
                : void 0;
              if (a.stateNode.current === a) {
                // We've determined that A is the current branch.
                return fiber;
              } // Otherwise B has to be current branch.
              return alternate;
            }
            function findCurrentHostFiber(parent) {
              var currentParent = findCurrentFiberUsingSlowPath(parent);
              if (!currentParent) {
                return null;
              } // Next we'll drill down this component to find the first HostComponent/Text.
              var node = currentParent;
              while (true) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  return node;
                } else if (node.child) {
                  node.child['return'] = node;
                  node = node.child;
                  continue;
                }
                if (node === currentParent) {
                  return null;
                }
                while (!node.sibling) {
                  if (!node['return'] || node['return'] === currentParent) {
                    return null;
                  }
                  node = node['return'];
                }
                node.sibling['return'] = node['return'];
                node = node.sibling;
              } // Flow needs the return null here, but ESLint complains about it.
              // eslint-disable-next-line no-unreachable
              return null;
            }
            function findCurrentHostFiberWithNoPortals(parent) {
              var currentParent = findCurrentFiberUsingSlowPath(parent);
              if (!currentParent) {
                return null;
              } // Next we'll drill down this component to find the first HostComponent/Text.
              var node = currentParent;
              while (true) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  return node;
                } else if (node.child && node.tag !== HostPortal) {
                  node.child['return'] = node;
                  node = node.child;
                  continue;
                }
                if (node === currentParent) {
                  return null;
                }
                while (!node.sibling) {
                  if (!node['return'] || node['return'] === currentParent) {
                    return null;
                  }
                  node = node['return'];
                }
                node.sibling['return'] = node['return'];
                node = node.sibling;
              } // Flow needs the return null here, but ESLint complains about it.
              // eslint-disable-next-line no-unreachable
              return null;
            }
            var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
            var callbackBookkeepingPool = [];
            /**
             * Find the deepest React component completely containing the root of the
             * passed-in instance (for use when entire React trees are nested within each
             * other). If React trees are not nested, returns null.
             */ function findRootContainerNode(inst) {
              // TODO: It may be a good idea to cache this to prevent unnecessary DOM
              // traversal, but caching is difficult to do correctly without using a
              // mutation observer to listen for all DOM changes.
              while (inst['return']) {
                inst = inst['return'];
              }
              if (inst.tag !== HostRoot) {
                // This can happen if we're in a detached tree.
                return null;
              }
              return inst.stateNode.containerInfo;
            } // Used to store ancestor hierarchy in top level callback
            function getTopLevelCallbackBookKeeping(
              topLevelType,
              nativeEvent,
              targetInst
            ) {
              if (callbackBookkeepingPool.length) {
                var instance = callbackBookkeepingPool.pop();
                instance.topLevelType = topLevelType;
                instance.nativeEvent = nativeEvent;
                instance.targetInst = targetInst;
                return instance;
              }
              return {
                topLevelType: topLevelType,
                nativeEvent: nativeEvent,
                targetInst: targetInst,
                ancestors: []
              };
            }
            function releaseTopLevelCallbackBookKeeping(instance) {
              instance.topLevelType = null;
              instance.nativeEvent = null;
              instance.targetInst = null;
              instance.ancestors.length = 0;
              if (
                callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE
              ) {
                callbackBookkeepingPool.push(instance);
              }
            }
            function handleTopLevelImpl(bookKeeping) {
              var targetInst = bookKeeping.targetInst; // Loop through the hierarchy, in case there's any nested components.
              // It's important that we build the array of ancestors before calling any
              // event handlers, because event handlers can modify the DOM, leading to
              // inconsistencies with ReactMount's node cache. See #1105.
              var ancestor = targetInst;
              do {
                if (!ancestor) {
                  bookKeeping.ancestors.push(ancestor);
                  break;
                }
                var root = findRootContainerNode(ancestor);
                if (!root) {
                  break;
                }
                bookKeeping.ancestors.push(ancestor);
                ancestor = getClosestInstanceFromNode(root);
              } while (ancestor);
              for (var i = 0; i < bookKeeping.ancestors.length; i++) {
                targetInst = bookKeeping.ancestors[i];
                _handleTopLevel(
                  bookKeeping.topLevelType,
                  targetInst,
                  bookKeeping.nativeEvent,
                  getEventTarget(bookKeeping.nativeEvent)
                );
              }
            } // TODO: can we stop exporting these?
            var _enabled = true;
            var _handleTopLevel = void 0;
            function setHandleTopLevel(handleTopLevel) {
              _handleTopLevel = handleTopLevel;
            }
            function setEnabled(enabled) {
              _enabled = !!enabled;
            }
            function isEnabled() {
              return _enabled;
            }
            /**
             * Traps top-level events by using event bubbling.
             *
             * @param {string} topLevelType Record from `BrowserEventConstants`.
             * @param {string} handlerBaseName Event name (e.g. "click").
             * @param {object} element Element on which to attach listener.
             * @return {?object} An object with a remove function which will forcefully
             *                  remove the listener.
             * @internal
             */ function trapBubbledEvent(
              topLevelType,
              handlerBaseName,
              element
            ) {
              if (!element) {
                return null;
              }
              return EventListener.listen(
                element,
                handlerBaseName,
                dispatchEvent.bind(null, topLevelType)
              );
            }
            /**
             * Traps a top-level event by using event capturing.
             *
             * @param {string} topLevelType Record from `BrowserEventConstants`.
             * @param {string} handlerBaseName Event name (e.g. "click").
             * @param {object} element Element on which to attach listener.
             * @return {?object} An object with a remove function which will forcefully
             *                  remove the listener.
             * @internal
             */ function trapCapturedEvent(
              topLevelType,
              handlerBaseName,
              element
            ) {
              if (!element) {
                return null;
              }
              return EventListener.capture(
                element,
                handlerBaseName,
                dispatchEvent.bind(null, topLevelType)
              );
            }
            function dispatchEvent(topLevelType, nativeEvent) {
              if (!_enabled) {
                return;
              }
              var nativeEventTarget = getEventTarget(nativeEvent);
              var targetInst = getClosestInstanceFromNode(nativeEventTarget);
              if (
                targetInst !== null &&
                typeof targetInst.tag === 'number' &&
                !isFiberMounted(targetInst)
              ) {
                // If we get an event (ex: img onload) before committing that
                // component's mount, ignore it for now (that is, treat it as if it was an
                // event on a non-React tree). We might also consider queueing events and
                // dispatching them after the mount.
                targetInst = null;
              }
              var bookKeeping = getTopLevelCallbackBookKeeping(
                topLevelType,
                nativeEvent,
                targetInst
              );
              try {
                // Event queue being processed in the same cycle allows
                // `preventDefault`.
                batchedUpdates(handleTopLevelImpl, bookKeeping);
              } finally {
                releaseTopLevelCallbackBookKeeping(bookKeeping);
              }
            }
            var ReactDOMEventListener = Object.freeze({
              get _enabled() {
                return _enabled;
              },
              get _handleTopLevel() {
                return _handleTopLevel;
              },
              setHandleTopLevel: setHandleTopLevel,
              setEnabled: setEnabled,
              isEnabled: isEnabled,
              trapBubbledEvent: trapBubbledEvent,
              trapCapturedEvent: trapCapturedEvent,
              dispatchEvent: dispatchEvent
            });
            /**
             * Generate a mapping of standard vendor prefixes using the defined style property and event name.
             *
             * @param {string} styleProp
             * @param {string} eventName
             * @returns {object}
             */ function makePrefixMap(styleProp, eventName) {
              var prefixes = {};
              prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
              prefixes['Webkit' + styleProp] = 'webkit' + eventName;
              prefixes['Moz' + styleProp] = 'moz' + eventName;
              prefixes['ms' + styleProp] = 'MS' + eventName;
              prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();
              return prefixes;
            }
            /**
             * A list of event names to a configurable list of vendor prefixes.
             */ var vendorPrefixes = {
              animationend: makePrefixMap('Animation', 'AnimationEnd'),
              animationiteration: makePrefixMap(
                'Animation',
                'AnimationIteration'
              ),
              animationstart: makePrefixMap('Animation', 'AnimationStart'),
              transitionend: makePrefixMap('Transition', 'TransitionEnd')
            };
            /**
             * Event names that have already been detected and prefixed (if applicable).
             */ var prefixedEventNames = {};
            /**
             * Element to check for prefixes on.
             */ var style = {};
            /**
             * Bootstrap if a DOM exists.
             */ if (ExecutionEnvironment.canUseDOM) {
              style = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,
              // the un-prefixed "animation" and "transition" properties are defined on the
              // style object but the events that fire will still be prefixed, so we need
              // to check if the un-prefixed events are usable, and if not remove them from the map.
              if (!('AnimationEvent' in window)) {
                delete vendorPrefixes.animationend.animation;
                delete vendorPrefixes.animationiteration.animation;
                delete vendorPrefixes.animationstart.animation;
              } // Same as above
              if (!('TransitionEvent' in window)) {
                delete vendorPrefixes.transitionend.transition;
              }
            }
            /**
             * Attempts to determine the correct vendor prefixed event name.
             *
             * @param {string} eventName
             * @returns {string}
             */ function getVendorPrefixedEventName(eventName) {
              if (prefixedEventNames[eventName]) {
                return prefixedEventNames[eventName];
              } else if (!vendorPrefixes[eventName]) {
                return eventName;
              }
              var prefixMap = vendorPrefixes[eventName];
              for (var styleProp in prefixMap) {
                if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                  return (prefixedEventNames[eventName] = prefixMap[styleProp]);
                }
              }
              return '';
            }
            /**
             * Types of raw signals from the browser caught at the top level.
             *
             * For events like 'submit' which don't consistently bubble (which we
             * trap at a lower node than `document`), binding at `document` would
             * cause duplicate events so we don't include them here.
             */ var topLevelTypes$1 = {
              topAbort: 'abort',
              topAnimationEnd:
                getVendorPrefixedEventName('animationend') || 'animationend',
              topAnimationIteration:
                getVendorPrefixedEventName('animationiteration') ||
                'animationiteration',
              topAnimationStart:
                getVendorPrefixedEventName('animationstart') ||
                'animationstart',
              topBlur: 'blur',
              topCancel: 'cancel',
              topCanPlay: 'canplay',
              topCanPlayThrough: 'canplaythrough',
              topChange: 'change',
              topClick: 'click',
              topClose: 'close',
              topCompositionEnd: 'compositionend',
              topCompositionStart: 'compositionstart',
              topCompositionUpdate: 'compositionupdate',
              topContextMenu: 'contextmenu',
              topCopy: 'copy',
              topCut: 'cut',
              topDoubleClick: 'dblclick',
              topDrag: 'drag',
              topDragEnd: 'dragend',
              topDragEnter: 'dragenter',
              topDragExit: 'dragexit',
              topDragLeave: 'dragleave',
              topDragOver: 'dragover',
              topDragStart: 'dragstart',
              topDrop: 'drop',
              topDurationChange: 'durationchange',
              topEmptied: 'emptied',
              topEncrypted: 'encrypted',
              topEnded: 'ended',
              topError: 'error',
              topFocus: 'focus',
              topInput: 'input',
              topKeyDown: 'keydown',
              topKeyPress: 'keypress',
              topKeyUp: 'keyup',
              topLoadedData: 'loadeddata',
              topLoad: 'load',
              topLoadedMetadata: 'loadedmetadata',
              topLoadStart: 'loadstart',
              topMouseDown: 'mousedown',
              topMouseMove: 'mousemove',
              topMouseOut: 'mouseout',
              topMouseOver: 'mouseover',
              topMouseUp: 'mouseup',
              topPaste: 'paste',
              topPause: 'pause',
              topPlay: 'play',
              topPlaying: 'playing',
              topProgress: 'progress',
              topRateChange: 'ratechange',
              topScroll: 'scroll',
              topSeeked: 'seeked',
              topSeeking: 'seeking',
              topSelectionChange: 'selectionchange',
              topStalled: 'stalled',
              topSuspend: 'suspend',
              topTextInput: 'textInput',
              topTimeUpdate: 'timeupdate',
              topToggle: 'toggle',
              topTouchCancel: 'touchcancel',
              topTouchEnd: 'touchend',
              topTouchMove: 'touchmove',
              topTouchStart: 'touchstart',
              topTransitionEnd:
                getVendorPrefixedEventName('transitionend') || 'transitionend',
              topVolumeChange: 'volumechange',
              topWaiting: 'waiting',
              topWheel: 'wheel'
            };
            var BrowserEventConstants = { topLevelTypes: topLevelTypes$1 };
            function runEventQueueInBatch(events) {
              enqueueEvents(events);
              processEventQueue(false);
            }
            /**
             * Streams a fired top-level event to `EventPluginHub` where plugins have the
             * opportunity to create `ReactEvent`s to be dispatched.
             */ function handleTopLevel(
              topLevelType,
              targetInst,
              nativeEvent,
              nativeEventTarget
            ) {
              var events = extractEvents(
                topLevelType,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
              runEventQueueInBatch(events);
            }
            var topLevelTypes = BrowserEventConstants.topLevelTypes;
            /**
             * Summary of `ReactBrowserEventEmitter` event handling:
             *
             *  - Top-level delegation is used to trap most native browser events. This
             *    may only occur in the main thread and is the responsibility of
             *    ReactDOMEventListener, which is injected and can therefore support
             *    pluggable event sources. This is the only work that occurs in the main
             *    thread.
             *
             *  - We normalize and de-duplicate events to account for browser quirks. This
             *    may be done in the worker thread.
             *
             *  - Forward these native events (with the associated top-level type used to
             *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
             *    to extract any synthetic events.
             *
             *  - The `EventPluginHub` will then process each event by annotating them with
             *    "dispatches", a sequence of listeners and IDs that care about that event.
             *
             *  - The `EventPluginHub` then dispatches the events.
             *
             * Overview of React and the event system:
             *
             * +------------+    .
             * |    DOM     |    .
             * +------------+    .
             *       |           .
             *       v           .
             * +------------+    .
             * | ReactEvent |    .
             * |  Listener  |    .
             * +------------+    .                         +-----------+
             *       |           .               +--------+|SimpleEvent|
             *       |           .               |         |Plugin     |
             * +-----|------+    .               v         +-----------+
             * |     |      |    .    +--------------+                    +------------+
             * |     +-----------.--->|EventPluginHub|                    |    Event   |
             * |            |    .    |              |     +-----------+  | Propagators|
             * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
             * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
             * |            |    .    |              |     +-----------+  |  utilities |
             * |     +-----------.--->|              |                    +------------+
             * |     |      |    .    +--------------+
             * +-----|------+    .                ^        +-----------+
             *       |           .                |        |Enter/Leave|
             *       +           .                +-------+|Plugin     |
             * +-------------+   .                         +-----------+
             * | application |   .
             * |-------------|   .
             * |             |   .
             * |             |   .
             * +-------------+   .
             *                   .
             *    React Core     .  General Purpose Event Plugin System
             */ var alreadyListeningTo = {};
            var reactTopListenersCounter = 0;
            /**
             * To ensure no conflicts with other potential React instances on the page
             */ var topListenersIDKey =
              '_reactListenersID' + ('' + Math.random()).slice(2);
            function getListeningForDocument(mountAt) {
              // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
              // directly.
              if (
                !Object.prototype.hasOwnProperty.call(
                  mountAt,
                  topListenersIDKey
                )
              ) {
                mountAt[topListenersIDKey] = reactTopListenersCounter++;
                alreadyListeningTo[mountAt[topListenersIDKey]] = {};
              }
              return alreadyListeningTo[mountAt[topListenersIDKey]];
            }
            /**
             * We listen for bubbled touch events on the document object.
             *
             * Firefox v8.01 (and possibly others) exhibited strange behavior when
             * mounting `onmousemove` events at some node that was not the document
             * element. The symptoms were that if your mouse is not moving over something
             * contained within that mount point (for example on the background) the
             * top-level listeners for `onmousemove` won't be called. However, if you
             * register the `mousemove` on the document object, then it will of course
             * catch all `mousemove`s. This along with iOS quirks, justifies restricting
             * top-level listeners to the document object only, at least for these
             * movement types of events and possibly all events.
             *
             * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
             *
             * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
             * they bubble to document.
             *
             * @param {string} registrationName Name of listener (e.g. `onClick`).
             * @param {object} contentDocumentHandle Document which owns the container
             */ function listenTo(registrationName, contentDocumentHandle) {
              var mountAt = contentDocumentHandle;
              var isListening = getListeningForDocument(mountAt);
              var dependencies = registrationNameDependencies[registrationName];
              for (var i = 0; i < dependencies.length; i++) {
                var dependency = dependencies[i];
                if (
                  !(
                    isListening.hasOwnProperty(dependency) &&
                    isListening[dependency]
                  )
                ) {
                  if (dependency === 'topScroll') {
                    trapCapturedEvent('topScroll', 'scroll', mountAt);
                  } else if (
                    dependency === 'topFocus' ||
                    dependency === 'topBlur'
                  ) {
                    trapCapturedEvent('topFocus', 'focus', mountAt);
                    trapCapturedEvent('topBlur', 'blur', mountAt); // to make sure blur and focus event listeners are only attached once
                    isListening.topBlur = true;
                    isListening.topFocus = true;
                  } else if (dependency === 'topCancel') {
                    if (isEventSupported('cancel', true)) {
                      trapCapturedEvent('topCancel', 'cancel', mountAt);
                    }
                    isListening.topCancel = true;
                  } else if (dependency === 'topClose') {
                    if (isEventSupported('close', true)) {
                      trapCapturedEvent('topClose', 'close', mountAt);
                    }
                    isListening.topClose = true;
                  } else if (topLevelTypes.hasOwnProperty(dependency)) {
                    trapBubbledEvent(
                      dependency,
                      topLevelTypes[dependency],
                      mountAt
                    );
                  }
                  isListening[dependency] = true;
                }
              }
            }
            function isListeningToAllDependencies(registrationName, mountAt) {
              var isListening = getListeningForDocument(mountAt);
              var dependencies = registrationNameDependencies[registrationName];
              for (var i = 0; i < dependencies.length; i++) {
                var dependency = dependencies[i];
                if (
                  !(
                    isListening.hasOwnProperty(dependency) &&
                    isListening[dependency]
                  )
                ) {
                  return false;
                }
              }
              return true;
            }
            /**
             * Given any node return the first leaf node without children.
             *
             * @param {DOMElement|DOMTextNode} node
             * @return {DOMElement|DOMTextNode}
             */ function getLeafNode(node) {
              while (node && node.firstChild) {
                node = node.firstChild;
              }
              return node;
            }
            /**
             * Get the next sibling within a container. This will walk up the
             * DOM if a node's siblings have been exhausted.
             *
             * @param {DOMElement|DOMTextNode} node
             * @return {?DOMElement|DOMTextNode}
             */ function getSiblingNode(node) {
              while (node) {
                if (node.nextSibling) {
                  return node.nextSibling;
                }
                node = node.parentNode;
              }
            }
            /**
             * Get object describing the nodes which contain characters at offset.
             *
             * @param {DOMElement|DOMTextNode} root
             * @param {number} offset
             * @return {?object}
             */ function getNodeForCharacterOffset(root, offset) {
              var node = getLeafNode(root);
              var nodeStart = 0;
              var nodeEnd = 0;
              while (node) {
                if (node.nodeType === TEXT_NODE) {
                  nodeEnd = nodeStart + node.textContent.length;
                  if (nodeStart <= offset && nodeEnd >= offset) {
                    return { node: node, offset: offset - nodeStart };
                  }
                  nodeStart = nodeEnd;
                }
                node = getLeafNode(getSiblingNode(node));
              }
            }
            /**
             * @param {DOMElement} outerNode
             * @return {?object}
             */ function getOffsets(outerNode) {
              var selection = window.getSelection && window.getSelection();
              if (!selection || selection.rangeCount === 0) {
                return null;
              }
              var anchorNode = selection.anchorNode,
                anchorOffset = selection.anchorOffset,
                focusNode$$1 = selection.focusNode,
                focusOffset = selection.focusOffset; // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
              // up/down buttons on an <input type="number">. Anonymous divs do not seem to
              // expose properties, triggering a "Permission denied error" if any of its
              // properties are accessed. The only seemingly possible way to avoid erroring
              // is to access a property that typically works for non-anonymous divs and
              // catch any error that may otherwise arise. See
              // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
              try {
                /* eslint-disable no-unused-expressions */ anchorNode.nodeType;
                focusNode$$1.nodeType; /* eslint-enable no-unused-expressions */
              } catch (e) {
                return null;
              }
              return getModernOffsetsFromPoints(
                outerNode,
                anchorNode,
                anchorOffset,
                focusNode$$1,
                focusOffset
              );
            }
            /**
             * Returns {start, end} where `start` is the character/codepoint index of
             * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
             * `end` is the index of (focusNode, focusOffset).
             *
             * Returns null if you pass in garbage input but we should probably just crash.
             *
             * Exported only for testing.
             */ function getModernOffsetsFromPoints(
              outerNode,
              anchorNode,
              anchorOffset,
              focusNode$$1,
              focusOffset
            ) {
              var length = 0;
              var start = -1;
              var end = -1;
              var indexWithinAnchor = 0;
              var indexWithinFocus = 0;
              var node = outerNode;
              var parentNode = null;
              outer: while (true) {
                var next = null;
                while (true) {
                  if (
                    node === anchorNode &&
                    (anchorOffset === 0 || node.nodeType === TEXT_NODE)
                  ) {
                    start = length + anchorOffset;
                  }
                  if (
                    node === focusNode$$1 &&
                    (focusOffset === 0 || node.nodeType === TEXT_NODE)
                  ) {
                    end = length + focusOffset;
                  }
                  if (node.nodeType === TEXT_NODE) {
                    length += node.nodeValue.length;
                  }
                  if ((next = node.firstChild) === null) {
                    break;
                  } // Moving from `node` to its first child `next`.
                  parentNode = node;
                  node = next;
                }
                while (true) {
                  if (node === outerNode) {
                    // If `outerNode` has children, this is always the second time visiting
                    // it. If it has no children, this is still the first loop, and the only
                    // valid selection is anchorNode and focusNode both equal to this node
                    // and both offsets 0, in which case we will have handled above.
                    break outer;
                  }
                  if (
                    parentNode === anchorNode &&
                    ++indexWithinAnchor === anchorOffset
                  ) {
                    start = length;
                  }
                  if (
                    parentNode === focusNode$$1 &&
                    ++indexWithinFocus === focusOffset
                  ) {
                    end = length;
                  }
                  if ((next = node.nextSibling) !== null) {
                    break;
                  }
                  node = parentNode;
                  parentNode = node.parentNode;
                } // Moving from `node` to its next sibling `next`.
                node = next;
              }
              if (start === -1 || end === -1) {
                // This should never happen. (Would happen if the anchor/focus nodes aren't
                // actually inside the passed-in node.)
                return null;
              }
              return { start: start, end: end };
            }
            /**
             * In modern non-IE browsers, we can support both forward and backward
             * selections.
             *
             * Note: IE10+ supports the Selection object, but it does not support
             * the `extend` method, which means that even in modern IE, it's not possible
             * to programmatically create a backward selection. Thus, for all IE
             * versions, we use the old IE API to create our selections.
             *
             * @param {DOMElement|DOMTextNode} node
             * @param {object} offsets
             */ function setOffsets(node, offsets) {
              if (!window.getSelection) {
                return;
              }
              var selection = window.getSelection();
              var length = node[getTextContentAccessor()].length;
              var start = Math.min(offsets.start, length);
              var end =
                offsets.end === undefined
                  ? start
                  : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.
              // Flip backward selections, so we can set with a single range.
              if (!selection.extend && start > end) {
                var temp = end;
                end = start;
                start = temp;
              }
              var startMarker = getNodeForCharacterOffset(node, start);
              var endMarker = getNodeForCharacterOffset(node, end);
              if (startMarker && endMarker) {
                if (
                  selection.rangeCount === 1 &&
                  selection.anchorNode === startMarker.node &&
                  selection.anchorOffset === startMarker.offset &&
                  selection.focusNode === endMarker.node &&
                  selection.focusOffset === endMarker.offset
                ) {
                  return;
                }
                var range = document.createRange();
                range.setStart(startMarker.node, startMarker.offset);
                selection.removeAllRanges();
                if (start > end) {
                  selection.addRange(range);
                  selection.extend(endMarker.node, endMarker.offset);
                } else {
                  range.setEnd(endMarker.node, endMarker.offset);
                  selection.addRange(range);
                }
              }
            }
            function isInDocument(node) {
              return containsNode(document.documentElement, node);
            }
            /**
             * @ReactInputSelection: React input selection module. Based on Selection.js,
             * but modified to be suitable for react and has a couple of bug fixes (doesn't
             * assume buttons have range selections allowed).
             * Input selection module for React.
             */ function hasSelectionCapabilities(elem) {
              var nodeName =
                elem && elem.nodeName && elem.nodeName.toLowerCase();
              return (
                nodeName &&
                ((nodeName === 'input' && elem.type === 'text') ||
                  nodeName === 'textarea' ||
                  elem.contentEditable === 'true')
              );
            }
            function getSelectionInformation() {
              var focusedElem = getActiveElement();
              return {
                focusedElem: focusedElem,
                selectionRange: hasSelectionCapabilities(focusedElem)
                  ? getSelection$1(focusedElem)
                  : null
              };
            }
            /**
             * @restoreSelection: If any selection information was potentially lost,
             * restore it. This is useful when performing operations that could remove dom
             * nodes and place them back in, resulting in focus being lost.
             */ function restoreSelection(priorSelectionInformation) {
              var curFocusedElem = getActiveElement();
              var priorFocusedElem = priorSelectionInformation.focusedElem;
              var priorSelectionRange =
                priorSelectionInformation.selectionRange;
              if (
                curFocusedElem !== priorFocusedElem &&
                isInDocument(priorFocusedElem)
              ) {
                if (hasSelectionCapabilities(priorFocusedElem)) {
                  setSelection(priorFocusedElem, priorSelectionRange);
                } // Focusing a node can change the scroll position, which is undesirable
                var ancestors = [];
                var ancestor = priorFocusedElem;
                while ((ancestor = ancestor.parentNode)) {
                  if (ancestor.nodeType === ELEMENT_NODE) {
                    ancestors.push({
                      element: ancestor,
                      left: ancestor.scrollLeft,
                      top: ancestor.scrollTop
                    });
                  }
                }
                focusNode(priorFocusedElem);
                for (var i = 0; i < ancestors.length; i++) {
                  var info = ancestors[i];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
            }
            /**
             * @getSelection: Gets the selection bounds of a focused textarea, input or
             * contentEditable node.
             * -@input: Look up selection bounds of this input
             * -@return {start: selectionStart, end: selectionEnd}
             */ function getSelection$1(input) {
              var selection = void 0;
              if ('selectionStart' in input) {
                // Modern browser with input or textarea.
                selection = {
                  start: input.selectionStart,
                  end: input.selectionEnd
                };
              } else {
                // Content editable or old IE textarea.
                selection = getOffsets(input);
              }
              return selection || { start: 0, end: 0 };
            }
            /**
             * @setSelection: Sets the selection bounds of a textarea or input and focuses
             * the input.
             * -@input     Set selection bounds of this input or textarea
             * -@offsets   Object of same form that is returned from get*
             */ function setSelection(input, offsets) {
              var start = offsets.start,
                end = offsets.end;
              if (end === undefined) {
                end = start;
              }
              if ('selectionStart' in input) {
                input.selectionStart = start;
                input.selectionEnd = Math.min(end, input.value.length);
              } else {
                setOffsets(input, offsets);
              }
            }
            var skipSelectionChangeEvent =
              ExecutionEnvironment.canUseDOM &&
              'documentMode' in document &&
              document.documentMode <= 11;
            var eventTypes$3 = {
              select: {
                phasedRegistrationNames: {
                  bubbled: 'onSelect',
                  captured: 'onSelectCapture'
                },
                dependencies: [
                  'topBlur',
                  'topContextMenu',
                  'topFocus',
                  'topKeyDown',
                  'topKeyUp',
                  'topMouseDown',
                  'topMouseUp',
                  'topSelectionChange'
                ]
              }
            };
            var activeElement$1 = null;
            var activeElementInst$1 = null;
            var lastSelection = null;
            var mouseDown = false;
            /**
             * Get an object which is a unique representation of the current selection.
             *
             * The return value will not be consistent across nodes or browsers, but
             * two identical selections on the same node will return identical objects.
             *
             * @param {DOMElement} node
             * @return {object}
             */ function getSelection(node) {
              if ('selectionStart' in node && hasSelectionCapabilities(node)) {
                return { start: node.selectionStart, end: node.selectionEnd };
              } else if (window.getSelection) {
                var selection = window.getSelection();
                return {
                  anchorNode: selection.anchorNode,
                  anchorOffset: selection.anchorOffset,
                  focusNode: selection.focusNode,
                  focusOffset: selection.focusOffset
                };
              }
            }
            /**
             * Poll selection to see whether it's changed.
             *
             * @param {object} nativeEvent
             * @return {?SyntheticEvent}
             */ function constructSelectEvent(nativeEvent, nativeEventTarget) {
              // Ensure we have the right element, and that the user is not dragging a
              // selection (this matches native `select` event behavior). In HTML5, select
              // fires only on input and textarea thus if there's no focused element we
              // won't dispatch.
              if (
                mouseDown ||
                activeElement$1 == null ||
                activeElement$1 !== getActiveElement()
              ) {
                return null;
              } // Only fire when selection has actually changed.
              var currentSelection = getSelection(activeElement$1);
              if (
                !lastSelection ||
                !shallowEqual(lastSelection, currentSelection)
              ) {
                lastSelection = currentSelection;
                var syntheticEvent = SyntheticEvent$1.getPooled(
                  eventTypes$3.select,
                  activeElementInst$1,
                  nativeEvent,
                  nativeEventTarget
                );
                syntheticEvent.type = 'select';
                syntheticEvent.target = activeElement$1;
                accumulateTwoPhaseDispatches(syntheticEvent);
                return syntheticEvent;
              }
              return null;
            }
            /**
             * This plugin creates an `onSelect` event that normalizes select events
             * across form elements.
             *
             * Supported elements are:
             * - input (see `isTextInputElement`)
             * - textarea
             * - contentEditable
             *
             * This differs from native browser implementations in the following ways:
             * - Fires on contentEditable fields as well as inputs.
             * - Fires for collapsed selection.
             * - Fires after user input.
             */ var SelectEventPlugin = {
              eventTypes: eventTypes$3,
              extractEvents: function extractEvents(
                topLevelType,
                targetInst,
                nativeEvent,
                nativeEventTarget
              ) {
                var doc =
                  nativeEventTarget.window === nativeEventTarget
                    ? nativeEventTarget.document
                    : nativeEventTarget.nodeType === DOCUMENT_NODE
                      ? nativeEventTarget
                      : nativeEventTarget.ownerDocument; // Track whether all listeners exists for this plugin. If none exist, we do
                // not extract events. See #3639.
                if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
                  return null;
                }
                var targetNode = targetInst
                  ? getNodeFromInstance$1(targetInst)
                  : window;
                switch (topLevelType) { // Track the input node that has focus.
                  case 'topFocus':
                    if (
                      isTextInputElement(targetNode) ||
                      targetNode.contentEditable === 'true'
                    ) {
                      activeElement$1 = targetNode;
                      activeElementInst$1 = targetInst;
                      lastSelection = null;
                    }
                    break;
                  case 'topBlur':
                    activeElement$1 = null;
                    activeElementInst$1 = null;
                    lastSelection = null;
                    break; // Don't fire the event while the user is dragging. This matches the
                  // semantics of the native select event.
                  case 'topMouseDown':
                    mouseDown = true;
                    break;
                  case 'topContextMenu':
                  case 'topMouseUp':
                    mouseDown = false;
                    return constructSelectEvent(nativeEvent, nativeEventTarget); // Chrome and IE fire non-standard event when selection is changed (and
                  // sometimes when it hasn't). IE's event fires out of order with respect
                  // to key and input events on deletion, so we discard it.
                  //
                  // Firefox doesn't support selectionchange, so check selection status
                  // after each key entry. The selection changes after keydown and before
                  // keyup, but we check on keydown as well in the case of holding down a
                  // key, when multiple keydown events are fired but only one keyup is.
                  // This is also our approach for IE handling, for the reason above.
                  case 'topSelectionChange':
                    if (skipSelectionChangeEvent) {
                      break;
                    } // falls through
                  case 'topKeyDown':
                  case 'topKeyUp':
                    return constructSelectEvent(nativeEvent, nativeEventTarget);
                }
                return null;
              }
            };
            /**
             * @interface Event
             * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
             * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
             */ var AnimationEventInterface = {
              animationName: null,
              elapsedTime: null,
              pseudoElement: null
            };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticEvent}
             */ function SyntheticAnimationEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticEvent$1.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticEvent$1.augmentClass(
              SyntheticAnimationEvent,
              AnimationEventInterface
            );
            /**
             * @interface Event
             * @see http://www.w3.org/TR/clipboard-apis/
             */ var ClipboardEventInterface = {
              clipboardData: function clipboardData(event) {
                return 'clipboardData' in event
                  ? event.clipboardData
                  : window.clipboardData;
              }
            };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticEvent}
             */ function SyntheticClipboardEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticEvent$1.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticEvent$1.augmentClass(
              SyntheticClipboardEvent,
              ClipboardEventInterface
            );
            /**
             * @interface FocusEvent
             * @see http://www.w3.org/TR/DOM-Level-3-Events/
             */ var FocusEventInterface = { relatedTarget: null };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticUIEvent}
             */ function SyntheticFocusEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticUIEvent.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticUIEvent.augmentClass(
              SyntheticFocusEvent,
              FocusEventInterface
            );
            /**
             * `charCode` represents the actual "character code" and is safe to use with
             * `String.fromCharCode`. As such, only keys that correspond to printable
             * characters produce a valid `charCode`, the only exception to this is Enter.
             * The Tab-key is considered non-printable and does not have a `charCode`,
             * presumably because it does not produce a tab-character in browsers.
             *
             * @param {object} nativeEvent Native browser event.
             * @return {number} Normalized `charCode` property.
             */ function getEventCharCode(nativeEvent) {
              var charCode;
              var keyCode = nativeEvent.keyCode;
              if ('charCode' in nativeEvent) {
                charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.
                if (charCode === 0 && keyCode === 13) {
                  charCode = 13;
                }
              } else {
                // IE8 does not implement `charCode`, but `keyCode` has the correct value.
                charCode = keyCode;
              } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
              // Must not discard the (non-)printable Enter-key.
              if (charCode >= 32 || charCode === 13) {
                return charCode;
              }
              return 0;
            }
            /**
             * Normalization of deprecated HTML5 `key` values
             * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
             */ var normalizeKey = {
              Esc: 'Escape',
              Spacebar: ' ',
              Left: 'ArrowLeft',
              Up: 'ArrowUp',
              Right: 'ArrowRight',
              Down: 'ArrowDown',
              Del: 'Delete',
              Win: 'OS',
              Menu: 'ContextMenu',
              Apps: 'ContextMenu',
              Scroll: 'ScrollLock',
              MozPrintableKey: 'Unidentified'
            };
            /**
             * Translation from legacy `keyCode` to HTML5 `key`
             * Only special keys supported, all others depend on keyboard layout or browser
             * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
             */ var translateToKey = {
              '8': 'Backspace',
              '9': 'Tab',
              '12': 'Clear',
              '13': 'Enter',
              '16': 'Shift',
              '17': 'Control',
              '18': 'Alt',
              '19': 'Pause',
              '20': 'CapsLock',
              '27': 'Escape',
              '32': ' ',
              '33': 'PageUp',
              '34': 'PageDown',
              '35': 'End',
              '36': 'Home',
              '37': 'ArrowLeft',
              '38': 'ArrowUp',
              '39': 'ArrowRight',
              '40': 'ArrowDown',
              '45': 'Insert',
              '46': 'Delete',
              '112': 'F1',
              '113': 'F2',
              '114': 'F3',
              '115': 'F4',
              '116': 'F5',
              '117': 'F6',
              '118': 'F7',
              '119': 'F8',
              '120': 'F9',
              '121': 'F10',
              '122': 'F11',
              '123': 'F12',
              '144': 'NumLock',
              '145': 'ScrollLock',
              '224': 'Meta'
            };
            /**
             * @param {object} nativeEvent Native browser event.
             * @return {string} Normalized `key` property.
             */ function getEventKey(nativeEvent) {
              if (nativeEvent.key) {
                // Normalize inconsistent values reported by browsers due to
                // implementations of a working draft specification.
                // FireFox implements `key` but returns `MozPrintableKey` for all
                // printable characters (normalized to `Unidentified`), ignore it.
                var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
                if (key !== 'Unidentified') {
                  return key;
                }
              } // Browser does not implement `key`, polyfill as much of it as we can.
              if (nativeEvent.type === 'keypress') {
                var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can
                // thus be captured by `keypress`, no other non-printable key should.
                return charCode === 13
                  ? 'Enter'
                  : String.fromCharCode(charCode);
              }
              if (
                nativeEvent.type === 'keydown' ||
                nativeEvent.type === 'keyup'
              ) {
                // While user keyboard layout determines the actual meaning of each
                // `keyCode` value, almost all function keys have a universal value.
                return translateToKey[nativeEvent.keyCode] || 'Unidentified';
              }
              return '';
            }
            /**
             * @interface KeyboardEvent
             * @see http://www.w3.org/TR/DOM-Level-3-Events/
             */ var KeyboardEventInterface = {
              key: getEventKey,
              location: null,
              ctrlKey: null,
              shiftKey: null,
              altKey: null,
              metaKey: null,
              repeat: null,
              locale: null,
              getModifierState: getEventModifierState, // Legacy Interface
              charCode: function charCode(event) {
                // `charCode` is the result of a KeyPress event and represents the value of
                // the actual printable character.
                // KeyPress is deprecated, but its replacement is not yet final and not
                // implemented in any major browser. Only KeyPress has charCode.
                if (event.type === 'keypress') {
                  return getEventCharCode(event);
                }
                return 0;
              },
              keyCode: function keyCode(event) {
                // `keyCode` is the result of a KeyDown/Up event and represents the value of
                // physical keyboard key.
                // The actual meaning of the value depends on the users' keyboard layout
                // which cannot be detected. Assuming that it is a US keyboard layout
                // provides a surprisingly accurate mapping for US and European users.
                // Due to this, it is left to the user to implement at this time.
                if (event.type === 'keydown' || event.type === 'keyup') {
                  return event.keyCode;
                }
                return 0;
              },
              which: function which(event) {
                // `which` is an alias for either `keyCode` or `charCode` depending on the
                // type of the event.
                if (event.type === 'keypress') {
                  return getEventCharCode(event);
                }
                if (event.type === 'keydown' || event.type === 'keyup') {
                  return event.keyCode;
                }
                return 0;
              }
            };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticUIEvent}
             */ function SyntheticKeyboardEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticUIEvent.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticUIEvent.augmentClass(
              SyntheticKeyboardEvent,
              KeyboardEventInterface
            );
            /**
             * @interface DragEvent
             * @see http://www.w3.org/TR/DOM-Level-3-Events/
             */ var DragEventInterface = { dataTransfer: null };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticMouseEvent}
             */ function SyntheticDragEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticMouseEvent.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticMouseEvent.augmentClass(
              SyntheticDragEvent,
              DragEventInterface
            );
            /**
             * @interface TouchEvent
             * @see http://www.w3.org/TR/touch-events/
             */ var TouchEventInterface = {
              touches: null,
              targetTouches: null,
              changedTouches: null,
              altKey: null,
              metaKey: null,
              ctrlKey: null,
              shiftKey: null,
              getModifierState: getEventModifierState
            };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticUIEvent}
             */ function SyntheticTouchEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticUIEvent.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticUIEvent.augmentClass(
              SyntheticTouchEvent,
              TouchEventInterface
            );
            /**
             * @interface Event
             * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
             * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
             */ var TransitionEventInterface = {
              propertyName: null,
              elapsedTime: null,
              pseudoElement: null
            };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticEvent}
             */ function SyntheticTransitionEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticEvent$1.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticEvent$1.augmentClass(
              SyntheticTransitionEvent,
              TransitionEventInterface
            );
            /**
             * @interface WheelEvent
             * @see http://www.w3.org/TR/DOM-Level-3-Events/
             */ var WheelEventInterface = {
              deltaX: function deltaX(event) {
                return 'deltaX' in event
                  ? event.deltaX // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
                  : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
              },
              deltaY: function deltaY(event) {
                return 'deltaY' in event
                  ? event.deltaY // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
                  : 'wheelDeltaY' in event
                    ? -event.wheelDeltaY // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                    : 'wheelDelta' in event ? -event.wheelDelta : 0;
              },
              deltaZ: null, // Browsers without "deltaMode" is reporting in raw wheel delta where one
              // notch on the scroll is always +/- 120, roughly equivalent to pixels.
              // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
              // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
              deltaMode: null
            };
            /**
             * @param {object} dispatchConfig Configuration used to dispatch this event.
             * @param {string} dispatchMarker Marker identifying the event target.
             * @param {object} nativeEvent Native browser event.
             * @extends {SyntheticMouseEvent}
             */ function SyntheticWheelEvent(
              dispatchConfig,
              dispatchMarker,
              nativeEvent,
              nativeEventTarget
            ) {
              return SyntheticMouseEvent.call(
                this,
                dispatchConfig,
                dispatchMarker,
                nativeEvent,
                nativeEventTarget
              );
            }
            SyntheticMouseEvent.augmentClass(
              SyntheticWheelEvent,
              WheelEventInterface
            );
            /**
             * Turns
             * ['abort', ...]
             * into
             * eventTypes = {
             *   'abort': {
             *     phasedRegistrationNames: {
             *       bubbled: 'onAbort',
             *       captured: 'onAbortCapture',
             *     },
             *     dependencies: ['topAbort'],
             *   },
             *   ...
             * };
             * topLevelEventsToDispatchConfig = {
             *   'topAbort': { sameConfig }
             * };
             */ var eventTypes$4 = {};
            var topLevelEventsToDispatchConfig = {};
            [
              'abort',
              'animationEnd',
              'animationIteration',
              'animationStart',
              'blur',
              'cancel',
              'canPlay',
              'canPlayThrough',
              'click',
              'close',
              'contextMenu',
              'copy',
              'cut',
              'doubleClick',
              'drag',
              'dragEnd',
              'dragEnter',
              'dragExit',
              'dragLeave',
              'dragOver',
              'dragStart',
              'drop',
              'durationChange',
              'emptied',
              'encrypted',
              'ended',
              'error',
              'focus',
              'input',
              'invalid',
              'keyDown',
              'keyPress',
              'keyUp',
              'load',
              'loadedData',
              'loadedMetadata',
              'loadStart',
              'mouseDown',
              'mouseMove',
              'mouseOut',
              'mouseOver',
              'mouseUp',
              'paste',
              'pause',
              'play',
              'playing',
              'progress',
              'rateChange',
              'reset',
              'scroll',
              'seeked',
              'seeking',
              'stalled',
              'submit',
              'suspend',
              'timeUpdate',
              'toggle',
              'touchCancel',
              'touchEnd',
              'touchMove',
              'touchStart',
              'transitionEnd',
              'volumeChange',
              'waiting',
              'wheel'
            ].forEach(function(event) {
              var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
              var onEvent = 'on' + capitalizedEvent;
              var topEvent = 'top' + capitalizedEvent;
              var type = {
                phasedRegistrationNames: {
                  bubbled: onEvent,
                  captured: onEvent + 'Capture'
                },
                dependencies: [topEvent]
              };
              eventTypes$4[event] = type;
              topLevelEventsToDispatchConfig[topEvent] = type;
            }); // Only used in DEV for exhaustiveness validation.
            var knownHTMLTopLevelTypes = [
              'topAbort',
              'topCancel',
              'topCanPlay',
              'topCanPlayThrough',
              'topClose',
              'topDurationChange',
              'topEmptied',
              'topEncrypted',
              'topEnded',
              'topError',
              'topInput',
              'topInvalid',
              'topLoad',
              'topLoadedData',
              'topLoadedMetadata',
              'topLoadStart',
              'topPause',
              'topPlay',
              'topPlaying',
              'topProgress',
              'topRateChange',
              'topReset',
              'topSeeked',
              'topSeeking',
              'topStalled',
              'topSubmit',
              'topSuspend',
              'topTimeUpdate',
              'topToggle',
              'topVolumeChange',
              'topWaiting'
            ];
            var SimpleEventPlugin = {
              eventTypes: eventTypes$4,
              extractEvents: function extractEvents(
                topLevelType,
                targetInst,
                nativeEvent,
                nativeEventTarget
              ) {
                var dispatchConfig =
                  topLevelEventsToDispatchConfig[topLevelType];
                if (!dispatchConfig) {
                  return null;
                }
                var EventConstructor;
                switch (topLevelType) {
                  case 'topKeyPress': // Firefox creates a keypress event for function keys too. This removes
                    // the unwanted keypress events. Enter is however both printable and
                    // non-printable. One would expect Tab to be as well (but it isn't).
                    if (getEventCharCode(nativeEvent) === 0) {
                      return null;
                    }
                  /* falls through */ case 'topKeyDown':
                  case 'topKeyUp':
                    EventConstructor = SyntheticKeyboardEvent;
                    break;
                  case 'topBlur':
                  case 'topFocus':
                    EventConstructor = SyntheticFocusEvent;
                    break;
                  case 'topClick': // Firefox creates a click event on right mouse clicks. This removes the
                    // unwanted click events.
                    if (nativeEvent.button === 2) {
                      return null;
                    }
                  /* falls through */ case 'topDoubleClick':
                  case 'topMouseDown':
                  case 'topMouseMove':
                  case 'topMouseUp': // TODO: Disabled elements should not respond to mouse events
                  /* falls through */ case 'topMouseOut':
                  case 'topMouseOver':
                  case 'topContextMenu':
                    EventConstructor = SyntheticMouseEvent;
                    break;
                  case 'topDrag':
                  case 'topDragEnd':
                  case 'topDragEnter':
                  case 'topDragExit':
                  case 'topDragLeave':
                  case 'topDragOver':
                  case 'topDragStart':
                  case 'topDrop':
                    EventConstructor = SyntheticDragEvent;
                    break;
                  case 'topTouchCancel':
                  case 'topTouchEnd':
                  case 'topTouchMove':
                  case 'topTouchStart':
                    EventConstructor = SyntheticTouchEvent;
                    break;
                  case 'topAnimationEnd':
                  case 'topAnimationIteration':
                  case 'topAnimationStart':
                    EventConstructor = SyntheticAnimationEvent;
                    break;
                  case 'topTransitionEnd':
                    EventConstructor = SyntheticTransitionEvent;
                    break;
                  case 'topScroll':
                    EventConstructor = SyntheticUIEvent;
                    break;
                  case 'topWheel':
                    EventConstructor = SyntheticWheelEvent;
                    break;
                  case 'topCopy':
                  case 'topCut':
                  case 'topPaste':
                    EventConstructor = SyntheticClipboardEvent;
                    break;
                  default:
                    {
                      if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
                        warning(
                          false,
                          'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' +
                            'is likely caused by a bug in React. Please file an issue.',
                          topLevelType
                        );
                      }
                    } // HTML Events
                    // @see http://www.w3.org/TR/html5/index.html#events-0
                    EventConstructor = SyntheticEvent$1;
                    break;
                }
                var event = EventConstructor.getPooled(
                  dispatchConfig,
                  targetInst,
                  nativeEvent,
                  nativeEventTarget
                );
                accumulateTwoPhaseDispatches(event);
                return event;
              }
            };
            setHandleTopLevel(handleTopLevel);
            /**
             * Inject modules for resolving DOM hierarchy and plugin ordering.
             */ injection$1.injectEventPluginOrder(DOMEventPluginOrder);
            injection$2.injectComponentTree(ReactDOMComponentTree);
            /**
             * Some important event plugins included by default (without having to require
             * them).
             */ injection$1.injectEventPluginsByName({
              SimpleEventPlugin: SimpleEventPlugin,
              EnterLeaveEventPlugin: EnterLeaveEventPlugin,
              ChangeEventPlugin: ChangeEventPlugin,
              SelectEventPlugin: SelectEventPlugin,
              BeforeInputEventPlugin: BeforeInputEventPlugin
            });
            var enableAsyncSubtreeAPI = true;
            var enableAsyncSchedulingByDefaultInReactDOM = false; // Exports ReactDOM.createRoot
            var enableCreateRoot = false;
            var enableUserTimingAPI = true; // Mutating mode (React DOM, React ART, React Native):
            var enableMutatingReconciler = true; // Experimental noop mode (currently unused):
            var enableNoopReconciler = false; // Experimental persistent mode (CS):
            var enablePersistentReconciler = false; // Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
            var debugRenderPhaseSideEffects = false; // Only used in www builds.
            var valueStack = [];
            {
              var fiberStack = [];
            }
            var index = -1;
            function createCursor(defaultValue) {
              return { current: defaultValue };
            }
            function pop(cursor, fiber) {
              if (index < 0) {
                {
                  warning(false, 'Unexpected pop.');
                }
                return;
              }
              {
                if (fiber !== fiberStack[index]) {
                  warning(false, 'Unexpected Fiber popped.');
                }
              }
              cursor.current = valueStack[index];
              valueStack[index] = null;
              {
                fiberStack[index] = null;
              }
              index--;
            }
            function push(cursor, value, fiber) {
              index++;
              valueStack[index] = cursor.current;
              {
                fiberStack[index] = fiber;
              }
              cursor.current = value;
            }
            function reset$1() {
              while (index > -1) {
                valueStack[index] = null;
                {
                  fiberStack[index] = null;
                }
                index--;
              }
            }
            var describeComponentFrame = function describeComponentFrame(
              name,
              source,
              ownerName
            ) {
              return (
                '\n    in ' +
                (name || 'Unknown') +
                (source
                  ? ' (at ' +
                    source.fileName.replace(/^.*[\\\/]/, '') +
                    ':' +
                    source.lineNumber +
                    ')'
                  : ownerName ? ' (created by ' + ownerName + ')' : '')
              );
            };
            function describeFiber(fiber) {
              switch (fiber.tag) {
                case IndeterminateComponent:
                case FunctionalComponent:
                case ClassComponent:
                case HostComponent:
                  var owner = fiber._debugOwner;
                  var source = fiber._debugSource;
                  var name = getComponentName(fiber);
                  var ownerName = null;
                  if (owner) {
                    ownerName = getComponentName(owner);
                  }
                  return describeComponentFrame(name, source, ownerName);
                default:
                  return '';
              }
            } // This function can only be called with a work-in-progress fiber and
            // only during begin or complete phase. Do not call it under any other
            // circumstances.
            function getStackAddendumByWorkInProgressFiber(workInProgress) {
              var info = '';
              var node = workInProgress;
              do {
                info += describeFiber(node); // Otherwise this return pointer might point to the wrong tree:
                node = node['return'];
              } while (node);
              return info;
            }
            function getCurrentFiberOwnerName() {
              {
                var fiber = ReactDebugCurrentFiber.current;
                if (fiber === null) {
                  return null;
                }
                var owner = fiber._debugOwner;
                if (owner !== null && typeof owner !== 'undefined') {
                  return getComponentName(owner);
                }
              }
              return null;
            }
            function getCurrentFiberStackAddendum() {
              {
                var fiber = ReactDebugCurrentFiber.current;
                if (fiber === null) {
                  return null;
                } // Safe because if current fiber exists, we are reconciling,
                // and it is guaranteed to be the work-in-progress version.
                return getStackAddendumByWorkInProgressFiber(fiber);
              }
              return null;
            }
            function resetCurrentFiber() {
              ReactDebugCurrentFrame.getCurrentStack = null;
              ReactDebugCurrentFiber.current = null;
              ReactDebugCurrentFiber.phase = null;
            }
            function setCurrentFiber(fiber) {
              ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
              ReactDebugCurrentFiber.current = fiber;
              ReactDebugCurrentFiber.phase = null;
            }
            function setCurrentPhase(phase) {
              ReactDebugCurrentFiber.phase = phase;
            }
            var ReactDebugCurrentFiber = {
              current: null,
              phase: null,
              resetCurrentFiber: resetCurrentFiber,
              setCurrentFiber: setCurrentFiber,
              setCurrentPhase: setCurrentPhase,
              getCurrentFiberOwnerName: getCurrentFiberOwnerName,
              getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
            }; // Prefix measurements so that it's possible to filter them.
            // Longer prefixes are hard to read in DevTools.
            var reactEmoji = '\u269B';
            var warningEmoji = '\u26D4';
            var supportsUserTiming =
              typeof performance !== 'undefined' &&
              typeof performance.mark === 'function' &&
              typeof performance.clearMarks === 'function' &&
              typeof performance.measure === 'function' &&
              typeof performance.clearMeasures === 'function'; // Keep track of current fiber so that we know the path to unwind on pause.
            // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
            var currentFiber = null; // If we're in the middle of user code, which fiber and method is it?
            // Reusing `currentFiber` would be confusing for this because user code fiber
            // can change during commit phase too, but we don't need to unwind it (since
            // lifecycles in the commit phase don't resemble a tree).
            var currentPhase = null;
            var currentPhaseFiber = null; // Did lifecycle hook schedule an update? This is often a performance problem,
            // so we will keep track of it, and include it in the report.
            // Track commits caused by cascading updates.
            var isCommitting = false;
            var hasScheduledUpdateInCurrentCommit = false;
            var hasScheduledUpdateInCurrentPhase = false;
            var commitCountInCurrentWorkLoop = 0;
            var effectCountInCurrentCommit = 0;
            var isWaitingForCallback = false; // During commits, we only show a measurement once per method name
            // to avoid stretch the commit phase with measurement overhead.
            var labelsInCurrentCommit = new Set();
            var formatMarkName = function formatMarkName(markName) {
              return reactEmoji + ' ' + markName;
            };
            var formatLabel = function formatLabel(label, warning$$1) {
              var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';
              var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';
              return '' + prefix + label + suffix;
            };
            var beginMark = function beginMark(markName) {
              performance.mark(formatMarkName(markName));
            };
            var clearMark = function clearMark(markName) {
              performance.clearMarks(formatMarkName(markName));
            };
            var endMark = function endMark(label, markName, warning$$1) {
              var formattedMarkName = formatMarkName(markName);
              var formattedLabel = formatLabel(label, warning$$1);
              try {
                performance.measure(formattedLabel, formattedMarkName);
              } catch (err) {} // If previous mark was missing for some reason, this will throw.
              // This could only happen if React crashed in an unexpected place earlier.
              // Don't pile on with more errors.
              // Clear marks immediately to avoid growing buffer.
              performance.clearMarks(formattedMarkName);
              performance.clearMeasures(formattedLabel);
            };
            var getFiberMarkName = function getFiberMarkName(label, debugID) {
              return label + ' (#' + debugID + ')';
            };
            var getFiberLabel = function getFiberLabel(
              componentName,
              isMounted,
              phase
            ) {
              if (phase === null) {
                // These are composite component total time measurements.
                return (
                  componentName + ' [' + (isMounted ? 'update' : 'mount') + ']'
                );
              } else {
                // Composite component methods.
                return componentName + '.' + phase;
              }
            };
            var beginFiberMark = function beginFiberMark(fiber, phase) {
              var componentName = getComponentName(fiber) || 'Unknown';
              var debugID = fiber._debugID;
              var isMounted = fiber.alternate !== null;
              var label = getFiberLabel(componentName, isMounted, phase);
              if (isCommitting && labelsInCurrentCommit.has(label)) {
                // During the commit phase, we don't show duplicate labels because
                // there is a fixed overhead for every measurement, and we don't
                // want to stretch the commit phase beyond necessary.
                return false;
              }
              labelsInCurrentCommit.add(label);
              var markName = getFiberMarkName(label, debugID);
              beginMark(markName);
              return true;
            };
            var clearFiberMark = function clearFiberMark(fiber, phase) {
              var componentName = getComponentName(fiber) || 'Unknown';
              var debugID = fiber._debugID;
              var isMounted = fiber.alternate !== null;
              var label = getFiberLabel(componentName, isMounted, phase);
              var markName = getFiberMarkName(label, debugID);
              clearMark(markName);
            };
            var endFiberMark = function endFiberMark(fiber, phase, warning$$1) {
              var componentName = getComponentName(fiber) || 'Unknown';
              var debugID = fiber._debugID;
              var isMounted = fiber.alternate !== null;
              var label = getFiberLabel(componentName, isMounted, phase);
              var markName = getFiberMarkName(label, debugID);
              endMark(label, markName, warning$$1);
            };
            var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {
              // Host components should be skipped in the timeline.
              // We could check typeof fiber.type, but does this work with RN?
              switch (fiber.tag) {
                case HostRoot:
                case HostComponent:
                case HostText:
                case HostPortal:
                case ReturnComponent:
                case Fragment:
                  return true;
                default:
                  return false;
              }
            };
            var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {
              if (currentPhase !== null && currentPhaseFiber !== null) {
                clearFiberMark(currentPhaseFiber, currentPhase);
              }
              currentPhaseFiber = null;
              currentPhase = null;
              hasScheduledUpdateInCurrentPhase = false;
            };
            var pauseTimers = function pauseTimers() {
              // Stops all currently active measurements so that they can be resumed
              // if we continue in a later deferred loop from the same unit of work.
              var fiber = currentFiber;
              while (fiber) {
                if (fiber._debugIsCurrentlyTiming) {
                  endFiberMark(fiber, null, null);
                }
                fiber = fiber['return'];
              }
            };
            var resumeTimersRecursively = function resumeTimersRecursively(
              fiber
            ) {
              if (fiber['return'] !== null) {
                resumeTimersRecursively(fiber['return']);
              }
              if (fiber._debugIsCurrentlyTiming) {
                beginFiberMark(fiber, null);
              }
            };
            var resumeTimers = function resumeTimers() {
              // Resumes all measurements that were active during the last deferred loop.
              if (currentFiber !== null) {
                resumeTimersRecursively(currentFiber);
              }
            };
            function recordEffect() {
              if (enableUserTimingAPI) {
                effectCountInCurrentCommit++;
              }
            }
            function recordScheduleUpdate() {
              if (enableUserTimingAPI) {
                if (isCommitting) {
                  hasScheduledUpdateInCurrentCommit = true;
                }
                if (
                  currentPhase !== null &&
                  currentPhase !== 'componentWillMount' &&
                  currentPhase !== 'componentWillReceiveProps'
                ) {
                  hasScheduledUpdateInCurrentPhase = true;
                }
              }
            }
            function startRequestCallbackTimer() {
              if (enableUserTimingAPI) {
                if (supportsUserTiming && !isWaitingForCallback) {
                  isWaitingForCallback = true;
                  beginMark('(Waiting for async callback...)');
                }
              }
            }
            function stopRequestCallbackTimer(didExpire) {
              if (enableUserTimingAPI) {
                if (supportsUserTiming) {
                  isWaitingForCallback = false;
                  var warning$$1 = didExpire
                    ? 'React was blocked by main thread'
                    : null;
                  endMark(
                    '(Waiting for async callback...)',
                    '(Waiting for async callback...)',
                    warning$$1
                  );
                }
              }
            }
            function startWorkTimer(fiber) {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                  return;
                } // If we pause, this is the fiber to unwind from.
                currentFiber = fiber;
                if (!beginFiberMark(fiber, null)) {
                  return;
                }
                fiber._debugIsCurrentlyTiming = true;
              }
            }
            function cancelWorkTimer(fiber) {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                  return;
                } // Remember we shouldn't complete measurement for this fiber.
                // Otherwise flamechart will be deep even for small updates.
                fiber._debugIsCurrentlyTiming = false;
                clearFiberMark(fiber, null);
              }
            }
            function stopWorkTimer(fiber) {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                  return;
                } // If we pause, its parent is the fiber to unwind from.
                currentFiber = fiber['return'];
                if (!fiber._debugIsCurrentlyTiming) {
                  return;
                }
                fiber._debugIsCurrentlyTiming = false;
                endFiberMark(fiber, null, null);
              }
            }
            function stopFailedWorkTimer(fiber) {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
                  return;
                } // If we pause, its parent is the fiber to unwind from.
                currentFiber = fiber['return'];
                if (!fiber._debugIsCurrentlyTiming) {
                  return;
                }
                fiber._debugIsCurrentlyTiming = false;
                var warning$$1 =
                  'An error was thrown inside this error boundary';
                endFiberMark(fiber, null, warning$$1);
              }
            }
            function startPhaseTimer(fiber, phase) {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming) {
                  return;
                }
                clearPendingPhaseMeasurement();
                if (!beginFiberMark(fiber, phase)) {
                  return;
                }
                currentPhaseFiber = fiber;
                currentPhase = phase;
              }
            }
            function stopPhaseTimer() {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming) {
                  return;
                }
                if (currentPhase !== null && currentPhaseFiber !== null) {
                  var warning$$1 = hasScheduledUpdateInCurrentPhase
                    ? 'Scheduled a cascading update'
                    : null;
                  endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
                }
                currentPhase = null;
                currentPhaseFiber = null;
              }
            }
            function startWorkLoopTimer(nextUnitOfWork) {
              if (enableUserTimingAPI) {
                currentFiber = nextUnitOfWork;
                if (!supportsUserTiming) {
                  return;
                }
                commitCountInCurrentWorkLoop = 0; // This is top level call.
                // Any other measurements are performed within.
                beginMark('(React Tree Reconciliation)'); // Resume any measurements that were in progress during the last loop.
                resumeTimers();
              }
            }
            function stopWorkLoopTimer(interruptedBy) {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming) {
                  return;
                }
                var warning$$1 = null;
                if (interruptedBy !== null) {
                  if (interruptedBy.tag === HostRoot) {
                    warning$$1 =
                      'A top-level update interrupted the previous render';
                  } else {
                    var componentName =
                      getComponentName(interruptedBy) || 'Unknown';
                    warning$$1 =
                      'An update to ' +
                      componentName +
                      ' interrupted the previous render';
                  }
                } else if (commitCountInCurrentWorkLoop > 1) {
                  warning$$1 = 'There were cascading updates';
                }
                commitCountInCurrentWorkLoop = 0; // Pause any measurements until the next loop.
                pauseTimers();
                endMark(
                  '(React Tree Reconciliation)',
                  '(React Tree Reconciliation)',
                  warning$$1
                );
              }
            }
            function startCommitTimer() {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming) {
                  return;
                }
                isCommitting = true;
                hasScheduledUpdateInCurrentCommit = false;
                labelsInCurrentCommit.clear();
                beginMark('(Committing Changes)');
              }
            }
            function stopCommitTimer() {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming) {
                  return;
                }
                var warning$$1 = null;
                if (hasScheduledUpdateInCurrentCommit) {
                  warning$$1 = 'Lifecycle hook scheduled a cascading update';
                } else if (commitCountInCurrentWorkLoop > 0) {
                  warning$$1 = 'Caused by a cascading update in earlier commit';
                }
                hasScheduledUpdateInCurrentCommit = false;
                commitCountInCurrentWorkLoop++;
                isCommitting = false;
                labelsInCurrentCommit.clear();
                endMark(
                  '(Committing Changes)',
                  '(Committing Changes)',
                  warning$$1
                );
              }
            }
            function startCommitHostEffectsTimer() {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming) {
                  return;
                }
                effectCountInCurrentCommit = 0;
                beginMark('(Committing Host Effects)');
              }
            }
            function stopCommitHostEffectsTimer() {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming) {
                  return;
                }
                var count = effectCountInCurrentCommit;
                effectCountInCurrentCommit = 0;
                endMark(
                  '(Committing Host Effects: ' + count + ' Total)',
                  '(Committing Host Effects)',
                  null
                );
              }
            }
            function startCommitLifeCyclesTimer() {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming) {
                  return;
                }
                effectCountInCurrentCommit = 0;
                beginMark('(Calling Lifecycle Methods)');
              }
            }
            function stopCommitLifeCyclesTimer() {
              if (enableUserTimingAPI) {
                if (!supportsUserTiming) {
                  return;
                }
                var count = effectCountInCurrentCommit;
                effectCountInCurrentCommit = 0;
                endMark(
                  '(Calling Lifecycle Methods: ' + count + ' Total)',
                  '(Calling Lifecycle Methods)',
                  null
                );
              }
            }
            {
              var warnedAboutMissingGetChildContext = {};
            } // A cursor to the current merged context object on the stack.
            var contextStackCursor = createCursor(emptyObject); // A cursor to a boolean indicating whether the context has changed.
            var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
            // We use this to get access to the parent context after we have already
            // pushed the next context provider, and now need to merge their contexts.
            var previousContext = emptyObject;
            function getUnmaskedContext(workInProgress) {
              var hasOwnContext = isContextProvider(workInProgress);
              if (hasOwnContext) {
                // If the fiber is a context provider itself, when we read its context
                // we have already pushed its own child context on the stack. A context
                // provider should not "see" its own child context. Therefore we read the
                // previous (parent) context instead for a context provider.
                return previousContext;
              }
              return contextStackCursor.current;
            }
            function cacheContext(
              workInProgress,
              unmaskedContext,
              maskedContext
            ) {
              var instance = workInProgress.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
            function getMaskedContext(workInProgress, unmaskedContext) {
              var type = workInProgress.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyObject;
              } // Avoid recreating masked context unless unmasked context has changed.
              // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
              // This may trigger infinite loops if componentWillReceiveProps calls setState.
              var instance = workInProgress.stateNode;
              if (
                instance &&
                instance.__reactInternalMemoizedUnmaskedChildContext ===
                  unmaskedContext
              ) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name = getComponentName(workInProgress) || 'Unknown';
                checkPropTypes(
                  contextTypes,
                  context,
                  'context',
                  name,
                  ReactDebugCurrentFiber.getCurrentFiberStackAddendum
                );
              } // Cache unmasked context so we can avoid recreating masked context unless necessary.
              // Context is created before the class component is instantiated so check for instance.
              if (instance) {
                cacheContext(workInProgress, unmaskedContext, context);
              }
              return context;
            }
            function hasContextChanged() {
              return didPerformWorkStackCursor.current;
            }
            function isContextConsumer(fiber) {
              return (
                fiber.tag === ClassComponent && fiber.type.contextTypes != null
              );
            }
            function isContextProvider(fiber) {
              return (
                fiber.tag === ClassComponent &&
                fiber.type.childContextTypes != null
              );
            }
            function popContextProvider(fiber) {
              if (!isContextProvider(fiber)) {
                return;
              }
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
            function popTopLevelContextObject(fiber) {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
            function pushTopLevelContextObject(fiber, context, didChange) {
              !(contextStackCursor.cursor == null)
                ? invariant(
                    false,
                    'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'
                  )
                : void 0;
              push(contextStackCursor, context, fiber);
              push(didPerformWorkStackCursor, didChange, fiber);
            }
            function processChildContext(fiber, parentContext) {
              var instance = fiber.stateNode;
              var childContextTypes = fiber.type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
              // It has only been added in Fiber to match the (unintentional) behavior in Stack.
              if (typeof instance.getChildContext !== 'function') {
                {
                  var componentName = getComponentName(fiber) || 'Unknown';
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    warning(
                      false,
                      '%s.childContextTypes is specified but there is no getChildContext() method ' +
                        'on the instance. You can either define getChildContext() on %s or remove ' +
                        'childContextTypes from it.',
                      componentName,
                      componentName
                    );
                  }
                }
                return parentContext;
              }
              var childContext = void 0;
              {
                ReactDebugCurrentFiber.setCurrentPhase('getChildContext');
              }
              startPhaseTimer(fiber, 'getChildContext');
              childContext = instance.getChildContext();
              stopPhaseTimer();
              {
                ReactDebugCurrentFiber.setCurrentPhase(null);
              }
              for (var contextKey in childContext) {
                !(contextKey in childContextTypes)
                  ? invariant(
                      false,
                      '%s.getChildContext(): key "%s" is not defined in childContextTypes.',
                      getComponentName(fiber) || 'Unknown',
                      contextKey
                    )
                  : void 0;
              }
              {
                var name = getComponentName(fiber) || 'Unknown';
                checkPropTypes(
                  childContextTypes,
                  childContext,
                  'child context',
                  name, // In practice, there is one case in which we won't get a stack. It's when
                  // somebody calls unstable_renderSubtreeIntoContainer() and we process
                  // context from the parent component instance. The stack will be missing
                  // because it's outside of the reconciliation, and so the pointer has not
                  // been set. This is rare and doesn't matter. We'll also remove that API.
                  ReactDebugCurrentFiber.getCurrentFiberStackAddendum
                );
              }
              return _assign({}, parentContext, childContext);
            }
            function pushContextProvider(workInProgress) {
              if (!isContextProvider(workInProgress)) {
                return false;
              }
              var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
              // If the instance does not exist yet, we will push null at first,
              // and replace it on the stack later when invalidating the context.
              var memoizedMergedChildContext =
                (instance &&
                  instance.__reactInternalMemoizedMergedChildContext) ||
                emptyObject; // Remember the parent context so we can merge with it later.
              // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
              previousContext = contextStackCursor.current;
              push(
                contextStackCursor,
                memoizedMergedChildContext,
                workInProgress
              );
              push(
                didPerformWorkStackCursor,
                didPerformWorkStackCursor.current,
                workInProgress
              );
              return true;
            }
            function invalidateContextProvider(workInProgress, didChange) {
              var instance = workInProgress.stateNode;
              !instance
                ? invariant(
                    false,
                    'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'
                  )
                : void 0;
              if (didChange) {
                // Merge parent and own context.
                // Skip this if we're not updating due to sCU.
                // This avoids unnecessarily recomputing memoized values.
                var mergedContext = processChildContext(
                  workInProgress,
                  previousContext
                );
                instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
                // It is important to unwind the context in the reverse order.
                pop(didPerformWorkStackCursor, workInProgress);
                pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.
                push(contextStackCursor, mergedContext, workInProgress);
                push(didPerformWorkStackCursor, didChange, workInProgress);
              } else {
                pop(didPerformWorkStackCursor, workInProgress);
                push(didPerformWorkStackCursor, didChange, workInProgress);
              }
            }
            function resetContext() {
              previousContext = emptyObject;
              contextStackCursor.current = emptyObject;
              didPerformWorkStackCursor.current = false;
            }
            function findCurrentUnmaskedContext(fiber) {
              // Currently this is only used with renderSubtreeIntoContainer; not sure if it
              // makes sense elsewhere
              !(isFiberMounted(fiber) && fiber.tag === ClassComponent)
                ? invariant(
                    false,
                    'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'
                  )
                : void 0;
              var node = fiber;
              while (node.tag !== HostRoot) {
                if (isContextProvider(node)) {
                  return node.stateNode
                    .__reactInternalMemoizedMergedChildContext;
                }
                var parent = node['return'];
                !parent
                  ? invariant(
                      false,
                      'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0;
                node = parent;
              }
              return node.stateNode.context;
            }
            var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax
            var Sync = 1;
            var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1
            var UNIT_SIZE = 10;
            var MAGIC_NUMBER_OFFSET = 2; // 1 unit of expiration time represents 10ms.
            function msToExpirationTime(ms) {
              // Always add an offset so that we don't clash with the magic number for NoWork.
              return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;
            }
            function expirationTimeToMs(expirationTime) {
              return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
            }
            function ceiling(num, precision) {
              return (((num / precision) | 0) + 1) * precision;
            }
            function computeExpirationBucket(
              currentTime,
              expirationInMs,
              bucketSizeMs
            ) {
              return ceiling(
                currentTime + expirationInMs / UNIT_SIZE,
                bucketSizeMs / UNIT_SIZE
              );
            }
            var NoContext = 0;
            var AsyncUpdates = 1;
            {
              var hasBadMapPolyfill = false;
              try {
                var nonExtensibleObject = Object.preventExtensions(
                  {}
                ); /* eslint-disable no-new */ /* eslint-enable no-new */
              } catch (e) {
                // TODO: Consider warning about bad polyfills
                hasBadMapPolyfill = true;
              }
            } // A Fiber is work on a Component that needs to be done or was done. There can
            // be more than one per component.
            {
              var debugCounter = 1;
            }
            function FiberNode(tag, key, internalContextTag) {
              // Instance
              this.tag = tag;
              this.key = key;
              this.type = null;
              this.stateNode = null; // Fiber
              this['return'] = null;
              this.child = null;
              this.sibling = null;
              this.index = 0;
              this.ref = null;
              this.pendingProps = null;
              this.memoizedProps = null;
              this.updateQueue = null;
              this.memoizedState = null;
              this.internalContextTag = internalContextTag; // Effects
              this.effectTag = NoEffect;
              this.nextEffect = null;
              this.firstEffect = null;
              this.lastEffect = null;
              this.expirationTime = NoWork;
              this.alternate = null;
              {
                this._debugID = debugCounter++;
                this._debugSource = null;
                this._debugOwner = null;
                this._debugIsCurrentlyTiming = false;
                if (
                  !hasBadMapPolyfill &&
                  typeof Object.preventExtensions === 'function'
                ) {
                  Object.preventExtensions(this);
                }
              }
            } // This is a constructor function, rather than a POJO constructor, still
            // please ensure we do the following:
            // 1) Nobody should add any instance methods on this. Instance methods can be
            //    more difficult to predict when they get optimized and they are almost
            //    never inlined properly in static compilers.
            // 2) Nobody should rely on `instanceof Fiber` for type testing. We should
            //    always know when it is a fiber.
            // 3) We might want to experiment with using numeric keys since they are easier
            //    to optimize in a non-JIT environment.
            // 4) We can easily go from a constructor to a createFiber object literal if that
            //    is faster.
            // 5) It should be easy to port this to a C struct and keep a C implementation
            //    compatible.
            var createFiber = function createFiber(
              tag,
              key,
              internalContextTag
            ) {
              // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
              return new FiberNode(tag, key, internalContextTag);
            };
            function shouldConstruct(Component) {
              return !!(
                Component.prototype && Component.prototype.isReactComponent
              );
            } // This is used to create an alternate fiber to do work on.
            function createWorkInProgress(
              current,
              pendingProps,
              expirationTime
            ) {
              var workInProgress = current.alternate;
              if (workInProgress === null) {
                // We use a double buffering pooling technique because we know that we'll
                // only ever need at most two versions of a tree. We pool the "other" unused
                // node that we're free to reuse. This is lazily created to avoid allocating
                // extra objects for things that are never updated. It also allow us to
                // reclaim the extra memory if needed.
                workInProgress = createFiber(
                  current.tag,
                  current.key,
                  current.internalContextTag
                );
                workInProgress.type = current.type;
                workInProgress.stateNode = current.stateNode;
                {
                  // DEV-only fields
                  workInProgress._debugID = current._debugID;
                  workInProgress._debugSource = current._debugSource;
                  workInProgress._debugOwner = current._debugOwner;
                }
                workInProgress.alternate = current;
                current.alternate = workInProgress;
              } else {
                // We already have an alternate.
                // Reset the effect tag.
                workInProgress.effectTag = NoEffect; // The effect list is no longer valid.
                workInProgress.nextEffect = null;
                workInProgress.firstEffect = null;
                workInProgress.lastEffect = null;
              }
              workInProgress.expirationTime = expirationTime;
              workInProgress.pendingProps = pendingProps;
              workInProgress.child = current.child;
              workInProgress.memoizedProps = current.memoizedProps;
              workInProgress.memoizedState = current.memoizedState;
              workInProgress.updateQueue = current.updateQueue; // These will be overridden during the parent's reconciliation
              workInProgress.sibling = current.sibling;
              workInProgress.index = current.index;
              workInProgress.ref = current.ref;
              return workInProgress;
            }
            function createHostRootFiber() {
              var fiber = createFiber(HostRoot, null, NoContext);
              return fiber;
            }
            function createFiberFromElement(
              element,
              internalContextTag,
              expirationTime
            ) {
              var owner = null;
              {
                owner = element._owner;
              }
              var fiber = void 0;
              var type = element.type,
                key = element.key;
              if (typeof type === 'function') {
                fiber = shouldConstruct(type)
                  ? createFiber(ClassComponent, key, internalContextTag)
                  : createFiber(
                      IndeterminateComponent,
                      key,
                      internalContextTag
                    );
                fiber.type = type;
                fiber.pendingProps = element.props;
              } else if (typeof type === 'string') {
                fiber = createFiber(HostComponent, key, internalContextTag);
                fiber.type = type;
                fiber.pendingProps = element.props;
              } else if (
                _typeof(type) === 'object' &&
                type !== null &&
                typeof type.tag === 'number'
              ) {
                // Currently assumed to be a continuation and therefore is a fiber already.
                // TODO: The yield system is currently broken for updates in some cases.
                // The reified yield stores a fiber, but we don't know which fiber that is;
                // the current or a workInProgress? When the continuation gets rendered here
                // we don't know if we can reuse that fiber or if we need to clone it.
                // There is probably a clever way to restructure this.
                fiber = type;
                fiber.pendingProps = element.props;
              } else {
                var info = '';
                {
                  if (
                    type === undefined ||
                    (_typeof(type) === 'object' &&
                      type !== null &&
                      Object.keys(type).length === 0)
                  ) {
                    info +=
                      ' You likely forgot to export your component from the file ' +
                      "it's defined in, or you might have mixed up default and named imports.";
                  }
                  var ownerName = owner ? getComponentName(owner) : null;
                  if (ownerName) {
                    info +=
                      '\n\nCheck the render method of `' + ownerName + '`.';
                  }
                }
                invariant(
                  false,
                  'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',
                  type == null ? type : _typeof(type),
                  info
                );
              }
              {
                fiber._debugSource = element._source;
                fiber._debugOwner = element._owner;
              }
              fiber.expirationTime = expirationTime;
              return fiber;
            }
            function createFiberFromFragment(
              elements,
              internalContextTag,
              expirationTime,
              key
            ) {
              var fiber = createFiber(Fragment, key, internalContextTag);
              fiber.pendingProps = elements;
              fiber.expirationTime = expirationTime;
              return fiber;
            }
            function createFiberFromText(
              content,
              internalContextTag,
              expirationTime
            ) {
              var fiber = createFiber(HostText, null, internalContextTag);
              fiber.pendingProps = content;
              fiber.expirationTime = expirationTime;
              return fiber;
            }
            function createFiberFromHostInstanceForDeletion() {
              var fiber = createFiber(HostComponent, null, NoContext);
              fiber.type = 'DELETED';
              return fiber;
            }
            function createFiberFromCall(
              call,
              internalContextTag,
              expirationTime
            ) {
              var fiber = createFiber(
                CallComponent,
                call.key,
                internalContextTag
              );
              fiber.type = call.handler;
              fiber.pendingProps = call;
              fiber.expirationTime = expirationTime;
              return fiber;
            }
            function createFiberFromReturn(
              returnNode,
              internalContextTag,
              expirationTime
            ) {
              var fiber = createFiber(
                ReturnComponent,
                null,
                internalContextTag
              );
              fiber.expirationTime = expirationTime;
              return fiber;
            }
            function createFiberFromPortal(
              portal,
              internalContextTag,
              expirationTime
            ) {
              var fiber = createFiber(
                HostPortal,
                portal.key,
                internalContextTag
              );
              fiber.pendingProps = portal.children || [];
              fiber.expirationTime = expirationTime;
              fiber.stateNode = {
                containerInfo: portal.containerInfo,
                pendingChildren: null, // Used by persistent updates
                implementation: portal.implementation
              };
              return fiber;
            }
            function createFiberRoot(containerInfo, hydrate) {
              // Cyclic construction. This cheats the type system right now because
              // stateNode is any.
              var uninitializedFiber = createHostRootFiber();
              var root = {
                current: uninitializedFiber,
                containerInfo: containerInfo,
                pendingChildren: null,
                remainingExpirationTime: NoWork,
                isReadyForCommit: false,
                finishedWork: null,
                context: null,
                pendingContext: null,
                hydrate: hydrate,
                nextScheduledRoot: null
              };
              uninitializedFiber.stateNode = root;
              return root;
            }
            var onCommitFiberRoot = null;
            var onCommitFiberUnmount = null;
            var hasLoggedError = false;
            function catchErrors(fn) {
              return function(arg) {
                try {
                  return fn(arg);
                } catch (err) {
                  if (true && !hasLoggedError) {
                    hasLoggedError = true;
                    warning(
                      false,
                      'React DevTools encountered an error: %s',
                      err
                    );
                  }
                }
              };
            }
            function injectInternals(internals) {
              if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
                // No DevTools
                return false;
              }
              var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
              if (hook.isDisabled) {
                // This isn't a real property on the hook, but it can be set to opt out
                // of DevTools integration and associated warnings and logs.
                // https://github.com/facebook/react/issues/3877
                return true;
              }
              if (!hook.supportsFiber) {
                {
                  warning(
                    false,
                    'The installed version of React DevTools is too old and will not work ' +
                      'with the current version of React. Please update React DevTools. ' +
                      'https://fb.me/react-devtools'
                  );
                } // DevTools exists, even though it doesn't support Fiber.
                return true;
              }
              try {
                var rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.
                onCommitFiberRoot = catchErrors(function(root) {
                  return hook.onCommitFiberRoot(rendererID, root);
                });
                onCommitFiberUnmount = catchErrors(function(fiber) {
                  return hook.onCommitFiberUnmount(rendererID, fiber);
                });
              } catch (err) {
                // Catch all errors because it is unsafe to throw during initialization.
                {
                  warning(
                    false,
                    'React DevTools encountered an error: %s.',
                    err
                  );
                }
              } // DevTools exists
              return true;
            }
            function onCommitRoot(root) {
              if (typeof onCommitFiberRoot === 'function') {
                onCommitFiberRoot(root);
              }
            }
            function onCommitUnmount(fiber) {
              if (typeof onCommitFiberUnmount === 'function') {
                onCommitFiberUnmount(fiber);
              }
            }
            {
              var didWarnUpdateInsideUpdate = false;
            } // Callbacks are not validated until invocation
            // Singly linked-list of updates. When an update is scheduled, it is added to
            // the queue of the current fiber and the work-in-progress fiber. The two queues
            // are separate but they share a persistent structure.
            //
            // During reconciliation, updates are removed from the work-in-progress fiber,
            // but they remain on the current fiber. That ensures that if a work-in-progress
            // is aborted, the aborted updates are recovered by cloning from current.
            //
            // The work-in-progress queue is always a subset of the current queue.
            //
            // When the tree is committed, the work-in-progress becomes the current.
            function createUpdateQueue(baseState) {
              var queue = {
                baseState: baseState,
                expirationTime: NoWork,
                first: null,
                last: null,
                callbackList: null,
                hasForceUpdate: false,
                isInitialized: false
              };
              {
                queue.isProcessing = false;
              }
              return queue;
            }
            function insertUpdateIntoQueue(queue, update) {
              // Append the update to the end of the list.
              if (queue.last === null) {
                // Queue is empty
                queue.first = queue.last = update;
              } else {
                queue.last.next = update;
                queue.last = update;
              }
              if (
                queue.expirationTime === NoWork ||
                queue.expirationTime > update.expirationTime
              ) {
                queue.expirationTime = update.expirationTime;
              }
            }
            function insertUpdateIntoFiber(fiber, update) {
              // We'll have at least one and at most two distinct update queues.
              var alternateFiber = fiber.alternate;
              var queue1 = fiber.updateQueue;
              if (queue1 === null) {
                // TODO: We don't know what the base state will be until we begin work.
                // It depends on which fiber is the next current. Initialize with an empty
                // base state, then set to the memoizedState when rendering. Not super
                // happy with this approach.
                queue1 = fiber.updateQueue = createUpdateQueue(null);
              }
              var queue2 = void 0;
              if (alternateFiber !== null) {
                queue2 = alternateFiber.updateQueue;
                if (queue2 === null) {
                  queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
                }
              } else {
                queue2 = null;
              }
              queue2 = queue2 !== queue1 ? queue2 : null; // Warn if an update is scheduled from inside an updater function.
              {
                if (
                  (queue1.isProcessing ||
                    (queue2 !== null && queue2.isProcessing)) &&
                  !didWarnUpdateInsideUpdate
                ) {
                  warning(
                    false,
                    'An update (setState, replaceState, or forceUpdate) was scheduled ' +
                      'from inside an update function. Update functions should be pure, ' +
                      'with zero side-effects. Consider using componentDidUpdate or a ' +
                      'callback.'
                  );
                  didWarnUpdateInsideUpdate = true;
                }
              } // If there's only one queue, add the update to that queue and exit.
              if (queue2 === null) {
                insertUpdateIntoQueue(queue1, update);
                return;
              } // If either queue is empty, we need to add to both queues.
              if (queue1.last === null || queue2.last === null) {
                insertUpdateIntoQueue(queue1, update);
                insertUpdateIntoQueue(queue2, update);
                return;
              } // If both lists are not empty, the last update is the same for both lists
              // because of structural sharing. So, we should only append to one of
              // the lists.
              insertUpdateIntoQueue(queue1, update); // But we still need to update the `last` pointer of queue2.
              queue2.last = update;
            }
            function getUpdateExpirationTime(fiber) {
              if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
                return NoWork;
              }
              var updateQueue = fiber.updateQueue;
              if (updateQueue === null) {
                return NoWork;
              }
              return updateQueue.expirationTime;
            }
            function getStateFromUpdate(update, instance, prevState, props) {
              var partialState = update.partialState;
              if (typeof partialState === 'function') {
                var updateFn = partialState; // Invoke setState callback an extra time to help detect side-effects.
                if (debugRenderPhaseSideEffects) {
                  updateFn.call(instance, prevState, props);
                }
                return updateFn.call(instance, prevState, props);
              } else {
                return partialState;
              }
            }
            function processUpdateQueue(
              current,
              workInProgress,
              queue,
              instance,
              props,
              renderExpirationTime
            ) {
              if (current !== null && current.updateQueue === queue) {
                // We need to create a work-in-progress queue, by cloning the current queue.
                var currentQueue = queue;
                queue = workInProgress.updateQueue = {
                  baseState: currentQueue.baseState,
                  expirationTime: currentQueue.expirationTime,
                  first: currentQueue.first,
                  last: currentQueue.last,
                  isInitialized: currentQueue.isInitialized, // These fields are no longer valid because they were already committed.
                  // Reset them.
                  callbackList: null,
                  hasForceUpdate: false
                };
              }
              {
                // Set this flag so we can warn if setState is called inside the update
                // function of another setState.
                queue.isProcessing = true;
              } // Reset the remaining expiration time. If we skip over any updates, we'll
              // increase this accordingly.
              queue.expirationTime = NoWork; // TODO: We don't know what the base state will be until we begin work.
              // It depends on which fiber is the next current. Initialize with an empty
              // base state, then set to the memoizedState when rendering. Not super
              // happy with this approach.
              var state = void 0;
              if (queue.isInitialized) {
                state = queue.baseState;
              } else {
                state = queue.baseState = workInProgress.memoizedState;
                queue.isInitialized = true;
              }
              var dontMutatePrevState = true;
              var update = queue.first;
              var didSkip = false;
              while (update !== null) {
                var updateExpirationTime = update.expirationTime;
                if (updateExpirationTime > renderExpirationTime) {
                  // This update does not have sufficient priority. Skip it.
                  var remainingExpirationTime = queue.expirationTime;
                  if (
                    remainingExpirationTime === NoWork ||
                    remainingExpirationTime > updateExpirationTime
                  ) {
                    // Update the remaining expiration time.
                    queue.expirationTime = updateExpirationTime;
                  }
                  if (!didSkip) {
                    didSkip = true;
                    queue.baseState = state;
                  } // Continue to the next update.
                  update = update.next;
                  continue;
                } // This update does have sufficient priority.
                // If no previous updates were skipped, drop this update from the queue by
                // advancing the head of the list.
                if (!didSkip) {
                  queue.first = update.next;
                  if (queue.first === null) {
                    queue.last = null;
                  }
                } // Process the update
                var _partialState = void 0;
                if (update.isReplace) {
                  state = getStateFromUpdate(update, instance, state, props);
                  dontMutatePrevState = true;
                } else {
                  _partialState = getStateFromUpdate(
                    update,
                    instance,
                    state,
                    props
                  );
                  if (_partialState) {
                    if (dontMutatePrevState) {
                      // $FlowFixMe: Idk how to type this properly.
                      state = _assign({}, state, _partialState);
                    } else {
                      state = _assign(state, _partialState);
                    }
                    dontMutatePrevState = false;
                  }
                }
                if (update.isForced) {
                  queue.hasForceUpdate = true;
                }
                if (update.callback !== null) {
                  // Append to list of callbacks.
                  var _callbackList = queue.callbackList;
                  if (_callbackList === null) {
                    _callbackList = queue.callbackList = [];
                  }
                  _callbackList.push(update);
                }
                update = update.next;
              }
              if (queue.callbackList !== null) {
                workInProgress.effectTag |= Callback;
              } else if (queue.first === null && !queue.hasForceUpdate) {
                // The queue is empty. We can reset it.
                workInProgress.updateQueue = null;
              }
              if (!didSkip) {
                didSkip = true;
                queue.baseState = state;
              }
              {
                // No longer processing.
                queue.isProcessing = false;
              }
              return state;
            }
            function commitCallbacks(queue, context) {
              var callbackList = queue.callbackList;
              if (callbackList === null) {
                return;
              } // Set the list to null to make sure they don't get called more than once.
              queue.callbackList = null;
              for (var i = 0; i < callbackList.length; i++) {
                var update = callbackList[i];
                var _callback = update.callback; // This update might be processed again. Clear the callback so it's only
                // called once.
                update.callback = null;
                !(typeof _callback === 'function')
                  ? invariant(
                      false,
                      'Invalid argument passed as callback. Expected a function. Instead received: %s',
                      _callback
                    )
                  : void 0;
                _callback.call(context);
              }
            }
            var fakeInternalInstance = {};
            var isArray = Array.isArray;
            {
              var didWarnAboutStateAssignmentForComponent = {};
              var warnOnInvalidCallback = function warnOnInvalidCallback(
                callback,
                callerName
              ) {
                warning(
                  callback === null || typeof callback === 'function',
                  '%s(...): Expected the last optional `callback` argument to be a ' +
                    'function. Instead received: %s.',
                  callerName,
                  callback
                );
              }; // This is so gross but it's at least non-critical and can be removed if
              // it causes problems. This is meant to give a nicer error message for
              // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
              // ...)) which otherwise throws a "_processChildContext is not a function"
              // exception.
              Object.defineProperty(
                fakeInternalInstance,
                '_processChildContext',
                {
                  enumerable: false,
                  value: function value() {
                    invariant(
                      false,
                      "_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal)."
                    );
                  }
                }
              );
              Object.freeze(fakeInternalInstance);
            }
            var ReactFiberClassComponent = function ReactFiberClassComponent(
              scheduleWork,
              computeExpirationForFiber,
              memoizeProps,
              memoizeState
            ) {
              // Class component state updater
              var updater = {
                isMounted: isMounted,
                enqueueSetState: function enqueueSetState(
                  instance,
                  partialState,
                  callback
                ) {
                  var fiber = get(instance);
                  callback = callback === undefined ? null : callback;
                  {
                    warnOnInvalidCallback(callback, 'setState');
                  }
                  var expirationTime = computeExpirationForFiber(fiber);
                  var update = {
                    expirationTime: expirationTime,
                    partialState: partialState,
                    callback: callback,
                    isReplace: false,
                    isForced: false,
                    nextCallback: null,
                    next: null
                  };
                  insertUpdateIntoFiber(fiber, update);
                  scheduleWork(fiber, expirationTime);
                },
                enqueueReplaceState: function enqueueReplaceState(
                  instance,
                  state,
                  callback
                ) {
                  var fiber = get(instance);
                  callback = callback === undefined ? null : callback;
                  {
                    warnOnInvalidCallback(callback, 'replaceState');
                  }
                  var expirationTime = computeExpirationForFiber(fiber);
                  var update = {
                    expirationTime: expirationTime,
                    partialState: state,
                    callback: callback,
                    isReplace: true,
                    isForced: false,
                    nextCallback: null,
                    next: null
                  };
                  insertUpdateIntoFiber(fiber, update);
                  scheduleWork(fiber, expirationTime);
                },
                enqueueForceUpdate: function enqueueForceUpdate(
                  instance,
                  callback
                ) {
                  var fiber = get(instance);
                  callback = callback === undefined ? null : callback;
                  {
                    warnOnInvalidCallback(callback, 'forceUpdate');
                  }
                  var expirationTime = computeExpirationForFiber(fiber);
                  var update = {
                    expirationTime: expirationTime,
                    partialState: null,
                    callback: callback,
                    isReplace: false,
                    isForced: true,
                    nextCallback: null,
                    next: null
                  };
                  insertUpdateIntoFiber(fiber, update);
                  scheduleWork(fiber, expirationTime);
                }
              };
              function checkShouldComponentUpdate(
                workInProgress,
                oldProps,
                newProps,
                oldState,
                newState,
                newContext
              ) {
                if (
                  oldProps === null ||
                  (workInProgress.updateQueue !== null &&
                    workInProgress.updateQueue.hasForceUpdate)
                ) {
                  // If the workInProgress already has an Update effect, return true
                  return true;
                }
                var instance = workInProgress.stateNode;
                var type = workInProgress.type;
                if (typeof instance.shouldComponentUpdate === 'function') {
                  startPhaseTimer(workInProgress, 'shouldComponentUpdate');
                  var shouldUpdate = instance.shouldComponentUpdate(
                    newProps,
                    newState,
                    newContext
                  );
                  stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.
                  if (debugRenderPhaseSideEffects) {
                    instance.shouldComponentUpdate(
                      newProps,
                      newState,
                      newContext
                    );
                  }
                  {
                    warning(
                      shouldUpdate !== undefined,
                      '%s.shouldComponentUpdate(): Returned undefined instead of a ' +
                        'boolean value. Make sure to return true or false.',
                      getComponentName(workInProgress) || 'Unknown'
                    );
                  }
                  return shouldUpdate;
                }
                if (type.prototype && type.prototype.isPureReactComponent) {
                  return (
                    !shallowEqual(oldProps, newProps) ||
                    !shallowEqual(oldState, newState)
                  );
                }
                return true;
              }
              function checkClassInstance(workInProgress) {
                var instance = workInProgress.stateNode;
                var type = workInProgress.type;
                {
                  var name = getComponentName(workInProgress);
                  var renderPresent = instance.render;
                  if (!renderPresent) {
                    if (
                      type.prototype &&
                      typeof type.prototype.render === 'function'
                    ) {
                      warning(
                        false,
                        '%s(...): No `render` method found on the returned component ' +
                          'instance: did you accidentally return an object from the constructor?',
                        name
                      );
                    } else {
                      warning(
                        false,
                        '%s(...): No `render` method found on the returned component ' +
                          'instance: you may have forgotten to define `render`.',
                        name
                      );
                    }
                  }
                  var noGetInitialStateOnES6 =
                    !instance.getInitialState ||
                    instance.getInitialState.isReactClassApproved ||
                    instance.state;
                  warning(
                    noGetInitialStateOnES6,
                    'getInitialState was defined on %s, a plain JavaScript class. ' +
                      'This is only supported for classes created using React.createClass. ' +
                      'Did you mean to define a state property instead?',
                    name
                  );
                  var noGetDefaultPropsOnES6 =
                    !instance.getDefaultProps ||
                    instance.getDefaultProps.isReactClassApproved;
                  warning(
                    noGetDefaultPropsOnES6,
                    'getDefaultProps was defined on %s, a plain JavaScript class. ' +
                      'This is only supported for classes created using React.createClass. ' +
                      'Use a static property to define defaultProps instead.',
                    name
                  );
                  var noInstancePropTypes = !instance.propTypes;
                  warning(
                    noInstancePropTypes,
                    'propTypes was defined as an instance property on %s. Use a static ' +
                      'property to define propTypes instead.',
                    name
                  );
                  var noInstanceContextTypes = !instance.contextTypes;
                  warning(
                    noInstanceContextTypes,
                    'contextTypes was defined as an instance property on %s. Use a static ' +
                      'property to define contextTypes instead.',
                    name
                  );
                  var noComponentShouldUpdate =
                    typeof instance.componentShouldUpdate !== 'function';
                  warning(
                    noComponentShouldUpdate,
                    '%s has a method called ' +
                      'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
                      'The name is phrased as a question because the function is ' +
                      'expected to return a value.',
                    name
                  );
                  if (
                    type.prototype &&
                    type.prototype.isPureReactComponent &&
                    typeof instance.shouldComponentUpdate !== 'undefined'
                  ) {
                    warning(
                      false,
                      '%s has a method called shouldComponentUpdate(). ' +
                        'shouldComponentUpdate should not be used when extending React.PureComponent. ' +
                        'Please extend React.Component if shouldComponentUpdate is used.',
                      getComponentName(workInProgress) || 'A pure component'
                    );
                  }
                  var noComponentDidUnmount =
                    typeof instance.componentDidUnmount !== 'function';
                  warning(
                    noComponentDidUnmount,
                    '%s has a method called ' +
                      'componentDidUnmount(). But there is no such lifecycle method. ' +
                      'Did you mean componentWillUnmount()?',
                    name
                  );
                  var noComponentDidReceiveProps =
                    typeof instance.componentDidReceiveProps !== 'function';
                  warning(
                    noComponentDidReceiveProps,
                    '%s has a method called ' +
                      'componentDidReceiveProps(). But there is no such lifecycle method. ' +
                      'If you meant to update the state in response to changing props, ' +
                      'use componentWillReceiveProps(). If you meant to fetch data or ' +
                      'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',
                    name
                  );
                  var noComponentWillRecieveProps =
                    typeof instance.componentWillRecieveProps !== 'function';
                  warning(
                    noComponentWillRecieveProps,
                    '%s has a method called ' +
                      'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',
                    name
                  );
                  var hasMutatedProps =
                    instance.props !== workInProgress.pendingProps;
                  warning(
                    instance.props === undefined || !hasMutatedProps,
                    '%s(...): When calling super() in `%s`, make sure to pass ' +
                      "up the same props that your component's constructor was passed.",
                    name,
                    name
                  );
                  var noInstanceDefaultProps = !instance.defaultProps;
                  warning(
                    noInstanceDefaultProps,
                    'Setting defaultProps as an instance property on %s is not supported and will be ignored.' +
                      ' Instead, define defaultProps as a static property on %s.',
                    name,
                    name
                  );
                }
                var state = instance.state;
                if (state && (_typeof(state) !== 'object' || isArray(state))) {
                  warning(
                    false,
                    '%s.state: must be set to an object or null',
                    getComponentName(workInProgress)
                  );
                }
                if (typeof instance.getChildContext === 'function') {
                  warning(
                    _typeof(workInProgress.type.childContextTypes) === 'object',
                    '%s.getChildContext(): childContextTypes must be defined in order to ' +
                      'use getChildContext().',
                    getComponentName(workInProgress)
                  );
                }
              }
              function resetInputPointers(workInProgress, instance) {
                instance.props = workInProgress.memoizedProps;
                instance.state = workInProgress.memoizedState;
              }
              function adoptClassInstance(workInProgress, instance) {
                instance.updater = updater;
                workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates
                set(instance, workInProgress);
                {
                  instance._reactInternalInstance = fakeInternalInstance;
                }
              }
              function constructClassInstance(workInProgress, props) {
                var ctor = workInProgress.type;
                var unmaskedContext = getUnmaskedContext(workInProgress);
                var needsContext = isContextConsumer(workInProgress);
                var context = needsContext
                  ? getMaskedContext(workInProgress, unmaskedContext)
                  : emptyObject;
                var instance = new ctor(props, context);
                adoptClassInstance(workInProgress, instance); // Cache unmasked context so we can avoid recreating masked context unless necessary.
                // ReactFiberContext usually updates this cache but can't for newly-created instances.
                if (needsContext) {
                  cacheContext(workInProgress, unmaskedContext, context);
                }
                return instance;
              }
              function callComponentWillMount(workInProgress, instance) {
                startPhaseTimer(workInProgress, 'componentWillMount');
                var oldState = instance.state;
                instance.componentWillMount();
                stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.
                if (debugRenderPhaseSideEffects) {
                  instance.componentWillMount();
                }
                if (oldState !== instance.state) {
                  {
                    warning(
                      false,
                      '%s.componentWillMount(): Assigning directly to this.state is ' +
                        "deprecated (except inside a component's " +
                        'constructor). Use setState instead.',
                      getComponentName(workInProgress)
                    );
                  }
                  updater.enqueueReplaceState(instance, instance.state, null);
                }
              }
              function callComponentWillReceiveProps(
                workInProgress,
                instance,
                newProps,
                newContext
              ) {
                startPhaseTimer(workInProgress, 'componentWillReceiveProps');
                var oldState = instance.state;
                instance.componentWillReceiveProps(newProps, newContext);
                stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.
                if (debugRenderPhaseSideEffects) {
                  instance.componentWillReceiveProps(newProps, newContext);
                }
                if (instance.state !== oldState) {
                  {
                    var componentName =
                      getComponentName(workInProgress) || 'Component';
                    if (
                      !didWarnAboutStateAssignmentForComponent[componentName]
                    ) {
                      warning(
                        false,
                        '%s.componentWillReceiveProps(): Assigning directly to ' +
                          "this.state is deprecated (except inside a component's " +
                          'constructor). Use setState instead.',
                        componentName
                      );
                      didWarnAboutStateAssignmentForComponent[
                        componentName
                      ] = true;
                    }
                  }
                  updater.enqueueReplaceState(instance, instance.state, null);
                }
              } // Invokes the mount life-cycles on a previously never rendered instance.
              function mountClassInstance(
                workInProgress,
                renderExpirationTime
              ) {
                var current = workInProgress.alternate;
                {
                  checkClassInstance(workInProgress);
                }
                var instance = workInProgress.stateNode;
                var state = instance.state || null;
                var props = workInProgress.pendingProps;
                !props
                  ? invariant(
                      false,
                      'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0;
                var unmaskedContext = getUnmaskedContext(workInProgress);
                instance.props = props;
                instance.state = workInProgress.memoizedState = state;
                instance.refs = emptyObject;
                instance.context = getMaskedContext(
                  workInProgress,
                  unmaskedContext
                );
                if (
                  enableAsyncSubtreeAPI &&
                  workInProgress.type != null &&
                  workInProgress.type.prototype != null &&
                  workInProgress.type.prototype
                    .unstable_isAsyncReactComponent === true
                ) {
                  workInProgress.internalContextTag |= AsyncUpdates;
                }
                if (typeof instance.componentWillMount === 'function') {
                  callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
                  // process them now.
                  var updateQueue = workInProgress.updateQueue;
                  if (updateQueue !== null) {
                    instance.state = processUpdateQueue(
                      current,
                      workInProgress,
                      updateQueue,
                      instance,
                      props,
                      renderExpirationTime
                    );
                  }
                }
                if (typeof instance.componentDidMount === 'function') {
                  workInProgress.effectTag |= Update;
                }
              } // Called on a preexisting class instance. Returns false if a resumed render
              // could be reused.
              // function resumeMountClassInstance(
              //   workInProgress: Fiber,
              //   priorityLevel: PriorityLevel,
              // ): boolean {
              //   const instance = workInProgress.stateNode;
              //   resetInputPointers(workInProgress, instance);
              //   let newState = workInProgress.memoizedState;
              //   let newProps = workInProgress.pendingProps;
              //   if (!newProps) {
              //     // If there isn't any new props, then we'll reuse the memoized props.
              //     // This could be from already completed work.
              //     newProps = workInProgress.memoizedProps;
              //     invariant(
              //       newProps != null,
              //       'There should always be pending or memoized props. This error is ' +
              //         'likely caused by a bug in React. Please file an issue.',
              //     );
              //   }
              //   const newUnmaskedContext = getUnmaskedContext(workInProgress);
              //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);
              //   const oldContext = instance.context;
              //   const oldProps = workInProgress.memoizedProps;
              //   if (
              //     typeof instance.componentWillReceiveProps === 'function' &&
              //     (oldProps !== newProps || oldContext !== newContext)
              //   ) {
              //     callComponentWillReceiveProps(
              //       workInProgress,
              //       instance,
              //       newProps,
              //       newContext,
              //     );
              //   }
              //   // Process the update queue before calling shouldComponentUpdate
              //   const updateQueue = workInProgress.updateQueue;
              //   if (updateQueue !== null) {
              //     newState = processUpdateQueue(
              //       workInProgress,
              //       updateQueue,
              //       instance,
              //       newState,
              //       newProps,
              //       priorityLevel,
              //     );
              //   }
              //   // TODO: Should we deal with a setState that happened after the last
              //   // componentWillMount and before this componentWillMount? Probably
              //   // unsupported anyway.
              //   if (
              //     !checkShouldComponentUpdate(
              //       workInProgress,
              //       workInProgress.memoizedProps,
              //       newProps,
              //       workInProgress.memoizedState,
              //       newState,
              //       newContext,
              //     )
              //   ) {
              //     // Update the existing instance's state, props, and context pointers even
              //     // though we're bailing out.
              //     instance.props = newProps;
              //     instance.state = newState;
              //     instance.context = newContext;
              //     return false;
              //   }
              //   // Update the input pointers now so that they are correct when we call
              //   // componentWillMount
              //   instance.props = newProps;
              //   instance.state = newState;
              //   instance.context = newContext;
              //   if (typeof instance.componentWillMount === 'function') {
              //     callComponentWillMount(workInProgress, instance);
              //     // componentWillMount may have called setState. Process the update queue.
              //     const newUpdateQueue = workInProgress.updateQueue;
              //     if (newUpdateQueue !== null) {
              //       newState = processUpdateQueue(
              //         workInProgress,
              //         newUpdateQueue,
              //         instance,
              //         newState,
              //         newProps,
              //         priorityLevel,
              //       );
              //     }
              //   }
              //   if (typeof instance.componentDidMount === 'function') {
              //     workInProgress.effectTag |= Update;
              //   }
              //   instance.state = newState;
              //   return true;
              // }
              // Invokes the update life-cycles and returns false if it shouldn't rerender.
              function updateClassInstance(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                var instance = workInProgress.stateNode;
                resetInputPointers(workInProgress, instance);
                var oldProps = workInProgress.memoizedProps;
                var newProps = workInProgress.pendingProps;
                if (!newProps) {
                  // If there aren't any new props, then we'll reuse the memoized props.
                  // This could be from already completed work.
                  newProps = oldProps;
                  !(newProps != null)
                    ? invariant(
                        false,
                        'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.'
                      )
                    : void 0;
                }
                var oldContext = instance.context;
                var newUnmaskedContext = getUnmaskedContext(workInProgress);
                var newContext = getMaskedContext(
                  workInProgress,
                  newUnmaskedContext
                ); // Note: During these life-cycles, instance.props/instance.state are what
                // ever the previously attempted to render - not the "current". However,
                // during componentDidUpdate we pass the "current" props.
                if (
                  typeof instance.componentWillReceiveProps === 'function' &&
                  (oldProps !== newProps || oldContext !== newContext)
                ) {
                  callComponentWillReceiveProps(
                    workInProgress,
                    instance,
                    newProps,
                    newContext
                  );
                } // Compute the next state using the memoized state and the update queue.
                var oldState = workInProgress.memoizedState; // TODO: Previous state can be null.
                var newState = void 0;
                if (workInProgress.updateQueue !== null) {
                  newState = processUpdateQueue(
                    current,
                    workInProgress,
                    workInProgress.updateQueue,
                    instance,
                    newProps,
                    renderExpirationTime
                  );
                } else {
                  newState = oldState;
                }
                if (
                  oldProps === newProps &&
                  oldState === newState &&
                  !hasContextChanged() &&
                  !(
                    workInProgress.updateQueue !== null &&
                    workInProgress.updateQueue.hasForceUpdate
                  )
                ) {
                  // If an update was already in progress, we should schedule an Update
                  // effect even though we're bailing out, so that cWU/cDU are called.
                  if (typeof instance.componentDidUpdate === 'function') {
                    if (
                      oldProps !== current.memoizedProps ||
                      oldState !== current.memoizedState
                    ) {
                      workInProgress.effectTag |= Update;
                    }
                  }
                  return false;
                }
                var shouldUpdate = checkShouldComponentUpdate(
                  workInProgress,
                  oldProps,
                  newProps,
                  oldState,
                  newState,
                  newContext
                );
                if (shouldUpdate) {
                  if (typeof instance.componentWillUpdate === 'function') {
                    startPhaseTimer(workInProgress, 'componentWillUpdate');
                    instance.componentWillUpdate(
                      newProps,
                      newState,
                      newContext
                    );
                    stopPhaseTimer(); // Simulate an async bailout/interruption by invoking lifecycle twice.
                    if (debugRenderPhaseSideEffects) {
                      instance.componentWillUpdate(
                        newProps,
                        newState,
                        newContext
                      );
                    }
                  }
                  if (typeof instance.componentDidUpdate === 'function') {
                    workInProgress.effectTag |= Update;
                  }
                } else {
                  // If an update was already in progress, we should schedule an Update
                  // effect even though we're bailing out, so that cWU/cDU are called.
                  if (typeof instance.componentDidUpdate === 'function') {
                    if (
                      oldProps !== current.memoizedProps ||
                      oldState !== current.memoizedState
                    ) {
                      workInProgress.effectTag |= Update;
                    }
                  } // If shouldComponentUpdate returned false, we should still update the
                  // memoized props/state to indicate that this work can be reused.
                  memoizeProps(workInProgress, newProps);
                  memoizeState(workInProgress, newState);
                } // Update the existing instance's state, props, and context pointers even
                // if shouldComponentUpdate returns false.
                instance.props = newProps;
                instance.state = newState;
                instance.context = newContext;
                return shouldUpdate;
              }
              return {
                adoptClassInstance: adoptClassInstance,
                constructClassInstance: constructClassInstance,
                mountClassInstance: mountClassInstance, // resumeMountClassInstance,
                updateClassInstance: updateClassInstance
              };
            }; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
            // nor polyfill, then a plain number is used for performance.
            var hasSymbol = typeof Symbol === 'function' && Symbol['for'];
            var REACT_ELEMENT_TYPE = hasSymbol
              ? Symbol['for']('react.element')
              : 0xeac7;
            var REACT_CALL_TYPE = hasSymbol
              ? Symbol['for']('react.call')
              : 0xeac8;
            var REACT_RETURN_TYPE = hasSymbol
              ? Symbol['for']('react.return')
              : 0xeac9;
            var REACT_PORTAL_TYPE = hasSymbol
              ? Symbol['for']('react.portal')
              : 0xeaca;
            var REACT_FRAGMENT_TYPE = hasSymbol
              ? Symbol['for']('react.fragment')
              : 0xeacb;
            var MAYBE_ITERATOR_SYMBOL =
              typeof Symbol === 'function' && Symbol.iterator;
            var FAUX_ITERATOR_SYMBOL = '@@iterator';
            function getIteratorFn(maybeIterable) {
              if (
                maybeIterable === null ||
                typeof maybeIterable === 'undefined'
              ) {
                return null;
              }
              var maybeIterator =
                (MAYBE_ITERATOR_SYMBOL &&
                  maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
                maybeIterable[FAUX_ITERATOR_SYMBOL];
              if (typeof maybeIterator === 'function') {
                return maybeIterator;
              }
              return null;
            }
            var getCurrentFiberStackAddendum$1 =
              ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
            {
              var didWarnAboutMaps = false;
              /**
               * Warn if there's no key explicitly set on dynamic arrays of children or
               * object keys are not valid. This allows us to keep track of children between
               * updates.
               */ var ownerHasKeyUseWarning = {};
              var ownerHasFunctionTypeWarning = {};
              var warnForMissingKey = function warnForMissingKey(child) {
                if (child === null || _typeof(child) !== 'object') {
                  return;
                }
                if (
                  !child._store ||
                  child._store.validated ||
                  child.key != null
                ) {
                  return;
                }
                !(_typeof(child._store) === 'object')
                  ? invariant(
                      false,
                      'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0;
                child._store.validated = true;
                var currentComponentErrorInfo =
                  'Each child in an array or iterator should have a unique ' +
                  '"key" prop. See https://fb.me/react-warning-keys for ' +
                  'more information.' +
                  (getCurrentFiberStackAddendum$1() || '');
                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                  return;
                }
                ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
                warning(
                  false,
                  'Each child in an array or iterator should have a unique ' +
                    '"key" prop. See https://fb.me/react-warning-keys for ' +
                    'more information.%s',
                  getCurrentFiberStackAddendum$1()
                );
              };
            }
            var isArray$1 = Array.isArray;
            function coerceRef(current, element) {
              var mixedRef = element.ref;
              if (mixedRef !== null && typeof mixedRef !== 'function') {
                if (element._owner) {
                  var owner = element._owner;
                  var inst = void 0;
                  if (owner) {
                    var ownerFiber = owner;
                    !(ownerFiber.tag === ClassComponent)
                      ? invariant(
                          false,
                          'Stateless function components cannot have refs.'
                        )
                      : void 0;
                    inst = ownerFiber.stateNode;
                  }
                  !inst
                    ? invariant(
                        false,
                        'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',
                        mixedRef
                      )
                    : void 0;
                  var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref
                  if (
                    current !== null &&
                    current.ref !== null &&
                    current.ref._stringRef === stringRef
                  ) {
                    return current.ref;
                  }
                  var ref = function ref(value) {
                    var refs =
                      inst.refs === emptyObject ? (inst.refs = {}) : inst.refs;
                    if (value === null) {
                      delete refs[stringRef];
                    } else {
                      refs[stringRef] = value;
                    }
                  };
                  ref._stringRef = stringRef;
                  return ref;
                } else {
                  !(typeof mixedRef === 'string')
                    ? invariant(
                        false,
                        'Expected ref to be a function or a string.'
                      )
                    : void 0;
                  !element._owner
                    ? invariant(
                        false,
                        'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).',
                        mixedRef
                      )
                    : void 0;
                }
              }
              return mixedRef;
            }
            function throwOnInvalidObjectType(returnFiber, newChild) {
              if (returnFiber.type !== 'textarea') {
                var addendum = '';
                {
                  addendum =
                    ' If you meant to render a collection of children, use an array ' +
                    'instead.' +
                    (getCurrentFiberStackAddendum$1() || '');
                }
                invariant(
                  false,
                  'Objects are not valid as a React child (found: %s).%s',
                  Object.prototype.toString.call(newChild) === '[object Object]'
                    ? 'object with keys {' +
                      Object.keys(newChild).join(', ') +
                      '}'
                    : newChild,
                  addendum
                );
              }
            }
            function warnOnFunctionType() {
              var currentComponentErrorInfo =
                'Functions are not valid as a React child. This may happen if ' +
                'you return a Component instead of <Component /> from render. ' +
                'Or maybe you meant to call this function rather than return it.' +
                (getCurrentFiberStackAddendum$1() || '');
              if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
              warning(
                false,
                'Functions are not valid as a React child. This may happen if ' +
                  'you return a Component instead of <Component /> from render. ' +
                  'Or maybe you meant to call this function rather than return it.%s',
                getCurrentFiberStackAddendum$1() || ''
              );
            } // This wrapper function exists because I expect to clone the code in each path
            // to be able to optimize each path individually by branching early. This needs
            // a compiler or we can do it manually. Helpers that don't need this branching
            // live outside of this function.
            function ChildReconciler(shouldTrackSideEffects) {
              function deleteChild(returnFiber, childToDelete) {
                if (!shouldTrackSideEffects) {
                  // Noop.
                  return;
                } // Deletions are added in reversed order so we add it to the front.
                // At this point, the return fiber's effect list is empty except for
                // deletions, so we can just append the deletion to the list. The remaining
                // effects aren't added until the complete phase. Once we implement
                // resuming, this may not be true.
                var last = returnFiber.lastEffect;
                if (last !== null) {
                  last.nextEffect = childToDelete;
                  returnFiber.lastEffect = childToDelete;
                } else {
                  returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
                }
                childToDelete.nextEffect = null;
                childToDelete.effectTag = Deletion;
              }
              function deleteRemainingChildren(returnFiber, currentFirstChild) {
                if (!shouldTrackSideEffects) {
                  // Noop.
                  return null;
                } // TODO: For the shouldClone case, this could be micro-optimized a bit by
                // assuming that after the first child we've already added everything.
                var childToDelete = currentFirstChild;
                while (childToDelete !== null) {
                  deleteChild(returnFiber, childToDelete);
                  childToDelete = childToDelete.sibling;
                }
                return null;
              }
              function mapRemainingChildren(returnFiber, currentFirstChild) {
                // Add the remaining children to a temporary map so that we can find them by
                // keys quickly. Implicit (null) keys get added to this set with their index
                var existingChildren = new Map();
                var existingChild = currentFirstChild;
                while (existingChild !== null) {
                  if (existingChild.key !== null) {
                    existingChildren.set(existingChild.key, existingChild);
                  } else {
                    existingChildren.set(existingChild.index, existingChild);
                  }
                  existingChild = existingChild.sibling;
                }
                return existingChildren;
              }
              function useFiber(fiber, pendingProps, expirationTime) {
                // We currently set sibling to null and index to 0 here because it is easy
                // to forget to do before returning it. E.g. for the single child case.
                var clone = createWorkInProgress(
                  fiber,
                  pendingProps,
                  expirationTime
                );
                clone.index = 0;
                clone.sibling = null;
                return clone;
              }
              function placeChild(newFiber, lastPlacedIndex, newIndex) {
                newFiber.index = newIndex;
                if (!shouldTrackSideEffects) {
                  // Noop.
                  return lastPlacedIndex;
                }
                var current = newFiber.alternate;
                if (current !== null) {
                  var oldIndex = current.index;
                  if (oldIndex < lastPlacedIndex) {
                    // This is a move.
                    newFiber.effectTag = Placement;
                    return lastPlacedIndex;
                  } else {
                    // This item can stay in place.
                    return oldIndex;
                  }
                } else {
                  // This is an insertion.
                  newFiber.effectTag = Placement;
                  return lastPlacedIndex;
                }
              }
              function placeSingleChild(newFiber) {
                // This is simpler for the single child case. We only need to do a
                // placement for inserting new children.
                if (shouldTrackSideEffects && newFiber.alternate === null) {
                  newFiber.effectTag = Placement;
                }
                return newFiber;
              }
              function updateTextNode(
                returnFiber,
                current,
                textContent,
                expirationTime
              ) {
                if (current === null || current.tag !== HostText) {
                  // Insert
                  var created = createFiberFromText(
                    textContent,
                    returnFiber.internalContextTag,
                    expirationTime
                  );
                  created['return'] = returnFiber;
                  return created;
                } else {
                  // Update
                  var existing = useFiber(current, textContent, expirationTime);
                  existing['return'] = returnFiber;
                  return existing;
                }
              }
              function updateElement(
                returnFiber,
                current,
                element,
                expirationTime
              ) {
                if (current !== null && current.type === element.type) {
                  // Move based on index
                  var existing = useFiber(
                    current,
                    element.props,
                    expirationTime
                  );
                  existing.ref = coerceRef(current, element);
                  existing['return'] = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                } else {
                  // Insert
                  var created = createFiberFromElement(
                    element,
                    returnFiber.internalContextTag,
                    expirationTime
                  );
                  created.ref = coerceRef(current, element);
                  created['return'] = returnFiber;
                  return created;
                }
              }
              function updateCall(returnFiber, current, call, expirationTime) {
                // TODO: Should this also compare handler to determine whether to reuse?
                if (current === null || current.tag !== CallComponent) {
                  // Insert
                  var created = createFiberFromCall(
                    call,
                    returnFiber.internalContextTag,
                    expirationTime
                  );
                  created['return'] = returnFiber;
                  return created;
                } else {
                  // Move based on index
                  var existing = useFiber(current, call, expirationTime);
                  existing['return'] = returnFiber;
                  return existing;
                }
              }
              function updateReturn(
                returnFiber,
                current,
                returnNode,
                expirationTime
              ) {
                if (current === null || current.tag !== ReturnComponent) {
                  // Insert
                  var created = createFiberFromReturn(
                    returnNode,
                    returnFiber.internalContextTag,
                    expirationTime
                  );
                  created.type = returnNode.value;
                  created['return'] = returnFiber;
                  return created;
                } else {
                  // Move based on index
                  var existing = useFiber(current, null, expirationTime);
                  existing.type = returnNode.value;
                  existing['return'] = returnFiber;
                  return existing;
                }
              }
              function updatePortal(
                returnFiber,
                current,
                portal,
                expirationTime
              ) {
                if (
                  current === null ||
                  current.tag !== HostPortal ||
                  current.stateNode.containerInfo !== portal.containerInfo ||
                  current.stateNode.implementation !== portal.implementation
                ) {
                  // Insert
                  var created = createFiberFromPortal(
                    portal,
                    returnFiber.internalContextTag,
                    expirationTime
                  );
                  created['return'] = returnFiber;
                  return created;
                } else {
                  // Update
                  var existing = useFiber(
                    current,
                    portal.children || [],
                    expirationTime
                  );
                  existing['return'] = returnFiber;
                  return existing;
                }
              }
              function updateFragment(
                returnFiber,
                current,
                fragment,
                expirationTime,
                key
              ) {
                if (current === null || current.tag !== Fragment) {
                  // Insert
                  var created = createFiberFromFragment(
                    fragment,
                    returnFiber.internalContextTag,
                    expirationTime,
                    key
                  );
                  created['return'] = returnFiber;
                  return created;
                } else {
                  // Update
                  var existing = useFiber(current, fragment, expirationTime);
                  existing['return'] = returnFiber;
                  return existing;
                }
              }
              function createChild(returnFiber, newChild, expirationTime) {
                if (
                  typeof newChild === 'string' ||
                  typeof newChild === 'number'
                ) {
                  // Text nodes don't have keys. If the previous node is implicitly keyed
                  // we can continue to replace it without aborting even if it is not a text
                  // node.
                  var created = createFiberFromText(
                    '' + newChild,
                    returnFiber.internalContextTag,
                    expirationTime
                  );
                  created['return'] = returnFiber;
                  return created;
                }
                if (_typeof(newChild) === 'object' && newChild !== null) {
                  switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE: {
                      if (newChild.type === REACT_FRAGMENT_TYPE) {
                        var _created = createFiberFromFragment(
                          newChild.props.children,
                          returnFiber.internalContextTag,
                          expirationTime,
                          newChild.key
                        );
                        _created['return'] = returnFiber;
                        return _created;
                      } else {
                        var _created2 = createFiberFromElement(
                          newChild,
                          returnFiber.internalContextTag,
                          expirationTime
                        );
                        _created2.ref = coerceRef(null, newChild);
                        _created2['return'] = returnFiber;
                        return _created2;
                      }
                    }
                    case REACT_CALL_TYPE: {
                      var _created3 = createFiberFromCall(
                        newChild,
                        returnFiber.internalContextTag,
                        expirationTime
                      );
                      _created3['return'] = returnFiber;
                      return _created3;
                    }
                    case REACT_RETURN_TYPE: {
                      var _created4 = createFiberFromReturn(
                        newChild,
                        returnFiber.internalContextTag,
                        expirationTime
                      );
                      _created4.type = newChild.value;
                      _created4['return'] = returnFiber;
                      return _created4;
                    }
                    case REACT_PORTAL_TYPE: {
                      var _created5 = createFiberFromPortal(
                        newChild,
                        returnFiber.internalContextTag,
                        expirationTime
                      );
                      _created5['return'] = returnFiber;
                      return _created5;
                    }
                  }
                  if (isArray$1(newChild) || getIteratorFn(newChild)) {
                    var _created6 = createFiberFromFragment(
                      newChild,
                      returnFiber.internalContextTag,
                      expirationTime,
                      null
                    );
                    _created6['return'] = returnFiber;
                    return _created6;
                  }
                  throwOnInvalidObjectType(returnFiber, newChild);
                }
                {
                  if (typeof newChild === 'function') {
                    warnOnFunctionType();
                  }
                }
                return null;
              }
              function updateSlot(
                returnFiber,
                oldFiber,
                newChild,
                expirationTime
              ) {
                // Update the fiber if the keys match, otherwise return null.
                var key = oldFiber !== null ? oldFiber.key : null;
                if (
                  typeof newChild === 'string' ||
                  typeof newChild === 'number'
                ) {
                  // Text nodes don't have keys. If the previous node is implicitly keyed
                  // we can continue to replace it without aborting even if it is not a text
                  // node.
                  if (key !== null) {
                    return null;
                  }
                  return updateTextNode(
                    returnFiber,
                    oldFiber,
                    '' + newChild,
                    expirationTime
                  );
                }
                if (_typeof(newChild) === 'object' && newChild !== null) {
                  switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE: {
                      if (newChild.key === key) {
                        if (newChild.type === REACT_FRAGMENT_TYPE) {
                          return updateFragment(
                            returnFiber,
                            oldFiber,
                            newChild.props.children,
                            expirationTime,
                            key
                          );
                        }
                        return updateElement(
                          returnFiber,
                          oldFiber,
                          newChild,
                          expirationTime
                        );
                      } else {
                        return null;
                      }
                    }
                    case REACT_CALL_TYPE: {
                      if (newChild.key === key) {
                        return updateCall(
                          returnFiber,
                          oldFiber,
                          newChild,
                          expirationTime
                        );
                      } else {
                        return null;
                      }
                    }
                    case REACT_RETURN_TYPE: {
                      // Returns don't have keys. If the previous node is implicitly keyed
                      // we can continue to replace it without aborting even if it is not a
                      // yield.
                      if (key === null) {
                        return updateReturn(
                          returnFiber,
                          oldFiber,
                          newChild,
                          expirationTime
                        );
                      } else {
                        return null;
                      }
                    }
                    case REACT_PORTAL_TYPE: {
                      if (newChild.key === key) {
                        return updatePortal(
                          returnFiber,
                          oldFiber,
                          newChild,
                          expirationTime
                        );
                      } else {
                        return null;
                      }
                    }
                  }
                  if (isArray$1(newChild) || getIteratorFn(newChild)) {
                    if (key !== null) {
                      return null;
                    }
                    return updateFragment(
                      returnFiber,
                      oldFiber,
                      newChild,
                      expirationTime,
                      null
                    );
                  }
                  throwOnInvalidObjectType(returnFiber, newChild);
                }
                {
                  if (typeof newChild === 'function') {
                    warnOnFunctionType();
                  }
                }
                return null;
              }
              function updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                expirationTime
              ) {
                if (
                  typeof newChild === 'string' ||
                  typeof newChild === 'number'
                ) {
                  // Text nodes don't have keys, so we neither have to check the old nor
                  // new node for the key. If both are text nodes, they match.
                  var matchedFiber = existingChildren.get(newIdx) || null;
                  return updateTextNode(
                    returnFiber,
                    matchedFiber,
                    '' + newChild,
                    expirationTime
                  );
                }
                if (_typeof(newChild) === 'object' && newChild !== null) {
                  switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE: {
                      var _matchedFiber =
                        existingChildren.get(
                          newChild.key === null ? newIdx : newChild.key
                        ) || null;
                      if (newChild.type === REACT_FRAGMENT_TYPE) {
                        return updateFragment(
                          returnFiber,
                          _matchedFiber,
                          newChild.props.children,
                          expirationTime,
                          newChild.key
                        );
                      }
                      return updateElement(
                        returnFiber,
                        _matchedFiber,
                        newChild,
                        expirationTime
                      );
                    }
                    case REACT_CALL_TYPE: {
                      var _matchedFiber2 =
                        existingChildren.get(
                          newChild.key === null ? newIdx : newChild.key
                        ) || null;
                      return updateCall(
                        returnFiber,
                        _matchedFiber2,
                        newChild,
                        expirationTime
                      );
                    }
                    case REACT_RETURN_TYPE: {
                      // Returns don't have keys, so we neither have to check the old nor
                      // new node for the key. If both are returns, they match.
                      var _matchedFiber3 = existingChildren.get(newIdx) || null;
                      return updateReturn(
                        returnFiber,
                        _matchedFiber3,
                        newChild,
                        expirationTime
                      );
                    }
                    case REACT_PORTAL_TYPE: {
                      var _matchedFiber4 =
                        existingChildren.get(
                          newChild.key === null ? newIdx : newChild.key
                        ) || null;
                      return updatePortal(
                        returnFiber,
                        _matchedFiber4,
                        newChild,
                        expirationTime
                      );
                    }
                  }
                  if (isArray$1(newChild) || getIteratorFn(newChild)) {
                    var _matchedFiber5 = existingChildren.get(newIdx) || null;
                    return updateFragment(
                      returnFiber,
                      _matchedFiber5,
                      newChild,
                      expirationTime,
                      null
                    );
                  }
                  throwOnInvalidObjectType(returnFiber, newChild);
                }
                {
                  if (typeof newChild === 'function') {
                    warnOnFunctionType();
                  }
                }
                return null;
              }
              /**
               * Warns if there is a duplicate or missing key
               */ function warnOnInvalidKey(child, knownKeys) {
                {
                  if (_typeof(child) !== 'object' || child === null) {
                    return knownKeys;
                  }
                  switch (child.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_CALL_TYPE:
                    case REACT_PORTAL_TYPE:
                      warnForMissingKey(child);
                      var key = child.key;
                      if (typeof key !== 'string') {
                        break;
                      }
                      if (knownKeys === null) {
                        knownKeys = new Set();
                        knownKeys.add(key);
                        break;
                      }
                      if (!knownKeys.has(key)) {
                        knownKeys.add(key);
                        break;
                      }
                      warning(
                        false,
                        'Encountered two children with the same key, `%s`. ' +
                          'Keys should be unique so that components maintain their identity ' +
                          'across updates. Non-unique keys may cause children to be ' +
                          'duplicated and/or omitted  the behavior is unsupported and ' +
                          'could change in a future version.%s',
                        key,
                        getCurrentFiberStackAddendum$1()
                      );
                      break;
                    default:
                      break;
                  }
                }
                return knownKeys;
              }
              function reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChildren,
                expirationTime
              ) {
                // This algorithm can't optimize by searching from boths ends since we
                // don't have backpointers on fibers. I'm trying to see how far we can get
                // with that model. If it ends up not being worth the tradeoffs, we can
                // add it later.
                // Even with a two ended optimization, we'd want to optimize for the case
                // where there are few changes and brute force the comparison instead of
                // going for the Map. It'd like to explore hitting that path first in
                // forward-only mode and only go for the Map once we notice that we need
                // lots of look ahead. This doesn't handle reversal as well as two ended
                // search but that's unusual. Besides, for the two ended optimization to
                // work on Iterables, we'd need to copy the whole set.
                // In this first iteration, we'll just live with hitting the bad case
                // (adding everything to a Map) in for every insert/move.
                // If you change this code, also update reconcileChildrenIterator() which
                // uses the same algorithm.
                {
                  // First, validate keys.
                  var knownKeys = null;
                  for (var i = 0; i < newChildren.length; i++) {
                    var child = newChildren[i];
                    knownKeys = warnOnInvalidKey(child, knownKeys);
                  }
                }
                var resultingFirstChild = null;
                var previousNewFiber = null;
                var oldFiber = currentFirstChild;
                var lastPlacedIndex = 0;
                var newIdx = 0;
                var nextOldFiber = null;
                for (
                  ;
                  oldFiber !== null && newIdx < newChildren.length;
                  newIdx++
                ) {
                  if (oldFiber.index > newIdx) {
                    nextOldFiber = oldFiber;
                    oldFiber = null;
                  } else {
                    nextOldFiber = oldFiber.sibling;
                  }
                  var newFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChildren[newIdx],
                    expirationTime
                  );
                  if (newFiber === null) {
                    // TODO: This breaks on empty slots like null children. That's
                    // unfortunate because it triggers the slow path all the time. We need
                    // a better way to communicate whether this was a miss or null,
                    // boolean, undefined, etc.
                    if (oldFiber === null) {
                      oldFiber = nextOldFiber;
                    }
                    break;
                  }
                  if (shouldTrackSideEffects) {
                    if (oldFiber && newFiber.alternate === null) {
                      // We matched the slot, but we didn't reuse the existing fiber, so we
                      // need to delete the existing child.
                      deleteChild(returnFiber, oldFiber);
                    }
                  }
                  lastPlacedIndex = placeChild(
                    newFiber,
                    lastPlacedIndex,
                    newIdx
                  );
                  if (previousNewFiber === null) {
                    // TODO: Move out of the loop. This only happens for the first run.
                    resultingFirstChild = newFiber;
                  } else {
                    // TODO: Defer siblings if we're not at the right index for this slot.
                    // I.e. if we had null values before, then we want to defer this
                    // for each null value. However, we also don't want to call updateSlot
                    // with the previous one.
                    previousNewFiber.sibling = newFiber;
                  }
                  previousNewFiber = newFiber;
                  oldFiber = nextOldFiber;
                }
                if (newIdx === newChildren.length) {
                  // We've reached the end of the new children. We can delete the rest.
                  deleteRemainingChildren(returnFiber, oldFiber);
                  return resultingFirstChild;
                }
                if (oldFiber === null) {
                  // If we don't have any more existing children we can choose a fast path
                  // since the rest will all be insertions.
                  for (; newIdx < newChildren.length; newIdx++) {
                    var _newFiber = createChild(
                      returnFiber,
                      newChildren[newIdx],
                      expirationTime
                    );
                    if (!_newFiber) {
                      continue;
                    }
                    lastPlacedIndex = placeChild(
                      _newFiber,
                      lastPlacedIndex,
                      newIdx
                    );
                    if (previousNewFiber === null) {
                      // TODO: Move out of the loop. This only happens for the first run.
                      resultingFirstChild = _newFiber;
                    } else {
                      previousNewFiber.sibling = _newFiber;
                    }
                    previousNewFiber = _newFiber;
                  }
                  return resultingFirstChild;
                } // Add all children to a key map for quick lookups.
                var existingChildren = mapRemainingChildren(
                  returnFiber,
                  oldFiber
                ); // Keep scanning and use the map to restore deleted items as moves.
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber2 = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChildren[newIdx],
                    expirationTime
                  );
                  if (_newFiber2) {
                    if (shouldTrackSideEffects) {
                      if (_newFiber2.alternate !== null) {
                        // The new fiber is a work in progress, but if there exists a
                        // current, that means that we reused the fiber. We need to delete
                        // it from the child list so that we don't add it to the deletion
                        // list.
                        existingChildren['delete'](
                          _newFiber2.key === null ? newIdx : _newFiber2.key
                        );
                      }
                    }
                    lastPlacedIndex = placeChild(
                      _newFiber2,
                      lastPlacedIndex,
                      newIdx
                    );
                    if (previousNewFiber === null) {
                      resultingFirstChild = _newFiber2;
                    } else {
                      previousNewFiber.sibling = _newFiber2;
                    }
                    previousNewFiber = _newFiber2;
                  }
                }
                if (shouldTrackSideEffects) {
                  // Any existing children that weren't consumed above were deleted. We need
                  // to add them to the deletion list.
                  existingChildren.forEach(function(child) {
                    return deleteChild(returnFiber, child);
                  });
                }
                return resultingFirstChild;
              }
              function reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChildrenIterable,
                expirationTime
              ) {
                // This is the same implementation as reconcileChildrenArray(),
                // but using the iterator instead.
                var iteratorFn = getIteratorFn(newChildrenIterable);
                !(typeof iteratorFn === 'function')
                  ? invariant(
                      false,
                      'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0;
                {
                  // Warn about using Maps as children
                  if (typeof newChildrenIterable.entries === 'function') {
                    var possibleMap = newChildrenIterable;
                    if (possibleMap.entries === iteratorFn) {
                      warning(
                        didWarnAboutMaps,
                        'Using Maps as children is unsupported and will likely yield ' +
                          'unexpected results. Convert it to a sequence/iterable of keyed ' +
                          'ReactElements instead.%s',
                        getCurrentFiberStackAddendum$1()
                      );
                      didWarnAboutMaps = true;
                    }
                  } // First, validate keys.
                  // We'll get a different iterator later for the main pass.
                  var _newChildren = iteratorFn.call(newChildrenIterable);
                  if (_newChildren) {
                    var knownKeys = null;
                    var _step = _newChildren.next();
                    for (; !_step.done; _step = _newChildren.next()) {
                      var child = _step.value;
                      knownKeys = warnOnInvalidKey(child, knownKeys);
                    }
                  }
                }
                var newChildren = iteratorFn.call(newChildrenIterable);
                !(newChildren != null)
                  ? invariant(false, 'An iterable object provided no iterator.')
                  : void 0;
                var resultingFirstChild = null;
                var previousNewFiber = null;
                var oldFiber = currentFirstChild;
                var lastPlacedIndex = 0;
                var newIdx = 0;
                var nextOldFiber = null;
                var step = newChildren.next();
                for (
                  ;
                  oldFiber !== null && !step.done;
                  newIdx++, step = newChildren.next()
                ) {
                  if (oldFiber.index > newIdx) {
                    nextOldFiber = oldFiber;
                    oldFiber = null;
                  } else {
                    nextOldFiber = oldFiber.sibling;
                  }
                  var newFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    step.value,
                    expirationTime
                  );
                  if (newFiber === null) {
                    // TODO: This breaks on empty slots like null children. That's
                    // unfortunate because it triggers the slow path all the time. We need
                    // a better way to communicate whether this was a miss or null,
                    // boolean, undefined, etc.
                    if (!oldFiber) {
                      oldFiber = nextOldFiber;
                    }
                    break;
                  }
                  if (shouldTrackSideEffects) {
                    if (oldFiber && newFiber.alternate === null) {
                      // We matched the slot, but we didn't reuse the existing fiber, so we
                      // need to delete the existing child.
                      deleteChild(returnFiber, oldFiber);
                    }
                  }
                  lastPlacedIndex = placeChild(
                    newFiber,
                    lastPlacedIndex,
                    newIdx
                  );
                  if (previousNewFiber === null) {
                    // TODO: Move out of the loop. This only happens for the first run.
                    resultingFirstChild = newFiber;
                  } else {
                    // TODO: Defer siblings if we're not at the right index for this slot.
                    // I.e. if we had null values before, then we want to defer this
                    // for each null value. However, we also don't want to call updateSlot
                    // with the previous one.
                    previousNewFiber.sibling = newFiber;
                  }
                  previousNewFiber = newFiber;
                  oldFiber = nextOldFiber;
                }
                if (step.done) {
                  // We've reached the end of the new children. We can delete the rest.
                  deleteRemainingChildren(returnFiber, oldFiber);
                  return resultingFirstChild;
                }
                if (oldFiber === null) {
                  // If we don't have any more existing children we can choose a fast path
                  // since the rest will all be insertions.
                  for (; !step.done; newIdx++, step = newChildren.next()) {
                    var _newFiber3 = createChild(
                      returnFiber,
                      step.value,
                      expirationTime
                    );
                    if (_newFiber3 === null) {
                      continue;
                    }
                    lastPlacedIndex = placeChild(
                      _newFiber3,
                      lastPlacedIndex,
                      newIdx
                    );
                    if (previousNewFiber === null) {
                      // TODO: Move out of the loop. This only happens for the first run.
                      resultingFirstChild = _newFiber3;
                    } else {
                      previousNewFiber.sibling = _newFiber3;
                    }
                    previousNewFiber = _newFiber3;
                  }
                  return resultingFirstChild;
                } // Add all children to a key map for quick lookups.
                var existingChildren = mapRemainingChildren(
                  returnFiber,
                  oldFiber
                ); // Keep scanning and use the map to restore deleted items as moves.
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber4 = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    step.value,
                    expirationTime
                  );
                  if (_newFiber4 !== null) {
                    if (shouldTrackSideEffects) {
                      if (_newFiber4.alternate !== null) {
                        // The new fiber is a work in progress, but if there exists a
                        // current, that means that we reused the fiber. We need to delete
                        // it from the child list so that we don't add it to the deletion
                        // list.
                        existingChildren['delete'](
                          _newFiber4.key === null ? newIdx : _newFiber4.key
                        );
                      }
                    }
                    lastPlacedIndex = placeChild(
                      _newFiber4,
                      lastPlacedIndex,
                      newIdx
                    );
                    if (previousNewFiber === null) {
                      resultingFirstChild = _newFiber4;
                    } else {
                      previousNewFiber.sibling = _newFiber4;
                    }
                    previousNewFiber = _newFiber4;
                  }
                }
                if (shouldTrackSideEffects) {
                  // Any existing children that weren't consumed above were deleted. We need
                  // to add them to the deletion list.
                  existingChildren.forEach(function(child) {
                    return deleteChild(returnFiber, child);
                  });
                }
                return resultingFirstChild;
              }
              function reconcileSingleTextNode(
                returnFiber,
                currentFirstChild,
                textContent,
                expirationTime
              ) {
                // There's no need to check for keys on text nodes since we don't have a
                // way to define them.
                if (
                  currentFirstChild !== null &&
                  currentFirstChild.tag === HostText
                ) {
                  // We already have an existing node so let's just update it and delete
                  // the rest.
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  var existing = useFiber(
                    currentFirstChild,
                    textContent,
                    expirationTime
                  );
                  existing['return'] = returnFiber;
                  return existing;
                } // The existing first child is not a text node so we need to create one
                // and delete the existing ones.
                deleteRemainingChildren(returnFiber, currentFirstChild);
                var created = createFiberFromText(
                  textContent,
                  returnFiber.internalContextTag,
                  expirationTime
                );
                created['return'] = returnFiber;
                return created;
              }
              function reconcileSingleElement(
                returnFiber,
                currentFirstChild,
                element,
                expirationTime
              ) {
                var key = element.key;
                var child = currentFirstChild;
                while (child !== null) {
                  // TODO: If key === null and child.key === null, then this only applies to
                  // the first item in the list.
                  if (child.key === key) {
                    if (
                      child.tag === Fragment
                        ? element.type === REACT_FRAGMENT_TYPE
                        : child.type === element.type
                    ) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(
                        child,
                        element.type === REACT_FRAGMENT_TYPE
                          ? element.props.children
                          : element.props,
                        expirationTime
                      );
                      existing.ref = coerceRef(child, element);
                      existing['return'] = returnFiber;
                      {
                        existing._debugSource = element._source;
                        existing._debugOwner = element._owner;
                      }
                      return existing;
                    } else {
                      deleteRemainingChildren(returnFiber, child);
                      break;
                    }
                  } else {
                    deleteChild(returnFiber, child);
                  }
                  child = child.sibling;
                }
                if (element.type === REACT_FRAGMENT_TYPE) {
                  var created = createFiberFromFragment(
                    element.props.children,
                    returnFiber.internalContextTag,
                    expirationTime,
                    element.key
                  );
                  created['return'] = returnFiber;
                  return created;
                } else {
                  var _created7 = createFiberFromElement(
                    element,
                    returnFiber.internalContextTag,
                    expirationTime
                  );
                  _created7.ref = coerceRef(currentFirstChild, element);
                  _created7['return'] = returnFiber;
                  return _created7;
                }
              }
              function reconcileSingleCall(
                returnFiber,
                currentFirstChild,
                call,
                expirationTime
              ) {
                var key = call.key;
                var child = currentFirstChild;
                while (child !== null) {
                  // TODO: If key === null and child.key === null, then this only applies to
                  // the first item in the list.
                  if (child.key === key) {
                    if (child.tag === CallComponent) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(child, call, expirationTime);
                      existing['return'] = returnFiber;
                      return existing;
                    } else {
                      deleteRemainingChildren(returnFiber, child);
                      break;
                    }
                  } else {
                    deleteChild(returnFiber, child);
                  }
                  child = child.sibling;
                }
                var created = createFiberFromCall(
                  call,
                  returnFiber.internalContextTag,
                  expirationTime
                );
                created['return'] = returnFiber;
                return created;
              }
              function reconcileSingleReturn(
                returnFiber,
                currentFirstChild,
                returnNode,
                expirationTime
              ) {
                // There's no need to check for keys on yields since they're stateless.
                var child = currentFirstChild;
                if (child !== null) {
                  if (child.tag === ReturnComponent) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, null, expirationTime);
                    existing.type = returnNode.value;
                    existing['return'] = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                  }
                }
                var created = createFiberFromReturn(
                  returnNode,
                  returnFiber.internalContextTag,
                  expirationTime
                );
                created.type = returnNode.value;
                created['return'] = returnFiber;
                return created;
              }
              function reconcileSinglePortal(
                returnFiber,
                currentFirstChild,
                portal,
                expirationTime
              ) {
                var key = portal.key;
                var child = currentFirstChild;
                while (child !== null) {
                  // TODO: If key === null and child.key === null, then this only applies to
                  // the first item in the list.
                  if (child.key === key) {
                    if (
                      child.tag === HostPortal &&
                      child.stateNode.containerInfo === portal.containerInfo &&
                      child.stateNode.implementation === portal.implementation
                    ) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(
                        child,
                        portal.children || [],
                        expirationTime
                      );
                      existing['return'] = returnFiber;
                      return existing;
                    } else {
                      deleteRemainingChildren(returnFiber, child);
                      break;
                    }
                  } else {
                    deleteChild(returnFiber, child);
                  }
                  child = child.sibling;
                }
                var created = createFiberFromPortal(
                  portal,
                  returnFiber.internalContextTag,
                  expirationTime
                );
                created['return'] = returnFiber;
                return created;
              } // This API will tag the children with the side-effect of the reconciliation
              // itself. They will be added to the side-effect list as we pass through the
              // children and the parent.
              function reconcileChildFibers(
                returnFiber,
                currentFirstChild,
                newChild,
                expirationTime
              ) {
                // This function is not recursive.
                // If the top level item is an array, we treat it as a set of children,
                // not as a fragment. Nested arrays on the other hand will be treated as
                // fragment nodes. Recursion happens at the normal flow.
                // Handle top level unkeyed fragments as if they were arrays.
                // This leads to an ambiguity between <>{[...]}</> and <>...</>.
                // We treat the ambiguous cases above the same.
                if (
                  _typeof(newChild) === 'object' &&
                  newChild !== null &&
                  newChild.type === REACT_FRAGMENT_TYPE &&
                  newChild.key === null
                ) {
                  newChild = newChild.props.children;
                } // Handle object types
                var isObject =
                  _typeof(newChild) === 'object' && newChild !== null;
                if (isObject) {
                  switch (newChild.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                      return placeSingleChild(
                        reconcileSingleElement(
                          returnFiber,
                          currentFirstChild,
                          newChild,
                          expirationTime
                        )
                      );
                    case REACT_CALL_TYPE:
                      return placeSingleChild(
                        reconcileSingleCall(
                          returnFiber,
                          currentFirstChild,
                          newChild,
                          expirationTime
                        )
                      );
                    case REACT_RETURN_TYPE:
                      return placeSingleChild(
                        reconcileSingleReturn(
                          returnFiber,
                          currentFirstChild,
                          newChild,
                          expirationTime
                        )
                      );
                    case REACT_PORTAL_TYPE:
                      return placeSingleChild(
                        reconcileSinglePortal(
                          returnFiber,
                          currentFirstChild,
                          newChild,
                          expirationTime
                        )
                      );
                  }
                }
                if (
                  typeof newChild === 'string' ||
                  typeof newChild === 'number'
                ) {
                  return placeSingleChild(
                    reconcileSingleTextNode(
                      returnFiber,
                      currentFirstChild,
                      '' + newChild,
                      expirationTime
                    )
                  );
                }
                if (isArray$1(newChild)) {
                  return reconcileChildrenArray(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    expirationTime
                  );
                }
                if (getIteratorFn(newChild)) {
                  return reconcileChildrenIterator(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    expirationTime
                  );
                }
                if (isObject) {
                  throwOnInvalidObjectType(returnFiber, newChild);
                }
                {
                  if (typeof newChild === 'function') {
                    warnOnFunctionType();
                  }
                }
                if (typeof newChild === 'undefined') {
                  // If the new child is undefined, and the return fiber is a composite
                  // component, throw an error. If Fiber return types are disabled,
                  // we already threw above.
                  switch (returnFiber.tag) {
                    case ClassComponent: {
                      {
                        var instance = returnFiber.stateNode;
                        if (instance.render._isMockFunction) {
                          // We allow auto-mocks to proceed as if they're returning null.
                          break;
                        }
                      }
                    } // Intentionally fall through to the next case, which handles both
                    // functions and classes
                    // eslint-disable-next-lined no-fallthrough
                    case FunctionalComponent: {
                      var Component = returnFiber.type;
                      invariant(
                        false,
                        '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',
                        Component.displayName || Component.name || 'Component'
                      );
                    }
                  }
                } // Remaining cases are all treated as empty.
                return deleteRemainingChildren(returnFiber, currentFirstChild);
              }
              return reconcileChildFibers;
            }
            var reconcileChildFibers = ChildReconciler(true);
            var mountChildFibers = ChildReconciler(false);
            function cloneChildFibers(current, workInProgress) {
              !(current === null || workInProgress.child === current.child)
                ? invariant(false, 'Resuming work not yet implemented.')
                : void 0;
              if (workInProgress.child === null) {
                return;
              }
              var currentChild = workInProgress.child;
              var newChild = createWorkInProgress(
                currentChild,
                currentChild.pendingProps,
                currentChild.expirationTime
              );
              workInProgress.child = newChild;
              newChild['return'] = workInProgress;
              while (currentChild.sibling !== null) {
                currentChild = currentChild.sibling;
                newChild = newChild.sibling = createWorkInProgress(
                  currentChild,
                  currentChild.pendingProps,
                  currentChild.expirationTime
                );
                newChild['return'] = workInProgress;
              }
              newChild.sibling = null;
            }
            {
              var warnedAboutStatelessRefs = {};
            }
            var ReactFiberBeginWork = function ReactFiberBeginWork(
              config,
              hostContext,
              hydrationContext,
              scheduleWork,
              computeExpirationForFiber
            ) {
              var shouldSetTextContent = config.shouldSetTextContent,
                useSyncScheduling = config.useSyncScheduling,
                shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
              var pushHostContext = hostContext.pushHostContext,
                pushHostContainer = hostContext.pushHostContainer;
              var enterHydrationState = hydrationContext.enterHydrationState,
                resetHydrationState = hydrationContext.resetHydrationState,
                tryToClaimNextHydratableInstance =
                  hydrationContext.tryToClaimNextHydratableInstance;
              var _ReactFiberClassCompo = ReactFiberClassComponent(
                  scheduleWork,
                  computeExpirationForFiber,
                  memoizeProps,
                  memoizeState
                ),
                adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
                constructClassInstance =
                  _ReactFiberClassCompo.constructClassInstance,
                mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
                updateClassInstance = _ReactFiberClassCompo.updateClassInstance; // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.
              function reconcileChildren(
                current,
                workInProgress,
                nextChildren
              ) {
                reconcileChildrenAtExpirationTime(
                  current,
                  workInProgress,
                  nextChildren,
                  workInProgress.expirationTime
                );
              }
              function reconcileChildrenAtExpirationTime(
                current,
                workInProgress,
                nextChildren,
                renderExpirationTime
              ) {
                if (current === null) {
                  // If this is a fresh new component that hasn't been rendered yet, we
                  // won't update its child set by applying minimal side-effects. Instead,
                  // we will add them all to the child before it gets rendered. That means
                  // we can optimize this reconciliation pass by not tracking side-effects.
                  workInProgress.child = mountChildFibers(
                    workInProgress,
                    null,
                    nextChildren,
                    renderExpirationTime
                  );
                } else {
                  // If the current child is the same as the work in progress, it means that
                  // we haven't yet started any work on these children. Therefore, we use
                  // the clone algorithm to create a copy of all the current children.
                  // If we had any progressed work already, that is invalid at this point so
                  // let's throw it out.
                  workInProgress.child = reconcileChildFibers(
                    workInProgress,
                    current.child,
                    nextChildren,
                    renderExpirationTime
                  );
                }
              }
              function updateFragment(current, workInProgress) {
                var nextChildren = workInProgress.pendingProps;
                if (hasContextChanged()) {
                  // Normally we can bail out on props equality but if context has changed
                  // we don't do the bailout and we have to reuse existing props instead.
                  if (nextChildren === null) {
                    nextChildren = workInProgress.memoizedProps;
                  }
                } else if (
                  nextChildren === null ||
                  workInProgress.memoizedProps === nextChildren
                ) {
                  return bailoutOnAlreadyFinishedWork(current, workInProgress);
                }
                reconcileChildren(current, workInProgress, nextChildren);
                memoizeProps(workInProgress, nextChildren);
                return workInProgress.child;
              }
              function markRef(current, workInProgress) {
                var ref = workInProgress.ref;
                if (ref !== null && (!current || current.ref !== ref)) {
                  // Schedule a Ref effect
                  workInProgress.effectTag |= Ref;
                }
              }
              function updateFunctionalComponent(current, workInProgress) {
                var fn = workInProgress.type;
                var nextProps = workInProgress.pendingProps;
                var memoizedProps = workInProgress.memoizedProps;
                if (hasContextChanged()) {
                  // Normally we can bail out on props equality but if context has changed
                  // we don't do the bailout and we have to reuse existing props instead.
                  if (nextProps === null) {
                    nextProps = memoizedProps;
                  }
                } else {
                  if (nextProps === null || memoizedProps === nextProps) {
                    return bailoutOnAlreadyFinishedWork(
                      current,
                      workInProgress
                    );
                  } // TODO: consider bringing fn.shouldComponentUpdate() back.
                  // It used to be here.
                }
                var unmaskedContext = getUnmaskedContext(workInProgress);
                var context = getMaskedContext(workInProgress, unmaskedContext);
                var nextChildren;
                {
                  ReactCurrentOwner.current = workInProgress;
                  ReactDebugCurrentFiber.setCurrentPhase('render');
                  nextChildren = fn(nextProps, context);
                  ReactDebugCurrentFiber.setCurrentPhase(null);
                } // React DevTools reads this flag.
                workInProgress.effectTag |= PerformedWork;
                reconcileChildren(current, workInProgress, nextChildren);
                memoizeProps(workInProgress, nextProps);
                return workInProgress.child;
              }
              function updateClassComponent(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                // Push context providers early to prevent context stack mismatches.
                // During mounting we don't know the child context yet as the instance doesn't exist.
                // We will invalidate the child context in finishClassComponent() right after rendering.
                var hasContext = pushContextProvider(workInProgress);
                var shouldUpdate = void 0;
                if (current === null) {
                  if (!workInProgress.stateNode) {
                    // In the initial pass we might need to construct the instance.
                    constructClassInstance(
                      workInProgress,
                      workInProgress.pendingProps
                    );
                    mountClassInstance(workInProgress, renderExpirationTime);
                    shouldUpdate = true;
                  } else {
                    invariant(false, 'Resuming work not yet implemented.'); // In a resume, we'll already have an instance we can reuse.
                    // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
                  }
                } else {
                  shouldUpdate = updateClassInstance(
                    current,
                    workInProgress,
                    renderExpirationTime
                  );
                }
                return finishClassComponent(
                  current,
                  workInProgress,
                  shouldUpdate,
                  hasContext
                );
              }
              function finishClassComponent(
                current,
                workInProgress,
                shouldUpdate,
                hasContext
              ) {
                // Refs should update even if shouldComponentUpdate returns false
                markRef(current, workInProgress);
                if (!shouldUpdate) {
                  // Context providers should defer to sCU for rendering
                  if (hasContext) {
                    invalidateContextProvider(workInProgress, false);
                  }
                  return bailoutOnAlreadyFinishedWork(current, workInProgress);
                }
                var instance = workInProgress.stateNode; // Rerender
                ReactCurrentOwner.current = workInProgress;
                var nextChildren = void 0;
                {
                  ReactDebugCurrentFiber.setCurrentPhase('render');
                  nextChildren = instance.render();
                  if (debugRenderPhaseSideEffects) {
                    instance.render();
                  }
                  ReactDebugCurrentFiber.setCurrentPhase(null);
                } // React DevTools reads this flag.
                workInProgress.effectTag |= PerformedWork;
                reconcileChildren(current, workInProgress, nextChildren); // Memoize props and state using the values we just used to render.
                // TODO: Restructure so we never read values from the instance.
                memoizeState(workInProgress, instance.state);
                memoizeProps(workInProgress, instance.props); // The context might have changed so we need to recalculate it.
                if (hasContext) {
                  invalidateContextProvider(workInProgress, true);
                }
                return workInProgress.child;
              }
              function pushHostRootContext(workInProgress) {
                var root = workInProgress.stateNode;
                if (root.pendingContext) {
                  pushTopLevelContextObject(
                    workInProgress,
                    root.pendingContext,
                    root.pendingContext !== root.context
                  );
                } else if (root.context) {
                  // Should always be set
                  pushTopLevelContextObject(
                    workInProgress,
                    root.context,
                    false
                  );
                }
                pushHostContainer(workInProgress, root.containerInfo);
              }
              function updateHostRoot(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                pushHostRootContext(workInProgress);
                var updateQueue = workInProgress.updateQueue;
                if (updateQueue !== null) {
                  var prevState = workInProgress.memoizedState;
                  var state = processUpdateQueue(
                    current,
                    workInProgress,
                    updateQueue,
                    null,
                    null,
                    renderExpirationTime
                  );
                  if (prevState === state) {
                    // If the state is the same as before, that's a bailout because we had
                    // no work that expires at this time.
                    resetHydrationState();
                    return bailoutOnAlreadyFinishedWork(
                      current,
                      workInProgress
                    );
                  }
                  var element = state.element;
                  var root = workInProgress.stateNode;
                  if (
                    (current === null || current.child === null) &&
                    root.hydrate &&
                    enterHydrationState(workInProgress)
                  ) {
                    // If we don't have any current children this might be the first pass.
                    // We always try to hydrate. If this isn't a hydration pass there won't
                    // be any children to hydrate which is effectively the same thing as
                    // not hydrating.
                    // This is a bit of a hack. We track the host root as a placement to
                    // know that we're currently in a mounting state. That way isMounted
                    // works as expected. We must reset this before committing.
                    // TODO: Delete this when we delete isMounted and findDOMNode.
                    workInProgress.effectTag |= Placement; // Ensure that children mount into this root without tracking
                    // side-effects. This ensures that we don't store Placement effects on
                    // nodes that will be hydrated.
                    workInProgress.child = mountChildFibers(
                      workInProgress,
                      null,
                      element,
                      renderExpirationTime
                    );
                  } else {
                    // Otherwise reset hydration state in case we aborted and resumed another
                    // root.
                    resetHydrationState();
                    reconcileChildren(current, workInProgress, element);
                  }
                  memoizeState(workInProgress, state);
                  return workInProgress.child;
                }
                resetHydrationState(); // If there is no update queue, that's a bailout because the root has no props.
                return bailoutOnAlreadyFinishedWork(current, workInProgress);
              }
              function updateHostComponent(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                pushHostContext(workInProgress);
                if (current === null) {
                  tryToClaimNextHydratableInstance(workInProgress);
                }
                var type = workInProgress.type;
                var memoizedProps = workInProgress.memoizedProps;
                var nextProps = workInProgress.pendingProps;
                if (nextProps === null) {
                  nextProps = memoizedProps;
                  !(nextProps !== null)
                    ? invariant(
                        false,
                        'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'
                      )
                    : void 0;
                }
                var prevProps = current !== null ? current.memoizedProps : null;
                if (hasContextChanged()) {
                  // Normally we can bail out on props equality but if context has changed
                  // we don't do the bailout and we have to reuse existing props instead.
                } else if (nextProps === null || memoizedProps === nextProps) {
                  return bailoutOnAlreadyFinishedWork(current, workInProgress);
                }
                var nextChildren = nextProps.children;
                var isDirectTextChild = shouldSetTextContent(type, nextProps);
                if (isDirectTextChild) {
                  // We special case a direct text child of a host node. This is a common
                  // case. We won't handle it as a reified child. We will instead handle
                  // this in the host environment that also have access to this prop. That
                  // avoids allocating another HostText fiber and traversing it.
                  nextChildren = null;
                } else if (prevProps && shouldSetTextContent(type, prevProps)) {
                  // If we're switching from a direct text child to a normal child, or to
                  // empty, we need to schedule the text content to be reset.
                  workInProgress.effectTag |= ContentReset;
                }
                markRef(current, workInProgress); // Check the host config to see if the children are offscreen/hidden.
                if (
                  renderExpirationTime !== Never &&
                  !useSyncScheduling &&
                  shouldDeprioritizeSubtree(type, nextProps)
                ) {
                  // Down-prioritize the children.
                  workInProgress.expirationTime = Never; // Bailout and come back to this fiber later.
                  return null;
                }
                reconcileChildren(current, workInProgress, nextChildren);
                memoizeProps(workInProgress, nextProps);
                return workInProgress.child;
              }
              function updateHostText(current, workInProgress) {
                if (current === null) {
                  tryToClaimNextHydratableInstance(workInProgress);
                }
                var nextProps = workInProgress.pendingProps;
                if (nextProps === null) {
                  nextProps = workInProgress.memoizedProps;
                }
                memoizeProps(workInProgress, nextProps); // Nothing to do here. This is terminal. We'll do the completion step
                // immediately after.
                return null;
              }
              function mountIndeterminateComponent(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                !(current === null)
                  ? invariant(
                      false,
                      'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0;
                var fn = workInProgress.type;
                var props = workInProgress.pendingProps;
                var unmaskedContext = getUnmaskedContext(workInProgress);
                var context = getMaskedContext(workInProgress, unmaskedContext);
                var value;
                {
                  if (
                    fn.prototype &&
                    typeof fn.prototype.render === 'function'
                  ) {
                    var componentName = getComponentName(workInProgress);
                    warning(
                      false,
                      "The <%s /> component appears to have a render method, but doesn't extend React.Component. " +
                        'This is likely to cause errors. Change %s to extend React.Component instead.',
                      componentName,
                      componentName
                    );
                  }
                  ReactCurrentOwner.current = workInProgress;
                  value = fn(props, context);
                } // React DevTools reads this flag.
                workInProgress.effectTag |= PerformedWork;
                if (
                  _typeof(value) === 'object' &&
                  value !== null &&
                  typeof value.render === 'function'
                ) {
                  // Proceed under the assumption that this is a class instance
                  workInProgress.tag = ClassComponent; // Push context providers early to prevent context stack mismatches.
                  // During mounting we don't know the child context yet as the instance doesn't exist.
                  // We will invalidate the child context in finishClassComponent() right after rendering.
                  var hasContext = pushContextProvider(workInProgress);
                  adoptClassInstance(workInProgress, value);
                  mountClassInstance(workInProgress, renderExpirationTime);
                  return finishClassComponent(
                    current,
                    workInProgress,
                    true,
                    hasContext
                  );
                } else {
                  // Proceed under the assumption that this is a functional component
                  workInProgress.tag = FunctionalComponent;
                  {
                    var Component = workInProgress.type;
                    if (Component) {
                      warning(
                        !Component.childContextTypes,
                        '%s(...): childContextTypes cannot be defined on a functional component.',
                        Component.displayName || Component.name || 'Component'
                      );
                    }
                    if (workInProgress.ref !== null) {
                      var info = '';
                      var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();
                      if (ownerName) {
                        info +=
                          '\n\nCheck the render method of `' + ownerName + '`.';
                      }
                      var warningKey =
                        ownerName || workInProgress._debugID || '';
                      var debugSource = workInProgress._debugSource;
                      if (debugSource) {
                        warningKey =
                          debugSource.fileName + ':' + debugSource.lineNumber;
                      }
                      if (!warnedAboutStatelessRefs[warningKey]) {
                        warnedAboutStatelessRefs[warningKey] = true;
                        warning(
                          false,
                          'Stateless function components cannot be given refs. ' +
                            'Attempts to access this ref will fail.%s%s',
                          info,
                          ReactDebugCurrentFiber.getCurrentFiberStackAddendum()
                        );
                      }
                    }
                  }
                  reconcileChildren(current, workInProgress, value);
                  memoizeProps(workInProgress, props);
                  return workInProgress.child;
                }
              }
              function updateCallComponent(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                var nextCall = workInProgress.pendingProps;
                if (hasContextChanged()) {
                  // Normally we can bail out on props equality but if context has changed
                  // we don't do the bailout and we have to reuse existing props instead.
                  if (nextCall === null) {
                    nextCall = current && current.memoizedProps;
                    !(nextCall !== null)
                      ? invariant(
                          false,
                          'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'
                        )
                      : void 0;
                  }
                } else if (
                  nextCall === null ||
                  workInProgress.memoizedProps === nextCall
                ) {
                  nextCall = workInProgress.memoizedProps; // TODO: When bailing out, we might need to return the stateNode instead
                  // of the child. To check it for work.
                  // return bailoutOnAlreadyFinishedWork(current, workInProgress);
                }
                var nextChildren = nextCall.children; // The following is a fork of reconcileChildrenAtExpirationTime but using
                // stateNode to store the child.
                if (current === null) {
                  workInProgress.stateNode = mountChildFibers(
                    workInProgress,
                    workInProgress.stateNode,
                    nextChildren,
                    renderExpirationTime
                  );
                } else {
                  workInProgress.stateNode = reconcileChildFibers(
                    workInProgress,
                    workInProgress.stateNode,
                    nextChildren,
                    renderExpirationTime
                  );
                }
                memoizeProps(workInProgress, nextCall); // This doesn't take arbitrary time so we could synchronously just begin
                // eagerly do the work of workInProgress.child as an optimization.
                return workInProgress.stateNode;
              }
              function updatePortalComponent(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                pushHostContainer(
                  workInProgress,
                  workInProgress.stateNode.containerInfo
                );
                var nextChildren = workInProgress.pendingProps;
                if (hasContextChanged()) {
                  // Normally we can bail out on props equality but if context has changed
                  // we don't do the bailout and we have to reuse existing props instead.
                  if (nextChildren === null) {
                    nextChildren = current && current.memoizedProps;
                    !(nextChildren != null)
                      ? invariant(
                          false,
                          'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'
                        )
                      : void 0;
                  }
                } else if (
                  nextChildren === null ||
                  workInProgress.memoizedProps === nextChildren
                ) {
                  return bailoutOnAlreadyFinishedWork(current, workInProgress);
                }
                if (current === null) {
                  // Portals are special because we don't append the children during mount
                  // but at commit. Therefore we need to track insertions which the normal
                  // flow doesn't do during mount. This doesn't happen at the root because
                  // the root always starts with a "current" with a null child.
                  // TODO: Consider unifying this with how the root works.
                  workInProgress.child = reconcileChildFibers(
                    workInProgress,
                    null,
                    nextChildren,
                    renderExpirationTime
                  );
                  memoizeProps(workInProgress, nextChildren);
                } else {
                  reconcileChildren(current, workInProgress, nextChildren);
                  memoizeProps(workInProgress, nextChildren);
                }
                return workInProgress.child;
              }
              /*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */ function bailoutOnAlreadyFinishedWork(
                current,
                workInProgress
              ) {
                cancelWorkTimer(workInProgress); // TODO: We should ideally be able to bail out early if the children have no
                // more work to do. However, since we don't have a separation of this
                // Fiber's priority and its children yet - we don't know without doing lots
                // of the same work we do anyway. Once we have that separation we can just
                // bail out here if the children has no more work at this priority level.
                // if (workInProgress.priorityOfChildren <= priorityLevel) {
                //   // If there are side-effects in these children that have not yet been
                //   // committed we need to ensure that they get properly transferred up.
                //   if (current && current.child !== workInProgress.child) {
                //     reuseChildrenEffects(workInProgress, child);
                //   }
                //   return null;
                // }
                cloneChildFibers(current, workInProgress);
                return workInProgress.child;
              }
              function bailoutOnLowPriority(current, workInProgress) {
                cancelWorkTimer(workInProgress); // TODO: Handle HostComponent tags here as well and call pushHostContext()?
                // See PR 8590 discussion for context
                switch (workInProgress.tag) {
                  case HostRoot:
                    pushHostRootContext(workInProgress);
                    break;
                  case ClassComponent:
                    pushContextProvider(workInProgress);
                    break;
                  case HostPortal:
                    pushHostContainer(
                      workInProgress,
                      workInProgress.stateNode.containerInfo
                    );
                    break;
                } // TODO: What if this is currently in progress?
                // How can that happen? How is this not being cloned?
                return null;
              } // TODO: Delete memoizeProps/State and move to reconcile/bailout instead
              function memoizeProps(workInProgress, nextProps) {
                workInProgress.memoizedProps = nextProps;
              }
              function memoizeState(workInProgress, nextState) {
                workInProgress.memoizedState = nextState; // Don't reset the updateQueue, in case there are pending updates. Resetting
                // is handled by processUpdateQueue.
              }
              function beginWork(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                if (
                  workInProgress.expirationTime === NoWork ||
                  workInProgress.expirationTime > renderExpirationTime
                ) {
                  return bailoutOnLowPriority(current, workInProgress);
                }
                switch (workInProgress.tag) {
                  case IndeterminateComponent:
                    return mountIndeterminateComponent(
                      current,
                      workInProgress,
                      renderExpirationTime
                    );
                  case FunctionalComponent:
                    return updateFunctionalComponent(current, workInProgress);
                  case ClassComponent:
                    return updateClassComponent(
                      current,
                      workInProgress,
                      renderExpirationTime
                    );
                  case HostRoot:
                    return updateHostRoot(
                      current,
                      workInProgress,
                      renderExpirationTime
                    );
                  case HostComponent:
                    return updateHostComponent(
                      current,
                      workInProgress,
                      renderExpirationTime
                    );
                  case HostText:
                    return updateHostText(current, workInProgress);
                  case CallHandlerPhase: // This is a restart. Reset the tag to the initial phase.
                    workInProgress.tag = CallComponent; // Intentionally fall through since this is now the same.
                  case CallComponent:
                    return updateCallComponent(
                      current,
                      workInProgress,
                      renderExpirationTime
                    );
                  case ReturnComponent: // A return component is just a placeholder, we can just run through the
                    // next one immediately.
                    return null;
                  case HostPortal:
                    return updatePortalComponent(
                      current,
                      workInProgress,
                      renderExpirationTime
                    );
                  case Fragment:
                    return updateFragment(current, workInProgress);
                  default:
                    invariant(
                      false,
                      'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.'
                    );
                }
              }
              function beginFailedWork(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                // Push context providers here to avoid a push/pop context mismatch.
                switch (workInProgress.tag) {
                  case ClassComponent:
                    pushContextProvider(workInProgress);
                    break;
                  case HostRoot:
                    pushHostRootContext(workInProgress);
                    break;
                  default:
                    invariant(
                      false,
                      'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.'
                    );
                } // Add an error effect so we can handle the error during the commit phase
                workInProgress.effectTag |= Err; // This is a weird case where we do "resume" work  work that failed on
                // our first attempt. Because we no longer have a notion of "progressed
                // deletions," reset the child to the current child to make sure we delete
                // it again. TODO: Find a better way to handle this, perhaps during a more
                // general overhaul of error handling.
                if (current === null) {
                  workInProgress.child = null;
                } else if (workInProgress.child !== current.child) {
                  workInProgress.child = current.child;
                }
                if (
                  workInProgress.expirationTime === NoWork ||
                  workInProgress.expirationTime > renderExpirationTime
                ) {
                  return bailoutOnLowPriority(current, workInProgress);
                } // If we don't bail out, we're going be recomputing our children so we need
                // to drop our effect list.
                workInProgress.firstEffect = null;
                workInProgress.lastEffect = null; // Unmount the current children as if the component rendered null
                var nextChildren = null;
                reconcileChildrenAtExpirationTime(
                  current,
                  workInProgress,
                  nextChildren,
                  renderExpirationTime
                );
                if (workInProgress.tag === ClassComponent) {
                  var instance = workInProgress.stateNode;
                  workInProgress.memoizedProps = instance.props;
                  workInProgress.memoizedState = instance.state;
                }
                return workInProgress.child;
              }
              return { beginWork: beginWork, beginFailedWork: beginFailedWork };
            };
            var ReactFiberCompleteWork = function ReactFiberCompleteWork(
              config,
              hostContext,
              hydrationContext
            ) {
              var createInstance = config.createInstance,
                createTextInstance = config.createTextInstance,
                appendInitialChild = config.appendInitialChild,
                finalizeInitialChildren = config.finalizeInitialChildren,
                prepareUpdate = config.prepareUpdate,
                mutation = config.mutation,
                persistence = config.persistence;
              var getRootHostContainer = hostContext.getRootHostContainer,
                popHostContext = hostContext.popHostContext,
                getHostContext = hostContext.getHostContext,
                popHostContainer = hostContext.popHostContainer;
              var prepareToHydrateHostInstance =
                  hydrationContext.prepareToHydrateHostInstance,
                prepareToHydrateHostTextInstance =
                  hydrationContext.prepareToHydrateHostTextInstance,
                popHydrationState = hydrationContext.popHydrationState;
              function markUpdate(workInProgress) {
                // Tag the fiber with an update effect. This turns a Placement into
                // an UpdateAndPlacement.
                workInProgress.effectTag |= Update;
              }
              function markRef(workInProgress) {
                workInProgress.effectTag |= Ref;
              }
              function appendAllReturns(returns, workInProgress) {
                var node = workInProgress.stateNode;
                if (node) {
                  node['return'] = workInProgress;
                }
                while (node !== null) {
                  if (
                    node.tag === HostComponent ||
                    node.tag === HostText ||
                    node.tag === HostPortal
                  ) {
                    invariant(
                      false,
                      'A call cannot have host component children.'
                    );
                  } else if (node.tag === ReturnComponent) {
                    returns.push(node.type);
                  } else if (node.child !== null) {
                    node.child['return'] = node;
                    node = node.child;
                    continue;
                  }
                  while (node.sibling === null) {
                    if (
                      node['return'] === null ||
                      node['return'] === workInProgress
                    ) {
                      return;
                    }
                    node = node['return'];
                  }
                  node.sibling['return'] = node['return'];
                  node = node.sibling;
                }
              }
              function moveCallToHandlerPhase(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                var call = workInProgress.memoizedProps;
                !call
                  ? invariant(
                      false,
                      'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0; // First step of the call has completed. Now we need to do the second.
                // TODO: It would be nice to have a multi stage call represented by a
                // single component, or at least tail call optimize nested ones. Currently
                // that requires additional fields that we don't want to add to the fiber.
                // So this requires nested handlers.
                // Note: This doesn't mutate the alternate node. I don't think it needs to
                // since this stage is reset for every pass.
                workInProgress.tag = CallHandlerPhase; // Build up the returns.
                // TODO: Compare this to a generator or opaque helpers like Children.
                var returns = [];
                appendAllReturns(returns, workInProgress);
                var fn = call.handler;
                var props = call.props;
                var nextChildren = fn(props, returns);
                var currentFirstChild = current !== null ? current.child : null;
                workInProgress.child = reconcileChildFibers(
                  workInProgress,
                  currentFirstChild,
                  nextChildren,
                  renderExpirationTime
                );
                return workInProgress.child;
              }
              function appendAllChildren(parent, workInProgress) {
                // We only have the top Fiber that was created but we need recurse down its
                // children to find all the terminal nodes.
                var node = workInProgress.child;
                while (node !== null) {
                  if (node.tag === HostComponent || node.tag === HostText) {
                    appendInitialChild(parent, node.stateNode);
                  } else if (node.tag === HostPortal) {
                    // If we have a portal child, then we don't want to traverse
                    // down its children. Instead, we'll get insertions from each child in
                    // the portal directly.
                  } else if (node.child !== null) {
                    node.child['return'] = node;
                    node = node.child;
                    continue;
                  }
                  if (node === workInProgress) {
                    return;
                  }
                  while (node.sibling === null) {
                    if (
                      node['return'] === null ||
                      node['return'] === workInProgress
                    ) {
                      return;
                    }
                    node = node['return'];
                  }
                  node.sibling['return'] = node['return'];
                  node = node.sibling;
                }
              }
              var updateHostContainer = void 0;
              var updateHostComponent = void 0;
              var updateHostText = void 0;
              if (mutation) {
                if (enableMutatingReconciler) {
                  // Mutation mode
                  updateHostContainer = function updateHostContainer(
                    workInProgress
                  ) {
                    // Noop
                  };
                  updateHostComponent = function updateHostComponent(
                    current,
                    workInProgress,
                    updatePayload,
                    type,
                    oldProps,
                    newProps,
                    rootContainerInstance
                  ) {
                    // TODO: Type this specific to this type of component.
                    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
                    // is a new ref we mark this as an update. All the work is done in commitWork.
                    if (updatePayload) {
                      markUpdate(workInProgress);
                    }
                  };
                  updateHostText = function updateHostText(
                    current,
                    workInProgress,
                    oldText,
                    newText
                  ) {
                    // If the text differs, mark it as an update. All the work in done in commitWork.
                    if (oldText !== newText) {
                      markUpdate(workInProgress);
                    }
                  };
                } else {
                  invariant(false, 'Mutating reconciler is disabled.');
                }
              } else if (persistence) {
                if (enablePersistentReconciler) {
                  // Persistent host tree mode
                  var cloneInstance = persistence.cloneInstance,
                    createContainerChildSet =
                      persistence.createContainerChildSet,
                    appendChildToContainerChildSet =
                      persistence.appendChildToContainerChildSet,
                    finalizeContainerChildren =
                      persistence.finalizeContainerChildren; // An unfortunate fork of appendAllChildren because we have two different parent types.
                  var appendAllChildrenToContainer = function appendAllChildrenToContainer(
                    containerChildSet,
                    workInProgress
                  ) {
                    // We only have the top Fiber that was created but we need recurse down its
                    // children to find all the terminal nodes.
                    var node = workInProgress.child;
                    while (node !== null) {
                      if (node.tag === HostComponent || node.tag === HostText) {
                        appendChildToContainerChildSet(
                          containerChildSet,
                          node.stateNode
                        );
                      } else if (node.tag === HostPortal) {
                        // If we have a portal child, then we don't want to traverse
                        // down its children. Instead, we'll get insertions from each child in
                        // the portal directly.
                      } else if (node.child !== null) {
                        node.child['return'] = node;
                        node = node.child;
                        continue;
                      }
                      if (node === workInProgress) {
                        return;
                      }
                      while (node.sibling === null) {
                        if (
                          node['return'] === null ||
                          node['return'] === workInProgress
                        ) {
                          return;
                        }
                        node = node['return'];
                      }
                      node.sibling['return'] = node['return'];
                      node = node.sibling;
                    }
                  };
                  updateHostContainer = function updateHostContainer(
                    workInProgress
                  ) {
                    var portalOrRoot = workInProgress.stateNode;
                    var childrenUnchanged = workInProgress.firstEffect === null;
                    if (childrenUnchanged) {
                      // No changes, just reuse the existing instance.
                    } else {
                      var container = portalOrRoot.containerInfo;
                      var newChildSet = createContainerChildSet(container);
                      if (finalizeContainerChildren(container, newChildSet)) {
                        markUpdate(workInProgress);
                      }
                      portalOrRoot.pendingChildren = newChildSet; // If children might have changed, we have to add them all to the set.
                      appendAllChildrenToContainer(newChildSet, workInProgress); // Schedule an update on the container to swap out the container.
                      markUpdate(workInProgress);
                    }
                  };
                  updateHostComponent = function updateHostComponent(
                    current,
                    workInProgress,
                    updatePayload,
                    type,
                    oldProps,
                    newProps,
                    rootContainerInstance
                  ) {
                    // If there are no effects associated with this node, then none of our children had any updates.
                    // This guarantees that we can reuse all of them.
                    var childrenUnchanged = workInProgress.firstEffect === null;
                    var currentInstance = current.stateNode;
                    if (childrenUnchanged && updatePayload === null) {
                      // No changes, just reuse the existing instance.
                      // Note that this might release a previous clone.
                      workInProgress.stateNode = currentInstance;
                    } else {
                      var recyclableInstance = workInProgress.stateNode;
                      var newInstance = cloneInstance(
                        currentInstance,
                        updatePayload,
                        type,
                        oldProps,
                        newProps,
                        workInProgress,
                        childrenUnchanged,
                        recyclableInstance
                      );
                      if (
                        finalizeInitialChildren(
                          newInstance,
                          type,
                          newProps,
                          rootContainerInstance
                        )
                      ) {
                        markUpdate(workInProgress);
                      }
                      workInProgress.stateNode = newInstance;
                      if (childrenUnchanged) {
                        // If there are no other effects in this tree, we need to flag this node as having one.
                        // Even though we're not going to use it for anything.
                        // Otherwise parents won't know that there are new children to propagate upwards.
                        markUpdate(workInProgress);
                      } else {
                        // If children might have changed, we have to add them all to the set.
                        appendAllChildren(newInstance, workInProgress);
                      }
                    }
                  };
                  updateHostText = function updateHostText(
                    current,
                    workInProgress,
                    oldText,
                    newText
                  ) {
                    if (oldText !== newText) {
                      // If the text content differs, we'll create a new text instance for it.
                      var rootContainerInstance = getRootHostContainer();
                      var currentHostContext = getHostContext();
                      workInProgress.stateNode = createTextInstance(
                        newText,
                        rootContainerInstance,
                        currentHostContext,
                        workInProgress
                      ); // We'll have to mark it as having an effect, even though we won't use the effect for anything.
                      // This lets the parents know that at least one of their children has changed.
                      markUpdate(workInProgress);
                    }
                  };
                } else {
                  invariant(false, 'Persistent reconciler is disabled.');
                }
              } else {
                if (enableNoopReconciler) {
                  // No host operations
                  updateHostContainer = function updateHostContainer(
                    workInProgress
                  ) {
                    // Noop
                  };
                  updateHostComponent = function updateHostComponent(
                    current,
                    workInProgress,
                    updatePayload,
                    type,
                    oldProps,
                    newProps,
                    rootContainerInstance
                  ) {
                    // Noop
                  };
                  updateHostText = function updateHostText(
                    current,
                    workInProgress,
                    oldText,
                    newText
                  ) {
                    // Noop
                  };
                } else {
                  invariant(false, 'Noop reconciler is disabled.');
                }
              }
              function completeWork(
                current,
                workInProgress,
                renderExpirationTime
              ) {
                // Get the latest props.
                var newProps = workInProgress.pendingProps;
                if (newProps === null) {
                  newProps = workInProgress.memoizedProps;
                } else if (
                  workInProgress.expirationTime !== Never ||
                  renderExpirationTime === Never
                ) {
                  // Reset the pending props, unless this was a down-prioritization.
                  workInProgress.pendingProps = null;
                }
                switch (workInProgress.tag) {
                  case FunctionalComponent:
                    return null;
                  case ClassComponent: {
                    // We are leaving this subtree, so pop context if any.
                    popContextProvider(workInProgress);
                    return null;
                  }
                  case HostRoot: {
                    popHostContainer(workInProgress);
                    popTopLevelContextObject(workInProgress);
                    var fiberRoot = workInProgress.stateNode;
                    if (fiberRoot.pendingContext) {
                      fiberRoot.context = fiberRoot.pendingContext;
                      fiberRoot.pendingContext = null;
                    }
                    if (current === null || current.child === null) {
                      // If we hydrated, pop so that we can delete any remaining children
                      // that weren't hydrated.
                      popHydrationState(workInProgress); // This resets the hacky state to fix isMounted before committing.
                      // TODO: Delete this when we delete isMounted and findDOMNode.
                      workInProgress.effectTag &= ~Placement;
                    }
                    updateHostContainer(workInProgress);
                    return null;
                  }
                  case HostComponent: {
                    popHostContext(workInProgress);
                    var rootContainerInstance = getRootHostContainer();
                    var type = workInProgress.type;
                    if (current !== null && workInProgress.stateNode != null) {
                      // If we have an alternate, that means this is an update and we need to
                      // schedule a side-effect to do the updates.
                      var oldProps = current.memoizedProps; // If we get updated because one of our children updated, we don't
                      // have newProps so we'll have to reuse them.
                      // TODO: Split the update API as separate for the props vs. children.
                      // Even better would be if children weren't special cased at all tho.
                      var instance = workInProgress.stateNode;
                      var currentHostContext = getHostContext();
                      var updatePayload = prepareUpdate(
                        instance,
                        type,
                        oldProps,
                        newProps,
                        rootContainerInstance,
                        currentHostContext
                      );
                      updateHostComponent(
                        current,
                        workInProgress,
                        updatePayload,
                        type,
                        oldProps,
                        newProps,
                        rootContainerInstance
                      );
                      if (current.ref !== workInProgress.ref) {
                        markRef(workInProgress);
                      }
                    } else {
                      if (!newProps) {
                        !(workInProgress.stateNode !== null)
                          ? invariant(
                              false,
                              'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'
                            )
                          : void 0; // This can happen when we abort work.
                        return null;
                      }
                      var _currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context
                      // "stack" as the parent. Then append children as we go in beginWork
                      // or completeWork depending on we want to add then top->down or
                      // bottom->up. Top->down is faster in IE11.
                      var wasHydrated = popHydrationState(workInProgress);
                      if (wasHydrated) {
                        // TODO: Move this and createInstance step into the beginPhase
                        // to consolidate.
                        if (
                          prepareToHydrateHostInstance(
                            workInProgress,
                            rootContainerInstance,
                            _currentHostContext
                          )
                        ) {
                          // If changes to the hydrated node needs to be applied at the
                          // commit-phase we mark this as such.
                          markUpdate(workInProgress);
                        }
                      } else {
                        var _instance = createInstance(
                          type,
                          newProps,
                          rootContainerInstance,
                          _currentHostContext,
                          workInProgress
                        );
                        appendAllChildren(_instance, workInProgress); // Certain renderers require commit-time effects for initial mount.
                        // (eg DOM renderer supports auto-focus for certain elements).
                        // Make sure such renderers get scheduled for later work.
                        if (
                          finalizeInitialChildren(
                            _instance,
                            type,
                            newProps,
                            rootContainerInstance
                          )
                        ) {
                          markUpdate(workInProgress);
                        }
                        workInProgress.stateNode = _instance;
                      }
                      if (workInProgress.ref !== null) {
                        // If there is a ref on a host node we need to schedule a callback
                        markRef(workInProgress);
                      }
                    }
                    return null;
                  }
                  case HostText: {
                    var newText = newProps;
                    if (current && workInProgress.stateNode != null) {
                      var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need
                      // to schedule a side-effect to do the updates.
                      updateHostText(current, workInProgress, oldText, newText);
                    } else {
                      if (typeof newText !== 'string') {
                        !(workInProgress.stateNode !== null)
                          ? invariant(
                              false,
                              'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'
                            )
                          : void 0; // This can happen when we abort work.
                        return null;
                      }
                      var _rootContainerInstance = getRootHostContainer();
                      var _currentHostContext2 = getHostContext();
                      var _wasHydrated = popHydrationState(workInProgress);
                      if (_wasHydrated) {
                        if (prepareToHydrateHostTextInstance(workInProgress)) {
                          markUpdate(workInProgress);
                        }
                      } else {
                        workInProgress.stateNode = createTextInstance(
                          newText,
                          _rootContainerInstance,
                          _currentHostContext2,
                          workInProgress
                        );
                      }
                    }
                    return null;
                  }
                  case CallComponent:
                    return moveCallToHandlerPhase(
                      current,
                      workInProgress,
                      renderExpirationTime
                    );
                  case CallHandlerPhase: // Reset the tag to now be a first phase call.
                    workInProgress.tag = CallComponent;
                    return null;
                  case ReturnComponent: // Does nothing.
                    return null;
                  case Fragment:
                    return null;
                  case HostPortal:
                    popHostContainer(workInProgress);
                    updateHostContainer(workInProgress);
                    return null; // Error cases
                  case IndeterminateComponent:
                    invariant(
                      false,
                      'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.'
                    ); // eslint-disable-next-line no-fallthrough
                  default:
                    invariant(
                      false,
                      'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.'
                    );
                }
              }
              return { completeWork: completeWork };
            };
            var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
            var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
            var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;
            var ReactFiberCommitWork = function ReactFiberCommitWork(
              config,
              captureError
            ) {
              var getPublicInstance = config.getPublicInstance,
                mutation = config.mutation,
                persistence = config.persistence;
              var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(
                current,
                instance
              ) {
                startPhaseTimer(current, 'componentWillUnmount');
                instance.props = current.memoizedProps;
                instance.state = current.memoizedState;
                instance.componentWillUnmount();
                stopPhaseTimer();
              }; // Capture errors so they don't interrupt unmounting.
              function safelyCallComponentWillUnmount(current, instance) {
                {
                  invokeGuardedCallback$2(
                    null,
                    callComponentWillUnmountWithTimer,
                    null,
                    current,
                    instance
                  );
                  if (hasCaughtError$1()) {
                    var unmountError = clearCaughtError$1();
                    captureError(current, unmountError);
                  }
                }
              }
              function safelyDetachRef(current) {
                var ref = current.ref;
                if (ref !== null) {
                  {
                    invokeGuardedCallback$2(null, ref, null, null);
                    if (hasCaughtError$1()) {
                      var refError = clearCaughtError$1();
                      captureError(current, refError);
                    }
                  }
                }
              }
              function commitLifeCycles(current, finishedWork) {
                switch (finishedWork.tag) {
                  case ClassComponent: {
                    var instance = finishedWork.stateNode;
                    if (finishedWork.effectTag & Update) {
                      if (current === null) {
                        startPhaseTimer(finishedWork, 'componentDidMount');
                        instance.props = finishedWork.memoizedProps;
                        instance.state = finishedWork.memoizedState;
                        instance.componentDidMount();
                        stopPhaseTimer();
                      } else {
                        var prevProps = current.memoizedProps;
                        var prevState = current.memoizedState;
                        startPhaseTimer(finishedWork, 'componentDidUpdate');
                        instance.props = finishedWork.memoizedProps;
                        instance.state = finishedWork.memoizedState;
                        instance.componentDidUpdate(prevProps, prevState);
                        stopPhaseTimer();
                      }
                    }
                    var updateQueue = finishedWork.updateQueue;
                    if (updateQueue !== null) {
                      commitCallbacks(updateQueue, instance);
                    }
                    return;
                  }
                  case HostRoot: {
                    var _updateQueue = finishedWork.updateQueue;
                    if (_updateQueue !== null) {
                      var _instance =
                        finishedWork.child !== null
                          ? finishedWork.child.stateNode
                          : null;
                      commitCallbacks(_updateQueue, _instance);
                    }
                    return;
                  }
                  case HostComponent: {
                    var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted
                    // (eg DOM renderer may schedule auto-focus for inputs and form controls).
                    // These effects should only be committed when components are first mounted,
                    // aka when there is no current/alternate.
                    if (current === null && finishedWork.effectTag & Update) {
                      var type = finishedWork.type;
                      var props = finishedWork.memoizedProps;
                      commitMount(_instance2, type, props, finishedWork);
                    }
                    return;
                  }
                  case HostText: {
                    // We have no life-cycles associated with text.
                    return;
                  }
                  case HostPortal: {
                    // We have no life-cycles associated with portals.
                    return;
                  }
                  default: {
                    invariant(
                      false,
                      'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
                    );
                  }
                }
              }
              function commitAttachRef(finishedWork) {
                var ref = finishedWork.ref;
                if (ref !== null) {
                  var instance = finishedWork.stateNode;
                  switch (finishedWork.tag) {
                    case HostComponent:
                      ref(getPublicInstance(instance));
                      break;
                    default:
                      ref(instance);
                  }
                }
              }
              function commitDetachRef(current) {
                var currentRef = current.ref;
                if (currentRef !== null) {
                  currentRef(null);
                }
              } // User-originating errors (lifecycles and refs) should not interrupt
              // deletion, so don't let them throw. Host-originating errors should
              // interrupt deletion, so it's okay
              function commitUnmount(current) {
                if (typeof onCommitUnmount === 'function') {
                  onCommitUnmount(current);
                }
                switch (current.tag) {
                  case ClassComponent: {
                    safelyDetachRef(current);
                    var instance = current.stateNode;
                    if (typeof instance.componentWillUnmount === 'function') {
                      safelyCallComponentWillUnmount(current, instance);
                    }
                    return;
                  }
                  case HostComponent: {
                    safelyDetachRef(current);
                    return;
                  }
                  case CallComponent: {
                    commitNestedUnmounts(current.stateNode);
                    return;
                  }
                  case HostPortal: {
                    // TODO: this is recursive.
                    // We are also not using this parent because
                    // the portal will get pushed immediately.
                    if (enableMutatingReconciler && mutation) {
                      unmountHostComponents(current);
                    } else if (enablePersistentReconciler && persistence) {
                      emptyPortalContainer(current);
                    }
                    return;
                  }
                }
              }
              function commitNestedUnmounts(root) {
                // While we're inside a removed host node we don't want to call
                // removeChild on the inner nodes because they're removed by the top
                // call anyway. We also want to call componentWillUnmount on all
                // composites before this host node is removed from the tree. Therefore
                var node = root;
                while (true) {
                  commitUnmount(node); // Visit children because they may contain more composite or host nodes.
                  // Skip portals because commitUnmount() currently visits them recursively.
                  if (
                    node.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
                    // If we don't use mutation we drill down into portals here instead.
                    (!mutation || node.tag !== HostPortal)
                  ) {
                    node.child['return'] = node;
                    node = node.child;
                    continue;
                  }
                  if (node === root) {
                    return;
                  }
                  while (node.sibling === null) {
                    if (node['return'] === null || node['return'] === root) {
                      return;
                    }
                    node = node['return'];
                  }
                  node.sibling['return'] = node['return'];
                  node = node.sibling;
                }
              }
              function detachFiber(current) {
                // Cut off the return pointers to disconnect it from the tree. Ideally, we
                // should clear the child pointer of the parent alternate to let this
                // get GC:ed but we don't know which for sure which parent is the current
                // one so we'll settle for GC:ing the subtree of this child. This child
                // itself will be GC:ed when the parent updates the next time.
                current['return'] = null;
                current.child = null;
                if (current.alternate) {
                  current.alternate.child = null;
                  current.alternate['return'] = null;
                }
              }
              if (!mutation) {
                var commitContainer = void 0;
                if (persistence) {
                  var replaceContainerChildren =
                      persistence.replaceContainerChildren,
                    createContainerChildSet =
                      persistence.createContainerChildSet;
                  var emptyPortalContainer = function emptyPortalContainer(
                    current
                  ) {
                    var portal = current.stateNode;
                    var containerInfo = portal.containerInfo;
                    var emptyChildSet = createContainerChildSet(containerInfo);
                    replaceContainerChildren(containerInfo, emptyChildSet);
                  };
                  commitContainer = function commitContainer(finishedWork) {
                    switch (finishedWork.tag) {
                      case ClassComponent: {
                        return;
                      }
                      case HostComponent: {
                        return;
                      }
                      case HostText: {
                        return;
                      }
                      case HostRoot:
                      case HostPortal: {
                        var portalOrRoot = finishedWork.stateNode;
                        var containerInfo = portalOrRoot.containerInfo,
                          _pendingChildren = portalOrRoot.pendingChildren;
                        replaceContainerChildren(
                          containerInfo,
                          _pendingChildren
                        );
                        return;
                      }
                      default: {
                        invariant(
                          false,
                          'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
                        );
                      }
                    }
                  };
                } else {
                  commitContainer = function commitContainer(finishedWork) {
                    // Noop
                  };
                }
                if (enablePersistentReconciler || enableNoopReconciler) {
                  return {
                    commitResetTextContent: function commitResetTextContent(
                      finishedWork
                    ) {},
                    commitPlacement: function commitPlacement(finishedWork) {},
                    commitDeletion: function commitDeletion(current) {
                      // Detach refs and call componentWillUnmount() on the whole subtree.
                      commitNestedUnmounts(current);
                      detachFiber(current);
                    },
                    commitWork: function commitWork(current, finishedWork) {
                      commitContainer(finishedWork);
                    },
                    commitLifeCycles: commitLifeCycles,
                    commitAttachRef: commitAttachRef,
                    commitDetachRef: commitDetachRef
                  };
                } else if (persistence) {
                  invariant(false, 'Persistent reconciler is disabled.');
                } else {
                  invariant(false, 'Noop reconciler is disabled.');
                }
              }
              var commitMount = mutation.commitMount,
                commitUpdate = mutation.commitUpdate,
                resetTextContent = mutation.resetTextContent,
                commitTextUpdate = mutation.commitTextUpdate,
                appendChild = mutation.appendChild,
                appendChildToContainer = mutation.appendChildToContainer,
                insertBefore = mutation.insertBefore,
                insertInContainerBefore = mutation.insertInContainerBefore,
                removeChild = mutation.removeChild,
                removeChildFromContainer = mutation.removeChildFromContainer;
              function getHostParentFiber(fiber) {
                var parent = fiber['return'];
                while (parent !== null) {
                  if (isHostParent(parent)) {
                    return parent;
                  }
                  parent = parent['return'];
                }
                invariant(
                  false,
                  'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'
                );
              }
              function isHostParent(fiber) {
                return (
                  fiber.tag === HostComponent ||
                  fiber.tag === HostRoot ||
                  fiber.tag === HostPortal
                );
              }
              function getHostSibling(fiber) {
                // We're going to search forward into the tree until we find a sibling host
                // node. Unfortunately, if multiple insertions are done in a row we have to
                // search past them. This leads to exponential search for the next sibling.
                var node = fiber;
                siblings: while (true) {
                  // If we didn't find anything, let's try the next sibling.
                  while (node.sibling === null) {
                    if (
                      node['return'] === null ||
                      isHostParent(node['return'])
                    ) {
                      // If we pop out of the root or hit the parent the fiber we are the
                      // last sibling.
                      return null;
                    }
                    node = node['return'];
                  }
                  node.sibling['return'] = node['return'];
                  node = node.sibling;
                  while (node.tag !== HostComponent && node.tag !== HostText) {
                    // If it is not host node and, we might have a host node inside it.
                    // Try to search down until we find one.
                    if (node.effectTag & Placement) {
                      // If we don't have a child, try the siblings instead.
                      continue siblings;
                    } // If we don't have a child, try the siblings instead.
                    // We also skip portals because they are not part of this host tree.
                    if (node.child === null || node.tag === HostPortal) {
                      continue siblings;
                    } else {
                      node.child['return'] = node;
                      node = node.child;
                    }
                  } // Check if this host node is stable or about to be placed.
                  if (!(node.effectTag & Placement)) {
                    // Found it!
                    return node.stateNode;
                  }
                }
              }
              function commitPlacement(finishedWork) {
                // Recursively insert all host nodes into the parent.
                var parentFiber = getHostParentFiber(finishedWork);
                var parent = void 0;
                var isContainer = void 0;
                switch (parentFiber.tag) {
                  case HostComponent:
                    parent = parentFiber.stateNode;
                    isContainer = false;
                    break;
                  case HostRoot:
                    parent = parentFiber.stateNode.containerInfo;
                    isContainer = true;
                    break;
                  case HostPortal:
                    parent = parentFiber.stateNode.containerInfo;
                    isContainer = true;
                    break;
                  default:
                    invariant(
                      false,
                      'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.'
                    );
                }
                if (parentFiber.effectTag & ContentReset) {
                  // Reset the text content of the parent before doing any insertions
                  resetTextContent(parent); // Clear ContentReset from the effect tag
                  parentFiber.effectTag &= ~ContentReset;
                }
                var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need recurse down its
                // children to find all the terminal nodes.
                var node = finishedWork;
                while (true) {
                  if (node.tag === HostComponent || node.tag === HostText) {
                    if (before) {
                      if (isContainer) {
                        insertInContainerBefore(parent, node.stateNode, before);
                      } else {
                        insertBefore(parent, node.stateNode, before);
                      }
                    } else {
                      if (isContainer) {
                        appendChildToContainer(parent, node.stateNode);
                      } else {
                        appendChild(parent, node.stateNode);
                      }
                    }
                  } else if (node.tag === HostPortal) {
                    // If the insertion itself is a portal, then we don't want to traverse
                    // down its children. Instead, we'll get insertions from each child in
                    // the portal directly.
                  } else if (node.child !== null) {
                    node.child['return'] = node;
                    node = node.child;
                    continue;
                  }
                  if (node === finishedWork) {
                    return;
                  }
                  while (node.sibling === null) {
                    if (
                      node['return'] === null ||
                      node['return'] === finishedWork
                    ) {
                      return;
                    }
                    node = node['return'];
                  }
                  node.sibling['return'] = node['return'];
                  node = node.sibling;
                }
              }
              function unmountHostComponents(current) {
                // We only have the top Fiber that was inserted but we need recurse down its
                var node = current; // Each iteration, currentParent is populated with node's host parent if not
                // currentParentIsValid.
                var currentParentIsValid = false;
                var currentParent = void 0;
                var currentParentIsContainer = void 0;
                while (true) {
                  if (!currentParentIsValid) {
                    var parent = node['return'];
                    findParent: while (true) {
                      !(parent !== null)
                        ? invariant(
                            false,
                            'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'
                          )
                        : void 0;
                      switch (parent.tag) {
                        case HostComponent:
                          currentParent = parent.stateNode;
                          currentParentIsContainer = false;
                          break findParent;
                        case HostRoot:
                          currentParent = parent.stateNode.containerInfo;
                          currentParentIsContainer = true;
                          break findParent;
                        case HostPortal:
                          currentParent = parent.stateNode.containerInfo;
                          currentParentIsContainer = true;
                          break findParent;
                      }
                      parent = parent['return'];
                    }
                    currentParentIsValid = true;
                  }
                  if (node.tag === HostComponent || node.tag === HostText) {
                    commitNestedUnmounts(node); // After all the children have unmounted, it is now safe to remove the
                    // node from the tree.
                    if (currentParentIsContainer) {
                      removeChildFromContainer(currentParent, node.stateNode);
                    } else {
                      removeChild(currentParent, node.stateNode);
                    } // Don't visit children because we already visited them.
                  } else if (node.tag === HostPortal) {
                    // When we go into a portal, it becomes the parent to remove from.
                    // We will reassign it back when we pop the portal on the way up.
                    currentParent = node.stateNode.containerInfo; // Visit children because portals might contain host components.
                    if (node.child !== null) {
                      node.child['return'] = node;
                      node = node.child;
                      continue;
                    }
                  } else {
                    commitUnmount(node); // Visit children because we may find more host components below.
                    if (node.child !== null) {
                      node.child['return'] = node;
                      node = node.child;
                      continue;
                    }
                  }
                  if (node === current) {
                    return;
                  }
                  while (node.sibling === null) {
                    if (node['return'] === null || node['return'] === current) {
                      return;
                    }
                    node = node['return'];
                    if (node.tag === HostPortal) {
                      // When we go out of the portal, we need to restore the parent.
                      // Since we don't keep a stack of them, we will search for it.
                      currentParentIsValid = false;
                    }
                  }
                  node.sibling['return'] = node['return'];
                  node = node.sibling;
                }
              }
              function commitDeletion(current) {
                // Recursively delete all host nodes from the parent.
                // Detach refs and call componentWillUnmount() on the whole subtree.
                unmountHostComponents(current);
                detachFiber(current);
              }
              function commitWork(current, finishedWork) {
                switch (finishedWork.tag) {
                  case ClassComponent: {
                    return;
                  }
                  case HostComponent: {
                    var instance = finishedWork.stateNode;
                    if (instance != null) {
                      // Commit the work prepared earlier.
                      var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
                      // as the newProps. The updatePayload will contain the real change in
                      // this case.
                      var oldProps =
                        current !== null ? current.memoizedProps : newProps;
                      var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.
                      var updatePayload = finishedWork.updateQueue;
                      finishedWork.updateQueue = null;
                      if (updatePayload !== null) {
                        commitUpdate(
                          instance,
                          updatePayload,
                          type,
                          oldProps,
                          newProps,
                          finishedWork
                        );
                      }
                    }
                    return;
                  }
                  case HostText: {
                    !(finishedWork.stateNode !== null)
                      ? invariant(
                          false,
                          'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'
                        )
                      : void 0;
                    var textInstance = finishedWork.stateNode;
                    var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
                    // as the newProps. The updatePayload will contain the real change in
                    // this case.
                    var oldText =
                      current !== null ? current.memoizedProps : newText;
                    commitTextUpdate(textInstance, oldText, newText);
                    return;
                  }
                  case HostRoot: {
                    return;
                  }
                  default: {
                    invariant(
                      false,
                      'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.'
                    );
                  }
                }
              }
              function commitResetTextContent(current) {
                resetTextContent(current.stateNode);
              }
              if (enableMutatingReconciler) {
                return {
                  commitResetTextContent: commitResetTextContent,
                  commitPlacement: commitPlacement,
                  commitDeletion: commitDeletion,
                  commitWork: commitWork,
                  commitLifeCycles: commitLifeCycles,
                  commitAttachRef: commitAttachRef,
                  commitDetachRef: commitDetachRef
                };
              } else {
                invariant(false, 'Mutating reconciler is disabled.');
              }
            };
            var NO_CONTEXT = {};
            var ReactFiberHostContext = function ReactFiberHostContext(config) {
              var getChildHostContext = config.getChildHostContext,
                getRootHostContext = config.getRootHostContext;
              var contextStackCursor = createCursor(NO_CONTEXT);
              var contextFiberStackCursor = createCursor(NO_CONTEXT);
              var rootInstanceStackCursor = createCursor(NO_CONTEXT);
              function requiredContext(c) {
                !(c !== NO_CONTEXT)
                  ? invariant(
                      false,
                      'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0;
                return c;
              }
              function getRootHostContainer() {
                var rootInstance = requiredContext(
                  rootInstanceStackCursor.current
                );
                return rootInstance;
              }
              function pushHostContainer(fiber, nextRootInstance) {
                // Push current root instance onto the stack;
                // This allows us to reset root when portals are popped.
                push(rootInstanceStackCursor, nextRootInstance, fiber);
                var nextRootContext = getRootHostContext(nextRootInstance); // Track the context and the Fiber that provided it.
                // This enables us to pop only Fibers that provide unique contexts.
                push(contextFiberStackCursor, fiber, fiber);
                push(contextStackCursor, nextRootContext, fiber);
              }
              function popHostContainer(fiber) {
                pop(contextStackCursor, fiber);
                pop(contextFiberStackCursor, fiber);
                pop(rootInstanceStackCursor, fiber);
              }
              function getHostContext() {
                var context = requiredContext(contextStackCursor.current);
                return context;
              }
              function pushHostContext(fiber) {
                var rootInstance = requiredContext(
                  rootInstanceStackCursor.current
                );
                var context = requiredContext(contextStackCursor.current);
                var nextContext = getChildHostContext(
                  context,
                  fiber.type,
                  rootInstance
                ); // Don't push this Fiber's context unless it's unique.
                if (context === nextContext) {
                  return;
                } // Track the context and the Fiber that provided it.
                // This enables us to pop only Fibers that provide unique contexts.
                push(contextFiberStackCursor, fiber, fiber);
                push(contextStackCursor, nextContext, fiber);
              }
              function popHostContext(fiber) {
                // Do not pop unless this Fiber provided the current context.
                // pushHostContext() only pushes Fibers that provide unique contexts.
                if (contextFiberStackCursor.current !== fiber) {
                  return;
                }
                pop(contextStackCursor, fiber);
                pop(contextFiberStackCursor, fiber);
              }
              function resetHostContainer() {
                contextStackCursor.current = NO_CONTEXT;
                rootInstanceStackCursor.current = NO_CONTEXT;
              }
              return {
                getHostContext: getHostContext,
                getRootHostContainer: getRootHostContainer,
                popHostContainer: popHostContainer,
                popHostContext: popHostContext,
                pushHostContainer: pushHostContainer,
                pushHostContext: pushHostContext,
                resetHostContainer: resetHostContainer
              };
            };
            var ReactFiberHydrationContext = function ReactFiberHydrationContext(
              config
            ) {
              var shouldSetTextContent = config.shouldSetTextContent,
                hydration = config.hydration; // If this doesn't have hydration mode.
              if (!hydration) {
                return {
                  enterHydrationState: function enterHydrationState() {
                    return false;
                  },
                  resetHydrationState: function resetHydrationState() {},
                  tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {},
                  prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
                    invariant(
                      false,
                      'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.'
                    );
                  },
                  prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
                    invariant(
                      false,
                      'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.'
                    );
                  },
                  popHydrationState: function popHydrationState(fiber) {
                    return false;
                  }
                };
              }
              var canHydrateInstance = hydration.canHydrateInstance,
                canHydrateTextInstance = hydration.canHydrateTextInstance,
                getNextHydratableSibling = hydration.getNextHydratableSibling,
                getFirstHydratableChild = hydration.getFirstHydratableChild,
                hydrateInstance = hydration.hydrateInstance,
                hydrateTextInstance = hydration.hydrateTextInstance,
                didNotMatchHydratedContainerTextInstance =
                  hydration.didNotMatchHydratedContainerTextInstance,
                didNotMatchHydratedTextInstance =
                  hydration.didNotMatchHydratedTextInstance,
                didNotHydrateContainerInstance =
                  hydration.didNotHydrateContainerInstance,
                didNotHydrateInstance = hydration.didNotHydrateInstance,
                didNotFindHydratableContainerInstance =
                  hydration.didNotFindHydratableContainerInstance,
                didNotFindHydratableContainerTextInstance =
                  hydration.didNotFindHydratableContainerTextInstance,
                didNotFindHydratableInstance =
                  hydration.didNotFindHydratableInstance,
                didNotFindHydratableTextInstance =
                  hydration.didNotFindHydratableTextInstance; // The deepest Fiber on the stack involved in a hydration context.
              // This may have been an insertion or a hydration.
              var hydrationParentFiber = null;
              var nextHydratableInstance = null;
              var isHydrating = false;
              function enterHydrationState(fiber) {
                var parentInstance = fiber.stateNode.containerInfo;
                nextHydratableInstance = getFirstHydratableChild(
                  parentInstance
                );
                hydrationParentFiber = fiber;
                isHydrating = true;
                return true;
              }
              function deleteHydratableInstance(returnFiber, instance) {
                {
                  switch (returnFiber.tag) {
                    case HostRoot:
                      didNotHydrateContainerInstance(
                        returnFiber.stateNode.containerInfo,
                        instance
                      );
                      break;
                    case HostComponent:
                      didNotHydrateInstance(
                        returnFiber.type,
                        returnFiber.memoizedProps,
                        returnFiber.stateNode,
                        instance
                      );
                      break;
                  }
                }
                var childToDelete = createFiberFromHostInstanceForDeletion();
                childToDelete.stateNode = instance;
                childToDelete['return'] = returnFiber;
                childToDelete.effectTag = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,
                // these children are not part of the reconciliation list of children.
                // Even if we abort and rereconcile the children, that will try to hydrate
                // again and the nodes are still in the host tree so these will be
                // recreated.
                if (returnFiber.lastEffect !== null) {
                  returnFiber.lastEffect.nextEffect = childToDelete;
                  returnFiber.lastEffect = childToDelete;
                } else {
                  returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
                }
              }
              function insertNonHydratedInstance(returnFiber, fiber) {
                fiber.effectTag |= Placement;
                {
                  switch (returnFiber.tag) {
                    case HostRoot: {
                      var parentContainer = returnFiber.stateNode.containerInfo;
                      switch (fiber.tag) {
                        case HostComponent:
                          var type = fiber.type;
                          var props = fiber.pendingProps;
                          didNotFindHydratableContainerInstance(
                            parentContainer,
                            type,
                            props
                          );
                          break;
                        case HostText:
                          var text = fiber.pendingProps;
                          didNotFindHydratableContainerTextInstance(
                            parentContainer,
                            text
                          );
                          break;
                      }
                      break;
                    }
                    case HostComponent: {
                      var parentType = returnFiber.type;
                      var parentProps = returnFiber.memoizedProps;
                      var parentInstance = returnFiber.stateNode;
                      switch (fiber.tag) {
                        case HostComponent:
                          var _type = fiber.type;
                          var _props = fiber.pendingProps;
                          didNotFindHydratableInstance(
                            parentType,
                            parentProps,
                            parentInstance,
                            _type,
                            _props
                          );
                          break;
                        case HostText:
                          var _text = fiber.pendingProps;
                          didNotFindHydratableTextInstance(
                            parentType,
                            parentProps,
                            parentInstance,
                            _text
                          );
                          break;
                      }
                      break;
                    }
                    default:
                      return;
                  }
                }
              }
              function tryHydrate(fiber, nextInstance) {
                switch (fiber.tag) {
                  case HostComponent: {
                    var type = fiber.type;
                    var props = fiber.pendingProps;
                    var instance = canHydrateInstance(
                      nextInstance,
                      type,
                      props
                    );
                    if (instance !== null) {
                      fiber.stateNode = instance;
                      return true;
                    }
                    return false;
                  }
                  case HostText: {
                    var text = fiber.pendingProps;
                    var textInstance = canHydrateTextInstance(
                      nextInstance,
                      text
                    );
                    if (textInstance !== null) {
                      fiber.stateNode = textInstance;
                      return true;
                    }
                    return false;
                  }
                  default:
                    return false;
                }
              }
              function tryToClaimNextHydratableInstance(fiber) {
                if (!isHydrating) {
                  return;
                }
                var nextInstance = nextHydratableInstance;
                if (!nextInstance) {
                  // Nothing to hydrate. Make it an insertion.
                  insertNonHydratedInstance(hydrationParentFiber, fiber);
                  isHydrating = false;
                  hydrationParentFiber = fiber;
                  return;
                }
                if (!tryHydrate(fiber, nextInstance)) {
                  // If we can't hydrate this instance let's try the next one.
                  // We use this as a heuristic. It's based on intuition and not data so it
                  // might be flawed or unnecessary.
                  nextInstance = getNextHydratableSibling(nextInstance);
                  if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                    // Nothing to hydrate. Make it an insertion.
                    insertNonHydratedInstance(hydrationParentFiber, fiber);
                    isHydrating = false;
                    hydrationParentFiber = fiber;
                    return;
                  } // We matched the next one, we'll now assume that the first one was
                  // superfluous and we'll delete it. Since we can't eagerly delete it
                  // we'll have to schedule a deletion. To do that, this node needs a dummy
                  // fiber associated with it.
                  deleteHydratableInstance(
                    hydrationParentFiber,
                    nextHydratableInstance
                  );
                }
                hydrationParentFiber = fiber;
                nextHydratableInstance = getFirstHydratableChild(nextInstance);
              }
              function prepareToHydrateHostInstance(
                fiber,
                rootContainerInstance,
                hostContext
              ) {
                var instance = fiber.stateNode;
                var updatePayload = hydrateInstance(
                  instance,
                  fiber.type,
                  fiber.memoizedProps,
                  rootContainerInstance,
                  hostContext,
                  fiber
                ); // TODO: Type this specific to this type of component.
                fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
                // is a new ref we mark this as an update.
                if (updatePayload !== null) {
                  return true;
                }
                return false;
              }
              function prepareToHydrateHostTextInstance(fiber) {
                var textInstance = fiber.stateNode;
                var textContent = fiber.memoizedProps;
                var shouldUpdate = hydrateTextInstance(
                  textInstance,
                  textContent,
                  fiber
                );
                {
                  if (shouldUpdate) {
                    // We assume that prepareToHydrateHostTextInstance is called in a context where the
                    // hydration parent is the parent host component of this host text.
                    var returnFiber = hydrationParentFiber;
                    if (returnFiber !== null) {
                      switch (returnFiber.tag) {
                        case HostRoot: {
                          var parentContainer =
                            returnFiber.stateNode.containerInfo;
                          didNotMatchHydratedContainerTextInstance(
                            parentContainer,
                            textInstance,
                            textContent
                          );
                          break;
                        }
                        case HostComponent: {
                          var parentType = returnFiber.type;
                          var parentProps = returnFiber.memoizedProps;
                          var parentInstance = returnFiber.stateNode;
                          didNotMatchHydratedTextInstance(
                            parentType,
                            parentProps,
                            parentInstance,
                            textInstance,
                            textContent
                          );
                          break;
                        }
                      }
                    }
                  }
                }
                return shouldUpdate;
              }
              function popToNextHostParent(fiber) {
                var parent = fiber['return'];
                while (
                  parent !== null &&
                  parent.tag !== HostComponent &&
                  parent.tag !== HostRoot
                ) {
                  parent = parent['return'];
                }
                hydrationParentFiber = parent;
              }
              function popHydrationState(fiber) {
                if (fiber !== hydrationParentFiber) {
                  // We're deeper than the current hydration context, inside an inserted
                  // tree.
                  return false;
                }
                if (!isHydrating) {
                  // If we're not currently hydrating but we're in a hydration context, then
                  // we were an insertion and now need to pop up reenter hydration of our
                  // siblings.
                  popToNextHostParent(fiber);
                  isHydrating = true;
                  return false;
                }
                var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.
                // We only do this deeper than head and body since they tend to have random
                // other nodes in them. We also ignore components with pure text content in
                // side of them.
                // TODO: Better heuristic.
                if (
                  fiber.tag !== HostComponent ||
                  (type !== 'head' &&
                    type !== 'body' &&
                    !shouldSetTextContent(type, fiber.memoizedProps))
                ) {
                  var nextInstance = nextHydratableInstance;
                  while (nextInstance) {
                    deleteHydratableInstance(fiber, nextInstance);
                    nextInstance = getNextHydratableSibling(nextInstance);
                  }
                }
                popToNextHostParent(fiber);
                nextHydratableInstance = hydrationParentFiber
                  ? getNextHydratableSibling(fiber.stateNode)
                  : null;
                return true;
              }
              function resetHydrationState() {
                hydrationParentFiber = null;
                nextHydratableInstance = null;
                isHydrating = false;
              }
              return {
                enterHydrationState: enterHydrationState,
                resetHydrationState: resetHydrationState,
                tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
                prepareToHydrateHostInstance: prepareToHydrateHostInstance,
                prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
                popHydrationState: popHydrationState
              };
            }; // This lets us hook into Fiber to debug what it's doing.
            // See https://github.com/facebook/react/pull/8033.
            // This is not part of the public API, not even for React DevTools.
            // You may only inject a debugTool if you work on React Fiber itself.
            var ReactFiberInstrumentation = { debugTool: null };
            var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;
            var defaultShowDialog = function defaultShowDialog(capturedError) {
              return true;
            };
            var showDialog = defaultShowDialog;
            function logCapturedError(capturedError) {
              var logError = showDialog(capturedError); // Allow injected showDialog() to prevent default console.error logging.
              // This enables renderers like ReactNative to better manage redbox behavior.
              if (logError === false) {
                return;
              }
              var error = capturedError.error;
              var suppressLogging = error && error.suppressReactErrorLogging;
              if (suppressLogging) {
                return;
              }
              {
                var componentName = capturedError.componentName,
                  componentStack = capturedError.componentStack,
                  errorBoundaryName = capturedError.errorBoundaryName,
                  errorBoundaryFound = capturedError.errorBoundaryFound,
                  willRetry = capturedError.willRetry;
                var componentNameMessage = componentName
                  ? 'The above error occurred in the <' +
                    componentName +
                    '> component:'
                  : 'The above error occurred in one of your React components:';
                var errorBoundaryMessage = void 0; // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
                if (errorBoundaryFound && errorBoundaryName) {
                  if (willRetry) {
                    errorBoundaryMessage =
                      'React will try to recreate this component tree from scratch ' +
                      ('using the error boundary you provided, ' +
                        errorBoundaryName +
                        '.');
                  } else {
                    errorBoundaryMessage =
                      'This error was initially handled by the error boundary ' +
                      errorBoundaryName +
                      '.\n' +
                      'Recreating the tree from scratch failed so React will unmount the tree.';
                  }
                } else {
                  errorBoundaryMessage =
                    'Consider adding an error boundary to your tree to customize error handling behavior.\n' +
                    'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
                }
                var combinedMessage =
                  '' +
                  componentNameMessage +
                  componentStack +
                  '\n\n' +
                  ('' + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
                // We don't include the original error message and JS stack because the browser
                // has already printed it. Even if the application swallows the error, it is still
                // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
                console.error(combinedMessage);
              }
            }
            var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
            var hasCaughtError = ReactErrorUtils.hasCaughtError;
            var clearCaughtError = ReactErrorUtils.clearCaughtError;
            {
              var didWarnAboutStateTransition = false;
              var didWarnSetStateChildContext = false;
              var didWarnStateUpdateForUnmountedComponent = {};
              var warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(
                fiber
              ) {
                var componentName = getComponentName(fiber) || 'ReactClass';
                if (didWarnStateUpdateForUnmountedComponent[componentName]) {
                  return;
                }
                warning(
                  false,
                  'Can only update a mounted or mounting ' +
                    'component. This usually means you called setState, replaceState, ' +
                    'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease ' +
                    'check the code for the %s component.',
                  componentName
                );
                didWarnStateUpdateForUnmountedComponent[componentName] = true;
              };
              var warnAboutInvalidUpdates = function warnAboutInvalidUpdates(
                instance
              ) {
                switch (ReactDebugCurrentFiber.phase) {
                  case 'getChildContext':
                    if (didWarnSetStateChildContext) {
                      return;
                    }
                    warning(
                      false,
                      'setState(...): Cannot call setState() inside getChildContext()'
                    );
                    didWarnSetStateChildContext = true;
                    break;
                  case 'render':
                    if (didWarnAboutStateTransition) {
                      return;
                    }
                    warning(
                      false,
                      'Cannot update during an existing state transition (such as within ' +
                        "`render` or another component's constructor). Render methods should " +
                        'be a pure function of props and state; constructor side-effects are ' +
                        'an anti-pattern, but can be moved to `componentWillMount`.'
                    );
                    didWarnAboutStateTransition = true;
                    break;
                }
              };
            }
            var ReactFiberScheduler = function ReactFiberScheduler(config) {
              var hostContext = ReactFiberHostContext(config);
              var hydrationContext = ReactFiberHydrationContext(config);
              var popHostContainer = hostContext.popHostContainer,
                popHostContext = hostContext.popHostContext,
                resetHostContainer = hostContext.resetHostContainer;
              var _ReactFiberBeginWork = ReactFiberBeginWork(
                  config,
                  hostContext,
                  hydrationContext,
                  scheduleWork,
                  computeExpirationForFiber
                ),
                beginWork = _ReactFiberBeginWork.beginWork,
                beginFailedWork = _ReactFiberBeginWork.beginFailedWork;
              var _ReactFiberCompleteWo = ReactFiberCompleteWork(
                  config,
                  hostContext,
                  hydrationContext
                ),
                completeWork = _ReactFiberCompleteWo.completeWork;
              var _ReactFiberCommitWork = ReactFiberCommitWork(
                  config,
                  captureError
                ),
                commitResetTextContent =
                  _ReactFiberCommitWork.commitResetTextContent,
                commitPlacement = _ReactFiberCommitWork.commitPlacement,
                commitDeletion = _ReactFiberCommitWork.commitDeletion,
                commitWork = _ReactFiberCommitWork.commitWork,
                commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
                commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
                commitDetachRef = _ReactFiberCommitWork.commitDetachRef;
              var now = config.now,
                scheduleDeferredCallback = config.scheduleDeferredCallback,
                cancelDeferredCallback = config.cancelDeferredCallback,
                useSyncScheduling = config.useSyncScheduling,
                prepareForCommit = config.prepareForCommit,
                resetAfterCommit = config.resetAfterCommit; // Represents the current time in ms.
              var startTime = now();
              var mostRecentCurrentTime = msToExpirationTime(0); // Represents the expiration time that incoming updates should use. (If this
              // is NoWork, use the default strategy: async updates in async mode, sync
              // updates in sync mode.)
              var expirationContext = NoWork;
              var isWorking = false; // The next work in progress fiber that we're currently working on.
              var nextUnitOfWork = null;
              var nextRoot = null; // The time at which we're currently rendering work.
              var nextRenderExpirationTime = NoWork; // The next fiber with an effect that we're currently committing.
              var nextEffect = null; // Keep track of which fibers have captured an error that need to be handled.
              // Work is removed from this collection after componentDidCatch is called.
              var capturedErrors = null; // Keep track of which fibers have failed during the current batch of work.
              // This is a different set than capturedErrors, because it is not reset until
              // the end of the batch. This is needed to propagate errors correctly if a
              // subtree fails more than once.
              var failedBoundaries = null; // Error boundaries that captured an error during the current commit.
              var commitPhaseBoundaries = null;
              var firstUncaughtError = null;
              var didFatal = false;
              var isCommitting = false;
              var isUnmounting = false; // Used for performance tracking.
              var interruptedBy = null;
              function resetContextStack() {
                // Reset the stack
                reset$1(); // Reset the cursors
                resetContext();
                resetHostContainer();
              }
              function commitAllHostEffects() {
                while (nextEffect !== null) {
                  {
                    ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
                  }
                  recordEffect();
                  var effectTag = nextEffect.effectTag;
                  if (effectTag & ContentReset) {
                    commitResetTextContent(nextEffect);
                  }
                  if (effectTag & Ref) {
                    var current = nextEffect.alternate;
                    if (current !== null) {
                      commitDetachRef(current);
                    }
                  } // The following switch statement is only concerned about placement,
                  // updates, and deletions. To avoid needing to add a case for every
                  // possible bitmap value, we remove the secondary effects from the
                  // effect tag and switch on that value.
                  var primaryEffectTag =
                    effectTag &
                    ~(Callback | Err | ContentReset | Ref | PerformedWork);
                  switch (primaryEffectTag) {
                    case Placement: {
                      commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is inserted, before
                      // any life-cycles like componentDidMount gets called.
                      // TODO: findDOMNode doesn't rely on this any more but isMounted
                      // does and isMounted is deprecated anyway so we should be able
                      // to kill this.
                      nextEffect.effectTag &= ~Placement;
                      break;
                    }
                    case PlacementAndUpdate: {
                      // Placement
                      commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is inserted, before
                      // any life-cycles like componentDidMount gets called.
                      nextEffect.effectTag &= ~Placement; // Update
                      var _current = nextEffect.alternate;
                      commitWork(_current, nextEffect);
                      break;
                    }
                    case Update: {
                      var _current2 = nextEffect.alternate;
                      commitWork(_current2, nextEffect);
                      break;
                    }
                    case Deletion: {
                      isUnmounting = true;
                      commitDeletion(nextEffect);
                      isUnmounting = false;
                      break;
                    }
                  }
                  nextEffect = nextEffect.nextEffect;
                }
                {
                  ReactDebugCurrentFiber.resetCurrentFiber();
                }
              }
              function commitAllLifeCycles() {
                while (nextEffect !== null) {
                  var effectTag = nextEffect.effectTag;
                  if (effectTag & (Update | Callback)) {
                    recordEffect();
                    var current = nextEffect.alternate;
                    commitLifeCycles(current, nextEffect);
                  }
                  if (effectTag & Ref) {
                    recordEffect();
                    commitAttachRef(nextEffect);
                  }
                  if (effectTag & Err) {
                    recordEffect();
                    commitErrorHandling(nextEffect);
                  }
                  var next = nextEffect.nextEffect; // Ensure that we clean these up so that we don't accidentally keep them.
                  // I'm not actually sure this matters because we can't reset firstEffect
                  // and lastEffect since they're on every node, not just the effectful
                  // ones. So we have to clean everything as we reuse nodes anyway.
                  nextEffect.nextEffect = null; // Ensure that we reset the effectTag here so that we can rely on effect
                  // tags to reason about the current life-cycle.
                  nextEffect = next;
                }
              }
              function commitRoot(finishedWork) {
                // We keep track of this so that captureError can collect any boundaries
                // that capture an error during the commit phase. The reason these aren't
                // local to this function is because errors that occur during cWU are
                // captured elsewhere, to prevent the unmount from being interrupted.
                isWorking = true;
                isCommitting = true;
                startCommitTimer();
                var root = finishedWork.stateNode;
                !(root.current !== finishedWork)
                  ? invariant(
                      false,
                      'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0;
                root.isReadyForCommit = false; // Reset this to null before calling lifecycles
                ReactCurrentOwner.current = null;
                var firstEffect = void 0;
                if (finishedWork.effectTag > PerformedWork) {
                  // A fiber's effect list consists only of its children, not itself. So if
                  // the root has an effect, we need to add it to the end of the list. The
                  // resulting list is the set that would belong to the root's parent, if
                  // it had one; that is, all the effects in the tree including the root.
                  if (finishedWork.lastEffect !== null) {
                    finishedWork.lastEffect.nextEffect = finishedWork;
                    firstEffect = finishedWork.firstEffect;
                  } else {
                    firstEffect = finishedWork;
                  }
                } else {
                  // There is no effect on the root.
                  firstEffect = finishedWork.firstEffect;
                }
                prepareForCommit(); // Commit all the side-effects within a tree. We'll do this in two passes.
                // The first pass performs all the host insertions, updates, deletions and
                // ref unmounts.
                nextEffect = firstEffect;
                startCommitHostEffectsTimer();
                while (nextEffect !== null) {
                  var didError = false;
                  var _error = void 0;
                  {
                    invokeGuardedCallback$1(null, commitAllHostEffects, null);
                    if (hasCaughtError()) {
                      didError = true;
                      _error = clearCaughtError();
                    }
                  }
                  if (didError) {
                    !(nextEffect !== null)
                      ? invariant(
                          false,
                          'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'
                        )
                      : void 0;
                    captureError(nextEffect, _error); // Clean-up
                    if (nextEffect !== null) {
                      nextEffect = nextEffect.nextEffect;
                    }
                  }
                }
                stopCommitHostEffectsTimer();
                resetAfterCommit(); // The work-in-progress tree is now the current tree. This must come after
                // the first pass of the commit phase, so that the previous tree is still
                // current during componentWillUnmount, but before the second pass, so that
                // the finished work is current during componentDidMount/Update.
                root.current = finishedWork; // In the second pass we'll perform all life-cycles and ref callbacks.
                // Life-cycles happen as a separate pass so that all placements, updates,
                // and deletions in the entire tree have already been invoked.
                // This pass also triggers any renderer-specific initial effects.
                nextEffect = firstEffect;
                startCommitLifeCyclesTimer();
                while (nextEffect !== null) {
                  var _didError = false;
                  var _error2 = void 0;
                  {
                    invokeGuardedCallback$1(null, commitAllLifeCycles, null);
                    if (hasCaughtError()) {
                      _didError = true;
                      _error2 = clearCaughtError();
                    }
                  }
                  if (_didError) {
                    !(nextEffect !== null)
                      ? invariant(
                          false,
                          'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'
                        )
                      : void 0;
                    captureError(nextEffect, _error2);
                    if (nextEffect !== null) {
                      nextEffect = nextEffect.nextEffect;
                    }
                  }
                }
                isCommitting = false;
                isWorking = false;
                stopCommitLifeCyclesTimer();
                stopCommitTimer();
                if (typeof onCommitRoot === 'function') {
                  onCommitRoot(finishedWork.stateNode);
                }
                if (true && ReactFiberInstrumentation_1.debugTool) {
                  ReactFiberInstrumentation_1.debugTool.onCommitWork(
                    finishedWork
                  );
                } // If we caught any errors during this commit, schedule their boundaries
                // to update.
                if (commitPhaseBoundaries) {
                  commitPhaseBoundaries.forEach(scheduleErrorRecovery);
                  commitPhaseBoundaries = null;
                }
                if (firstUncaughtError !== null) {
                  var _error3 = firstUncaughtError;
                  firstUncaughtError = null;
                  onUncaughtError(_error3);
                }
                var remainingTime = root.current.expirationTime;
                if (remainingTime === NoWork) {
                  capturedErrors = null;
                  failedBoundaries = null;
                }
                return remainingTime;
              }
              function resetExpirationTime(workInProgress, renderTime) {
                if (
                  renderTime !== Never &&
                  workInProgress.expirationTime === Never
                ) {
                  // The children of this component are hidden. Don't bubble their
                  // expiration times.
                  return;
                } // Check for pending updates.
                var newExpirationTime = getUpdateExpirationTime(workInProgress); // TODO: Calls need to visit stateNode
                // Bubble up the earliest expiration time.
                var child = workInProgress.child;
                while (child !== null) {
                  if (
                    child.expirationTime !== NoWork &&
                    (newExpirationTime === NoWork ||
                      newExpirationTime > child.expirationTime)
                  ) {
                    newExpirationTime = child.expirationTime;
                  }
                  child = child.sibling;
                }
                workInProgress.expirationTime = newExpirationTime;
              }
              function completeUnitOfWork(workInProgress) {
                while (true) {
                  // The current, flushed, state of this fiber is the alternate.
                  // Ideally nothing should rely on this, but relying on it here
                  // means that we don't need an additional field on the work in
                  // progress.
                  var current = workInProgress.alternate;
                  {
                    ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
                  }
                  var next = completeWork(
                    current,
                    workInProgress,
                    nextRenderExpirationTime
                  );
                  {
                    ReactDebugCurrentFiber.resetCurrentFiber();
                  }
                  var returnFiber = workInProgress['return'];
                  var siblingFiber = workInProgress.sibling;
                  resetExpirationTime(workInProgress, nextRenderExpirationTime);
                  if (next !== null) {
                    stopWorkTimer(workInProgress);
                    if (true && ReactFiberInstrumentation_1.debugTool) {
                      ReactFiberInstrumentation_1.debugTool.onCompleteWork(
                        workInProgress
                      );
                    } // If completing this work spawned new work, do that next. We'll come
                    // back here again.
                    return next;
                  }
                  if (returnFiber !== null) {
                    // Append all the effects of the subtree and this fiber onto the effect
                    // list of the parent. The completion order of the children affects the
                    // side-effect order.
                    if (returnFiber.firstEffect === null) {
                      returnFiber.firstEffect = workInProgress.firstEffect;
                    }
                    if (workInProgress.lastEffect !== null) {
                      if (returnFiber.lastEffect !== null) {
                        returnFiber.lastEffect.nextEffect =
                          workInProgress.firstEffect;
                      }
                      returnFiber.lastEffect = workInProgress.lastEffect;
                    } // If this fiber had side-effects, we append it AFTER the children's
                    // side-effects. We can perform certain side-effects earlier if
                    // needed, by doing multiple passes over the effect list. We don't want
                    // to schedule our own side-effect on our own list because if end up
                    // reusing children we'll schedule this effect onto itself since we're
                    // at the end.
                    var effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect list.
                    // PerformedWork effect is read by React DevTools but shouldn't be committed.
                    if (effectTag > PerformedWork) {
                      if (returnFiber.lastEffect !== null) {
                        returnFiber.lastEffect.nextEffect = workInProgress;
                      } else {
                        returnFiber.firstEffect = workInProgress;
                      }
                      returnFiber.lastEffect = workInProgress;
                    }
                  }
                  stopWorkTimer(workInProgress);
                  if (true && ReactFiberInstrumentation_1.debugTool) {
                    ReactFiberInstrumentation_1.debugTool.onCompleteWork(
                      workInProgress
                    );
                  }
                  if (siblingFiber !== null) {
                    // If there is more work to do in this returnFiber, do that next.
                    return siblingFiber;
                  } else if (returnFiber !== null) {
                    // If there's no more work in this returnFiber. Complete the returnFiber.
                    workInProgress = returnFiber;
                    continue;
                  } else {
                    // We've reached the root.
                    var root = workInProgress.stateNode;
                    root.isReadyForCommit = true;
                    return null;
                  }
                } // Without this explicit null return Flow complains of invalid return type
                // TODO Remove the above while(true) loop
                // eslint-disable-next-line no-unreachable
                return null;
              }
              function performUnitOfWork(workInProgress) {
                // The current, flushed, state of this fiber is the alternate.
                // Ideally nothing should rely on this, but relying on it here
                // means that we don't need an additional field on the work in
                // progress.
                var current = workInProgress.alternate; // See if beginning this work spawns more work.
                startWorkTimer(workInProgress);
                {
                  ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
                }
                var next = beginWork(
                  current,
                  workInProgress,
                  nextRenderExpirationTime
                );
                {
                  ReactDebugCurrentFiber.resetCurrentFiber();
                }
                if (true && ReactFiberInstrumentation_1.debugTool) {
                  ReactFiberInstrumentation_1.debugTool.onBeginWork(
                    workInProgress
                  );
                }
                if (next === null) {
                  // If this doesn't spawn new work, complete the current work.
                  next = completeUnitOfWork(workInProgress);
                }
                ReactCurrentOwner.current = null;
                return next;
              }
              function performFailedUnitOfWork(workInProgress) {
                // The current, flushed, state of this fiber is the alternate.
                // Ideally nothing should rely on this, but relying on it here
                // means that we don't need an additional field on the work in
                // progress.
                var current = workInProgress.alternate; // See if beginning this work spawns more work.
                startWorkTimer(workInProgress);
                {
                  ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
                }
                var next = beginFailedWork(
                  current,
                  workInProgress,
                  nextRenderExpirationTime
                );
                {
                  ReactDebugCurrentFiber.resetCurrentFiber();
                }
                if (true && ReactFiberInstrumentation_1.debugTool) {
                  ReactFiberInstrumentation_1.debugTool.onBeginWork(
                    workInProgress
                  );
                }
                if (next === null) {
                  // If this doesn't spawn new work, complete the current work.
                  next = completeUnitOfWork(workInProgress);
                }
                ReactCurrentOwner.current = null;
                return next;
              }
              function workLoop(expirationTime) {
                if (capturedErrors !== null) {
                  // If there are unhandled errors, switch to the slow work loop.
                  // TODO: How to avoid this check in the fast path? Maybe the renderer
                  // could keep track of which roots have unhandled errors and call a
                  // forked version of renderRoot.
                  slowWorkLoopThatChecksForFailedWork(expirationTime);
                  return;
                }
                if (
                  nextRenderExpirationTime === NoWork ||
                  nextRenderExpirationTime > expirationTime
                ) {
                  return;
                }
                if (nextRenderExpirationTime <= mostRecentCurrentTime) {
                  // Flush all expired work.
                  while (nextUnitOfWork !== null) {
                    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
                  }
                } else {
                  // Flush asynchronous work until the deadline runs out of time.
                  while (nextUnitOfWork !== null && !shouldYield()) {
                    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
                  }
                }
              }
              function slowWorkLoopThatChecksForFailedWork(expirationTime) {
                if (
                  nextRenderExpirationTime === NoWork ||
                  nextRenderExpirationTime > expirationTime
                ) {
                  return;
                }
                if (nextRenderExpirationTime <= mostRecentCurrentTime) {
                  // Flush all expired work.
                  while (nextUnitOfWork !== null) {
                    if (hasCapturedError(nextUnitOfWork)) {
                      // Use a forked version of performUnitOfWork
                      nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
                    } else {
                      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
                    }
                  }
                } else {
                  // Flush asynchronous work until the deadline runs out of time.
                  while (nextUnitOfWork !== null && !shouldYield()) {
                    if (hasCapturedError(nextUnitOfWork)) {
                      // Use a forked version of performUnitOfWork
                      nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
                    } else {
                      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
                    }
                  }
                }
              }
              function renderRootCatchBlock(
                root,
                failedWork,
                boundary,
                expirationTime
              ) {
                // We're going to restart the error boundary that captured the error.
                // Conceptually, we're unwinding the stack. We need to unwind the
                // context stack, too.
                unwindContexts(failedWork, boundary); // Restart the error boundary using a forked version of
                // performUnitOfWork that deletes the boundary's children. The entire
                // failed subree will be unmounted. During the commit phase, a special
                // lifecycle method is called on the error boundary, which triggers
                // a re-render.
                nextUnitOfWork = performFailedUnitOfWork(boundary); // Continue working.
                workLoop(expirationTime);
              }
              function renderRoot(root, expirationTime) {
                !!isWorking
                  ? invariant(
                      false,
                      'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0;
                isWorking = true; // We're about to mutate the work-in-progress tree. If the root was pending
                // commit, it no longer is: we'll need to complete it again.
                root.isReadyForCommit = false; // Check if we're starting from a fresh stack, or if we're resuming from
                // previously yielded work.
                if (
                  root !== nextRoot ||
                  expirationTime !== nextRenderExpirationTime ||
                  nextUnitOfWork === null
                ) {
                  // Reset the stack and start working from the root.
                  resetContextStack();
                  nextRoot = root;
                  nextRenderExpirationTime = expirationTime;
                  nextUnitOfWork = createWorkInProgress(
                    nextRoot.current,
                    null,
                    expirationTime
                  );
                }
                startWorkLoopTimer(nextUnitOfWork);
                var didError = false;
                var error = null;
                {
                  invokeGuardedCallback$1(null, workLoop, null, expirationTime);
                  if (hasCaughtError()) {
                    didError = true;
                    error = clearCaughtError();
                  }
                } // An error was thrown during the render phase.
                while (didError) {
                  if (didFatal) {
                    // This was a fatal error. Don't attempt to recover from it.
                    firstUncaughtError = error;
                    break;
                  }
                  var failedWork = nextUnitOfWork;
                  if (failedWork === null) {
                    // An error was thrown but there's no current unit of work. This can
                    // happen during the commit phase if there's a bug in the renderer.
                    didFatal = true;
                    continue;
                  } // "Capture" the error by finding the nearest boundary. If there is no
                  // error boundary, we use the root.
                  var boundary = captureError(failedWork, error);
                  !(boundary !== null)
                    ? invariant(
                        false,
                        'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.'
                      )
                    : void 0;
                  if (didFatal) {
                    // The error we just captured was a fatal error. This happens
                    // when the error propagates to the root more than once.
                    continue;
                  }
                  didError = false;
                  error = null;
                  {
                    invokeGuardedCallback$1(
                      null,
                      renderRootCatchBlock,
                      null,
                      root,
                      failedWork,
                      boundary,
                      expirationTime
                    );
                    if (hasCaughtError()) {
                      didError = true;
                      error = clearCaughtError();
                      continue;
                    }
                  } // We're finished working. Exit the error loop.
                  break;
                }
                var uncaughtError = firstUncaughtError; // We're done performing work. Time to clean up.
                stopWorkLoopTimer(interruptedBy);
                interruptedBy = null;
                isWorking = false;
                didFatal = false;
                firstUncaughtError = null;
                if (uncaughtError !== null) {
                  onUncaughtError(uncaughtError);
                }
                return root.isReadyForCommit ? root.current.alternate : null;
              } // Returns the boundary that captured the error, or null if the error is ignored
              function captureError(failedWork, error) {
                // It is no longer valid because we exited the user code.
                ReactCurrentOwner.current = null;
                {
                  ReactDebugCurrentFiber.resetCurrentFiber();
                } // Search for the nearest error boundary.
                var boundary = null; // Passed to logCapturedError()
                var errorBoundaryFound = false;
                var willRetry = false;
                var errorBoundaryName = null; // Host containers are a special case. If the failed work itself is a host
                // container, then it acts as its own boundary. In all other cases, we
                // ignore the work itself and only search through the parents.
                if (failedWork.tag === HostRoot) {
                  boundary = failedWork;
                  if (isFailedBoundary(failedWork)) {
                    // If this root already failed, there must have been an error when
                    // attempting to unmount it. This is a worst-case scenario and
                    // should only be possible if there's a bug in the renderer.
                    didFatal = true;
                  }
                } else {
                  var node = failedWork['return'];
                  while (node !== null && boundary === null) {
                    if (node.tag === ClassComponent) {
                      var instance = node.stateNode;
                      if (typeof instance.componentDidCatch === 'function') {
                        errorBoundaryFound = true;
                        errorBoundaryName = getComponentName(node); // Found an error boundary!
                        boundary = node;
                        willRetry = true;
                      }
                    } else if (node.tag === HostRoot) {
                      // Treat the root like a no-op error boundary
                      boundary = node;
                    }
                    if (isFailedBoundary(node)) {
                      // This boundary is already in a failed state.
                      // If we're currently unmounting, that means this error was
                      // thrown while unmounting a failed subtree. We should ignore
                      // the error.
                      if (isUnmounting) {
                        return null;
                      } // If we're in the commit phase, we should check to see if
                      // this boundary already captured an error during this commit.
                      // This case exists because multiple errors can be thrown during
                      // a single commit without interruption.
                      if (
                        commitPhaseBoundaries !== null &&
                        (commitPhaseBoundaries.has(node) ||
                          (node.alternate !== null &&
                            commitPhaseBoundaries.has(node.alternate)))
                      ) {
                        // If so, we should ignore this error.
                        return null;
                      } // The error should propagate to the next boundary - we keep looking.
                      boundary = null;
                      willRetry = false;
                    }
                    node = node['return'];
                  }
                }
                if (boundary !== null) {
                  // Add to the collection of failed boundaries. This lets us know that
                  // subsequent errors in this subtree should propagate to the next boundary.
                  if (failedBoundaries === null) {
                    failedBoundaries = new Set();
                  }
                  failedBoundaries.add(boundary); // This method is unsafe outside of the begin and complete phases.
                  // We might be in the commit phase when an error is captured.
                  // The risk is that the return path from this Fiber may not be accurate.
                  // That risk is acceptable given the benefit of providing users more context.
                  var _componentStack = getStackAddendumByWorkInProgressFiber(
                    failedWork
                  );
                  var _componentName = getComponentName(failedWork); // Add to the collection of captured errors. This is stored as a global
                  // map of errors and their component stack location keyed by the boundaries
                  // that capture them. We mostly use this Map as a Set; it's a Map only to
                  // avoid adding a field to Fiber to store the error.
                  if (capturedErrors === null) {
                    capturedErrors = new Map();
                  }
                  var capturedError = {
                    componentName: _componentName,
                    componentStack: _componentStack,
                    error: error,
                    errorBoundary: errorBoundaryFound
                      ? boundary.stateNode
                      : null,
                    errorBoundaryFound: errorBoundaryFound,
                    errorBoundaryName: errorBoundaryName,
                    willRetry: willRetry
                  };
                  capturedErrors.set(boundary, capturedError);
                  try {
                    logCapturedError(capturedError);
                  } catch (e) {
                    // Prevent cycle if logCapturedError() throws.
                    // A cycle may still occur if logCapturedError renders a component that throws.
                    var suppressLogging = e && e.suppressReactErrorLogging;
                    if (!suppressLogging) {
                      console.error(e);
                    }
                  } // If we're in the commit phase, defer scheduling an update on the
                  // boundary until after the commit is complete
                  if (isCommitting) {
                    if (commitPhaseBoundaries === null) {
                      commitPhaseBoundaries = new Set();
                    }
                    commitPhaseBoundaries.add(boundary);
                  } else {
                    // Otherwise, schedule an update now.
                    // TODO: Is this actually necessary during the render phase? Is it
                    // possible to unwind and continue rendering at the same priority,
                    // without corrupting internal state?
                    scheduleErrorRecovery(boundary);
                  }
                  return boundary;
                } else if (firstUncaughtError === null) {
                  // If no boundary is found, we'll need to throw the error
                  firstUncaughtError = error;
                }
                return null;
              }
              function hasCapturedError(fiber) {
                // TODO: capturedErrors should store the boundary instance, to avoid needing
                // to check the alternate.
                return (
                  capturedErrors !== null &&
                  (capturedErrors.has(fiber) ||
                    (fiber.alternate !== null &&
                      capturedErrors.has(fiber.alternate)))
                );
              }
              function isFailedBoundary(fiber) {
                // TODO: failedBoundaries should store the boundary instance, to avoid
                // needing to check the alternate.
                return (
                  failedBoundaries !== null &&
                  (failedBoundaries.has(fiber) ||
                    (fiber.alternate !== null &&
                      failedBoundaries.has(fiber.alternate)))
                );
              }
              function commitErrorHandling(effectfulFiber) {
                var capturedError = void 0;
                if (capturedErrors !== null) {
                  capturedError = capturedErrors.get(effectfulFiber);
                  capturedErrors['delete'](effectfulFiber);
                  if (capturedError == null) {
                    if (effectfulFiber.alternate !== null) {
                      effectfulFiber = effectfulFiber.alternate;
                      capturedError = capturedErrors.get(effectfulFiber);
                      capturedErrors['delete'](effectfulFiber);
                    }
                  }
                }
                !(capturedError != null)
                  ? invariant(
                      false,
                      'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0;
                switch (effectfulFiber.tag) {
                  case ClassComponent:
                    var instance = effectfulFiber.stateNode;
                    var info = { componentStack: capturedError.componentStack }; // Allow the boundary to handle the error, usually by scheduling
                    // an update to itself
                    instance.componentDidCatch(capturedError.error, info);
                    return;
                  case HostRoot:
                    if (firstUncaughtError === null) {
                      firstUncaughtError = capturedError.error;
                    }
                    return;
                  default:
                    invariant(
                      false,
                      'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.'
                    );
                }
              }
              function unwindContexts(from, to) {
                var node = from;
                while (node !== null) {
                  switch (node.tag) {
                    case ClassComponent:
                      popContextProvider(node);
                      break;
                    case HostComponent:
                      popHostContext(node);
                      break;
                    case HostRoot:
                      popHostContainer(node);
                      break;
                    case HostPortal:
                      popHostContainer(node);
                      break;
                  }
                  if (node === to || node.alternate === to) {
                    stopFailedWorkTimer(node);
                    break;
                  } else {
                    stopWorkTimer(node);
                  }
                  node = node['return'];
                }
              }
              function computeAsyncExpiration() {
                // Given the current clock time, returns an expiration time. We use rounding
                // to batch like updates together.
                // Should complete within ~1000ms. 1200ms max.
                var currentTime = recalculateCurrentTime();
                var expirationMs = 1000;
                var bucketSizeMs = 200;
                return computeExpirationBucket(
                  currentTime,
                  expirationMs,
                  bucketSizeMs
                );
              }
              function computeExpirationForFiber(fiber) {
                var expirationTime = void 0;
                if (expirationContext !== NoWork) {
                  // An explicit expiration context was set;
                  expirationTime = expirationContext;
                } else if (isWorking) {
                  if (isCommitting) {
                    // Updates that occur during the commit phase should have sync priority
                    // by default.
                    expirationTime = Sync;
                  } else {
                    // Updates during the render phase should expire at the same time as
                    // the work that is being rendered.
                    expirationTime = nextRenderExpirationTime;
                  }
                } else {
                  // No explicit expiration context was set, and we're not currently
                  // performing work. Calculate a new expiration time.
                  if (
                    useSyncScheduling &&
                    !(fiber.internalContextTag & AsyncUpdates)
                  ) {
                    // This is a sync update
                    expirationTime = Sync;
                  } else {
                    // This is an async update
                    expirationTime = computeAsyncExpiration();
                  }
                }
                return expirationTime;
              }
              function scheduleWork(fiber, expirationTime) {
                return scheduleWorkImpl(fiber, expirationTime, false);
              }
              function checkRootNeedsClearing(root, fiber, expirationTime) {
                if (
                  !isWorking &&
                  root === nextRoot &&
                  expirationTime < nextRenderExpirationTime
                ) {
                  // Restart the root from the top.
                  if (nextUnitOfWork !== null) {
                    // This is an interruption. (Used for performance tracking.)
                    interruptedBy = fiber;
                  }
                  nextRoot = null;
                  nextUnitOfWork = null;
                  nextRenderExpirationTime = NoWork;
                }
              }
              function scheduleWorkImpl(
                fiber,
                expirationTime,
                isErrorRecovery
              ) {
                recordScheduleUpdate();
                {
                  if (!isErrorRecovery && fiber.tag === ClassComponent) {
                    var instance = fiber.stateNode;
                    warnAboutInvalidUpdates(instance);
                  }
                }
                var node = fiber;
                while (node !== null) {
                  // Walk the parent path to the root and update each node's
                  // expiration time.
                  if (
                    node.expirationTime === NoWork ||
                    node.expirationTime > expirationTime
                  ) {
                    node.expirationTime = expirationTime;
                  }
                  if (node.alternate !== null) {
                    if (
                      node.alternate.expirationTime === NoWork ||
                      node.alternate.expirationTime > expirationTime
                    ) {
                      node.alternate.expirationTime = expirationTime;
                    }
                  }
                  if (node['return'] === null) {
                    if (node.tag === HostRoot) {
                      var root = node.stateNode;
                      checkRootNeedsClearing(root, fiber, expirationTime);
                      requestWork(root, expirationTime);
                      checkRootNeedsClearing(root, fiber, expirationTime);
                    } else {
                      {
                        if (!isErrorRecovery && fiber.tag === ClassComponent) {
                          warnAboutUpdateOnUnmounted(fiber);
                        }
                      }
                      return;
                    }
                  }
                  node = node['return'];
                }
              }
              function scheduleErrorRecovery(fiber) {
                scheduleWorkImpl(fiber, Sync, true);
              }
              function recalculateCurrentTime() {
                // Subtract initial time so it fits inside 32bits
                var ms = now() - startTime;
                mostRecentCurrentTime = msToExpirationTime(ms);
                return mostRecentCurrentTime;
              }
              function deferredUpdates(fn) {
                var previousExpirationContext = expirationContext;
                expirationContext = computeAsyncExpiration();
                try {
                  return fn();
                } finally {
                  expirationContext = previousExpirationContext;
                }
              }
              function syncUpdates(fn) {
                var previousExpirationContext = expirationContext;
                expirationContext = Sync;
                try {
                  return fn();
                } finally {
                  expirationContext = previousExpirationContext;
                }
              } // TODO: Everything below this is written as if it has been lifted to the
              // renderers. I'll do this in a follow-up.
              // Linked-list of roots
              var firstScheduledRoot = null;
              var lastScheduledRoot = null;
              var callbackExpirationTime = NoWork;
              var callbackID = -1;
              var isRendering = false;
              var nextFlushedRoot = null;
              var nextFlushedExpirationTime = NoWork;
              var deadlineDidExpire = false;
              var hasUnhandledError = false;
              var unhandledError = null;
              var deadline = null;
              var isBatchingUpdates = false;
              var isUnbatchingUpdates = false; // Use these to prevent an infinite loop of nested updates
              var NESTED_UPDATE_LIMIT = 1000;
              var nestedUpdateCount = 0;
              var timeHeuristicForUnitOfWork = 1;
              function scheduleCallbackWithExpiration(expirationTime) {
                if (callbackExpirationTime !== NoWork) {
                  // A callback is already scheduled. Check its expiration time (timeout).
                  if (expirationTime > callbackExpirationTime) {
                    // Existing callback has sufficient timeout. Exit.
                    return;
                  } else {
                    // Existing callback has insufficient timeout. Cancel and schedule a
                    // new one.
                    cancelDeferredCallback(callbackID);
                  } // The request callback timer is already running. Don't start a new one.
                } else {
                  startRequestCallbackTimer();
                } // Compute a timeout for the given expiration time.
                var currentMs = now() - startTime;
                var expirationMs = expirationTimeToMs(expirationTime);
                var timeout = expirationMs - currentMs;
                callbackExpirationTime = expirationTime;
                callbackID = scheduleDeferredCallback(performAsyncWork, {
                  timeout: timeout
                });
              } // requestWork is called by the scheduler whenever a root receives an update.
              // It's up to the renderer to call renderRoot at some point in the future.
              function requestWork(root, expirationTime) {
                if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
                  invariant(
                    false,
                    'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.'
                  );
                } // Add the root to the schedule.
                // Check if this root is already part of the schedule.
                if (root.nextScheduledRoot === null) {
                  // This root is not already scheduled. Add it.
                  root.remainingExpirationTime = expirationTime;
                  if (lastScheduledRoot === null) {
                    firstScheduledRoot = lastScheduledRoot = root;
                    root.nextScheduledRoot = root;
                  } else {
                    lastScheduledRoot.nextScheduledRoot = root;
                    lastScheduledRoot = root;
                    lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                  }
                } else {
                  // This root is already scheduled, but its priority may have increased.
                  var remainingExpirationTime = root.remainingExpirationTime;
                  if (
                    remainingExpirationTime === NoWork ||
                    expirationTime < remainingExpirationTime
                  ) {
                    // Update the priority.
                    root.remainingExpirationTime = expirationTime;
                  }
                }
                if (isRendering) {
                  // Prevent reentrancy. Remaining work will be scheduled at the end of
                  // the currently rendering batch.
                  return;
                }
                if (isBatchingUpdates) {
                  // Flush work at the end of the batch.
                  if (isUnbatchingUpdates) {
                    // ...unless we're inside unbatchedUpdates, in which case we should
                    // flush it now.
                    nextFlushedRoot = root;
                    nextFlushedExpirationTime = Sync;
                    performWorkOnRoot(
                      nextFlushedRoot,
                      nextFlushedExpirationTime
                    );
                  }
                  return;
                } // TODO: Get rid of Sync and use current time?
                if (expirationTime === Sync) {
                  performWork(Sync, null);
                } else {
                  scheduleCallbackWithExpiration(expirationTime);
                }
              }
              function findHighestPriorityRoot() {
                var highestPriorityWork = NoWork;
                var highestPriorityRoot = null;
                if (lastScheduledRoot !== null) {
                  var previousScheduledRoot = lastScheduledRoot;
                  var root = firstScheduledRoot;
                  while (root !== null) {
                    var remainingExpirationTime = root.remainingExpirationTime;
                    if (remainingExpirationTime === NoWork) {
                      // This root no longer has work. Remove it from the scheduler.
                      // TODO: This check is redudant, but Flow is confused by the branch
                      // below where we set lastScheduledRoot to null, even though we break
                      // from the loop right after.
                      !(
                        previousScheduledRoot !== null &&
                        lastScheduledRoot !== null
                      )
                        ? invariant(
                            false,
                            'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'
                          )
                        : void 0;
                      if (root === root.nextScheduledRoot) {
                        // This is the only root in the list.
                        root.nextScheduledRoot = null;
                        firstScheduledRoot = lastScheduledRoot = null;
                        break;
                      } else if (root === firstScheduledRoot) {
                        // This is the first root in the list.
                        var next = root.nextScheduledRoot;
                        firstScheduledRoot = next;
                        lastScheduledRoot.nextScheduledRoot = next;
                        root.nextScheduledRoot = null;
                      } else if (root === lastScheduledRoot) {
                        // This is the last root in the list.
                        lastScheduledRoot = previousScheduledRoot;
                        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                        root.nextScheduledRoot = null;
                        break;
                      } else {
                        previousScheduledRoot.nextScheduledRoot =
                          root.nextScheduledRoot;
                        root.nextScheduledRoot = null;
                      }
                      root = previousScheduledRoot.nextScheduledRoot;
                    } else {
                      if (
                        highestPriorityWork === NoWork ||
                        remainingExpirationTime < highestPriorityWork
                      ) {
                        // Update the priority, if it's higher
                        highestPriorityWork = remainingExpirationTime;
                        highestPriorityRoot = root;
                      }
                      if (root === lastScheduledRoot) {
                        break;
                      }
                      previousScheduledRoot = root;
                      root = root.nextScheduledRoot;
                    }
                  }
                } // If the next root is the same as the previous root, this is a nested
                // update. To prevent an infinite loop, increment the nested update count.
                var previousFlushedRoot = nextFlushedRoot;
                if (
                  previousFlushedRoot !== null &&
                  previousFlushedRoot === highestPriorityRoot
                ) {
                  nestedUpdateCount++;
                } else {
                  // Reset whenever we switch roots.
                  nestedUpdateCount = 0;
                }
                nextFlushedRoot = highestPriorityRoot;
                nextFlushedExpirationTime = highestPriorityWork;
              }
              function performAsyncWork(dl) {
                performWork(NoWork, dl);
              }
              function performWork(minExpirationTime, dl) {
                deadline = dl; // Keep working on roots until there's no more work, or until the we reach
                // the deadline.
                findHighestPriorityRoot();
                if (enableUserTimingAPI && deadline !== null) {
                  var didExpire =
                    nextFlushedExpirationTime < recalculateCurrentTime();
                  stopRequestCallbackTimer(didExpire);
                }
                while (
                  nextFlushedRoot !== null &&
                  nextFlushedExpirationTime !== NoWork &&
                  (minExpirationTime === NoWork ||
                    nextFlushedExpirationTime <= minExpirationTime) &&
                  !deadlineDidExpire
                ) {
                  performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime); // Find the next highest priority work.
                  findHighestPriorityRoot();
                } // We're done flushing work. Either we ran out of time in this callback,
                // or there's no more work left with sufficient priority.
                // If we're inside a callback, set this to false since we just completed it.
                if (deadline !== null) {
                  callbackExpirationTime = NoWork;
                  callbackID = -1;
                } // If there's work left over, schedule a new callback.
                if (nextFlushedExpirationTime !== NoWork) {
                  scheduleCallbackWithExpiration(nextFlushedExpirationTime);
                } // Clean-up.
                deadline = null;
                deadlineDidExpire = false;
                nestedUpdateCount = 0;
                if (hasUnhandledError) {
                  var _error4 = unhandledError;
                  unhandledError = null;
                  hasUnhandledError = false;
                  throw _error4;
                }
              }
              function performWorkOnRoot(root, expirationTime) {
                !!isRendering
                  ? invariant(
                      false,
                      'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0;
                isRendering = true; // Check if this is async work or sync/expired work.
                // TODO: Pass current time as argument to renderRoot, commitRoot
                if (expirationTime <= recalculateCurrentTime()) {
                  // Flush sync work.
                  var finishedWork = root.finishedWork;
                  if (finishedWork !== null) {
                    // This root is already complete. We can commit it.
                    root.finishedWork = null;
                    root.remainingExpirationTime = commitRoot(finishedWork);
                  } else {
                    root.finishedWork = null;
                    finishedWork = renderRoot(root, expirationTime);
                    if (finishedWork !== null) {
                      // We've completed the root. Commit it.
                      root.remainingExpirationTime = commitRoot(finishedWork);
                    }
                  }
                } else {
                  // Flush async work.
                  var _finishedWork = root.finishedWork;
                  if (_finishedWork !== null) {
                    // This root is already complete. We can commit it.
                    root.finishedWork = null;
                    root.remainingExpirationTime = commitRoot(_finishedWork);
                  } else {
                    root.finishedWork = null;
                    _finishedWork = renderRoot(root, expirationTime);
                    if (_finishedWork !== null) {
                      // We've completed the root. Check the deadline one more time
                      // before committing.
                      if (!shouldYield()) {
                        // Still time left. Commit the root.
                        root.remainingExpirationTime = commitRoot(
                          _finishedWork
                        );
                      } else {
                        // There's no time left. Mark this root as complete. We'll come
                        // back and commit it later.
                        root.finishedWork = _finishedWork;
                      }
                    }
                  }
                }
                isRendering = false;
              } // When working on async work, the reconciler asks the renderer if it should
              // yield execution. For DOM, we implement this with requestIdleCallback.
              function shouldYield() {
                if (deadline === null) {
                  return false;
                }
                if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
                  // Disregard deadline.didTimeout. Only expired work should be flushed
                  // during a timeout. This path is only hit for non-expired work.
                  return false;
                }
                deadlineDidExpire = true;
                return true;
              } // TODO: Not happy about this hook. Conceptually, renderRoot should return a
              // tuple of (isReadyForCommit, didError, error)
              function onUncaughtError(error) {
                !(nextFlushedRoot !== null)
                  ? invariant(
                      false,
                      'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'
                    )
                  : void 0; // Unschedule this root so we don't work on it again until there's
                // another update.
                nextFlushedRoot.remainingExpirationTime = NoWork;
                if (!hasUnhandledError) {
                  hasUnhandledError = true;
                  unhandledError = error;
                }
              } // TODO: Batching should be implemented at the renderer level, not inside
              // the reconciler.
              function batchedUpdates(fn, a) {
                var previousIsBatchingUpdates = isBatchingUpdates;
                isBatchingUpdates = true;
                try {
                  return fn(a);
                } finally {
                  isBatchingUpdates = previousIsBatchingUpdates;
                  if (!isBatchingUpdates && !isRendering) {
                    performWork(Sync, null);
                  }
                }
              } // TODO: Batching should be implemented at the renderer level, not inside
              // the reconciler.
              function unbatchedUpdates(fn) {
                if (isBatchingUpdates && !isUnbatchingUpdates) {
                  isUnbatchingUpdates = true;
                  try {
                    return fn();
                  } finally {
                    isUnbatchingUpdates = false;
                  }
                }
                return fn();
              } // TODO: Batching should be implemented at the renderer level, not within
              // the reconciler.
              function flushSync(fn) {
                var previousIsBatchingUpdates = isBatchingUpdates;
                isBatchingUpdates = true;
                try {
                  return syncUpdates(fn);
                } finally {
                  isBatchingUpdates = previousIsBatchingUpdates;
                  !!isRendering
                    ? invariant(
                        false,
                        'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'
                      )
                    : void 0;
                  performWork(Sync, null);
                }
              }
              return {
                computeAsyncExpiration: computeAsyncExpiration,
                computeExpirationForFiber: computeExpirationForFiber,
                scheduleWork: scheduleWork,
                batchedUpdates: batchedUpdates,
                unbatchedUpdates: unbatchedUpdates,
                flushSync: flushSync,
                deferredUpdates: deferredUpdates
              };
            };
            {
              var didWarnAboutNestedUpdates = false;
            } // 0 is PROD, 1 is DEV.
            // Might add PROFILE later.
            function getContextForSubtree(parentComponent) {
              if (!parentComponent) {
                return emptyObject;
              }
              var fiber = get(parentComponent);
              var parentContext = findCurrentUnmaskedContext(fiber);
              return isContextProvider(fiber)
                ? processChildContext(fiber, parentContext)
                : parentContext;
            }
            var ReactFiberReconciler$1 = function ReactFiberReconciler$1(
              config
            ) {
              var getPublicInstance = config.getPublicInstance;
              var _ReactFiberScheduler = ReactFiberScheduler(config),
                computeAsyncExpiration =
                  _ReactFiberScheduler.computeAsyncExpiration,
                computeExpirationForFiber =
                  _ReactFiberScheduler.computeExpirationForFiber,
                scheduleWork = _ReactFiberScheduler.scheduleWork,
                batchedUpdates = _ReactFiberScheduler.batchedUpdates,
                unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
                flushSync = _ReactFiberScheduler.flushSync,
                deferredUpdates = _ReactFiberScheduler.deferredUpdates;
              function scheduleTopLevelUpdate(current, element, callback) {
                {
                  if (
                    ReactDebugCurrentFiber.phase === 'render' &&
                    ReactDebugCurrentFiber.current !== null &&
                    !didWarnAboutNestedUpdates
                  ) {
                    didWarnAboutNestedUpdates = true;
                    warning(
                      false,
                      'Render methods should be a pure function of props and state; ' +
                        'triggering nested component updates from render is not allowed. ' +
                        'If necessary, trigger nested updates in componentDidUpdate.\n\n' +
                        'Check the render method of %s.',
                      getComponentName(ReactDebugCurrentFiber.current) ||
                        'Unknown'
                    );
                  }
                }
                callback = callback === undefined ? null : callback;
                {
                  warning(
                    callback === null || typeof callback === 'function',
                    'render(...): Expected the last optional `callback` argument to be a ' +
                      'function. Instead received: %s.',
                    callback
                  );
                }
                var expirationTime = void 0; // Check if the top-level element is an async wrapper component. If so,
                // treat updates to the root as async. This is a bit weird but lets us
                // avoid a separate `renderAsync` API.
                if (
                  enableAsyncSubtreeAPI &&
                  element != null &&
                  element.type != null &&
                  element.type.prototype != null &&
                  element.type.prototype.unstable_isAsyncReactComponent === true
                ) {
                  expirationTime = computeAsyncExpiration();
                } else {
                  expirationTime = computeExpirationForFiber(current);
                }
                var update = {
                  expirationTime: expirationTime,
                  partialState: { element: element },
                  callback: callback,
                  isReplace: false,
                  isForced: false,
                  nextCallback: null,
                  next: null
                };
                insertUpdateIntoFiber(current, update);
                scheduleWork(current, expirationTime);
              }
              function findHostInstance(fiber) {
                var hostFiber = findCurrentHostFiber(fiber);
                if (hostFiber === null) {
                  return null;
                }
                return hostFiber.stateNode;
              }
              return {
                createContainer: function createContainer(
                  containerInfo,
                  hydrate
                ) {
                  return createFiberRoot(containerInfo, hydrate);
                },
                updateContainer: function updateContainer(
                  element,
                  container,
                  parentComponent,
                  callback
                ) {
                  // TODO: If this is a nested container, this won't be the root.
                  var current = container.current;
                  {
                    if (ReactFiberInstrumentation_1.debugTool) {
                      if (current.alternate === null) {
                        ReactFiberInstrumentation_1.debugTool.onMountContainer(
                          container
                        );
                      } else if (element === null) {
                        ReactFiberInstrumentation_1.debugTool.onUnmountContainer(
                          container
                        );
                      } else {
                        ReactFiberInstrumentation_1.debugTool.onUpdateContainer(
                          container
                        );
                      }
                    }
                  }
                  var context = getContextForSubtree(parentComponent);
                  if (container.context === null) {
                    container.context = context;
                  } else {
                    container.pendingContext = context;
                  }
                  scheduleTopLevelUpdate(current, element, callback);
                },
                batchedUpdates: batchedUpdates,
                unbatchedUpdates: unbatchedUpdates,
                deferredUpdates: deferredUpdates,
                flushSync: flushSync,
                getPublicRootInstance: function getPublicRootInstance(
                  container
                ) {
                  var containerFiber = container.current;
                  if (!containerFiber.child) {
                    return null;
                  }
                  switch (containerFiber.child.tag) {
                    case HostComponent:
                      return getPublicInstance(containerFiber.child.stateNode);
                    default:
                      return containerFiber.child.stateNode;
                  }
                },
                findHostInstance: findHostInstance,
                findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(
                  fiber
                ) {
                  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
                  if (hostFiber === null) {
                    return null;
                  }
                  return hostFiber.stateNode;
                },
                injectIntoDevTools: function injectIntoDevTools(
                  devToolsConfig
                ) {
                  var _findFiberByHostInstance =
                    devToolsConfig.findFiberByHostInstance;
                  return injectInternals(
                    _assign({}, devToolsConfig, {
                      findHostInstanceByFiber: function findHostInstanceByFiber(
                        fiber
                      ) {
                        return findHostInstance(fiber);
                      },
                      findFiberByHostInstance: function findFiberByHostInstance(
                        instance
                      ) {
                        if (!_findFiberByHostInstance) {
                          // Might not be implemented by the renderer.
                          return null;
                        }
                        return _findFiberByHostInstance(instance);
                      }
                    })
                  );
                }
              };
            };
            var ReactFiberReconciler$2 = Object.freeze({
              default: ReactFiberReconciler$1
            });
            var ReactFiberReconciler$3 =
              (ReactFiberReconciler$2 && ReactFiberReconciler$1) ||
              ReactFiberReconciler$2; // TODO: bundle Flow types with the package.
            // TODO: decide on the top-level export form.
            // This is hacky but makes it work with both Rollup and Jest.
            var reactReconciler = ReactFiberReconciler$3['default']
              ? ReactFiberReconciler$3['default']
              : ReactFiberReconciler$3;
            function createPortal$1(
              children,
              containerInfo, // TODO: figure out the API for cross-renderer implementation.
              implementation
            ) {
              var key =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : null;
              return {
                // This tag allow us to uniquely identify this as a React Portal
                $$typeof: REACT_PORTAL_TYPE,
                key: key == null ? null : '' + key,
                children: children,
                containerInfo: containerInfo,
                implementation: implementation
              };
            } // TODO: this is special because it gets imported during build.
            var ReactVersion = '16.2.0'; // a requestAnimationFrame, storing the time for the start of the frame, then
            // scheduling a postMessage which gets scheduled after paint. Within the
            // postMessage handler do as much work as possible until time + frame rate.
            // By separating the idle call into a separate event tick we ensure that
            // layout, paint and other browser work is counted against the available time.
            // The frame rate is dynamically adjusted.
            {
              if (
                ExecutionEnvironment.canUseDOM &&
                typeof requestAnimationFrame !== 'function'
              ) {
                warning(
                  false,
                  'React depends on requestAnimationFrame. Make sure that you load a ' +
                    'polyfill in older browsers. http://fb.me/react-polyfills'
                );
              }
            }
            var hasNativePerformanceNow =
              (typeof performance === 'undefined'
                ? 'undefined'
                : _typeof(performance)) === 'object' &&
              typeof performance.now === 'function';
            var now = void 0;
            if (hasNativePerformanceNow) {
              now = function now() {
                return performance.now();
              };
            } else {
              now = function now() {
                return Date.now();
              };
            } // TODO: There's no way to cancel, because Fiber doesn't atm.
            var rIC = void 0;
            var cIC = void 0;
            if (!ExecutionEnvironment.canUseDOM) {
              rIC = function rIC(frameCallback) {
                return setTimeout(function() {
                  frameCallback({
                    timeRemaining: function timeRemaining() {
                      return Infinity;
                    }
                  });
                });
              };
              cIC = function cIC(timeoutID) {
                clearTimeout(timeoutID);
              };
            } else if (
              typeof requestIdleCallback !== 'function' ||
              typeof cancelIdleCallback !== 'function'
            ) {
              // Polyfill requestIdleCallback and cancelIdleCallback
              var scheduledRICCallback = null;
              var isIdleScheduled = false;
              var timeoutTime = -1;
              var isAnimationFrameScheduled = false;
              var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking
              // will adjust this value to a faster fps if we get more frequent animation
              // frames.
              var previousFrameTime = 33;
              var activeFrameTime = 33;
              var frameDeadlineObject;
              if (hasNativePerformanceNow) {
                frameDeadlineObject = {
                  didTimeout: false,
                  timeRemaining: function timeRemaining() {
                    // We assume that if we have a performance timer that the rAF callback
                    // gets a performance timer value. Not sure if this is always true.
                    var remaining = frameDeadline - performance.now();
                    return remaining > 0 ? remaining : 0;
                  }
                };
              } else {
                frameDeadlineObject = {
                  didTimeout: false,
                  timeRemaining: function timeRemaining() {
                    // Fallback to Date.now()
                    var remaining = frameDeadline - Date.now();
                    return remaining > 0 ? remaining : 0;
                  }
                };
              } // We use the postMessage trick to defer idle work until after the repaint.
              var messageKey =
                '__reactIdleCallback$' +
                Math.random()
                  .toString(36)
                  .slice(2);
              var idleTick = function idleTick(event) {
                if (event.source !== window || event.data !== messageKey) {
                  return;
                }
                isIdleScheduled = false;
                var currentTime = now();
                if (frameDeadline - currentTime <= 0) {
                  // There's no time left in this idle period. Check if the callback has
                  // a timeout and whether it's been exceeded.
                  if (timeoutTime !== -1 && timeoutTime <= currentTime) {
                    // Exceeded the timeout. Invoke the callback even though there's no
                    // time left.
                    frameDeadlineObject.didTimeout = true;
                  } else {
                    // No timeout.
                    if (!isAnimationFrameScheduled) {
                      // Schedule another animation callback so we retry later.
                      isAnimationFrameScheduled = true;
                      requestAnimationFrame(animationTick);
                    } // Exit without invoking the callback.
                    return;
                  }
                } else {
                  // There's still time left in this idle period.
                  frameDeadlineObject.didTimeout = false;
                }
                timeoutTime = -1;
                var callback = scheduledRICCallback;
                scheduledRICCallback = null;
                if (callback !== null) {
                  callback(frameDeadlineObject);
                }
              }; // Assumes that we have addEventListener in this environment. Might need
              // something better for old IE.
              window.addEventListener('message', idleTick, false);
              var animationTick = function animationTick(rafTime) {
                isAnimationFrameScheduled = false;
                var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
                if (
                  nextFrameTime < activeFrameTime &&
                  previousFrameTime < activeFrameTime
                ) {
                  if (nextFrameTime < 8) {
                    // Defensive coding. We don't support higher frame rates than 120hz.
                    // If we get lower than that, it is probably a bug.
                    nextFrameTime = 8;
                  } // If one frame goes long, then the next one can be short to catch up.
                  // If two frames are short in a row, then that's an indication that we
                  // actually have a higher frame rate than what we're currently optimizing.
                  // We adjust our heuristic dynamically accordingly. For example, if we're
                  // running on 120hz display or 90hz VR display.
                  // Take the max of the two in case one of them was an anomaly due to
                  // missed frame deadlines.
                  activeFrameTime =
                    nextFrameTime < previousFrameTime
                      ? previousFrameTime
                      : nextFrameTime;
                } else {
                  previousFrameTime = nextFrameTime;
                }
                frameDeadline = rafTime + activeFrameTime;
                if (!isIdleScheduled) {
                  isIdleScheduled = true;
                  window.postMessage(messageKey, '*');
                }
              };
              rIC = function rIC(callback, options) {
                // This assumes that we only schedule one callback at a time because that's
                // how Fiber uses it.
                scheduledRICCallback = callback;
                if (options != null && typeof options.timeout === 'number') {
                  timeoutTime = now() + options.timeout;
                }
                if (!isAnimationFrameScheduled) {
                  // If rAF didn't already schedule one, we need to schedule a frame.
                  // TODO: If this rAF doesn't materialize because the browser throttles, we
                  // might want to still have setTimeout trigger rIC as a backup to ensure
                  // that we keep performing work.
                  isAnimationFrameScheduled = true;
                  requestAnimationFrame(animationTick);
                }
                return 0;
              };
              cIC = function cIC() {
                scheduledRICCallback = null;
                isIdleScheduled = false;
                timeoutTime = -1;
              };
            } else {
              rIC = window.requestIdleCallback;
              cIC = window.cancelIdleCallback;
            }
            /**
             * Forked from fbjs/warning:
             * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
             *
             * Only change is we use console.warn instead of console.error,
             * and do nothing when 'console' is not supported.
             * This really simplifies the code.
             * ---
             * Similar to invariant but only logs a warning if the condition is not met.
             * This can be used to log issues in development environments in critical
             * paths. Removing the logging code for production environments will keep the
             * same logic and follow the same code paths.
             */ var lowPriorityWarning = function lowPriorityWarning() {};
            {
              var printWarning = function printWarning(format) {
                for (
                  var _len = arguments.length,
                    args = Array(_len > 1 ? _len - 1 : 0),
                    _key = 1;
                  _key < _len;
                  _key++
                ) {
                  args[_key - 1] = arguments[_key];
                }
                var argIndex = 0;
                var message =
                  'Warning: ' +
                  format.replace(/%s/g, function() {
                    return args[argIndex++];
                  });
                if (typeof console !== 'undefined') {
                  console.warn(message);
                }
                try {
                  // --- Welcome to debugging React ---
                  // This error was thrown as a convenience so that you can use this stack
                  // to find the callsite that caused this warning to fire.
                  throw new Error(message);
                } catch (x) {}
              };
              lowPriorityWarning = function lowPriorityWarning(
                condition,
                format
              ) {
                if (format === undefined) {
                  throw new Error(
                    '`warning(condition, format, ...args)` requires a warning ' +
                      'message argument'
                  );
                }
                if (!condition) {
                  for (
                    var _len2 = arguments.length,
                      args = Array(_len2 > 2 ? _len2 - 2 : 0),
                      _key2 = 2;
                    _key2 < _len2;
                    _key2++
                  ) {
                    args[_key2 - 2] = arguments[_key2];
                  }
                  printWarning.apply(undefined, [format].concat(args));
                }
              };
            }
            var lowPriorityWarning$1 = lowPriorityWarning; // isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
            // TODO: Find a better place for this.
            var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(
              '^[' +
                ATTRIBUTE_NAME_START_CHAR +
                '][' +
                ATTRIBUTE_NAME_CHAR +
                ']*$'
            );
            var illegalAttributeNameCache = {};
            var validatedAttributeNameCache = {};
            function isAttributeNameSafe(attributeName) {
              if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
                return true;
              }
              if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
                return false;
              }
              if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
                validatedAttributeNameCache[attributeName] = true;
                return true;
              }
              illegalAttributeNameCache[attributeName] = true;
              {
                warning(false, 'Invalid attribute name: `%s`', attributeName);
              }
              return false;
            } // shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
            // TODO: Find a better place for this.
            function shouldIgnoreValue(propertyInfo, value) {
              return (
                value == null ||
                (propertyInfo.hasBooleanValue && !value) ||
                (propertyInfo.hasNumericValue && isNaN(value)) ||
                (propertyInfo.hasPositiveNumericValue && value < 1) ||
                (propertyInfo.hasOverloadedBooleanValue && value === false)
              );
            }
            /**
             * Operations for dealing with DOM properties.
             */ /**
             * Get the value for a property on a node. Only used in DEV for SSR validation.
             * The "expected" argument is used as a hint of what the expected value is.
             * Some properties have multiple equivalent values.
             */ function getValueForProperty(node, name, expected) {
              {
                var propertyInfo = getPropertyInfo(name);
                if (propertyInfo) {
                  var mutationMethod = propertyInfo.mutationMethod;
                  if (mutationMethod || propertyInfo.mustUseProperty) {
                    return node[propertyInfo.propertyName];
                  } else {
                    var attributeName = propertyInfo.attributeName;
                    var stringValue = null;
                    if (propertyInfo.hasOverloadedBooleanValue) {
                      if (node.hasAttribute(attributeName)) {
                        var value = node.getAttribute(attributeName);
                        if (value === '') {
                          return true;
                        }
                        if (shouldIgnoreValue(propertyInfo, expected)) {
                          return value;
                        }
                        if (value === '' + expected) {
                          return expected;
                        }
                        return value;
                      }
                    } else if (node.hasAttribute(attributeName)) {
                      if (shouldIgnoreValue(propertyInfo, expected)) {
                        // We had an attribute but shouldn't have had one, so read it
                        // for the error message.
                        return node.getAttribute(attributeName);
                      }
                      if (propertyInfo.hasBooleanValue) {
                        // If this was a boolean, it doesn't matter what the value is
                        // the fact that we have it is the same as the expected.
                        return expected;
                      } // Even if this property uses a namespace we use getAttribute
                      // because we assume its namespaced name is the same as our config.
                      // To use getAttributeNS we need the local name which we don't have
                      // in our config atm.
                      stringValue = node.getAttribute(attributeName);
                    }
                    if (shouldIgnoreValue(propertyInfo, expected)) {
                      return stringValue === null ? expected : stringValue;
                    } else if (stringValue === '' + expected) {
                      return expected;
                    } else {
                      return stringValue;
                    }
                  }
                }
              }
            }
            /**
             * Get the value for a attribute on a node. Only used in DEV for SSR validation.
             * The third argument is used as a hint of what the expected value is. Some
             * attributes have multiple equivalent values.
             */ function getValueForAttribute(node, name, expected) {
              {
                if (!isAttributeNameSafe(name)) {
                  return;
                }
                if (!node.hasAttribute(name)) {
                  return expected === undefined ? undefined : null;
                }
                var value = node.getAttribute(name);
                if (value === '' + expected) {
                  return expected;
                }
                return value;
              }
            }
            /**
             * Sets the value for a property on a node.
             *
             * @param {DOMElement} node
             * @param {string} name
             * @param {*} value
             */ function setValueForProperty(node, name, value) {
              var propertyInfo = getPropertyInfo(name);
              if (propertyInfo && shouldSetAttribute(name, value)) {
                var mutationMethod = propertyInfo.mutationMethod;
                if (mutationMethod) {
                  mutationMethod(node, value);
                } else if (shouldIgnoreValue(propertyInfo, value)) {
                  deleteValueForProperty(node, name);
                  return;
                } else if (propertyInfo.mustUseProperty) {
                  // Contrary to `setAttribute`, object properties are properly
                  // `toString`ed by IE8/9.
                  node[propertyInfo.propertyName] = value;
                } else {
                  var attributeName = propertyInfo.attributeName;
                  var namespace = propertyInfo.attributeNamespace; // `setAttribute` with objects becomes only `[object]` in IE8/9,
                  // ('' + value) makes it output the correct toString()-value.
                  if (namespace) {
                    node.setAttributeNS(namespace, attributeName, '' + value);
                  } else if (
                    propertyInfo.hasBooleanValue ||
                    (propertyInfo.hasOverloadedBooleanValue && value === true)
                  ) {
                    node.setAttribute(attributeName, '');
                  } else {
                    node.setAttribute(attributeName, '' + value);
                  }
                }
              } else {
                setValueForAttribute(
                  node,
                  name,
                  shouldSetAttribute(name, value) ? value : null
                );
                return;
              }
              {
              }
            }
            function setValueForAttribute(node, name, value) {
              if (!isAttributeNameSafe(name)) {
                return;
              }
              if (value == null) {
                node.removeAttribute(name);
              } else {
                node.setAttribute(name, '' + value);
              }
              {
              }
            }
            /**
             * Deletes an attributes from a node.
             *
             * @param {DOMElement} node
             * @param {string} name
             */ function deleteValueForAttribute(node, name) {
              node.removeAttribute(name);
            }
            /**
             * Deletes the value for a property on a node.
             *
             * @param {DOMElement} node
             * @param {string} name
             */ function deleteValueForProperty(node, name) {
              var propertyInfo = getPropertyInfo(name);
              if (propertyInfo) {
                var mutationMethod = propertyInfo.mutationMethod;
                if (mutationMethod) {
                  mutationMethod(node, undefined);
                } else if (propertyInfo.mustUseProperty) {
                  var propName = propertyInfo.propertyName;
                  if (propertyInfo.hasBooleanValue) {
                    node[propName] = false;
                  } else {
                    node[propName] = '';
                  }
                } else {
                  node.removeAttribute(propertyInfo.attributeName);
                }
              } else {
                node.removeAttribute(name);
              }
            }
            var ReactControlledValuePropTypes = { checkPropTypes: null };
            {
              var hasReadOnlyValue = {
                button: true,
                checkbox: true,
                image: true,
                hidden: true,
                radio: true,
                reset: true,
                submit: true
              };
              var propTypes = {
                value: function value(props, propName, componentName) {
                  if (
                    !props[propName] ||
                    hasReadOnlyValue[props.type] ||
                    props.onChange ||
                    props.readOnly ||
                    props.disabled
                  ) {
                    return null;
                  }
                  return new Error(
                    'You provided a `value` prop to a form field without an ' +
                      '`onChange` handler. This will render a read-only field. If ' +
                      'the field should be mutable use `defaultValue`. Otherwise, ' +
                      'set either `onChange` or `readOnly`.'
                  );
                },
                checked: function checked(props, propName, componentName) {
                  if (
                    !props[propName] ||
                    props.onChange ||
                    props.readOnly ||
                    props.disabled
                  ) {
                    return null;
                  }
                  return new Error(
                    'You provided a `checked` prop to a form field without an ' +
                      '`onChange` handler. This will render a read-only field. If ' +
                      'the field should be mutable use `defaultChecked`. Otherwise, ' +
                      'set either `onChange` or `readOnly`.'
                  );
                }
              };
              /**
               * Provide a linked `value` attribute for controlled forms. You should not use
               * this outside of the ReactDOM controlled form components.
               */ ReactControlledValuePropTypes.checkPropTypes = function(
                tagName,
                props,
                getStack
              ) {
                checkPropTypes(propTypes, props, 'prop', tagName, getStack);
              };
            } // TODO: direct imports like some-package/src/* are bad. Fix me.
            var getCurrentFiberOwnerName$2 =
              ReactDebugCurrentFiber.getCurrentFiberOwnerName;
            var getCurrentFiberStackAddendum$3 =
              ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
            var didWarnValueDefaultValue = false;
            var didWarnCheckedDefaultChecked = false;
            var didWarnControlledToUncontrolled = false;
            var didWarnUncontrolledToControlled = false;
            function isControlled(props) {
              var usesChecked =
                props.type === 'checkbox' || props.type === 'radio';
              return usesChecked ? props.checked != null : props.value != null;
            }
            /**
             * Implements an <input> host component that allows setting these optional
             * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
             *
             * If `checked` or `value` are not supplied (or null/undefined), user actions
             * that affect the checked state or value will trigger updates to the element.
             *
             * If they are supplied (and not null/undefined), the rendered element will not
             * trigger updates to the element. Instead, the props must change in order for
             * the rendered element to be updated.
             *
             * The rendered element will be initialized as unchecked (or `defaultChecked`)
             * with an empty value (or `defaultValue`).
             *
             * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
             */ function getHostProps(element, props) {
              var node = element;
              var value = props.value;
              var checked = props.checked;
              var hostProps = _assign(
                {
                  // Make sure we set .type before any other properties (setting .value
                  // before .type means .value is lost in IE11 and below)
                  type: undefined, // Make sure we set .step before .value (setting .value before .step
                  // means .value is rounded on mount, based upon step precision)
                  step: undefined, // Make sure we set .min & .max before .value (to ensure proper order
                  // in corner cases such as min or max deriving from value, e.g. Issue #7170)
                  min: undefined,
                  max: undefined
                },
                props,
                {
                  defaultChecked: undefined,
                  defaultValue: undefined,
                  value:
                    value != null ? value : node._wrapperState.initialValue,
                  checked:
                    checked != null
                      ? checked
                      : node._wrapperState.initialChecked
                }
              );
              return hostProps;
            }
            function initWrapperState(element, props) {
              {
                ReactControlledValuePropTypes.checkPropTypes(
                  'input',
                  props,
                  getCurrentFiberStackAddendum$3
                );
                if (
                  props.checked !== undefined &&
                  props.defaultChecked !== undefined &&
                  !didWarnCheckedDefaultChecked
                ) {
                  warning(
                    false,
                    '%s contains an input of type %s with both checked and defaultChecked props. ' +
                      'Input elements must be either controlled or uncontrolled ' +
                      '(specify either the checked prop, or the defaultChecked prop, but not ' +
                      'both). Decide between using a controlled or uncontrolled input ' +
                      'element and remove one of these props. More info: ' +
                      'https://fb.me/react-controlled-components',
                    getCurrentFiberOwnerName$2() || 'A component',
                    props.type
                  );
                  didWarnCheckedDefaultChecked = true;
                }
                if (
                  props.value !== undefined &&
                  props.defaultValue !== undefined &&
                  !didWarnValueDefaultValue
                ) {
                  warning(
                    false,
                    '%s contains an input of type %s with both value and defaultValue props. ' +
                      'Input elements must be either controlled or uncontrolled ' +
                      '(specify either the value prop, or the defaultValue prop, but not ' +
                      'both). Decide between using a controlled or uncontrolled input ' +
                      'element and remove one of these props. More info: ' +
                      'https://fb.me/react-controlled-components',
                    getCurrentFiberOwnerName$2() || 'A component',
                    props.type
                  );
                  didWarnValueDefaultValue = true;
                }
              }
              var defaultValue = props.defaultValue;
              var node = element;
              node._wrapperState = {
                initialChecked:
                  props.checked != null ? props.checked : props.defaultChecked,
                initialValue: props.value != null ? props.value : defaultValue,
                controlled: isControlled(props)
              };
            }
            function updateChecked(element, props) {
              var node = element;
              var checked = props.checked;
              if (checked != null) {
                setValueForProperty(node, 'checked', checked);
              }
            }
            function updateWrapper(element, props) {
              var node = element;
              {
                var controlled = isControlled(props);
                if (
                  !node._wrapperState.controlled &&
                  controlled &&
                  !didWarnUncontrolledToControlled
                ) {
                  warning(
                    false,
                    'A component is changing an uncontrolled input of type %s to be controlled. ' +
                      'Input elements should not switch from uncontrolled to controlled (or vice versa). ' +
                      'Decide between using a controlled or uncontrolled input ' +
                      'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',
                    props.type,
                    getCurrentFiberStackAddendum$3()
                  );
                  didWarnUncontrolledToControlled = true;
                }
                if (
                  node._wrapperState.controlled &&
                  !controlled &&
                  !didWarnControlledToUncontrolled
                ) {
                  warning(
                    false,
                    'A component is changing a controlled input of type %s to be uncontrolled. ' +
                      'Input elements should not switch from controlled to uncontrolled (or vice versa). ' +
                      'Decide between using a controlled or uncontrolled input ' +
                      'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',
                    props.type,
                    getCurrentFiberStackAddendum$3()
                  );
                  didWarnControlledToUncontrolled = true;
                }
              }
              updateChecked(element, props);
              var value = props.value;
              if (value != null) {
                if (value === 0 && node.value === '') {
                  node.value = '0'; // Note: IE9 reports a number inputs as 'text', so check props instead.
                } else if (props.type === 'number') {
                  // Simulate `input.valueAsNumber`. IE9 does not support it
                  var valueAsNumber = parseFloat(node.value) || 0;
                  if (
                    // eslint-disable-next-line
                    value != valueAsNumber || // eslint-disable-next-line
                    (value == valueAsNumber && node.value != value)
                  ) {
                    // Cast `value` to a string to ensure the value is set correctly. While
                    // browsers typically do this as necessary, jsdom doesn't.
                    node.value = '' + value;
                  }
                } else if (node.value !== '' + value) {
                  // Cast `value` to a string to ensure the value is set correctly. While
                  // browsers typically do this as necessary, jsdom doesn't.
                  node.value = '' + value;
                }
              } else {
                if (props.value == null && props.defaultValue != null) {
                  // In Chrome, assigning defaultValue to certain input types triggers input validation.
                  // For number inputs, the display value loses trailing decimal points. For email inputs,
                  // Chrome raises "The specified value <x> is not a valid email address".
                  //
                  // Here we check to see if the defaultValue has actually changed, avoiding these problems
                  // when the user is inputting text
                  //
                  // https://github.com/facebook/react/issues/7253
                  if (node.defaultValue !== '' + props.defaultValue) {
                    node.defaultValue = '' + props.defaultValue;
                  }
                }
                if (props.checked == null && props.defaultChecked != null) {
                  node.defaultChecked = !!props.defaultChecked;
                }
              }
            }
            function postMountWrapper(element, props) {
              var node = element; // Detach value from defaultValue. We won't do anything if we're working on
              // submit or reset inputs as those values & defaultValues are linked. They
              // are not resetable nodes so this operation doesn't matter and actually
              // removes browser-default values (eg "Submit Query") when no value is
              // provided.
              switch (props.type) {
                case 'submit':
                case 'reset':
                  break;
                case 'color':
                case 'date':
                case 'datetime':
                case 'datetime-local':
                case 'month':
                case 'time':
                case 'week': // This fixes the no-show issue on iOS Safari and Android Chrome:
                  // https://github.com/facebook/react/issues/7233
                  node.value = '';
                  node.value = node.defaultValue;
                  break;
                default:
                  node.value = node.value;
                  break;
              } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
              // this is needed to work around a chrome bug where setting defaultChecked
              // will sometimes influence the value of checked (even after detachment).
              // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
              // We need to temporarily unset name to avoid disrupting radio button groups.
              var name = node.name;
              if (name !== '') {
                node.name = '';
              }
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !node.defaultChecked;
              if (name !== '') {
                node.name = name;
              }
            }
            function restoreControlledState$1(element, props) {
              var node = element;
              updateWrapper(node, props);
              updateNamedCousins(node, props);
            }
            function updateNamedCousins(rootNode, props) {
              var name = props.name;
              if (props.type === 'radio' && name != null) {
                var queryRoot = rootNode;
                while (queryRoot.parentNode) {
                  queryRoot = queryRoot.parentNode;
                } // If `rootNode.form` was non-null, then we could try `form.elements`,
                // but that sometimes behaves strangely in IE8. We could also try using
                // `form.getElementsByName`, but that will only return direct children
                // and won't include inputs that use the HTML5 `form=` attribute. Since
                // the input might not even be in a form. It might not even be in the
                // document. Let's just use the local `querySelectorAll` to ensure we don't
                // miss anything.
                var group = queryRoot.querySelectorAll(
                  'input[name=' + JSON.stringify('' + name) + '][type="radio"]'
                );
                for (var i = 0; i < group.length; i++) {
                  var otherNode = group[i];
                  if (
                    otherNode === rootNode ||
                    otherNode.form !== rootNode.form
                  ) {
                    continue;
                  } // This will throw if radio buttons rendered by different copies of React
                  // and the same name are rendered into the same form (same as #1939).
                  // That's probably okay; we don't support it just as we don't support
                  // mixing React radio buttons with non-React ones.
                  var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
                  !otherProps
                    ? invariant(
                        false,
                        'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'
                      )
                    : void 0; // We need update the tracked value on the named cousin since the value
                  // was changed but the input saw no event or value set
                  updateValueIfChanged(otherNode); // If this is a controlled radio button group, forcing the input that
                  // was previously checked to update will cause it to be come re-checked
                  // as appropriate.
                  updateWrapper(otherNode, otherProps);
                }
              }
            }
            function flattenChildren(children) {
              var content = ''; // Flatten children and warn if they aren't strings or numbers;
              // invalid types are ignored.
              // We can silently skip them because invalid DOM nesting warning
              // catches these cases in Fiber.
              React.Children.forEach(children, function(child) {
                if (child == null) {
                  return;
                }
                if (typeof child === 'string' || typeof child === 'number') {
                  content += child;
                }
              });
              return content;
            }
            /**
             * Implements an <option> host component that warns when `selected` is set.
             */ function validateProps(element, props) {
              // TODO (yungsters): Remove support for `selected` in <option>.
              {
                warning(
                  props.selected == null,
                  'Use the `defaultValue` or `value` props on <select> instead of ' +
                    'setting `selected` on <option>.'
                );
              }
            }
            function postMountWrapper$1(element, props) {
              // value="" should make a value attribute (#6219)
              if (props.value != null) {
                element.setAttribute('value', props.value);
              }
            }
            function getHostProps$1(element, props) {
              var hostProps = _assign({ children: undefined }, props);
              var content = flattenChildren(props.children);
              if (content) {
                hostProps.children = content;
              }
              return hostProps;
            } // TODO: direct imports like some-package/src/* are bad. Fix me.
            var getCurrentFiberOwnerName$3 =
              ReactDebugCurrentFiber.getCurrentFiberOwnerName;
            var getCurrentFiberStackAddendum$4 =
              ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
            {
              var didWarnValueDefaultValue$1 = false;
            }
            function getDeclarationErrorAddendum() {
              var ownerName = getCurrentFiberOwnerName$3();
              if (ownerName) {
                return '\n\nCheck the render method of `' + ownerName + '`.';
              }
              return '';
            }
            var valuePropNames = ['value', 'defaultValue'];
            /**
             * Validation function for `value` and `defaultValue`.
             */ function checkSelectPropTypes(props) {
              ReactControlledValuePropTypes.checkPropTypes(
                'select',
                props,
                getCurrentFiberStackAddendum$4
              );
              for (var i = 0; i < valuePropNames.length; i++) {
                var propName = valuePropNames[i];
                if (props[propName] == null) {
                  continue;
                }
                var isArray = Array.isArray(props[propName]);
                if (props.multiple && !isArray) {
                  warning(
                    false,
                    'The `%s` prop supplied to <select> must be an array if ' +
                      '`multiple` is true.%s',
                    propName,
                    getDeclarationErrorAddendum()
                  );
                } else if (!props.multiple && isArray) {
                  warning(
                    false,
                    'The `%s` prop supplied to <select> must be a scalar ' +
                      'value if `multiple` is false.%s',
                    propName,
                    getDeclarationErrorAddendum()
                  );
                }
              }
            }
            function updateOptions(
              node,
              multiple,
              propValue,
              setDefaultSelected
            ) {
              var options = node.options;
              if (multiple) {
                var selectedValues = propValue;
                var selectedValue = {};
                for (var i = 0; i < selectedValues.length; i++) {
                  // Prefix to avoid chaos with special keys.
                  selectedValue['$' + selectedValues[i]] = true;
                }
                for (var _i = 0; _i < options.length; _i++) {
                  var selected = selectedValue.hasOwnProperty(
                    '$' + options[_i].value
                  );
                  if (options[_i].selected !== selected) {
                    options[_i].selected = selected;
                  }
                  if (selected && setDefaultSelected) {
                    options[_i].defaultSelected = true;
                  }
                }
              } else {
                // Do not set `select.value` as exact behavior isn't consistent across all
                // browsers for all cases.
                var _selectedValue = '' + propValue;
                var defaultSelected = null;
                for (var _i2 = 0; _i2 < options.length; _i2++) {
                  if (options[_i2].value === _selectedValue) {
                    options[_i2].selected = true;
                    if (setDefaultSelected) {
                      options[_i2].defaultSelected = true;
                    }
                    return;
                  }
                  if (defaultSelected === null && !options[_i2].disabled) {
                    defaultSelected = options[_i2];
                  }
                }
                if (defaultSelected !== null) {
                  defaultSelected.selected = true;
                }
              }
            }
            /**
             * Implements a <select> host component that allows optionally setting the
             * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
             * stringable. If `multiple` is true, the prop must be an array of stringables.
             *
             * If `value` is not supplied (or null/undefined), user actions that change the
             * selected option will trigger updates to the rendered options.
             *
             * If it is supplied (and not null/undefined), the rendered options will not
             * update in response to user actions. Instead, the `value` prop must change in
             * order for the rendered options to update.
             *
             * If `defaultValue` is provided, any options with the supplied values will be
             * selected.
             */ function getHostProps$2(element, props) {
              return _assign({}, props, { value: undefined });
            }
            function initWrapperState$1(element, props) {
              var node = element;
              {
                checkSelectPropTypes(props);
              }
              var value = props.value;
              node._wrapperState = {
                initialValue: value != null ? value : props.defaultValue,
                wasMultiple: !!props.multiple
              };
              {
                if (
                  props.value !== undefined &&
                  props.defaultValue !== undefined &&
                  !didWarnValueDefaultValue$1
                ) {
                  warning(
                    false,
                    'Select elements must be either controlled or uncontrolled ' +
                      '(specify either the value prop, or the defaultValue prop, but not ' +
                      'both). Decide between using a controlled or uncontrolled select ' +
                      'element and remove one of these props. More info: ' +
                      'https://fb.me/react-controlled-components'
                  );
                  didWarnValueDefaultValue$1 = true;
                }
              }
            }
            function postMountWrapper$2(element, props) {
              var node = element;
              node.multiple = !!props.multiple;
              var value = props.value;
              if (value != null) {
                updateOptions(node, !!props.multiple, value, false);
              } else if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              }
            }
            function postUpdateWrapper(element, props) {
              var node = element; // After the initial mount, we control selected-ness manually so don't pass
              // this value down
              node._wrapperState.initialValue = undefined;
              var wasMultiple = node._wrapperState.wasMultiple;
              node._wrapperState.wasMultiple = !!props.multiple;
              var value = props.value;
              if (value != null) {
                updateOptions(node, !!props.multiple, value, false);
              } else if (wasMultiple !== !!props.multiple) {
                // For simplicity, reapply `defaultValue` if `multiple` is toggled.
                if (props.defaultValue != null) {
                  updateOptions(
                    node,
                    !!props.multiple,
                    props.defaultValue,
                    true
                  );
                } else {
                  // Revert the select back to its default unselected state.
                  updateOptions(
                    node,
                    !!props.multiple,
                    props.multiple ? [] : '',
                    false
                  );
                }
              }
            }
            function restoreControlledState$2(element, props) {
              var node = element;
              var value = props.value;
              if (value != null) {
                updateOptions(node, !!props.multiple, value, false);
              }
            } // TODO: direct imports like some-package/src/* are bad. Fix me.
            var getCurrentFiberStackAddendum$5 =
              ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
            var didWarnValDefaultVal = false;
            /**
             * Implements a <textarea> host component that allows setting `value`, and
             * `defaultValue`. This differs from the traditional DOM API because value is
             * usually set as PCDATA children.
             *
             * If `value` is not supplied (or null/undefined), user actions that affect the
             * value will trigger updates to the element.
             *
             * If `value` is supplied (and not null/undefined), the rendered element will
             * not trigger updates to the element. Instead, the `value` prop must change in
             * order for the rendered element to be updated.
             *
             * The rendered element will be initialized with an empty value, the prop
             * `defaultValue` if specified, or the children content (deprecated).
             */ function getHostProps$3(element, props) {
              var node = element;
              !(props.dangerouslySetInnerHTML == null)
                ? invariant(
                    false,
                    '`dangerouslySetInnerHTML` does not make sense on <textarea>.'
                  )
                : void 0; // Always set children to the same thing. In IE9, the selection range will
              // get reset if `textContent` is mutated.  We could add a check in setTextContent
              // to only set the value if/when the value differs from the node value (which would
              // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
              // solution. The value can be a boolean or object so that's why it's forced
              // to be a string.
              var hostProps = _assign({}, props, {
                value: undefined,
                defaultValue: undefined,
                children: '' + node._wrapperState.initialValue
              });
              return hostProps;
            }
            function initWrapperState$2(element, props) {
              var node = element;
              {
                ReactControlledValuePropTypes.checkPropTypes(
                  'textarea',
                  props,
                  getCurrentFiberStackAddendum$5
                );
                if (
                  props.value !== undefined &&
                  props.defaultValue !== undefined &&
                  !didWarnValDefaultVal
                ) {
                  warning(
                    false,
                    'Textarea elements must be either controlled or uncontrolled ' +
                      '(specify either the value prop, or the defaultValue prop, but not ' +
                      'both). Decide between using a controlled or uncontrolled textarea ' +
                      'and remove one of these props. More info: ' +
                      'https://fb.me/react-controlled-components'
                  );
                  didWarnValDefaultVal = true;
                }
              }
              var initialValue = props.value; // Only bother fetching default value if we're going to use it
              if (initialValue == null) {
                var defaultValue = props.defaultValue; // TODO (yungsters): Remove support for children content in <textarea>.
                var children = props.children;
                if (children != null) {
                  {
                    warning(
                      false,
                      'Use the `defaultValue` or `value` props instead of setting ' +
                        'children on <textarea>.'
                    );
                  }
                  !(defaultValue == null)
                    ? invariant(
                        false,
                        'If you supply `defaultValue` on a <textarea>, do not pass children.'
                      )
                    : void 0;
                  if (Array.isArray(children)) {
                    !(children.length <= 1)
                      ? invariant(
                          false,
                          '<textarea> can only have at most one child.'
                        )
                      : void 0;
                    children = children[0];
                  }
                  defaultValue = '' + children;
                }
                if (defaultValue == null) {
                  defaultValue = '';
                }
                initialValue = defaultValue;
              }
              node._wrapperState = { initialValue: '' + initialValue };
            }
            function updateWrapper$1(element, props) {
              var node = element;
              var value = props.value;
              if (value != null) {
                // Cast `value` to a string to ensure the value is set correctly. While
                // browsers typically do this as necessary, jsdom doesn't.
                var newValue = '' + value; // To avoid side effects (such as losing text selection), only set value if changed
                if (newValue !== node.value) {
                  node.value = newValue;
                }
                if (props.defaultValue == null) {
                  node.defaultValue = newValue;
                }
              }
              if (props.defaultValue != null) {
                node.defaultValue = props.defaultValue;
              }
            }
            function postMountWrapper$3(element, props) {
              var node = element; // This is in postMount because we need access to the DOM node, which is not
              // available until after the component has mounted.
              var textContent = node.textContent; // Only set node.value if textContent is equal to the expected
              // initial value. In IE10/IE11 there is a bug where the placeholder attribute
              // will populate textContent as well.
              // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
              if (textContent === node._wrapperState.initialValue) {
                node.value = textContent;
              }
            }
            function restoreControlledState$3(element, props) {
              // DOM component is still mounted; update
              updateWrapper$1(element, props);
            }
            var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
            var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
            var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
            var Namespaces = {
              html: HTML_NAMESPACE$1,
              mathml: MATH_NAMESPACE,
              svg: SVG_NAMESPACE
            }; // Assumes there is no parent namespace.
            function getIntrinsicNamespace(type) {
              switch (type) {
                case 'svg':
                  return SVG_NAMESPACE;
                case 'math':
                  return MATH_NAMESPACE;
                default:
                  return HTML_NAMESPACE$1;
              }
            }
            function getChildNamespace(parentNamespace, type) {
              if (
                parentNamespace == null ||
                parentNamespace === HTML_NAMESPACE$1
              ) {
                // No (or default) parent namespace: potential entry point.
                return getIntrinsicNamespace(type);
              }
              if (
                parentNamespace === SVG_NAMESPACE &&
                type === 'foreignObject'
              ) {
                // We're leaving SVG.
                return HTML_NAMESPACE$1;
              } // By default, pass namespace below.
              return parentNamespace;
            }
            /* globals MSApp */ /**
             * Create a function which has 'unsafe' privileges (required by windows8 apps)
             */ var createMicrosoftUnsafeLocalFunction = function createMicrosoftUnsafeLocalFunction(
              func
            ) {
              if (
                typeof MSApp !== 'undefined' &&
                MSApp.execUnsafeLocalFunction
              ) {
                return function(arg0, arg1, arg2, arg3) {
                  MSApp.execUnsafeLocalFunction(function() {
                    return func(arg0, arg1, arg2, arg3);
                  });
                };
              } else {
                return func;
              }
            }; // SVG temp container for IE lacking innerHTML
            var reusableSVGContainer = void 0;
            /**
             * Set the innerHTML property of a node
             *
             * @param {DOMElement} node
             * @param {string} html
             * @internal
             */ var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(
              node,
              html
            ) {
              // IE does not have innerHTML for SVG nodes, so instead we inject the
              // new markup in a temp node and then move the child nodes across into
              // the target node
              if (
                node.namespaceURI === Namespaces.svg &&
                !('innerHTML' in node)
              ) {
                reusableSVGContainer =
                  reusableSVGContainer || document.createElement('div');
                reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
              } else {
                node.innerHTML = html;
              }
            });
            /**
             * Set the textContent property of a node, ensuring that whitespace is preserved
             * even in IE8. innerText is a poor substitute for textContent and, among many
             * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
             * as it should.
             *
             * @param {DOMElement} node
             * @param {string} text
             * @internal
             */ var setTextContent = function setTextContent(node, text) {
              if (text) {
                var firstChild = node.firstChild;
                if (
                  firstChild &&
                  firstChild === node.lastChild &&
                  firstChild.nodeType === TEXT_NODE
                ) {
                  firstChild.nodeValue = text;
                  return;
                }
              }
              node.textContent = text;
            };
            /**
             * CSS properties which accept numbers but are not in units of "px".
             */ var isUnitlessNumber = {
              animationIterationCount: true,
              borderImageOutset: true,
              borderImageSlice: true,
              borderImageWidth: true,
              boxFlex: true,
              boxFlexGroup: true,
              boxOrdinalGroup: true,
              columnCount: true,
              columns: true,
              flex: true,
              flexGrow: true,
              flexPositive: true,
              flexShrink: true,
              flexNegative: true,
              flexOrder: true,
              gridRow: true,
              gridRowEnd: true,
              gridRowSpan: true,
              gridRowStart: true,
              gridColumn: true,
              gridColumnEnd: true,
              gridColumnSpan: true,
              gridColumnStart: true,
              fontWeight: true,
              lineClamp: true,
              lineHeight: true,
              opacity: true,
              order: true,
              orphans: true,
              tabSize: true,
              widows: true,
              zIndex: true,
              zoom: true, // SVG-related properties
              fillOpacity: true,
              floodOpacity: true,
              stopOpacity: true,
              strokeDasharray: true,
              strokeDashoffset: true,
              strokeMiterlimit: true,
              strokeOpacity: true,
              strokeWidth: true
            };
            /**
             * @param {string} prefix vendor-specific prefix, eg: Webkit
             * @param {string} key style name, eg: transitionDuration
             * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
             * WebkitTransitionDuration
             */ function prefixKey(prefix, key) {
              return prefix + key.charAt(0).toUpperCase() + key.substring(1);
            }
            /**
             * Support style names that may come passed in prefixed by adding permutations
             * of vendor prefixes.
             */ var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
            // infinite loop, because it iterates over the newly added props too.
            Object.keys(isUnitlessNumber).forEach(function(prop) {
              prefixes.forEach(function(prefix) {
                isUnitlessNumber[prefixKey(prefix, prop)] =
                  isUnitlessNumber[prop];
              });
            });
            /**
             * Convert a value into the proper css writable value. The style name `name`
             * should be logical (no hyphens), as specified
             * in `CSSProperty.isUnitlessNumber`.
             *
             * @param {string} name CSS property name such as `topMargin`.
             * @param {*} value CSS property value such as `10px`.
             * @return {string} Normalized style value with dimensions applied.
             */ function dangerousStyleValue(name, value, isCustomProperty) {
              // Note that we've removed escapeTextForBrowser() calls here since the
              // whole string will be escaped when the attribute is injected into
              // the markup. If you provide unsafe user data here they can inject
              // arbitrary CSS which may be problematic (I couldn't repro this):
              // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
              // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
              // This is not an XSS hole but instead a potential CSS injection issue
              // which has lead to a greater discussion about how we're going to
              // trust URLs moving forward. See #2115901
              var isEmpty =
                value == null || typeof value === 'boolean' || value === '';
              if (isEmpty) {
                return '';
              }
              if (
                !isCustomProperty &&
                typeof value === 'number' &&
                value !== 0 &&
                !(
                  isUnitlessNumber.hasOwnProperty(name) &&
                  isUnitlessNumber[name]
                )
              ) {
                return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
              }
              return ('' + value).trim();
            }
            var warnValidStyle = emptyFunction;
            {
              // 'msTransform' is correct, but the other prefixes should be capitalized
              var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/; // style values shouldn't contain a semicolon
              var badStyleValueWithSemicolonPattern = /;\s*$/;
              var warnedStyleNames = {};
              var warnedStyleValues = {};
              var warnedForNaNValue = false;
              var warnedForInfinityValue = false;
              var warnHyphenatedStyleName = function warnHyphenatedStyleName(
                name,
                getStack
              ) {
                if (
                  warnedStyleNames.hasOwnProperty(name) &&
                  warnedStyleNames[name]
                ) {
                  return;
                }
                warnedStyleNames[name] = true;
                warning(
                  false,
                  'Unsupported style property %s. Did you mean %s?%s',
                  name,
                  camelizeStyleName(name),
                  getStack()
                );
              };
              var warnBadVendoredStyleName = function warnBadVendoredStyleName(
                name,
                getStack
              ) {
                if (
                  warnedStyleNames.hasOwnProperty(name) &&
                  warnedStyleNames[name]
                ) {
                  return;
                }
                warnedStyleNames[name] = true;
                warning(
                  false,
                  'Unsupported vendor-prefixed style property %s. Did you mean %s?%s',
                  name,
                  name.charAt(0).toUpperCase() + name.slice(1),
                  getStack()
                );
              };
              var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(
                name,
                value,
                getStack
              ) {
                if (
                  warnedStyleValues.hasOwnProperty(value) &&
                  warnedStyleValues[value]
                ) {
                  return;
                }
                warnedStyleValues[value] = true;
                warning(
                  false,
                  "Style property values shouldn't contain a semicolon. " +
                    'Try "%s: %s" instead.%s',
                  name,
                  value.replace(badStyleValueWithSemicolonPattern, ''),
                  getStack()
                );
              };
              var warnStyleValueIsNaN = function warnStyleValueIsNaN(
                name,
                value,
                getStack
              ) {
                if (warnedForNaNValue) {
                  return;
                }
                warnedForNaNValue = true;
                warning(
                  false,
                  '`NaN` is an invalid value for the `%s` css style property.%s',
                  name,
                  getStack()
                );
              };
              var warnStyleValueIsInfinity = function warnStyleValueIsInfinity(
                name,
                value,
                getStack
              ) {
                if (warnedForInfinityValue) {
                  return;
                }
                warnedForInfinityValue = true;
                warning(
                  false,
                  '`Infinity` is an invalid value for the `%s` css style property.%s',
                  name,
                  getStack()
                );
              };
              warnValidStyle = function warnValidStyle(name, value, getStack) {
                if (name.indexOf('-') > -1) {
                  warnHyphenatedStyleName(name, getStack);
                } else if (badVendoredStyleNamePattern.test(name)) {
                  warnBadVendoredStyleName(name, getStack);
                } else if (badStyleValueWithSemicolonPattern.test(value)) {
                  warnStyleValueWithSemicolon(name, value, getStack);
                }
                if (typeof value === 'number') {
                  if (isNaN(value)) {
                    warnStyleValueIsNaN(name, value, getStack);
                  } else if (!isFinite(value)) {
                    warnStyleValueIsInfinity(name, value, getStack);
                  }
                }
              };
            }
            var warnValidStyle$1 = warnValidStyle;
            /**
             * Operations for dealing with CSS properties.
             */ /**
             * This creates a string that is expected to be equivalent to the style
             * attribute generated by server-side rendering. It by-passes warnings and
             * security checks so it's not safe to use this value for anything other than
             * comparison. It is only used in DEV for SSR validation.
             */ function createDangerousStringForStyles(styles) {
              {
                var serialized = '';
                var delimiter = '';
                for (var styleName in styles) {
                  if (!styles.hasOwnProperty(styleName)) {
                    continue;
                  }
                  var styleValue = styles[styleName];
                  if (styleValue != null) {
                    var isCustomProperty = styleName.indexOf('--') === 0;
                    serialized +=
                      delimiter + hyphenateStyleName(styleName) + ':';
                    serialized += dangerousStyleValue(
                      styleName,
                      styleValue,
                      isCustomProperty
                    );
                    delimiter = ';';
                  }
                }
                return serialized || null;
              }
            }
            /**
             * Sets the value for multiple styles on a node.  If a value is specified as
             * '' (empty string), the corresponding style property will be unset.
             *
             * @param {DOMElement} node
             * @param {object} styles
             */ function setValueForStyles(node, styles, getStack) {
              var style = node.style;
              for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                  continue;
                }
                var isCustomProperty = styleName.indexOf('--') === 0;
                {
                  if (!isCustomProperty) {
                    warnValidStyle$1(styleName, styles[styleName], getStack);
                  }
                }
                var styleValue = dangerousStyleValue(
                  styleName,
                  styles[styleName],
                  isCustomProperty
                );
                if (styleName === 'float') {
                  styleName = 'cssFloat';
                }
                if (isCustomProperty) {
                  style.setProperty(styleName, styleValue);
                } else {
                  style[styleName] = styleValue;
                }
              }
            } // For HTML, certain tags should omit their close tag. We keep a whitelist for
            // those special-case tags.
            var omittedCloseTags = {
              area: true,
              base: true,
              br: true,
              col: true,
              embed: true,
              hr: true,
              img: true,
              input: true,
              keygen: true,
              link: true,
              meta: true,
              param: true,
              source: true,
              track: true,
              wbr: true
            }; // For HTML, certain tags cannot have children. This has the same purpose as
            // `omittedCloseTags` except that `menuitem` should still have its closing tag.
            var voidElementTags = _assign({ menuitem: true }, omittedCloseTags);
            var HTML$1 = '__html';
            function assertValidProps(tag, props, getStack) {
              if (!props) {
                return;
              } // Note the use of `==` which checks for null or undefined.
              if (voidElementTags[tag]) {
                !(
                  props.children == null &&
                  props.dangerouslySetInnerHTML == null
                )
                  ? invariant(
                      false,
                      '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',
                      tag,
                      getStack()
                    )
                  : void 0;
              }
              if (props.dangerouslySetInnerHTML != null) {
                !(props.children == null)
                  ? invariant(
                      false,
                      'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'
                    )
                  : void 0;
                !(
                  _typeof(props.dangerouslySetInnerHTML) === 'object' &&
                  HTML$1 in props.dangerouslySetInnerHTML
                )
                  ? invariant(
                      false,
                      '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'
                    )
                  : void 0;
              }
              {
                warning(
                  props.suppressContentEditableWarning ||
                    !props.contentEditable ||
                    props.children == null,
                  'A component is `contentEditable` and contains `children` managed by ' +
                    'React. It is now your responsibility to guarantee that none of ' +
                    'those nodes are unexpectedly modified or duplicated. This is ' +
                    'probably not intentional.%s',
                  getStack()
                );
              }
              !(props.style == null || _typeof(props.style) === 'object')
                ? invariant(
                    false,
                    "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.%s",
                    getStack()
                  )
                : void 0;
            }
            function isCustomComponent(tagName, props) {
              if (tagName.indexOf('-') === -1) {
                return typeof props.is === 'string';
              }
              switch (tagName) { // These are reserved SVG and MathML elements.
                // We don't mind this whitelist too much because we expect it to never grow.
                // The alternative is to track the namespace in a few places which is convoluted.
                // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
                case 'annotation-xml':
                case 'color-profile':
                case 'font-face':
                case 'font-face-src':
                case 'font-face-uri':
                case 'font-face-format':
                case 'font-face-name':
                case 'missing-glyph':
                  return false;
                default:
                  return true;
              }
            }
            var ariaProperties = {
              'aria-current': 0, // state
              'aria-details': 0,
              'aria-disabled': 0, // state
              'aria-hidden': 0, // state
              'aria-invalid': 0, // state
              'aria-keyshortcuts': 0,
              'aria-label': 0,
              'aria-roledescription': 0, // Widget Attributes
              'aria-autocomplete': 0,
              'aria-checked': 0,
              'aria-expanded': 0,
              'aria-haspopup': 0,
              'aria-level': 0,
              'aria-modal': 0,
              'aria-multiline': 0,
              'aria-multiselectable': 0,
              'aria-orientation': 0,
              'aria-placeholder': 0,
              'aria-pressed': 0,
              'aria-readonly': 0,
              'aria-required': 0,
              'aria-selected': 0,
              'aria-sort': 0,
              'aria-valuemax': 0,
              'aria-valuemin': 0,
              'aria-valuenow': 0,
              'aria-valuetext': 0, // Live Region Attributes
              'aria-atomic': 0,
              'aria-busy': 0,
              'aria-live': 0,
              'aria-relevant': 0, // Drag-and-Drop Attributes
              'aria-dropeffect': 0,
              'aria-grabbed': 0, // Relationship Attributes
              'aria-activedescendant': 0,
              'aria-colcount': 0,
              'aria-colindex': 0,
              'aria-colspan': 0,
              'aria-controls': 0,
              'aria-describedby': 0,
              'aria-errormessage': 0,
              'aria-flowto': 0,
              'aria-labelledby': 0,
              'aria-owns': 0,
              'aria-posinset': 0,
              'aria-rowcount': 0,
              'aria-rowindex': 0,
              'aria-rowspan': 0,
              'aria-setsize': 0
            };
            var warnedProperties = {};
            var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
            var rARIACamel = new RegExp(
              '^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$'
            );
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            function getStackAddendum() {
              var stack = ReactDebugCurrentFrame.getStackAddendum();
              return stack != null ? stack : '';
            }
            function validateProperty(tagName, name) {
              if (
                hasOwnProperty.call(warnedProperties, name) &&
                warnedProperties[name]
              ) {
                return true;
              }
              if (rARIACamel.test(name)) {
                var ariaName = 'aria-' + name.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName)
                  ? ariaName
                  : null; // If this is an aria-* attribute, but is not listed in the known DOM
                // DOM properties, then it is an invalid aria-* attribute.
                if (correctName == null) {
                  warning(
                    false,
                    'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s',
                    name,
                    getStackAddendum()
                  );
                  warnedProperties[name] = true;
                  return true;
                } // aria-* attributes should be lowercase; suggest the lowercase version.
                if (name !== correctName) {
                  warning(
                    false,
                    'Invalid ARIA attribute `%s`. Did you mean `%s`?%s',
                    name,
                    correctName,
                    getStackAddendum()
                  );
                  warnedProperties[name] = true;
                  return true;
                }
              }
              if (rARIA.test(name)) {
                var lowerCasedName = name.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName)
                  ? lowerCasedName
                  : null; // If this is an aria-* attribute, but is not listed in the known DOM
                // DOM properties, then it is an invalid aria-* attribute.
                if (standardName == null) {
                  warnedProperties[name] = true;
                  return false;
                } // aria-* attributes should be lowercase; suggest the lowercase version.
                if (name !== standardName) {
                  warning(
                    false,
                    'Unknown ARIA attribute `%s`. Did you mean `%s`?%s',
                    name,
                    standardName,
                    getStackAddendum()
                  );
                  warnedProperties[name] = true;
                  return true;
                }
              }
              return true;
            }
            function warnInvalidARIAProps(type, props) {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps
                .map(function(prop) {
                  return '`' + prop + '`';
                })
                .join(', ');
              if (invalidProps.length === 1) {
                warning(
                  false,
                  'Invalid aria prop %s on <%s> tag. ' +
                    'For details, see https://fb.me/invalid-aria-prop%s',
                  unknownPropString,
                  type,
                  getStackAddendum()
                );
              } else if (invalidProps.length > 1) {
                warning(
                  false,
                  'Invalid aria props %s on <%s> tag. ' +
                    'For details, see https://fb.me/invalid-aria-prop%s',
                  unknownPropString,
                  type,
                  getStackAddendum()
                );
              }
            }
            function validateProperties(type, props) {
              if (isCustomComponent(type, props)) {
                return;
              }
              warnInvalidARIAProps(type, props);
            }
            var didWarnValueNull = false;
            function getStackAddendum$1() {
              var stack = ReactDebugCurrentFrame.getStackAddendum();
              return stack != null ? stack : '';
            }
            function validateProperties$1(type, props) {
              if (
                type !== 'input' &&
                type !== 'textarea' &&
                type !== 'select'
              ) {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === 'select' && props.multiple) {
                  warning(
                    false,
                    '`value` prop on `%s` should not be null. ' +
                      'Consider using an empty array when `multiple` is set to `true` ' +
                      'to clear the component or `undefined` for uncontrolled components.%s',
                    type,
                    getStackAddendum$1()
                  );
                } else {
                  warning(
                    false,
                    '`value` prop on `%s` should not be null. ' +
                      'Consider using an empty string to clear the component or `undefined` ' +
                      'for uncontrolled components.%s',
                    type,
                    getStackAddendum$1()
                  );
                }
              }
            } // When adding attributes to the HTML or SVG whitelist, be sure to
            // also add them to this module to ensure casing and incorrect name
            // warnings.
            var possibleStandardNames = {
              // HTML
              accept: 'accept',
              acceptcharset: 'acceptCharset',
              'accept-charset': 'acceptCharset',
              accesskey: 'accessKey',
              action: 'action',
              allowfullscreen: 'allowFullScreen',
              alt: 'alt',
              as: 'as',
              async: 'async',
              autocapitalize: 'autoCapitalize',
              autocomplete: 'autoComplete',
              autocorrect: 'autoCorrect',
              autofocus: 'autoFocus',
              autoplay: 'autoPlay',
              autosave: 'autoSave',
              capture: 'capture',
              cellpadding: 'cellPadding',
              cellspacing: 'cellSpacing',
              challenge: 'challenge',
              charset: 'charSet',
              checked: 'checked',
              children: 'children',
              cite: 'cite',
              class: 'className',
              classid: 'classID',
              classname: 'className',
              cols: 'cols',
              colspan: 'colSpan',
              content: 'content',
              contenteditable: 'contentEditable',
              contextmenu: 'contextMenu',
              controls: 'controls',
              controlslist: 'controlsList',
              coords: 'coords',
              crossorigin: 'crossOrigin',
              dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
              data: 'data',
              datetime: 'dateTime',
              default: 'default',
              defaultchecked: 'defaultChecked',
              defaultvalue: 'defaultValue',
              defer: 'defer',
              dir: 'dir',
              disabled: 'disabled',
              download: 'download',
              draggable: 'draggable',
              enctype: 'encType',
              for: 'htmlFor',
              form: 'form',
              formmethod: 'formMethod',
              formaction: 'formAction',
              formenctype: 'formEncType',
              formnovalidate: 'formNoValidate',
              formtarget: 'formTarget',
              frameborder: 'frameBorder',
              headers: 'headers',
              height: 'height',
              hidden: 'hidden',
              high: 'high',
              href: 'href',
              hreflang: 'hrefLang',
              htmlfor: 'htmlFor',
              httpequiv: 'httpEquiv',
              'http-equiv': 'httpEquiv',
              icon: 'icon',
              id: 'id',
              innerhtml: 'innerHTML',
              inputmode: 'inputMode',
              integrity: 'integrity',
              is: 'is',
              itemid: 'itemID',
              itemprop: 'itemProp',
              itemref: 'itemRef',
              itemscope: 'itemScope',
              itemtype: 'itemType',
              keyparams: 'keyParams',
              keytype: 'keyType',
              kind: 'kind',
              label: 'label',
              lang: 'lang',
              list: 'list',
              loop: 'loop',
              low: 'low',
              manifest: 'manifest',
              marginwidth: 'marginWidth',
              marginheight: 'marginHeight',
              max: 'max',
              maxlength: 'maxLength',
              media: 'media',
              mediagroup: 'mediaGroup',
              method: 'method',
              min: 'min',
              minlength: 'minLength',
              multiple: 'multiple',
              muted: 'muted',
              name: 'name',
              nonce: 'nonce',
              novalidate: 'noValidate',
              open: 'open',
              optimum: 'optimum',
              pattern: 'pattern',
              placeholder: 'placeholder',
              playsinline: 'playsInline',
              poster: 'poster',
              preload: 'preload',
              profile: 'profile',
              radiogroup: 'radioGroup',
              readonly: 'readOnly',
              referrerpolicy: 'referrerPolicy',
              rel: 'rel',
              required: 'required',
              reversed: 'reversed',
              role: 'role',
              rows: 'rows',
              rowspan: 'rowSpan',
              sandbox: 'sandbox',
              scope: 'scope',
              scoped: 'scoped',
              scrolling: 'scrolling',
              seamless: 'seamless',
              selected: 'selected',
              shape: 'shape',
              size: 'size',
              sizes: 'sizes',
              span: 'span',
              spellcheck: 'spellCheck',
              src: 'src',
              srcdoc: 'srcDoc',
              srclang: 'srcLang',
              srcset: 'srcSet',
              start: 'start',
              step: 'step',
              style: 'style',
              summary: 'summary',
              tabindex: 'tabIndex',
              target: 'target',
              title: 'title',
              type: 'type',
              usemap: 'useMap',
              value: 'value',
              width: 'width',
              wmode: 'wmode',
              wrap: 'wrap', // SVG
              about: 'about',
              accentheight: 'accentHeight',
              'accent-height': 'accentHeight',
              accumulate: 'accumulate',
              additive: 'additive',
              alignmentbaseline: 'alignmentBaseline',
              'alignment-baseline': 'alignmentBaseline',
              allowreorder: 'allowReorder',
              alphabetic: 'alphabetic',
              amplitude: 'amplitude',
              arabicform: 'arabicForm',
              'arabic-form': 'arabicForm',
              ascent: 'ascent',
              attributename: 'attributeName',
              attributetype: 'attributeType',
              autoreverse: 'autoReverse',
              azimuth: 'azimuth',
              basefrequency: 'baseFrequency',
              baselineshift: 'baselineShift',
              'baseline-shift': 'baselineShift',
              baseprofile: 'baseProfile',
              bbox: 'bbox',
              begin: 'begin',
              bias: 'bias',
              by: 'by',
              calcmode: 'calcMode',
              capheight: 'capHeight',
              'cap-height': 'capHeight',
              clip: 'clip',
              clippath: 'clipPath',
              'clip-path': 'clipPath',
              clippathunits: 'clipPathUnits',
              cliprule: 'clipRule',
              'clip-rule': 'clipRule',
              color: 'color',
              colorinterpolation: 'colorInterpolation',
              'color-interpolation': 'colorInterpolation',
              colorinterpolationfilters: 'colorInterpolationFilters',
              'color-interpolation-filters': 'colorInterpolationFilters',
              colorprofile: 'colorProfile',
              'color-profile': 'colorProfile',
              colorrendering: 'colorRendering',
              'color-rendering': 'colorRendering',
              contentscripttype: 'contentScriptType',
              contentstyletype: 'contentStyleType',
              cursor: 'cursor',
              cx: 'cx',
              cy: 'cy',
              d: 'd',
              datatype: 'datatype',
              decelerate: 'decelerate',
              descent: 'descent',
              diffuseconstant: 'diffuseConstant',
              direction: 'direction',
              display: 'display',
              divisor: 'divisor',
              dominantbaseline: 'dominantBaseline',
              'dominant-baseline': 'dominantBaseline',
              dur: 'dur',
              dx: 'dx',
              dy: 'dy',
              edgemode: 'edgeMode',
              elevation: 'elevation',
              enablebackground: 'enableBackground',
              'enable-background': 'enableBackground',
              end: 'end',
              exponent: 'exponent',
              externalresourcesrequired: 'externalResourcesRequired',
              fill: 'fill',
              fillopacity: 'fillOpacity',
              'fill-opacity': 'fillOpacity',
              fillrule: 'fillRule',
              'fill-rule': 'fillRule',
              filter: 'filter',
              filterres: 'filterRes',
              filterunits: 'filterUnits',
              floodopacity: 'floodOpacity',
              'flood-opacity': 'floodOpacity',
              floodcolor: 'floodColor',
              'flood-color': 'floodColor',
              focusable: 'focusable',
              fontfamily: 'fontFamily',
              'font-family': 'fontFamily',
              fontsize: 'fontSize',
              'font-size': 'fontSize',
              fontsizeadjust: 'fontSizeAdjust',
              'font-size-adjust': 'fontSizeAdjust',
              fontstretch: 'fontStretch',
              'font-stretch': 'fontStretch',
              fontstyle: 'fontStyle',
              'font-style': 'fontStyle',
              fontvariant: 'fontVariant',
              'font-variant': 'fontVariant',
              fontweight: 'fontWeight',
              'font-weight': 'fontWeight',
              format: 'format',
              from: 'from',
              fx: 'fx',
              fy: 'fy',
              g1: 'g1',
              g2: 'g2',
              glyphname: 'glyphName',
              'glyph-name': 'glyphName',
              glyphorientationhorizontal: 'glyphOrientationHorizontal',
              'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
              glyphorientationvertical: 'glyphOrientationVertical',
              'glyph-orientation-vertical': 'glyphOrientationVertical',
              glyphref: 'glyphRef',
              gradienttransform: 'gradientTransform',
              gradientunits: 'gradientUnits',
              hanging: 'hanging',
              horizadvx: 'horizAdvX',
              'horiz-adv-x': 'horizAdvX',
              horizoriginx: 'horizOriginX',
              'horiz-origin-x': 'horizOriginX',
              ideographic: 'ideographic',
              imagerendering: 'imageRendering',
              'image-rendering': 'imageRendering',
              in2: 'in2',
              in: 'in',
              inlist: 'inlist',
              intercept: 'intercept',
              k1: 'k1',
              k2: 'k2',
              k3: 'k3',
              k4: 'k4',
              k: 'k',
              kernelmatrix: 'kernelMatrix',
              kernelunitlength: 'kernelUnitLength',
              kerning: 'kerning',
              keypoints: 'keyPoints',
              keysplines: 'keySplines',
              keytimes: 'keyTimes',
              lengthadjust: 'lengthAdjust',
              letterspacing: 'letterSpacing',
              'letter-spacing': 'letterSpacing',
              lightingcolor: 'lightingColor',
              'lighting-color': 'lightingColor',
              limitingconeangle: 'limitingConeAngle',
              local: 'local',
              markerend: 'markerEnd',
              'marker-end': 'markerEnd',
              markerheight: 'markerHeight',
              markermid: 'markerMid',
              'marker-mid': 'markerMid',
              markerstart: 'markerStart',
              'marker-start': 'markerStart',
              markerunits: 'markerUnits',
              markerwidth: 'markerWidth',
              mask: 'mask',
              maskcontentunits: 'maskContentUnits',
              maskunits: 'maskUnits',
              mathematical: 'mathematical',
              mode: 'mode',
              numoctaves: 'numOctaves',
              offset: 'offset',
              opacity: 'opacity',
              operator: 'operator',
              order: 'order',
              orient: 'orient',
              orientation: 'orientation',
              origin: 'origin',
              overflow: 'overflow',
              overlineposition: 'overlinePosition',
              'overline-position': 'overlinePosition',
              overlinethickness: 'overlineThickness',
              'overline-thickness': 'overlineThickness',
              paintorder: 'paintOrder',
              'paint-order': 'paintOrder',
              panose1: 'panose1',
              'panose-1': 'panose1',
              pathlength: 'pathLength',
              patterncontentunits: 'patternContentUnits',
              patterntransform: 'patternTransform',
              patternunits: 'patternUnits',
              pointerevents: 'pointerEvents',
              'pointer-events': 'pointerEvents',
              points: 'points',
              pointsatx: 'pointsAtX',
              pointsaty: 'pointsAtY',
              pointsatz: 'pointsAtZ',
              prefix: 'prefix',
              preservealpha: 'preserveAlpha',
              preserveaspectratio: 'preserveAspectRatio',
              primitiveunits: 'primitiveUnits',
              property: 'property',
              r: 'r',
              radius: 'radius',
              refx: 'refX',
              refy: 'refY',
              renderingintent: 'renderingIntent',
              'rendering-intent': 'renderingIntent',
              repeatcount: 'repeatCount',
              repeatdur: 'repeatDur',
              requiredextensions: 'requiredExtensions',
              requiredfeatures: 'requiredFeatures',
              resource: 'resource',
              restart: 'restart',
              result: 'result',
              results: 'results',
              rotate: 'rotate',
              rx: 'rx',
              ry: 'ry',
              scale: 'scale',
              security: 'security',
              seed: 'seed',
              shaperendering: 'shapeRendering',
              'shape-rendering': 'shapeRendering',
              slope: 'slope',
              spacing: 'spacing',
              specularconstant: 'specularConstant',
              specularexponent: 'specularExponent',
              speed: 'speed',
              spreadmethod: 'spreadMethod',
              startoffset: 'startOffset',
              stddeviation: 'stdDeviation',
              stemh: 'stemh',
              stemv: 'stemv',
              stitchtiles: 'stitchTiles',
              stopcolor: 'stopColor',
              'stop-color': 'stopColor',
              stopopacity: 'stopOpacity',
              'stop-opacity': 'stopOpacity',
              strikethroughposition: 'strikethroughPosition',
              'strikethrough-position': 'strikethroughPosition',
              strikethroughthickness: 'strikethroughThickness',
              'strikethrough-thickness': 'strikethroughThickness',
              string: 'string',
              stroke: 'stroke',
              strokedasharray: 'strokeDasharray',
              'stroke-dasharray': 'strokeDasharray',
              strokedashoffset: 'strokeDashoffset',
              'stroke-dashoffset': 'strokeDashoffset',
              strokelinecap: 'strokeLinecap',
              'stroke-linecap': 'strokeLinecap',
              strokelinejoin: 'strokeLinejoin',
              'stroke-linejoin': 'strokeLinejoin',
              strokemiterlimit: 'strokeMiterlimit',
              'stroke-miterlimit': 'strokeMiterlimit',
              strokewidth: 'strokeWidth',
              'stroke-width': 'strokeWidth',
              strokeopacity: 'strokeOpacity',
              'stroke-opacity': 'strokeOpacity',
              suppresscontenteditablewarning: 'suppressContentEditableWarning',
              suppresshydrationwarning: 'suppressHydrationWarning',
              surfacescale: 'surfaceScale',
              systemlanguage: 'systemLanguage',
              tablevalues: 'tableValues',
              targetx: 'targetX',
              targety: 'targetY',
              textanchor: 'textAnchor',
              'text-anchor': 'textAnchor',
              textdecoration: 'textDecoration',
              'text-decoration': 'textDecoration',
              textlength: 'textLength',
              textrendering: 'textRendering',
              'text-rendering': 'textRendering',
              to: 'to',
              transform: 'transform',
              typeof: 'typeof',
              u1: 'u1',
              u2: 'u2',
              underlineposition: 'underlinePosition',
              'underline-position': 'underlinePosition',
              underlinethickness: 'underlineThickness',
              'underline-thickness': 'underlineThickness',
              unicode: 'unicode',
              unicodebidi: 'unicodeBidi',
              'unicode-bidi': 'unicodeBidi',
              unicoderange: 'unicodeRange',
              'unicode-range': 'unicodeRange',
              unitsperem: 'unitsPerEm',
              'units-per-em': 'unitsPerEm',
              unselectable: 'unselectable',
              valphabetic: 'vAlphabetic',
              'v-alphabetic': 'vAlphabetic',
              values: 'values',
              vectoreffect: 'vectorEffect',
              'vector-effect': 'vectorEffect',
              version: 'version',
              vertadvy: 'vertAdvY',
              'vert-adv-y': 'vertAdvY',
              vertoriginx: 'vertOriginX',
              'vert-origin-x': 'vertOriginX',
              vertoriginy: 'vertOriginY',
              'vert-origin-y': 'vertOriginY',
              vhanging: 'vHanging',
              'v-hanging': 'vHanging',
              videographic: 'vIdeographic',
              'v-ideographic': 'vIdeographic',
              viewbox: 'viewBox',
              viewtarget: 'viewTarget',
              visibility: 'visibility',
              vmathematical: 'vMathematical',
              'v-mathematical': 'vMathematical',
              vocab: 'vocab',
              widths: 'widths',
              wordspacing: 'wordSpacing',
              'word-spacing': 'wordSpacing',
              writingmode: 'writingMode',
              'writing-mode': 'writingMode',
              x1: 'x1',
              x2: 'x2',
              x: 'x',
              xchannelselector: 'xChannelSelector',
              xheight: 'xHeight',
              'x-height': 'xHeight',
              xlinkactuate: 'xlinkActuate',
              'xlink:actuate': 'xlinkActuate',
              xlinkarcrole: 'xlinkArcrole',
              'xlink:arcrole': 'xlinkArcrole',
              xlinkhref: 'xlinkHref',
              'xlink:href': 'xlinkHref',
              xlinkrole: 'xlinkRole',
              'xlink:role': 'xlinkRole',
              xlinkshow: 'xlinkShow',
              'xlink:show': 'xlinkShow',
              xlinktitle: 'xlinkTitle',
              'xlink:title': 'xlinkTitle',
              xlinktype: 'xlinkType',
              'xlink:type': 'xlinkType',
              xmlbase: 'xmlBase',
              'xml:base': 'xmlBase',
              xmllang: 'xmlLang',
              'xml:lang': 'xmlLang',
              xmlns: 'xmlns',
              'xml:space': 'xmlSpace',
              xmlnsxlink: 'xmlnsXlink',
              'xmlns:xlink': 'xmlnsXlink',
              xmlspace: 'xmlSpace',
              y1: 'y1',
              y2: 'y2',
              y: 'y',
              ychannelselector: 'yChannelSelector',
              z: 'z',
              zoomandpan: 'zoomAndPan'
            };
            function getStackAddendum$2() {
              var stack = ReactDebugCurrentFrame.getStackAddendum();
              return stack != null ? stack : '';
            }
            {
              var warnedProperties$1 = {};
              var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
              var EVENT_NAME_REGEX = /^on./;
              var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
              var rARIA$1 = new RegExp(
                '^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$'
              );
              var rARIACamel$1 = new RegExp(
                '^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$'
              );
              var validateProperty$1 = function validateProperty$1(
                tagName,
                name,
                value,
                canUseEventSystem
              ) {
                if (
                  hasOwnProperty$1.call(warnedProperties$1, name) &&
                  warnedProperties$1[name]
                ) {
                  return true;
                }
                var lowerCasedName = name.toLowerCase();
                if (
                  lowerCasedName === 'onfocusin' ||
                  lowerCasedName === 'onfocusout'
                ) {
                  warning(
                    false,
                    'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' +
                      'All React events are normalized to bubble, so onFocusIn and onFocusOut ' +
                      'are not needed/supported by React.'
                  );
                  warnedProperties$1[name] = true;
                  return true;
                } // We can't rely on the event system being injected on the server.
                if (canUseEventSystem) {
                  if (registrationNameModules.hasOwnProperty(name)) {
                    return true;
                  }
                  var registrationName = possibleRegistrationNames.hasOwnProperty(
                    lowerCasedName
                  )
                    ? possibleRegistrationNames[lowerCasedName]
                    : null;
                  if (registrationName != null) {
                    warning(
                      false,
                      'Invalid event handler property `%s`. Did you mean `%s`?%s',
                      name,
                      registrationName,
                      getStackAddendum$2()
                    );
                    warnedProperties$1[name] = true;
                    return true;
                  }
                  if (EVENT_NAME_REGEX.test(name)) {
                    warning(
                      false,
                      'Unknown event handler property `%s`. It will be ignored.%s',
                      name,
                      getStackAddendum$2()
                    );
                    warnedProperties$1[name] = true;
                    return true;
                  }
                } else if (EVENT_NAME_REGEX.test(name)) {
                  // If no event plugins have been injected, we are in a server environment.
                  // So we can't tell if the event name is correct for sure, but we can filter
                  // out known bad ones like `onclick`. We can't suggest a specific replacement though.
                  if (INVALID_EVENT_NAME_REGEX.test(name)) {
                    warning(
                      false,
                      'Invalid event handler property `%s`. ' +
                        'React events use the camelCase naming convention, for example `onClick`.%s',
                      name,
                      getStackAddendum$2()
                    );
                  }
                  warnedProperties$1[name] = true;
                  return true;
                } // Let the ARIA attribute hook validate ARIA attributes
                if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                  return true;
                }
                if (lowerCasedName === 'innerhtml') {
                  warning(
                    false,
                    'Directly setting property `innerHTML` is not permitted. ' +
                      'For more information, lookup documentation on `dangerouslySetInnerHTML`.'
                  );
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (lowerCasedName === 'aria') {
                  warning(
                    false,
                    'The `aria` attribute is reserved for future use in React. ' +
                      'Pass individual `aria-` attributes instead.'
                  );
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (
                  lowerCasedName === 'is' &&
                  value !== null &&
                  value !== undefined &&
                  typeof value !== 'string'
                ) {
                  warning(
                    false,
                    'Received a `%s` for a string attribute `is`. If this is expected, cast ' +
                      'the value to a string.%s',
                    _typeof(value),
                    getStackAddendum$2()
                  );
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (typeof value === 'number' && isNaN(value)) {
                  warning(
                    false,
                    'Received NaN for the `%s` attribute. If this is expected, cast ' +
                      'the value to a string.%s',
                    name,
                    getStackAddendum$2()
                  );
                  warnedProperties$1[name] = true;
                  return true;
                }
                var isReserved = isReservedProp(name); // Known attributes should match the casing specified in the property config.
                if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                  var standardName = possibleStandardNames[lowerCasedName];
                  if (standardName !== name) {
                    warning(
                      false,
                      'Invalid DOM property `%s`. Did you mean `%s`?%s',
                      name,
                      standardName,
                      getStackAddendum$2()
                    );
                    warnedProperties$1[name] = true;
                    return true;
                  }
                } else if (!isReserved && name !== lowerCasedName) {
                  // Unknown attributes should have lowercase casing since that's how they
                  // will be cased anyway with server rendering.
                  warning(
                    false,
                    'React does not recognize the `%s` prop on a DOM element. If you ' +
                      'intentionally want it to appear in the DOM as a custom ' +
                      'attribute, spell it as lowercase `%s` instead. ' +
                      'If you accidentally passed it from a parent component, remove ' +
                      'it from the DOM element.%s',
                    name,
                    lowerCasedName,
                    getStackAddendum$2()
                  );
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (
                  typeof value === 'boolean' &&
                  !shouldAttributeAcceptBooleanValue(name)
                ) {
                  if (value) {
                    warning(
                      false,
                      'Received `%s` for a non-boolean attribute `%s`.\n\n' +
                        'If you want to write it to the DOM, pass a string instead: ' +
                        '%s="%s" or %s={value.toString()}.%s',
                      value,
                      name,
                      name,
                      value,
                      name,
                      getStackAddendum$2()
                    );
                  } else {
                    warning(
                      false,
                      'Received `%s` for a non-boolean attribute `%s`.\n\n' +
                        'If you want to write it to the DOM, pass a string instead: ' +
                        '%s="%s" or %s={value.toString()}.\n\n' +
                        'If you used to conditionally omit it with %s={condition && value}, ' +
                        'pass %s={condition ? value : undefined} instead.%s',
                      value,
                      name,
                      name,
                      value,
                      name,
                      name,
                      name,
                      getStackAddendum$2()
                    );
                  }
                  warnedProperties$1[name] = true;
                  return true;
                } // Now that we've validated casing, do not validate
                // data types for reserved props
                if (isReserved) {
                  return true;
                } // Warn when a known attribute is a bad type
                if (!shouldSetAttribute(name, value)) {
                  warnedProperties$1[name] = true;
                  return false;
                }
                return true;
              };
            }
            var warnUnknownProperties = function warnUnknownProperties(
              type,
              props,
              canUseEventSystem
            ) {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(
                  type,
                  key,
                  props[key],
                  canUseEventSystem
                );
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps
                .map(function(prop) {
                  return '`' + prop + '`';
                })
                .join(', ');
              if (unknownProps.length === 1) {
                warning(
                  false,
                  'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' +
                    'or pass a string or number value to keep it in the DOM. ' +
                    'For details, see https://fb.me/react-attribute-behavior%s',
                  unknownPropString,
                  type,
                  getStackAddendum$2()
                );
              } else if (unknownProps.length > 1) {
                warning(
                  false,
                  'Invalid values for props %s on <%s> tag. Either remove them from the element, ' +
                    'or pass a string or number value to keep them in the DOM. ' +
                    'For details, see https://fb.me/react-attribute-behavior%s',
                  unknownPropString,
                  type,
                  getStackAddendum$2()
                );
              }
            };
            function validateProperties$2(type, props, canUseEventSystem) {
              if (isCustomComponent(type, props)) {
                return;
              }
              warnUnknownProperties(type, props, canUseEventSystem);
            } // TODO: direct imports like some-package/src/* are bad. Fix me.
            var getCurrentFiberOwnerName$1 =
              ReactDebugCurrentFiber.getCurrentFiberOwnerName;
            var getCurrentFiberStackAddendum$2 =
              ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
            var didWarnInvalidHydration = false;
            var didWarnShadyDOM = false;
            var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
            var SUPPRESS_CONTENT_EDITABLE_WARNING =
              'suppressContentEditableWarning';
            var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
            var AUTOFOCUS = 'autoFocus';
            var CHILDREN = 'children';
            var STYLE = 'style';
            var HTML = '__html';
            var HTML_NAMESPACE = Namespaces.html;
            var getStack = emptyFunction.thatReturns('');
            {
              getStack = getCurrentFiberStackAddendum$2;
              var warnedUnknownTags = {
                // Chrome is the only major browser not shipping <time>. But as of July
                // 2017 it intends to ship it due to widespread usage. We intentionally
                // *don't* warn for <time> even if it's unrecognized by Chrome because
                // it soon will be, and many apps have been using it anyway.
                time: true, // There are working polyfills for <dialog>. Let people use it.
                dialog: true
              };
              var validatePropertiesInDevelopment = function validatePropertiesInDevelopment(
                type,
                props
              ) {
                validateProperties(type, props);
                validateProperties$1(type, props);
                validateProperties$2(type, props, /* canUseEventSystem */ true);
              }; // HTML parsing normalizes CR and CRLF to LF.
              // It also can turn \u0000 into \uFFFD inside attributes.
              // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
              // If we have a mismatch, it might be caused by that.
              // We will still patch up in this case but not fire the warning.
              var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
              var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
              var normalizeMarkupForTextOrAttribute = function normalizeMarkupForTextOrAttribute(
                markup
              ) {
                var markupString =
                  typeof markup === 'string' ? markup : '' + markup;
                return markupString
                  .replace(NORMALIZE_NEWLINES_REGEX, '\n')
                  .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
              };
              var warnForTextDifference = function warnForTextDifference(
                serverText,
                clientText
              ) {
                if (didWarnInvalidHydration) {
                  return;
                }
                var normalizedClientText = normalizeMarkupForTextOrAttribute(
                  clientText
                );
                var normalizedServerText = normalizeMarkupForTextOrAttribute(
                  serverText
                );
                if (normalizedServerText === normalizedClientText) {
                  return;
                }
                didWarnInvalidHydration = true;
                warning(
                  false,
                  'Text content did not match. Server: "%s" Client: "%s"',
                  normalizedServerText,
                  normalizedClientText
                );
              };
              var warnForPropDifference = function warnForPropDifference(
                propName,
                serverValue,
                clientValue
              ) {
                if (didWarnInvalidHydration) {
                  return;
                }
                var normalizedClientValue = normalizeMarkupForTextOrAttribute(
                  clientValue
                );
                var normalizedServerValue = normalizeMarkupForTextOrAttribute(
                  serverValue
                );
                if (normalizedServerValue === normalizedClientValue) {
                  return;
                }
                didWarnInvalidHydration = true;
                warning(
                  false,
                  'Prop `%s` did not match. Server: %s Client: %s',
                  propName,
                  JSON.stringify(normalizedServerValue),
                  JSON.stringify(normalizedClientValue)
                );
              };
              var warnForExtraAttributes = function warnForExtraAttributes(
                attributeNames
              ) {
                if (didWarnInvalidHydration) {
                  return;
                }
                didWarnInvalidHydration = true;
                var names = [];
                attributeNames.forEach(function(name) {
                  names.push(name);
                });
                warning(false, 'Extra attributes from the server: %s', names);
              };
              var warnForInvalidEventListener = function warnForInvalidEventListener(
                registrationName,
                listener
              ) {
                if (listener === false) {
                  warning(
                    false,
                    'Expected `%s` listener to be a function, instead got `false`.\n\n' +
                      'If you used to conditionally omit it with %s={condition && value}, ' +
                      'pass %s={condition ? value : undefined} instead.%s',
                    registrationName,
                    registrationName,
                    registrationName,
                    getCurrentFiberStackAddendum$2()
                  );
                } else {
                  warning(
                    false,
                    'Expected `%s` listener to be a function, instead got a value of `%s` type.%s',
                    registrationName,
                    _typeof(listener),
                    getCurrentFiberStackAddendum$2()
                  );
                }
              }; // Parse the HTML and read it back to normalize the HTML string so that it
              // can be used for comparison.
              var normalizeHTML = function normalizeHTML(parent, html) {
                // We could have created a separate document here to avoid
                // re-initializing custom elements if they exist. But this breaks
                // how <noscript> is being handled. So we use the same document.
                // See the discussion in https://github.com/facebook/react/pull/11157.
                var testElement =
                  parent.namespaceURI === HTML_NAMESPACE
                    ? parent.ownerDocument.createElement(parent.tagName)
                    : parent.ownerDocument.createElementNS(
                        parent.namespaceURI,
                        parent.tagName
                      );
                testElement.innerHTML = html;
                return testElement.innerHTML;
              };
            }
            function ensureListeningTo(rootContainerElement, registrationName) {
              var isDocumentOrFragment =
                rootContainerElement.nodeType === DOCUMENT_NODE ||
                rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
              var doc = isDocumentOrFragment
                ? rootContainerElement
                : rootContainerElement.ownerDocument;
              listenTo(registrationName, doc);
            }
            function getOwnerDocumentFromRootContainer(rootContainerElement) {
              return rootContainerElement.nodeType === DOCUMENT_NODE
                ? rootContainerElement
                : rootContainerElement.ownerDocument;
            } // There are so many media events, it makes sense to just
            // maintain a list rather than create a `trapBubbledEvent` for each
            var mediaEvents = {
              topAbort: 'abort',
              topCanPlay: 'canplay',
              topCanPlayThrough: 'canplaythrough',
              topDurationChange: 'durationchange',
              topEmptied: 'emptied',
              topEncrypted: 'encrypted',
              topEnded: 'ended',
              topError: 'error',
              topLoadedData: 'loadeddata',
              topLoadedMetadata: 'loadedmetadata',
              topLoadStart: 'loadstart',
              topPause: 'pause',
              topPlay: 'play',
              topPlaying: 'playing',
              topProgress: 'progress',
              topRateChange: 'ratechange',
              topSeeked: 'seeked',
              topSeeking: 'seeking',
              topStalled: 'stalled',
              topSuspend: 'suspend',
              topTimeUpdate: 'timeupdate',
              topVolumeChange: 'volumechange',
              topWaiting: 'waiting'
            };
            function trapClickOnNonInteractiveElement(node) {
              // Mobile Safari does not fire properly bubble click events on
              // non-interactive elements, which means delegated click listeners do not
              // fire. The workaround for this bug involves attaching an empty click
              // listener on the target node.
              // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
              // Just set it using the onclick property so that we don't have to manage any
              // bookkeeping for it. Not sure if we need to clear it when the listener is
              // removed.
              // TODO: Only do this for the relevant Safaris maybe?
              node.onclick = emptyFunction;
            }
            function setInitialDOMProperties(
              tag,
              domElement,
              rootContainerElement,
              nextProps,
              isCustomComponentTag
            ) {
              for (var propKey in nextProps) {
                if (!nextProps.hasOwnProperty(propKey)) {
                  continue;
                }
                var nextProp = nextProps[propKey];
                if (propKey === STYLE) {
                  {
                    if (nextProp) {
                      // Freeze the next style object so that we can assume it won't be
                      // mutated. We have already warned for this in the past.
                      Object.freeze(nextProp);
                    }
                  } // Relies on `updateStylesByID` not mutating `styleUpdates`.
                  setValueForStyles(domElement, nextProp, getStack);
                } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var nextHtml = nextProp ? nextProp[HTML] : undefined;
                  if (nextHtml != null) {
                    setInnerHTML(domElement, nextHtml);
                  }
                } else if (propKey === CHILDREN) {
                  if (typeof nextProp === 'string') {
                    // Avoid setting initial textContent when the text is empty. In IE11 setting
                    // textContent on a <textarea> will cause the placeholder to not
                    // show within the <textarea> until it has been focused and blurred again.
                    // https://github.com/facebook/react/issues/6731#issuecomment-254874553
                    var canSetTextContent =
                      tag !== 'textarea' || nextProp !== '';
                    if (canSetTextContent) {
                      setTextContent(domElement, nextProp);
                    }
                  } else if (typeof nextProp === 'number') {
                    setTextContent(domElement, '' + nextProp);
                  }
                } else if (
                  propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
                  propKey === SUPPRESS_HYDRATION_WARNING$1
                ) {
                  // Noop
                } else if (propKey === AUTOFOCUS) {
                  // We polyfill it separately on the client during commit.
                  // We blacklist it here rather than in the property list because we emit it in SSR.
                } else if (registrationNameModules.hasOwnProperty(propKey)) {
                  if (nextProp != null) {
                    if (true && typeof nextProp !== 'function') {
                      warnForInvalidEventListener(propKey, nextProp);
                    }
                    ensureListeningTo(rootContainerElement, propKey);
                  }
                } else if (isCustomComponentTag) {
                  setValueForAttribute(domElement, propKey, nextProp);
                } else if (nextProp != null) {
                  // If we're updating to null or undefined, we should remove the property
                  // from the DOM node instead of inadvertently setting to a string. This
                  // brings us in line with the same behavior we have on initial render.
                  setValueForProperty(domElement, propKey, nextProp);
                }
              }
            }
            function updateDOMProperties(
              domElement,
              updatePayload,
              wasCustomComponentTag,
              isCustomComponentTag
            ) {
              // TODO: Handle wasCustomComponentTag
              for (var i = 0; i < updatePayload.length; i += 2) {
                var propKey = updatePayload[i];
                var propValue = updatePayload[i + 1];
                if (propKey === STYLE) {
                  setValueForStyles(domElement, propValue, getStack);
                } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  setInnerHTML(domElement, propValue);
                } else if (propKey === CHILDREN) {
                  setTextContent(domElement, propValue);
                } else if (isCustomComponentTag) {
                  if (propValue != null) {
                    setValueForAttribute(domElement, propKey, propValue);
                  } else {
                    deleteValueForAttribute(domElement, propKey);
                  }
                } else if (propValue != null) {
                  setValueForProperty(domElement, propKey, propValue);
                } else {
                  // If we're updating to null or undefined, we should remove the property
                  // from the DOM node instead of inadvertently setting to a string. This
                  // brings us in line with the same behavior we have on initial render.
                  deleteValueForProperty(domElement, propKey);
                }
              }
            }
            function createElement$1(
              type,
              props,
              rootContainerElement,
              parentNamespace
            ) {
              // We create tags in the namespace of their parent container, except HTML
              var ownerDocument = getOwnerDocumentFromRootContainer(
                rootContainerElement
              );
              var domElement;
              var namespaceURI = parentNamespace;
              if (namespaceURI === HTML_NAMESPACE) {
                namespaceURI = getIntrinsicNamespace(type);
              }
              if (namespaceURI === HTML_NAMESPACE) {
                {
                  var isCustomComponentTag = isCustomComponent(type, props); // Should this check be gated by parent namespace? Not sure we want to
                  // allow <SVG> or <mATH>.
                  warning(
                    isCustomComponentTag || type === type.toLowerCase(),
                    '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' +
                      'in React.',
                    type
                  );
                }
                if (type === 'script') {
                  // Create the script via .innerHTML so its "parser-inserted" flag is
                  // set to true and it does not execute
                  var div = ownerDocument.createElement('div');
                  div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
                  // This is guaranteed to yield a script element.
                  var firstChild = div.firstChild;
                  domElement = div.removeChild(firstChild);
                } else if (typeof props.is === 'string') {
                  // $FlowIssue `createElement` should be updated for Web Components
                  domElement = ownerDocument.createElement(type, {
                    is: props.is
                  });
                } else {
                  // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
                  // See discussion in https://github.com/facebook/react/pull/6896
                  // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
                  domElement = ownerDocument.createElement(type);
                }
              } else {
                domElement = ownerDocument.createElementNS(namespaceURI, type);
              }
              {
                if (namespaceURI === HTML_NAMESPACE) {
                  if (
                    !isCustomComponentTag &&
                    Object.prototype.toString.call(domElement) ===
                      '[object HTMLUnknownElement]' &&
                    !Object.prototype.hasOwnProperty.call(
                      warnedUnknownTags,
                      type
                    )
                  ) {
                    warnedUnknownTags[type] = true;
                    warning(
                      false,
                      'The tag <%s> is unrecognized in this browser. ' +
                        'If you meant to render a React component, start its name with ' +
                        'an uppercase letter.',
                      type
                    );
                  }
                }
              }
              return domElement;
            }
            function createTextNode$1(text, rootContainerElement) {
              return getOwnerDocumentFromRootContainer(
                rootContainerElement
              ).createTextNode(text);
            }
            function setInitialProperties$1(
              domElement,
              tag,
              rawProps,
              rootContainerElement
            ) {
              var isCustomComponentTag = isCustomComponent(tag, rawProps);
              {
                validatePropertiesInDevelopment(tag, rawProps);
                if (
                  isCustomComponentTag &&
                  !didWarnShadyDOM &&
                  domElement.shadyRoot
                ) {
                  warning(
                    false,
                    '%s is using shady DOM. Using shady DOM with React can ' +
                      'cause things to break subtly.',
                    getCurrentFiberOwnerName$1() || 'A component'
                  );
                  didWarnShadyDOM = true;
                }
              } // TODO: Make sure that we check isMounted before firing any of these events.
              var props;
              switch (tag) {
                case 'iframe':
                case 'object':
                  trapBubbledEvent('topLoad', 'load', domElement);
                  props = rawProps;
                  break;
                case 'video':
                case 'audio': // Create listener for each media event
                  for (var event in mediaEvents) {
                    if (mediaEvents.hasOwnProperty(event)) {
                      trapBubbledEvent(event, mediaEvents[event], domElement);
                    }
                  }
                  props = rawProps;
                  break;
                case 'source':
                  trapBubbledEvent('topError', 'error', domElement);
                  props = rawProps;
                  break;
                case 'img':
                case 'image':
                  trapBubbledEvent('topError', 'error', domElement);
                  trapBubbledEvent('topLoad', 'load', domElement);
                  props = rawProps;
                  break;
                case 'form':
                  trapBubbledEvent('topReset', 'reset', domElement);
                  trapBubbledEvent('topSubmit', 'submit', domElement);
                  props = rawProps;
                  break;
                case 'details':
                  trapBubbledEvent('topToggle', 'toggle', domElement);
                  props = rawProps;
                  break;
                case 'input':
                  initWrapperState(domElement, rawProps);
                  props = getHostProps(domElement, rawProps);
                  trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening
                  // to onChange. Even if there is no listener.
                  ensureListeningTo(rootContainerElement, 'onChange');
                  break;
                case 'option':
                  validateProps(domElement, rawProps);
                  props = getHostProps$1(domElement, rawProps);
                  break;
                case 'select':
                  initWrapperState$1(domElement, rawProps);
                  props = getHostProps$2(domElement, rawProps);
                  trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening
                  // to onChange. Even if there is no listener.
                  ensureListeningTo(rootContainerElement, 'onChange');
                  break;
                case 'textarea':
                  initWrapperState$2(domElement, rawProps);
                  props = getHostProps$3(domElement, rawProps);
                  trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening
                  // to onChange. Even if there is no listener.
                  ensureListeningTo(rootContainerElement, 'onChange');
                  break;
                default:
                  props = rawProps;
              }
              assertValidProps(tag, props, getStack);
              setInitialDOMProperties(
                tag,
                domElement,
                rootContainerElement,
                props,
                isCustomComponentTag
              );
              switch (tag) {
                case 'input': // TODO: Make sure we check if this is still unmounted or do any clean
                  // up necessary since we never stop tracking anymore.
                  track(domElement);
                  postMountWrapper(domElement, rawProps);
                  break;
                case 'textarea': // TODO: Make sure we check if this is still unmounted or do any clean
                  // up necessary since we never stop tracking anymore.
                  track(domElement);
                  postMountWrapper$3(domElement, rawProps);
                  break;
                case 'option':
                  postMountWrapper$1(domElement, rawProps);
                  break;
                case 'select':
                  postMountWrapper$2(domElement, rawProps);
                  break;
                default:
                  if (typeof props.onClick === 'function') {
                    // TODO: This cast may not be sound for SVG, MathML or custom elements.
                    trapClickOnNonInteractiveElement(domElement);
                  }
                  break;
              }
            } // Calculate the diff between the two objects.
            function diffProperties$1(
              domElement,
              tag,
              lastRawProps,
              nextRawProps,
              rootContainerElement
            ) {
              {
                validatePropertiesInDevelopment(tag, nextRawProps);
              }
              var updatePayload = null;
              var lastProps;
              var nextProps;
              switch (tag) {
                case 'input':
                  lastProps = getHostProps(domElement, lastRawProps);
                  nextProps = getHostProps(domElement, nextRawProps);
                  updatePayload = [];
                  break;
                case 'option':
                  lastProps = getHostProps$1(domElement, lastRawProps);
                  nextProps = getHostProps$1(domElement, nextRawProps);
                  updatePayload = [];
                  break;
                case 'select':
                  lastProps = getHostProps$2(domElement, lastRawProps);
                  nextProps = getHostProps$2(domElement, nextRawProps);
                  updatePayload = [];
                  break;
                case 'textarea':
                  lastProps = getHostProps$3(domElement, lastRawProps);
                  nextProps = getHostProps$3(domElement, nextRawProps);
                  updatePayload = [];
                  break;
                default:
                  lastProps = lastRawProps;
                  nextProps = nextRawProps;
                  if (
                    typeof lastProps.onClick !== 'function' &&
                    typeof nextProps.onClick === 'function'
                  ) {
                    // TODO: This cast may not be sound for SVG, MathML or custom elements.
                    trapClickOnNonInteractiveElement(domElement);
                  }
                  break;
              }
              assertValidProps(tag, nextProps, getStack);
              var propKey;
              var styleName;
              var styleUpdates = null;
              for (propKey in lastProps) {
                if (
                  nextProps.hasOwnProperty(propKey) ||
                  !lastProps.hasOwnProperty(propKey) ||
                  lastProps[propKey] == null
                ) {
                  continue;
                }
                if (propKey === STYLE) {
                  var lastStyle = lastProps[propKey];
                  for (styleName in lastStyle) {
                    if (lastStyle.hasOwnProperty(styleName)) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = '';
                    }
                  }
                } else if (
                  propKey === DANGEROUSLY_SET_INNER_HTML ||
                  propKey === CHILDREN
                ) {
                  // Noop. This is handled by the clear text mechanism.
                } else if (
                  propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
                  propKey === SUPPRESS_HYDRATION_WARNING$1
                ) {
                  // Noop
                } else if (propKey === AUTOFOCUS) {
                  // Noop. It doesn't work on updates anyway.
                } else if (registrationNameModules.hasOwnProperty(propKey)) {
                  // This is a special case. If any listener updates we need to ensure
                  // that the "current" fiber pointer gets updated so we need a commit
                  // to update this element.
                  if (!updatePayload) {
                    updatePayload = [];
                  }
                } else {
                  // For all other deleted properties we add it to the queue. We use
                  // the whitelist in the commit phase instead.
                  (updatePayload = updatePayload || []).push(propKey, null);
                }
              }
              for (propKey in nextProps) {
                var nextProp = nextProps[propKey];
                var lastProp =
                  lastProps != null ? lastProps[propKey] : undefined;
                if (
                  !nextProps.hasOwnProperty(propKey) ||
                  nextProp === lastProp ||
                  (nextProp == null && lastProp == null)
                ) {
                  continue;
                }
                if (propKey === STYLE) {
                  {
                    if (nextProp) {
                      // Freeze the next style object so that we can assume it won't be
                      // mutated. We have already warned for this in the past.
                      Object.freeze(nextProp);
                    }
                  }
                  if (lastProp) {
                    // Unset styles on `lastProp` but not on `nextProp`.
                    for (styleName in lastProp) {
                      if (
                        lastProp.hasOwnProperty(styleName) &&
                        (!nextProp || !nextProp.hasOwnProperty(styleName))
                      ) {
                        if (!styleUpdates) {
                          styleUpdates = {};
                        }
                        styleUpdates[styleName] = '';
                      }
                    } // Update styles that changed since `lastProp`.
                    for (styleName in nextProp) {
                      if (
                        nextProp.hasOwnProperty(styleName) &&
                        lastProp[styleName] !== nextProp[styleName]
                      ) {
                        if (!styleUpdates) {
                          styleUpdates = {};
                        }
                        styleUpdates[styleName] = nextProp[styleName];
                      }
                    }
                  } else {
                    // Relies on `updateStylesByID` not mutating `styleUpdates`.
                    if (!styleUpdates) {
                      if (!updatePayload) {
                        updatePayload = [];
                      }
                      updatePayload.push(propKey, styleUpdates);
                    }
                    styleUpdates = nextProp;
                  }
                } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var nextHtml = nextProp ? nextProp[HTML] : undefined;
                  var lastHtml = lastProp ? lastProp[HTML] : undefined;
                  if (nextHtml != null) {
                    if (lastHtml !== nextHtml) {
                      (updatePayload = updatePayload || []).push(
                        propKey,
                        '' + nextHtml
                      );
                    }
                  } else {
                    // TODO: It might be too late to clear this if we have children
                    // inserted already.
                  }
                } else if (propKey === CHILDREN) {
                  if (
                    lastProp !== nextProp &&
                    (typeof nextProp === 'string' ||
                      typeof nextProp === 'number')
                  ) {
                    (updatePayload = updatePayload || []).push(
                      propKey,
                      '' + nextProp
                    );
                  }
                } else if (
                  propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
                  propKey === SUPPRESS_HYDRATION_WARNING$1
                ) {
                  // Noop
                } else if (registrationNameModules.hasOwnProperty(propKey)) {
                  if (nextProp != null) {
                    // We eagerly listen to this even though we haven't committed yet.
                    if (true && typeof nextProp !== 'function') {
                      warnForInvalidEventListener(propKey, nextProp);
                    }
                    ensureListeningTo(rootContainerElement, propKey);
                  }
                  if (!updatePayload && lastProp !== nextProp) {
                    // This is a special case. If any listener updates we need to ensure
                    // that the "current" props pointer gets updated so we need a commit
                    // to update this element.
                    updatePayload = [];
                  }
                } else {
                  // For any other property we always add it to the queue and then we
                  // filter it out using the whitelist during the commit.
                  (updatePayload = updatePayload || []).push(propKey, nextProp);
                }
              }
              if (styleUpdates) {
                (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
              }
              return updatePayload;
            } // Apply the diff.
            function updateProperties$1(
              domElement,
              updatePayload,
              tag,
              lastRawProps,
              nextRawProps
            ) {
              // Update checked *before* name.
              // In the middle of an update, it is possible to have multiple checked.
              // When a checked radio tries to change name, browser makes another radio's checked false.
              if (
                tag === 'input' &&
                nextRawProps.type === 'radio' &&
                nextRawProps.name != null
              ) {
                updateChecked(domElement, nextRawProps);
              }
              var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
              var isCustomComponentTag = isCustomComponent(tag, nextRawProps); // Apply the diff.
              updateDOMProperties(
                domElement,
                updatePayload,
                wasCustomComponentTag,
                isCustomComponentTag
              ); // TODO: Ensure that an update gets scheduled if any of the special props
              // changed.
              switch (tag) {
                case 'input': // Update the wrapper around inputs *after* updating props. This has to
                  // happen after `updateDOMProperties`. Otherwise HTML5 input validations
                  // raise warnings and prevent the new value from being assigned.
                  updateWrapper(domElement, nextRawProps);
                  break;
                case 'textarea':
                  updateWrapper$1(domElement, nextRawProps);
                  break;
                case 'select': // <select> value update needs to occur after <option> children
                  // reconciliation
                  postUpdateWrapper(domElement, nextRawProps);
                  break;
              }
            }
            function diffHydratedProperties$1(
              domElement,
              tag,
              rawProps,
              parentNamespace,
              rootContainerElement
            ) {
              {
                var suppressHydrationWarning =
                  rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
                var isCustomComponentTag = isCustomComponent(tag, rawProps);
                validatePropertiesInDevelopment(tag, rawProps);
                if (
                  isCustomComponentTag &&
                  !didWarnShadyDOM &&
                  domElement.shadyRoot
                ) {
                  warning(
                    false,
                    '%s is using shady DOM. Using shady DOM with React can ' +
                      'cause things to break subtly.',
                    getCurrentFiberOwnerName$1() || 'A component'
                  );
                  didWarnShadyDOM = true;
                }
              } // TODO: Make sure that we check isMounted before firing any of these events.
              switch (tag) {
                case 'iframe':
                case 'object':
                  trapBubbledEvent('topLoad', 'load', domElement);
                  break;
                case 'video':
                case 'audio': // Create listener for each media event
                  for (var event in mediaEvents) {
                    if (mediaEvents.hasOwnProperty(event)) {
                      trapBubbledEvent(event, mediaEvents[event], domElement);
                    }
                  }
                  break;
                case 'source':
                  trapBubbledEvent('topError', 'error', domElement);
                  break;
                case 'img':
                case 'image':
                  trapBubbledEvent('topError', 'error', domElement);
                  trapBubbledEvent('topLoad', 'load', domElement);
                  break;
                case 'form':
                  trapBubbledEvent('topReset', 'reset', domElement);
                  trapBubbledEvent('topSubmit', 'submit', domElement);
                  break;
                case 'details':
                  trapBubbledEvent('topToggle', 'toggle', domElement);
                  break;
                case 'input':
                  initWrapperState(domElement, rawProps);
                  trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening
                  // to onChange. Even if there is no listener.
                  ensureListeningTo(rootContainerElement, 'onChange');
                  break;
                case 'option':
                  validateProps(domElement, rawProps);
                  break;
                case 'select':
                  initWrapperState$1(domElement, rawProps);
                  trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening
                  // to onChange. Even if there is no listener.
                  ensureListeningTo(rootContainerElement, 'onChange');
                  break;
                case 'textarea':
                  initWrapperState$2(domElement, rawProps);
                  trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening
                  // to onChange. Even if there is no listener.
                  ensureListeningTo(rootContainerElement, 'onChange');
                  break;
              }
              assertValidProps(tag, rawProps, getStack);
              {
                var extraAttributeNames = new Set();
                var attributes = domElement.attributes;
                for (var i = 0; i < attributes.length; i++) {
                  var name = attributes[i].name.toLowerCase();
                  switch (name) { // Built-in SSR attribute is whitelisted
                    case 'data-reactroot':
                      break; // Controlled attributes are not validated
                    // TODO: Only ignore them on controlled tags.
                    case 'value':
                      break;
                    case 'checked':
                      break;
                    case 'selected':
                      break;
                    default:
                      // Intentionally use the original name.
                      // See discussion in https://github.com/facebook/react/pull/10676.
                      extraAttributeNames.add(attributes[i].name);
                  }
                }
              }
              var updatePayload = null;
              for (var propKey in rawProps) {
                if (!rawProps.hasOwnProperty(propKey)) {
                  continue;
                }
                var nextProp = rawProps[propKey];
                if (propKey === CHILDREN) {
                  // For text content children we compare against textContent. This
                  // might match additional HTML that is hidden when we read it using
                  // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
                  // satisfies our requirement. Our requirement is not to produce perfect
                  // HTML and attributes. Ideally we should preserve structure but it's
                  // ok not to if the visible content is still enough to indicate what
                  // even listeners these nodes might be wired up to.
                  // TODO: Warn if there is more than a single textNode as a child.
                  // TODO: Should we use domElement.firstChild.nodeValue to compare?
                  if (typeof nextProp === 'string') {
                    if (domElement.textContent !== nextProp) {
                      if (true && !suppressHydrationWarning) {
                        warnForTextDifference(domElement.textContent, nextProp);
                      }
                      updatePayload = [CHILDREN, nextProp];
                    }
                  } else if (typeof nextProp === 'number') {
                    if (domElement.textContent !== '' + nextProp) {
                      if (true && !suppressHydrationWarning) {
                        warnForTextDifference(domElement.textContent, nextProp);
                      }
                      updatePayload = [CHILDREN, '' + nextProp];
                    }
                  }
                } else if (registrationNameModules.hasOwnProperty(propKey)) {
                  if (nextProp != null) {
                    if (true && typeof nextProp !== 'function') {
                      warnForInvalidEventListener(propKey, nextProp);
                    }
                    ensureListeningTo(rootContainerElement, propKey);
                  }
                } else {
                  // Validate that the properties correspond to their expected values.
                  var serverValue;
                  var propertyInfo;
                  if (suppressHydrationWarning) {
                    // Don't bother comparing. We're ignoring all these warnings.
                  } else if (
                    propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
                    propKey === SUPPRESS_HYDRATION_WARNING$1 || // Controlled attributes are not validated
                    // TODO: Only ignore them on controlled tags.
                    propKey === 'value' ||
                    propKey === 'checked' ||
                    propKey === 'selected'
                  ) {
                    // Noop
                  } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                    var rawHtml = nextProp ? nextProp[HTML] || '' : '';
                    var serverHTML = domElement.innerHTML;
                    var expectedHTML = normalizeHTML(domElement, rawHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  } else if (propKey === STYLE) {
                    // $FlowFixMe - Should be inferred as not undefined.
                    extraAttributeNames['delete'](propKey);
                    var expectedStyle = createDangerousStringForStyles(
                      nextProp
                    );
                    serverValue = domElement.getAttribute('style');
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(
                        propKey,
                        serverValue,
                        expectedStyle
                      );
                    }
                  } else if (isCustomComponentTag) {
                    // $FlowFixMe - Should be inferred as not undefined.
                    extraAttributeNames['delete'](propKey.toLowerCase());
                    serverValue = getValueForAttribute(
                      domElement,
                      propKey,
                      nextProp
                    );
                    if (nextProp !== serverValue) {
                      warnForPropDifference(propKey, serverValue, nextProp);
                    }
                  } else if (shouldSetAttribute(propKey, nextProp)) {
                    if ((propertyInfo = getPropertyInfo(propKey))) {
                      // $FlowFixMe - Should be inferred as not undefined.
                      extraAttributeNames['delete'](propertyInfo.attributeName);
                      serverValue = getValueForProperty(
                        domElement,
                        propKey,
                        nextProp
                      );
                    } else {
                      var ownNamespace = parentNamespace;
                      if (ownNamespace === HTML_NAMESPACE) {
                        ownNamespace = getIntrinsicNamespace(tag);
                      }
                      if (ownNamespace === HTML_NAMESPACE) {
                        // $FlowFixMe - Should be inferred as not undefined.
                        extraAttributeNames['delete'](propKey.toLowerCase());
                      } else {
                        // $FlowFixMe - Should be inferred as not undefined.
                        extraAttributeNames['delete'](propKey);
                      }
                      serverValue = getValueForAttribute(
                        domElement,
                        propKey,
                        nextProp
                      );
                    }
                    if (nextProp !== serverValue) {
                      warnForPropDifference(propKey, serverValue, nextProp);
                    }
                  }
                }
              }
              {
                // $FlowFixMe - Should be inferred as not undefined.
                if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
                  // $FlowFixMe - Should be inferred as not undefined.
                  warnForExtraAttributes(extraAttributeNames);
                }
              }
              switch (tag) {
                case 'input': // TODO: Make sure we check if this is still unmounted or do any clean
                  // up necessary since we never stop tracking anymore.
                  track(domElement);
                  postMountWrapper(domElement, rawProps);
                  break;
                case 'textarea': // TODO: Make sure we check if this is still unmounted or do any clean
                  // up necessary since we never stop tracking anymore.
                  track(domElement);
                  postMountWrapper$3(domElement, rawProps);
                  break;
                case 'select':
                case 'option': // For input and textarea we current always set the value property at
                  // post mount to force it to diverge from attributes. However, for
                  // option and select we don't quite do the same thing and select
                  // is not resilient to the DOM state changing so we don't do that here.
                  // TODO: Consider not doing this for input and textarea.
                  break;
                default:
                  if (typeof rawProps.onClick === 'function') {
                    // TODO: This cast may not be sound for SVG, MathML or custom elements.
                    trapClickOnNonInteractiveElement(domElement);
                  }
                  break;
              }
              return updatePayload;
            }
            function diffHydratedText$1(textNode, text) {
              var isDifferent = textNode.nodeValue !== text;
              return isDifferent;
            }
            function warnForUnmatchedText$1(textNode, text) {
              {
                warnForTextDifference(textNode.nodeValue, text);
              }
            }
            function warnForDeletedHydratableElement$1(parentNode, child) {
              {
                if (didWarnInvalidHydration) {
                  return;
                }
                didWarnInvalidHydration = true;
                warning(
                  false,
                  'Did not expect server HTML to contain a <%s> in <%s>.',
                  child.nodeName.toLowerCase(),
                  parentNode.nodeName.toLowerCase()
                );
              }
            }
            function warnForDeletedHydratableText$1(parentNode, child) {
              {
                if (didWarnInvalidHydration) {
                  return;
                }
                didWarnInvalidHydration = true;
                warning(
                  false,
                  'Did not expect server HTML to contain the text node "%s" in <%s>.',
                  child.nodeValue,
                  parentNode.nodeName.toLowerCase()
                );
              }
            }
            function warnForInsertedHydratedElement$1(parentNode, tag, props) {
              {
                if (didWarnInvalidHydration) {
                  return;
                }
                didWarnInvalidHydration = true;
                warning(
                  false,
                  'Expected server HTML to contain a matching <%s> in <%s>.',
                  tag,
                  parentNode.nodeName.toLowerCase()
                );
              }
            }
            function warnForInsertedHydratedText$1(parentNode, text) {
              {
                if (text === '') {
                  // We expect to insert empty text nodes since they're not represented in
                  // the HTML.
                  // TODO: Remove this special case if we can just avoid inserting empty
                  // text nodes.
                  return;
                }
                if (didWarnInvalidHydration) {
                  return;
                }
                didWarnInvalidHydration = true;
                warning(
                  false,
                  'Expected server HTML to contain a matching text node for "%s" in <%s>.',
                  text,
                  parentNode.nodeName.toLowerCase()
                );
              }
            }
            function restoreControlledState(domElement, tag, props) {
              switch (tag) {
                case 'input':
                  restoreControlledState$1(domElement, props);
                  return;
                case 'textarea':
                  restoreControlledState$3(domElement, props);
                  return;
                case 'select':
                  restoreControlledState$2(domElement, props);
                  return;
              }
            }
            var ReactDOMFiberComponent = Object.freeze({
              createElement: createElement$1,
              createTextNode: createTextNode$1,
              setInitialProperties: setInitialProperties$1,
              diffProperties: diffProperties$1,
              updateProperties: updateProperties$1,
              diffHydratedProperties: diffHydratedProperties$1,
              diffHydratedText: diffHydratedText$1,
              warnForUnmatchedText: warnForUnmatchedText$1,
              warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,
              warnForDeletedHydratableText: warnForDeletedHydratableText$1,
              warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,
              warnForInsertedHydratedText: warnForInsertedHydratedText$1,
              restoreControlledState: restoreControlledState
            }); // TODO: direct imports like some-package/src/* are bad. Fix me.
            var getCurrentFiberStackAddendum$6 =
              ReactDebugCurrentFiber.getCurrentFiberStackAddendum;
            var validateDOMNesting = emptyFunction;
            {
              // This validation code was written based on the HTML5 parsing spec:
              // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
              //
              // Note: this does not catch all invalid nesting, nor does it try to (as it's
              // not clear what practical benefit doing so provides); instead, we warn only
              // for cases where the parser will give a parse tree differing from what React
              // intended. For example, <b><div></div></b> is invalid but we don't warn
              // because it still parses correctly; we do warn for other cases like nested
              // <p> tags where the beginning of the second element implicitly closes the
              // first, causing a confusing mess.
              // https://html.spec.whatwg.org/multipage/syntax.html#special
              var specialTags = [
                'address',
                'applet',
                'area',
                'article',
                'aside',
                'base',
                'basefont',
                'bgsound',
                'blockquote',
                'body',
                'br',
                'button',
                'caption',
                'center',
                'col',
                'colgroup',
                'dd',
                'details',
                'dir',
                'div',
                'dl',
                'dt',
                'embed',
                'fieldset',
                'figcaption',
                'figure',
                'footer',
                'form',
                'frame',
                'frameset',
                'h1',
                'h2',
                'h3',
                'h4',
                'h5',
                'h6',
                'head',
                'header',
                'hgroup',
                'hr',
                'html',
                'iframe',
                'img',
                'input',
                'isindex',
                'li',
                'link',
                'listing',
                'main',
                'marquee',
                'menu',
                'menuitem',
                'meta',
                'nav',
                'noembed',
                'noframes',
                'noscript',
                'object',
                'ol',
                'p',
                'param',
                'plaintext',
                'pre',
                'script',
                'section',
                'select',
                'source',
                'style',
                'summary',
                'table',
                'tbody',
                'td',
                'template',
                'textarea',
                'tfoot',
                'th',
                'thead',
                'title',
                'tr',
                'track',
                'ul',
                'wbr',
                'xmp'
              ]; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
              var inScopeTags = [
                'applet',
                'caption',
                'html',
                'table',
                'td',
                'th',
                'marquee',
                'object',
                'template', // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
                // TODO: Distinguish by namespace here -- for <title>, including it here
                // errs on the side of fewer warnings
                'foreignObject',
                'desc',
                'title'
              ]; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
              var buttonScopeTags = inScopeTags.concat(['button']); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
              var impliedEndTags = [
                'dd',
                'dt',
                'li',
                'option',
                'optgroup',
                'p',
                'rp',
                'rt'
              ];
              var emptyAncestorInfo = {
                current: null,
                formTag: null,
                aTagInScope: null,
                buttonTagInScope: null,
                nobrTagInScope: null,
                pTagInButtonScope: null,
                listItemTagAutoclosing: null,
                dlItemTagAutoclosing: null
              };
              var updatedAncestorInfo$1 = function updatedAncestorInfo$1(
                oldInfo,
                tag,
                instance
              ) {
                var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
                var info = { tag: tag, instance: instance };
                if (inScopeTags.indexOf(tag) !== -1) {
                  ancestorInfo.aTagInScope = null;
                  ancestorInfo.buttonTagInScope = null;
                  ancestorInfo.nobrTagInScope = null;
                }
                if (buttonScopeTags.indexOf(tag) !== -1) {
                  ancestorInfo.pTagInButtonScope = null;
                } // See rules for 'li', 'dd', 'dt' start tags in
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
                if (
                  specialTags.indexOf(tag) !== -1 &&
                  tag !== 'address' &&
                  tag !== 'div' &&
                  tag !== 'p'
                ) {
                  ancestorInfo.listItemTagAutoclosing = null;
                  ancestorInfo.dlItemTagAutoclosing = null;
                }
                ancestorInfo.current = info;
                if (tag === 'form') {
                  ancestorInfo.formTag = info;
                }
                if (tag === 'a') {
                  ancestorInfo.aTagInScope = info;
                }
                if (tag === 'button') {
                  ancestorInfo.buttonTagInScope = info;
                }
                if (tag === 'nobr') {
                  ancestorInfo.nobrTagInScope = info;
                }
                if (tag === 'p') {
                  ancestorInfo.pTagInButtonScope = info;
                }
                if (tag === 'li') {
                  ancestorInfo.listItemTagAutoclosing = info;
                }
                if (tag === 'dd' || tag === 'dt') {
                  ancestorInfo.dlItemTagAutoclosing = info;
                }
                return ancestorInfo;
              };
              /**
               * Returns whether
               */ var isTagValidWithParent = function isTagValidWithParent(
                tag,
                parentTag
              ) {
                // First, let's check if we're in an unusual parsing mode...
                switch (parentTag) { // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
                  case 'select':
                    return (
                      tag === 'option' || tag === 'optgroup' || tag === '#text'
                    );
                  case 'optgroup':
                    return tag === 'option' || tag === '#text'; // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
                  // but
                  case 'option':
                    return tag === '#text'; // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
                  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
                  // No special behavior since these rules fall back to "in body" mode for
                  // all except special table nodes which cause bad parsing behavior anyway.
                  // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
                  case 'tr':
                    return (
                      tag === 'th' ||
                      tag === 'td' ||
                      tag === 'style' ||
                      tag === 'script' ||
                      tag === 'template'
                    ); // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
                  case 'tbody':
                  case 'thead':
                  case 'tfoot':
                    return (
                      tag === 'tr' ||
                      tag === 'style' ||
                      tag === 'script' ||
                      tag === 'template'
                    ); // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
                  case 'colgroup':
                    return tag === 'col' || tag === 'template'; // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
                  case 'table':
                    return (
                      tag === 'caption' ||
                      tag === 'colgroup' ||
                      tag === 'tbody' ||
                      tag === 'tfoot' ||
                      tag === 'thead' ||
                      tag === 'style' ||
                      tag === 'script' ||
                      tag === 'template'
                    ); // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
                  case 'head':
                    return (
                      tag === 'base' ||
                      tag === 'basefont' ||
                      tag === 'bgsound' ||
                      tag === 'link' ||
                      tag === 'meta' ||
                      tag === 'title' ||
                      tag === 'noscript' ||
                      tag === 'noframes' ||
                      tag === 'style' ||
                      tag === 'script' ||
                      tag === 'template'
                    ); // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
                  case 'html':
                    return tag === 'head' || tag === 'body';
                  case '#document':
                    return tag === 'html';
                } // Probably in the "in body" parsing mode, so we outlaw only tag combos
                // where the parsing rules cause implicit opens or closes to be added.
                // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
                switch (tag) {
                  case 'h1':
                  case 'h2':
                  case 'h3':
                  case 'h4':
                  case 'h5':
                  case 'h6':
                    return (
                      parentTag !== 'h1' &&
                      parentTag !== 'h2' &&
                      parentTag !== 'h3' &&
                      parentTag !== 'h4' &&
                      parentTag !== 'h5' &&
                      parentTag !== 'h6'
                    );
                  case 'rp':
                  case 'rt':
                    return impliedEndTags.indexOf(parentTag) === -1;
                  case 'body':
                  case 'caption':
                  case 'col':
                  case 'colgroup':
                  case 'frame':
                  case 'head':
                  case 'html':
                  case 'tbody':
                  case 'td':
                  case 'tfoot':
                  case 'th':
                  case 'thead':
                  case 'tr': // These tags are only valid with a few parents that have special child
                    // parsing rules -- if we're down here, then none of those matched and
                    // so we allow it only if we don't know what the parent is, as all other
                    // cases are invalid.
                    return parentTag == null;
                }
                return true;
              };
              /**
               * Returns whether
               */ var findInvalidAncestorForTag = function findInvalidAncestorForTag(
                tag,
                ancestorInfo
              ) {
                switch (tag) {
                  case 'address':
                  case 'article':
                  case 'aside':
                  case 'blockquote':
                  case 'center':
                  case 'details':
                  case 'dialog':
                  case 'dir':
                  case 'div':
                  case 'dl':
                  case 'fieldset':
                  case 'figcaption':
                  case 'figure':
                  case 'footer':
                  case 'header':
                  case 'hgroup':
                  case 'main':
                  case 'menu':
                  case 'nav':
                  case 'ol':
                  case 'p':
                  case 'section':
                  case 'summary':
                  case 'ul':
                  case 'pre':
                  case 'listing':
                  case 'table':
                  case 'hr':
                  case 'xmp':
                  case 'h1':
                  case 'h2':
                  case 'h3':
                  case 'h4':
                  case 'h5':
                  case 'h6':
                    return ancestorInfo.pTagInButtonScope;
                  case 'form':
                    return (
                      ancestorInfo.formTag || ancestorInfo.pTagInButtonScope
                    );
                  case 'li':
                    return ancestorInfo.listItemTagAutoclosing;
                  case 'dd':
                  case 'dt':
                    return ancestorInfo.dlItemTagAutoclosing;
                  case 'button':
                    return ancestorInfo.buttonTagInScope;
                  case 'a': // Spec says something about storing a list of markers, but it sounds
                    // equivalent to this check.
                    return ancestorInfo.aTagInScope;
                  case 'nobr':
                    return ancestorInfo.nobrTagInScope;
                }
                return null;
              };
              var didWarn = {};
              validateDOMNesting = function validateDOMNesting(
                childTag,
                childText,
                ancestorInfo
              ) {
                ancestorInfo = ancestorInfo || emptyAncestorInfo;
                var parentInfo = ancestorInfo.current;
                var parentTag = parentInfo && parentInfo.tag;
                if (childText != null) {
                  warning(
                    childTag == null,
                    'validateDOMNesting: when childText is passed, childTag should be null'
                  );
                  childTag = '#text';
                }
                var invalidParent = isTagValidWithParent(childTag, parentTag)
                  ? null
                  : parentInfo;
                var invalidAncestor = invalidParent
                  ? null
                  : findInvalidAncestorForTag(childTag, ancestorInfo);
                var invalidParentOrAncestor = invalidParent || invalidAncestor;
                if (!invalidParentOrAncestor) {
                  return;
                }
                var ancestorTag = invalidParentOrAncestor.tag;
                var addendum = getCurrentFiberStackAddendum$6();
                var warnKey =
                  !!invalidParent +
                  '|' +
                  childTag +
                  '|' +
                  ancestorTag +
                  '|' +
                  addendum;
                if (didWarn[warnKey]) {
                  return;
                }
                didWarn[warnKey] = true;
                var tagDisplayName = childTag;
                var whitespaceInfo = '';
                if (childTag === '#text') {
                  if (/\S/.test(childText)) {
                    tagDisplayName = 'Text nodes';
                  } else {
                    tagDisplayName = 'Whitespace text nodes';
                    whitespaceInfo =
                      " Make sure you don't have any extra whitespace between tags on " +
                      'each line of your source code.';
                  }
                } else {
                  tagDisplayName = '<' + childTag + '>';
                }
                if (invalidParent) {
                  var info = '';
                  if (ancestorTag === 'table' && childTag === 'tr') {
                    info +=
                      ' Add a <tbody> to your code to match the DOM tree generated by ' +
                      'the browser.';
                  }
                  warning(
                    false,
                    'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',
                    tagDisplayName,
                    ancestorTag,
                    whitespaceInfo,
                    info,
                    addendum
                  );
                } else {
                  warning(
                    false,
                    'validateDOMNesting(...): %s cannot appear as a descendant of ' +
                      '<%s>.%s',
                    tagDisplayName,
                    ancestorTag,
                    addendum
                  );
                }
              }; // TODO: turn this into a named export
              validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1; // For testing
              validateDOMNesting.isTagValidInContext = function(
                tag,
                ancestorInfo
              ) {
                ancestorInfo = ancestorInfo || emptyAncestorInfo;
                var parentInfo = ancestorInfo.current;
                var parentTag = parentInfo && parentInfo.tag;
                return (
                  isTagValidWithParent(tag, parentTag) &&
                  !findInvalidAncestorForTag(tag, ancestorInfo)
                );
              };
            }
            var validateDOMNesting$1 = validateDOMNesting; // TODO: direct imports like some-package/src/* are bad. Fix me.
            var createElement = createElement$1;
            var createTextNode = createTextNode$1;
            var setInitialProperties = setInitialProperties$1;
            var diffProperties = diffProperties$1;
            var updateProperties = updateProperties$1;
            var diffHydratedProperties = diffHydratedProperties$1;
            var diffHydratedText = diffHydratedText$1;
            var warnForUnmatchedText = warnForUnmatchedText$1;
            var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;
            var warnForDeletedHydratableText = warnForDeletedHydratableText$1;
            var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;
            var warnForInsertedHydratedText = warnForInsertedHydratedText$1;
            var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;
            var precacheFiberNode = precacheFiberNode$1;
            var updateFiberProps = updateFiberProps$1;
            {
              var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
              if (
                typeof Map !== 'function' ||
                Map.prototype == null ||
                typeof Map.prototype.forEach !== 'function' ||
                typeof Set !== 'function' ||
                Set.prototype == null ||
                typeof Set.prototype.clear !== 'function' ||
                typeof Set.prototype.forEach !== 'function'
              ) {
                warning(
                  false,
                  'React depends on Map and Set built-in types. Make sure that you load a ' +
                    'polyfill in older browsers. http://fb.me/react-polyfills'
                );
              }
            }
            injection$3.injectFiberControlledHostComponent(
              ReactDOMFiberComponent
            );
            var eventsEnabled = null;
            var selectionInformation = null;
            /**
             * True if the supplied DOM node is a valid node element.
             *
             * @param {?DOMElement} node The candidate DOM node.
             * @return {boolean} True if the DOM is a valid DOM node.
             * @internal
             */ function isValidContainer(node) {
              return !!(
                node &&
                (node.nodeType === ELEMENT_NODE ||
                  node.nodeType === DOCUMENT_NODE ||
                  node.nodeType === DOCUMENT_FRAGMENT_NODE ||
                  (node.nodeType === COMMENT_NODE &&
                    node.nodeValue === ' react-mount-point-unstable '))
              );
            }
            function getReactRootElementInContainer(container) {
              if (!container) {
                return null;
              }
              if (container.nodeType === DOCUMENT_NODE) {
                return container.documentElement;
              } else {
                return container.firstChild;
              }
            }
            function shouldHydrateDueToLegacyHeuristic(container) {
              var rootElement = getReactRootElementInContainer(container);
              return !!(
                rootElement &&
                rootElement.nodeType === ELEMENT_NODE &&
                rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)
              );
            }
            function shouldAutoFocusHostComponent(type, props) {
              switch (type) {
                case 'button':
                case 'input':
                case 'select':
                case 'textarea':
                  return !!props.autoFocus;
              }
              return false;
            }
            var DOMRenderer = reactReconciler({
              getRootHostContext: function getRootHostContext(
                rootContainerInstance
              ) {
                var type = void 0;
                var namespace = void 0;
                var nodeType = rootContainerInstance.nodeType;
                switch (nodeType) {
                  case DOCUMENT_NODE:
                  case DOCUMENT_FRAGMENT_NODE: {
                    type =
                      nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
                    var root = rootContainerInstance.documentElement;
                    namespace = root
                      ? root.namespaceURI
                      : getChildNamespace(null, '');
                    break;
                  }
                  default: {
                    var container =
                      nodeType === COMMENT_NODE
                        ? rootContainerInstance.parentNode
                        : rootContainerInstance;
                    var ownNamespace = container.namespaceURI || null;
                    type = container.tagName;
                    namespace = getChildNamespace(ownNamespace, type);
                    break;
                  }
                }
                {
                  var validatedTag = type.toLowerCase();
                  var _ancestorInfo = updatedAncestorInfo(
                    null,
                    validatedTag,
                    null
                  );
                  return { namespace: namespace, ancestorInfo: _ancestorInfo };
                }
                return namespace;
              },
              getChildHostContext: function getChildHostContext(
                parentHostContext,
                type
              ) {
                {
                  var parentHostContextDev = parentHostContext;
                  var _namespace = getChildNamespace(
                    parentHostContextDev.namespace,
                    type
                  );
                  var _ancestorInfo2 = updatedAncestorInfo(
                    parentHostContextDev.ancestorInfo,
                    type,
                    null
                  );
                  return {
                    namespace: _namespace,
                    ancestorInfo: _ancestorInfo2
                  };
                }
                var parentNamespace = parentHostContext;
                return getChildNamespace(parentNamespace, type);
              },
              getPublicInstance: function getPublicInstance(instance) {
                return instance;
              },
              prepareForCommit: function prepareForCommit() {
                eventsEnabled = isEnabled();
                selectionInformation = getSelectionInformation();
                setEnabled(false);
              },
              resetAfterCommit: function resetAfterCommit() {
                restoreSelection(selectionInformation);
                selectionInformation = null;
                setEnabled(eventsEnabled);
                eventsEnabled = null;
              },
              createInstance: function createInstance(
                type,
                props,
                rootContainerInstance,
                hostContext,
                internalInstanceHandle
              ) {
                var parentNamespace = void 0;
                {
                  // TODO: take namespace into account when validating.
                  var hostContextDev = hostContext;
                  validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);
                  if (
                    typeof props.children === 'string' ||
                    typeof props.children === 'number'
                  ) {
                    var string = '' + props.children;
                    var ownAncestorInfo = updatedAncestorInfo(
                      hostContextDev.ancestorInfo,
                      type,
                      null
                    );
                    validateDOMNesting$1(null, string, ownAncestorInfo);
                  }
                  parentNamespace = hostContextDev.namespace;
                }
                var domElement = createElement(
                  type,
                  props,
                  rootContainerInstance,
                  parentNamespace
                );
                precacheFiberNode(internalInstanceHandle, domElement);
                updateFiberProps(domElement, props);
                return domElement;
              },
              appendInitialChild: function appendInitialChild(
                parentInstance,
                child
              ) {
                parentInstance.appendChild(child);
              },
              finalizeInitialChildren: function finalizeInitialChildren(
                domElement,
                type,
                props,
                rootContainerInstance
              ) {
                setInitialProperties(
                  domElement,
                  type,
                  props,
                  rootContainerInstance
                );
                return shouldAutoFocusHostComponent(type, props);
              },
              prepareUpdate: function prepareUpdate(
                domElement,
                type,
                oldProps,
                newProps,
                rootContainerInstance,
                hostContext
              ) {
                {
                  var hostContextDev = hostContext;
                  if (
                    _typeof(newProps.children) !== _typeof(oldProps.children) &&
                    (typeof newProps.children === 'string' ||
                      typeof newProps.children === 'number')
                  ) {
                    var string = '' + newProps.children;
                    var ownAncestorInfo = updatedAncestorInfo(
                      hostContextDev.ancestorInfo,
                      type,
                      null
                    );
                    validateDOMNesting$1(null, string, ownAncestorInfo);
                  }
                }
                return diffProperties(
                  domElement,
                  type,
                  oldProps,
                  newProps,
                  rootContainerInstance
                );
              },
              shouldSetTextContent: function shouldSetTextContent(type, props) {
                return (
                  type === 'textarea' ||
                  typeof props.children === 'string' ||
                  typeof props.children === 'number' ||
                  (_typeof(props.dangerouslySetInnerHTML) === 'object' &&
                    props.dangerouslySetInnerHTML !== null &&
                    typeof props.dangerouslySetInnerHTML.__html === 'string')
                );
              },
              shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(
                type,
                props
              ) {
                return !!props.hidden;
              },
              createTextInstance: function createTextInstance(
                text,
                rootContainerInstance,
                hostContext,
                internalInstanceHandle
              ) {
                {
                  var hostContextDev = hostContext;
                  validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);
                }
                var textNode = createTextNode(text, rootContainerInstance);
                precacheFiberNode(internalInstanceHandle, textNode);
                return textNode;
              },
              now: now,
              mutation: {
                commitMount: function commitMount(
                  domElement,
                  type,
                  newProps,
                  internalInstanceHandle
                ) {
                  domElement.focus();
                },
                commitUpdate: function commitUpdate(
                  domElement,
                  updatePayload,
                  type,
                  oldProps,
                  newProps,
                  internalInstanceHandle
                ) {
                  // Update the props handle so that we know which props are the ones with
                  // with current event handlers.
                  updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.
                  updateProperties(
                    domElement,
                    updatePayload,
                    type,
                    oldProps,
                    newProps
                  );
                },
                resetTextContent: function resetTextContent(domElement) {
                  domElement.textContent = '';
                },
                commitTextUpdate: function commitTextUpdate(
                  textInstance,
                  oldText,
                  newText
                ) {
                  textInstance.nodeValue = newText;
                },
                appendChild: function appendChild(parentInstance, child) {
                  parentInstance.appendChild(child);
                },
                appendChildToContainer: function appendChildToContainer(
                  container,
                  child
                ) {
                  if (container.nodeType === COMMENT_NODE) {
                    container.parentNode.insertBefore(child, container);
                  } else {
                    container.appendChild(child);
                  }
                },
                insertBefore: function insertBefore(
                  parentInstance,
                  child,
                  beforeChild
                ) {
                  parentInstance.insertBefore(child, beforeChild);
                },
                insertInContainerBefore: function insertInContainerBefore(
                  container,
                  child,
                  beforeChild
                ) {
                  if (container.nodeType === COMMENT_NODE) {
                    container.parentNode.insertBefore(child, beforeChild);
                  } else {
                    container.insertBefore(child, beforeChild);
                  }
                },
                removeChild: function removeChild(parentInstance, child) {
                  parentInstance.removeChild(child);
                },
                removeChildFromContainer: function removeChildFromContainer(
                  container,
                  child
                ) {
                  if (container.nodeType === COMMENT_NODE) {
                    container.parentNode.removeChild(child);
                  } else {
                    container.removeChild(child);
                  }
                }
              },
              hydration: {
                canHydrateInstance: function canHydrateInstance(
                  instance,
                  type,
                  props
                ) {
                  if (
                    instance.nodeType !== ELEMENT_NODE ||
                    type.toLowerCase() !== instance.nodeName.toLowerCase()
                  ) {
                    return null;
                  } // This has now been refined to an element node.
                  return instance;
                },
                canHydrateTextInstance: function canHydrateTextInstance(
                  instance,
                  text
                ) {
                  if (text === '' || instance.nodeType !== TEXT_NODE) {
                    // Empty strings are not parsed by HTML so there won't be a correct match here.
                    return null;
                  } // This has now been refined to a text node.
                  return instance;
                },
                getNextHydratableSibling: function getNextHydratableSibling(
                  instance
                ) {
                  var node = instance.nextSibling; // Skip non-hydratable nodes.
                  while (
                    node &&
                    node.nodeType !== ELEMENT_NODE &&
                    node.nodeType !== TEXT_NODE
                  ) {
                    node = node.nextSibling;
                  }
                  return node;
                },
                getFirstHydratableChild: function getFirstHydratableChild(
                  parentInstance
                ) {
                  var next = parentInstance.firstChild; // Skip non-hydratable nodes.
                  while (
                    next &&
                    next.nodeType !== ELEMENT_NODE &&
                    next.nodeType !== TEXT_NODE
                  ) {
                    next = next.nextSibling;
                  }
                  return next;
                },
                hydrateInstance: function hydrateInstance(
                  instance,
                  type,
                  props,
                  rootContainerInstance,
                  hostContext,
                  internalInstanceHandle
                ) {
                  precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events
                  // get attached.
                  updateFiberProps(instance, props);
                  var parentNamespace = void 0;
                  {
                    var hostContextDev = hostContext;
                    parentNamespace = hostContextDev.namespace;
                  }
                  return diffHydratedProperties(
                    instance,
                    type,
                    props,
                    parentNamespace,
                    rootContainerInstance
                  );
                },
                hydrateTextInstance: function hydrateTextInstance(
                  textInstance,
                  text,
                  internalInstanceHandle
                ) {
                  precacheFiberNode(internalInstanceHandle, textInstance);
                  return diffHydratedText(textInstance, text);
                },
                didNotMatchHydratedContainerTextInstance: function didNotMatchHydratedContainerTextInstance(
                  parentContainer,
                  textInstance,
                  text
                ) {
                  {
                    warnForUnmatchedText(textInstance, text);
                  }
                },
                didNotMatchHydratedTextInstance: function didNotMatchHydratedTextInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  textInstance,
                  text
                ) {
                  if (
                    true &&
                    parentProps[SUPPRESS_HYDRATION_WARNING] !== true
                  ) {
                    warnForUnmatchedText(textInstance, text);
                  }
                },
                didNotHydrateContainerInstance: function didNotHydrateContainerInstance(
                  parentContainer,
                  instance
                ) {
                  {
                    if (instance.nodeType === 1) {
                      warnForDeletedHydratableElement(
                        parentContainer,
                        instance
                      );
                    } else {
                      warnForDeletedHydratableText(parentContainer, instance);
                    }
                  }
                },
                didNotHydrateInstance: function didNotHydrateInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  instance
                ) {
                  if (
                    true &&
                    parentProps[SUPPRESS_HYDRATION_WARNING] !== true
                  ) {
                    if (instance.nodeType === 1) {
                      warnForDeletedHydratableElement(parentInstance, instance);
                    } else {
                      warnForDeletedHydratableText(parentInstance, instance);
                    }
                  }
                },
                didNotFindHydratableContainerInstance: function didNotFindHydratableContainerInstance(
                  parentContainer,
                  type,
                  props
                ) {
                  {
                    warnForInsertedHydratedElement(
                      parentContainer,
                      type,
                      props
                    );
                  }
                },
                didNotFindHydratableContainerTextInstance: function didNotFindHydratableContainerTextInstance(
                  parentContainer,
                  text
                ) {
                  {
                    warnForInsertedHydratedText(parentContainer, text);
                  }
                },
                didNotFindHydratableInstance: function didNotFindHydratableInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  type,
                  props
                ) {
                  if (
                    true &&
                    parentProps[SUPPRESS_HYDRATION_WARNING] !== true
                  ) {
                    warnForInsertedHydratedElement(parentInstance, type, props);
                  }
                },
                didNotFindHydratableTextInstance: function didNotFindHydratableTextInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  text
                ) {
                  if (
                    true &&
                    parentProps[SUPPRESS_HYDRATION_WARNING] !== true
                  ) {
                    warnForInsertedHydratedText(parentInstance, text);
                  }
                }
              },
              scheduleDeferredCallback: rIC,
              cancelDeferredCallback: cIC,
              useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM
            });
            injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);
            var warnedAboutHydrateAPI = false;
            function renderSubtreeIntoContainer(
              parentComponent,
              children,
              container,
              forceHydrate,
              callback
            ) {
              !isValidContainer(container)
                ? invariant(false, 'Target container is not a DOM element.')
                : void 0;
              {
                if (
                  container._reactRootContainer &&
                  container.nodeType !== COMMENT_NODE
                ) {
                  var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(
                    container._reactRootContainer.current
                  );
                  if (hostInstance) {
                    warning(
                      hostInstance.parentNode === container,
                      'render(...): It looks like the React-rendered content of this ' +
                        'container was removed without using React. This is not ' +
                        'supported and will cause errors. Instead, call ' +
                        'ReactDOM.unmountComponentAtNode to empty a container.'
                    );
                  }
                }
                var isRootRenderedBySomeReact = !!container._reactRootContainer;
                var rootEl = getReactRootElementInContainer(container);
                var hasNonRootReactChild = !!(
                  rootEl && getInstanceFromNode$1(rootEl)
                );
                warning(
                  !hasNonRootReactChild || isRootRenderedBySomeReact,
                  'render(...): Replacing React-rendered children with a new root ' +
                    'component. If you intended to update the children of this node, ' +
                    'you should instead have the existing children update their state ' +
                    'and render the new components instead of calling ReactDOM.render.'
                );
                warning(
                  container.nodeType !== ELEMENT_NODE ||
                    !container.tagName ||
                    container.tagName.toUpperCase() !== 'BODY',
                  'render(): Rendering components directly into document.body is ' +
                    'discouraged, since its children are often manipulated by third-party ' +
                    'scripts and browser extensions. This may lead to subtle ' +
                    'reconciliation issues. Try rendering into a container element created ' +
                    'for your app.'
                );
              }
              var root = container._reactRootContainer;
              if (!root) {
                var shouldHydrate =
                  forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.
                if (!shouldHydrate) {
                  var warned = false;
                  var rootSibling = void 0;
                  while ((rootSibling = container.lastChild)) {
                    {
                      if (
                        !warned &&
                        rootSibling.nodeType === ELEMENT_NODE &&
                        rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)
                      ) {
                        warned = true;
                        warning(
                          false,
                          'render(): Target node has markup rendered by React, but there ' +
                            'are unrelated nodes as well. This is most commonly caused by ' +
                            'white-space inserted around server-rendered markup.'
                        );
                      }
                    }
                    container.removeChild(rootSibling);
                  }
                }
                {
                  if (
                    shouldHydrate &&
                    !forceHydrate &&
                    !warnedAboutHydrateAPI
                  ) {
                    warnedAboutHydrateAPI = true;
                    lowPriorityWarning$1(
                      false,
                      'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' +
                        'will stop working in React v17. Replace the ReactDOM.render() call ' +
                        'with ReactDOM.hydrate() if you want React to attach to the server HTML.'
                    );
                  }
                }
                var newRoot = DOMRenderer.createContainer(
                  container,
                  shouldHydrate
                );
                root = container._reactRootContainer = newRoot; // Initial mount should not be batched.
                DOMRenderer.unbatchedUpdates(function() {
                  DOMRenderer.updateContainer(
                    children,
                    newRoot,
                    parentComponent,
                    callback
                  );
                });
              } else {
                DOMRenderer.updateContainer(
                  children,
                  root,
                  parentComponent,
                  callback
                );
              }
              return DOMRenderer.getPublicRootInstance(root);
            }
            function createPortal(children, container) {
              var key =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : null;
              !isValidContainer(container)
                ? invariant(false, 'Target container is not a DOM element.')
                : void 0; // TODO: pass ReactDOM portal implementation as third argument
              return createPortal$1(children, container, null, key);
            }
            function ReactRoot(container, hydrate) {
              var root = DOMRenderer.createContainer(container, hydrate);
              this._reactRootContainer = root;
            }
            ReactRoot.prototype.render = function(children, callback) {
              var root = this._reactRootContainer;
              DOMRenderer.updateContainer(children, root, null, callback);
            };
            ReactRoot.prototype.unmount = function(callback) {
              var root = this._reactRootContainer;
              DOMRenderer.updateContainer(null, root, null, callback);
            };
            var ReactDOM = {
              createPortal: createPortal,
              findDOMNode: function findDOMNode(componentOrElement) {
                {
                  var owner = ReactCurrentOwner.current;
                  if (owner !== null) {
                    var warnedAboutRefsInRender =
                      owner.stateNode._warnedAboutRefsInRender;
                    warning(
                      warnedAboutRefsInRender,
                      '%s is accessing findDOMNode inside its render(). ' +
                        'render() should be a pure function of props and state. It should ' +
                        'never access something that requires stale data from the previous ' +
                        'render, such as refs. Move this logic to componentDidMount and ' +
                        'componentDidUpdate instead.',
                      getComponentName(owner) || 'A component'
                    );
                    owner.stateNode._warnedAboutRefsInRender = true;
                  }
                }
                if (componentOrElement == null) {
                  return null;
                }
                if (componentOrElement.nodeType === ELEMENT_NODE) {
                  return componentOrElement;
                }
                var inst = get(componentOrElement);
                if (inst) {
                  return DOMRenderer.findHostInstance(inst);
                }
                if (typeof componentOrElement.render === 'function') {
                  invariant(
                    false,
                    'Unable to find node on an unmounted component.'
                  );
                } else {
                  invariant(
                    false,
                    'Element appears to be neither ReactComponent nor DOMNode. Keys: %s',
                    Object.keys(componentOrElement)
                  );
                }
              },
              hydrate: function hydrate(element, container, callback) {
                // TODO: throw or warn if we couldn't hydrate?
                return renderSubtreeIntoContainer(
                  null,
                  element,
                  container,
                  true,
                  callback
                );
              },
              render: function render(element, container, callback) {
                return renderSubtreeIntoContainer(
                  null,
                  element,
                  container,
                  false,
                  callback
                );
              },
              unstable_renderSubtreeIntoContainer: function unstable_renderSubtreeIntoContainer(
                parentComponent,
                element,
                containerNode,
                callback
              ) {
                !(parentComponent != null && has(parentComponent))
                  ? invariant(
                      false,
                      'parentComponent must be a valid React Component'
                    )
                  : void 0;
                return renderSubtreeIntoContainer(
                  parentComponent,
                  element,
                  containerNode,
                  false,
                  callback
                );
              },
              unmountComponentAtNode: function unmountComponentAtNode(
                container
              ) {
                !isValidContainer(container)
                  ? invariant(
                      false,
                      'unmountComponentAtNode(...): Target container is not a DOM element.'
                    )
                  : void 0;
                if (container._reactRootContainer) {
                  {
                    var rootEl = getReactRootElementInContainer(container);
                    var renderedByDifferentReact =
                      rootEl && !getInstanceFromNode$1(rootEl);
                    warning(
                      !renderedByDifferentReact,
                      "unmountComponentAtNode(): The node you're attempting to unmount " +
                        'was rendered by another copy of React.'
                    );
                  } // Unmount should not be batched.
                  DOMRenderer.unbatchedUpdates(function() {
                    renderSubtreeIntoContainer(
                      null,
                      null,
                      container,
                      false,
                      function() {
                        container._reactRootContainer = null;
                      }
                    );
                  }); // If you call unmountComponentAtNode twice in quick succession, you'll
                  // get `true` twice. That's probably fine?
                  return true;
                } else {
                  {
                    var _rootEl = getReactRootElementInContainer(container);
                    var hasNonRootReactChild = !!(
                      _rootEl && getInstanceFromNode$1(_rootEl)
                    ); // Check if the container itself is a React root node.
                    var isContainerReactRoot =
                      container.nodeType === 1 &&
                      isValidContainer(container.parentNode) &&
                      !!container.parentNode._reactRootContainer;
                    warning(
                      !hasNonRootReactChild,
                      "unmountComponentAtNode(): The node you're attempting to unmount " +
                        'was rendered by React and is not a top-level container. %s',
                      isContainerReactRoot
                        ? 'You may have accidentally passed in a React root node instead ' +
                          'of its container.'
                        : 'Instead, have the parent component update its state and ' +
                          'rerender in order to remove this component.'
                    );
                  }
                  return false;
                }
              }, // Temporary alias since we already shipped React 16 RC with it.
              // TODO: remove in React 17.
              unstable_createPortal: createPortal,
              unstable_batchedUpdates: batchedUpdates,
              unstable_deferredUpdates: DOMRenderer.deferredUpdates,
              flushSync: DOMRenderer.flushSync,
              __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                // For TapEventPlugin which is popular in open source
                EventPluginHub: EventPluginHub, // Used by test-utils
                EventPluginRegistry: EventPluginRegistry,
                EventPropagators: EventPropagators,
                ReactControlledComponent: ReactControlledComponent,
                ReactDOMComponentTree: ReactDOMComponentTree,
                ReactDOMEventListener: ReactDOMEventListener
              }
            };
            if (enableCreateRoot) {
              ReactDOM.createRoot = function createRoot(container, options) {
                var hydrate = options != null && options.hydrate === true;
                return new ReactRoot(container, hydrate);
              };
            }
            var foundDevTools = DOMRenderer.injectIntoDevTools({
              findFiberByHostInstance: getClosestInstanceFromNode,
              bundleType: 1,
              version: ReactVersion,
              rendererPackageName: 'react-dom'
            });
            {
              if (
                !foundDevTools &&
                ExecutionEnvironment.canUseDOM &&
                window.top === window.self
              ) {
                // If we're in Chrome or Firefox, provide a download link if not installed.
                if (
                  (navigator.userAgent.indexOf('Chrome') > -1 &&
                    navigator.userAgent.indexOf('Edge') === -1) ||
                  navigator.userAgent.indexOf('Firefox') > -1
                ) {
                  var protocol = window.location.protocol; // Don't warn in exotic cases like chrome-extension://.
                  if (/^(https?|file):$/.test(protocol)) {
                    console.info(
                      '%cDownload the React DevTools ' +
                        'for a better development experience: ' +
                        'https://fb.me/react-devtools' +
                        (protocol === 'file:'
                          ? '\nYou might need to use a local HTTP server (instead of file://): ' +
                            'https://fb.me/react-devtools-faq'
                          : ''),
                      'font-weight:bold'
                    );
                  }
                }
              }
            }
            var ReactDOM$2 = Object.freeze({ default: ReactDOM });
            var ReactDOM$3 = (ReactDOM$2 && ReactDOM) || ReactDOM$2; // TODO: decide on the top-level export form.
            // This is hacky but makes it work with both Rollup and Jest.
            var reactDom = ReactDOM$3['default']
              ? ReactDOM$3['default']
              : ReactDOM$3;
            module.exports = reactDom;
          })();
        }

        /***/
      },

    /***/ './node_modules/react-dom/index.js':
      /*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function checkDCE() {
            /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
            if (
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
              typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
            ) {
              return;
            }

            if (true) {
              // This branch is unreachable because this function is only called
              // in production, but the condition is true only in development.
              // Therefore if the branch is still here, dead code elimination wasn't
              // properly applied.
              // Don't change the message. React DevTools relies on it. Also make sure
              // this message doesn't occur elsewhere in this function, or it will cause
              // a false positive.
              throw new Error('^_^');
            }

            try {
              // Verify that the code above has been dead code eliminated (DCE'd).
              __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
            } catch (err) {
              // DevTools shouldn't crash React, no matter what.
              // We should still report in case we break this code.
              console.error(err);
            }
          }

          if (false) {
          } else {
            module.exports = __webpack_require__(
              /*! ./cjs/react-dom.development.js */ './node_modules/react-dom/cjs/react-dom.development.js'
            );
          }

          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              checkDCE,
              'checkDCE',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/react-dom/index.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/react-hot-loader/dist/react-hot-loader.production.min.js':
      /*!*******************************************************************************!*\
  !*** ./node_modules/react-hot-loader/dist/react-hot-loader.production.min.js ***!
  \*******************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          function _interopDefault(e) {
            return e && 'object' == _typeof(e) && 'default' in e
              ? e.default
              : e;
          }

          Object.defineProperty(exports, '__esModule', {
            value: !0
          });

          var React = _interopDefault(
              __webpack_require__(/*! react */ './node_modules/react/index.js')
            ),
            classCallCheck = function classCallCheck(e, t) {
              if (!(e instanceof t))
                throw new TypeError('Cannot call a class as a function');
            },
            inherits = function inherits(e, t) {
              if ('function' != typeof t && null !== t)
                throw new TypeError(
                  'Super expression must either be null or a function, not ' +
                    _typeof(t)
                );
              (e.prototype = Object.create(t && t.prototype, {
                constructor: {
                  value: e,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0
                }
              })),
                t &&
                  (Object.setPrototypeOf
                    ? Object.setPrototypeOf(e, t)
                    : (e.__proto__ = t));
            },
            possibleConstructorReturn = function possibleConstructorReturn(
              e,
              t
            ) {
              if (!e)
                throw new ReferenceError(
                  "this hasn't been initialised - super() hasn't been called"
                );
              return !t || ('object' != _typeof(t) && 'function' != typeof t)
                ? e
                : t;
            },
            AppContainer = (function(e) {
              function t() {
                return (
                  classCallCheck(this, t),
                  possibleConstructorReturn(this, e.apply(this, arguments))
                );
              }

              return (
                inherits(t, e),
                (t.prototype.render = function() {
                  return React.Children.only(this.props.children);
                }),
                t
              );
            })(React.Component),
            hot_prod = function hot_prod() {
              return function(e) {
                return e;
              };
            },
            areComponentsEqual = function areComponentsEqual(e, t) {
              return e === t;
            },
            setConfig = function setConfig() {};

          (exports.AppContainer = AppContainer),
            (exports.hot = hot_prod),
            (exports.areComponentsEqual = areComponentsEqual),
            (exports.setConfig = setConfig);
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              _interopDefault,
              '_interopDefault',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/react-hot-loader/dist/react-hot-loader.production.min.js'
            );
            reactHotLoader.register(
              React,
              'React',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/react-hot-loader/dist/react-hot-loader.production.min.js'
            );
            reactHotLoader.register(
              classCallCheck,
              'classCallCheck',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/react-hot-loader/dist/react-hot-loader.production.min.js'
            );
            reactHotLoader.register(
              inherits,
              'inherits',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/react-hot-loader/dist/react-hot-loader.production.min.js'
            );
            reactHotLoader.register(
              possibleConstructorReturn,
              'possibleConstructorReturn',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/react-hot-loader/dist/react-hot-loader.production.min.js'
            );
            reactHotLoader.register(
              AppContainer,
              'AppContainer',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/react-hot-loader/dist/react-hot-loader.production.min.js'
            );
            reactHotLoader.register(
              hot_prod,
              'hot_prod',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/react-hot-loader/dist/react-hot-loader.production.min.js'
            );
            reactHotLoader.register(
              areComponentsEqual,
              'areComponentsEqual',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/react-hot-loader/dist/react-hot-loader.production.min.js'
            );
            reactHotLoader.register(
              setConfig,
              'setConfig',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/react-hot-loader/dist/react-hot-loader.production.min.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/react-hot-loader/index.js':
      /*!************************************************!*\
  !*** ./node_modules/react-hot-loader/index.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';

        if (true) {
          module.exports = __webpack_require__(
            /*! ./dist/react-hot-loader.production.min.js */ './node_modules/react-hot-loader/dist/react-hot-loader.production.min.js'
          );
        } else {
        }

        /***/
      },

    /***/ './node_modules/react/cjs/react.development.js':
      /*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /** @license React v16.2.0
         * react.development.js
         *
         * Copyright (c) 2013-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        function _typeof(obj) {
          if (
            typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === 'function' &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        if (true) {
          (function() {
            'use strict';

            var _assign = __webpack_require__(
              /*! object-assign */ './node_modules/object-assign/index.js'
            );

            var emptyObject = __webpack_require__(
              /*! fbjs/lib/emptyObject */ './node_modules/fbjs/lib/emptyObject.js'
            );

            var invariant = __webpack_require__(
              /*! fbjs/lib/invariant */ './node_modules/fbjs/lib/invariant.js'
            );

            var warning = __webpack_require__(
              /*! fbjs/lib/warning */ './node_modules/fbjs/lib/warning.js'
            );

            var emptyFunction = __webpack_require__(
              /*! fbjs/lib/emptyFunction */ './node_modules/fbjs/lib/emptyFunction.js'
            );

            var checkPropTypes = __webpack_require__(
              /*! prop-types/checkPropTypes */ './node_modules/prop-types/checkPropTypes.js'
            ); // TODO: this is special because it gets imported during build.

            var ReactVersion = '16.2.0'; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
            // nor polyfill, then a plain number is used for performance.

            var hasSymbol = typeof Symbol === 'function' && Symbol['for'];
            var REACT_ELEMENT_TYPE = hasSymbol
              ? Symbol['for']('react.element')
              : 0xeac7;
            var REACT_CALL_TYPE = hasSymbol
              ? Symbol['for']('react.call')
              : 0xeac8;
            var REACT_RETURN_TYPE = hasSymbol
              ? Symbol['for']('react.return')
              : 0xeac9;
            var REACT_PORTAL_TYPE = hasSymbol
              ? Symbol['for']('react.portal')
              : 0xeaca;
            var REACT_FRAGMENT_TYPE = hasSymbol
              ? Symbol['for']('react.fragment')
              : 0xeacb;
            var MAYBE_ITERATOR_SYMBOL =
              typeof Symbol === 'function' && Symbol.iterator;
            var FAUX_ITERATOR_SYMBOL = '@@iterator';

            function getIteratorFn(maybeIterable) {
              if (
                maybeIterable === null ||
                typeof maybeIterable === 'undefined'
              ) {
                return null;
              }

              var maybeIterator =
                (MAYBE_ITERATOR_SYMBOL &&
                  maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
                maybeIterable[FAUX_ITERATOR_SYMBOL];

              if (typeof maybeIterator === 'function') {
                return maybeIterator;
              }

              return null;
            }
            /**
             * WARNING: DO NOT manually require this module.
             * This is a replacement for `invariant(...)` used by the error code system
             * and will _only_ be required by the corresponding babel pass.
             * It always throws.
             */

            /**
             * Forked from fbjs/warning:
             * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
             *
             * Only change is we use console.warn instead of console.error,
             * and do nothing when 'console' is not supported.
             * This really simplifies the code.
             * ---
             * Similar to invariant but only logs a warning if the condition is not met.
             * This can be used to log issues in development environments in critical
             * paths. Removing the logging code for production environments will keep the
             * same logic and follow the same code paths.
             */

            var lowPriorityWarning = function lowPriorityWarning() {};

            {
              var printWarning = function printWarning(format) {
                for (
                  var _len = arguments.length,
                    args = Array(_len > 1 ? _len - 1 : 0),
                    _key = 1;
                  _key < _len;
                  _key++
                ) {
                  args[_key - 1] = arguments[_key];
                }

                var argIndex = 0;
                var message =
                  'Warning: ' +
                  format.replace(/%s/g, function() {
                    return args[argIndex++];
                  });

                if (typeof console !== 'undefined') {
                  console.warn(message);
                }

                try {
                  // --- Welcome to debugging React ---
                  // This error was thrown as a convenience so that you can use this stack
                  // to find the callsite that caused this warning to fire.
                  throw new Error(message);
                } catch (x) {}
              };

              lowPriorityWarning = function lowPriorityWarning(
                condition,
                format
              ) {
                if (format === undefined) {
                  throw new Error(
                    '`warning(condition, format, ...args)` requires a warning ' +
                      'message argument'
                  );
                }

                if (!condition) {
                  for (
                    var _len2 = arguments.length,
                      args = Array(_len2 > 2 ? _len2 - 2 : 0),
                      _key2 = 2;
                    _key2 < _len2;
                    _key2++
                  ) {
                    args[_key2 - 2] = arguments[_key2];
                  }

                  printWarning.apply(undefined, [format].concat(args));
                }
              };
            }
            var lowPriorityWarning$1 = lowPriorityWarning;
            var didWarnStateUpdateForUnmountedComponent = {};

            function warnNoop(publicInstance, callerName) {
              {
                var constructor = publicInstance.constructor;
                var componentName =
                  (constructor &&
                    (constructor.displayName || constructor.name)) ||
                  'ReactClass';
                var warningKey = componentName + '.' + callerName;

                if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                  return;
                }

                warning(
                  false,
                  '%s(...): Can only update a mounted or mounting component. ' +
                    'This usually means you called %s() on an unmounted component. ' +
                    'This is a no-op.\n\nPlease check the code for the %s component.',
                  callerName,
                  callerName,
                  componentName
                );
                didWarnStateUpdateForUnmountedComponent[warningKey] = true;
              }
            }
            /**
             * This is the abstract API for an update queue.
             */

            var ReactNoopUpdateQueue = {
              /**
               * Checks whether or not this composite component is mounted.
               * @param {ReactClass} publicInstance The instance we want to test.
               * @return {boolean} True if mounted, false otherwise.
               * @protected
               * @final
               */
              isMounted: function isMounted(publicInstance) {
                return false;
              },

              /**
               * Forces an update. This should only be invoked when it is known with
               * certainty that we are **not** in a DOM transaction.
               *
               * You may want to call this when you know that some deeper aspect of the
               * component's state has changed but `setState` was not called.
               *
               * This will not invoke `shouldComponentUpdate`, but it will invoke
               * `componentWillUpdate` and `componentDidUpdate`.
               *
               * @param {ReactClass} publicInstance The instance that should rerender.
               * @param {?function} callback Called after component is updated.
               * @param {?string} callerName name of the calling function in the public API.
               * @internal
               */
              enqueueForceUpdate: function enqueueForceUpdate(
                publicInstance,
                callback,
                callerName
              ) {
                warnNoop(publicInstance, 'forceUpdate');
              },

              /**
               * Replaces all of the state. Always use this or `setState` to mutate state.
               * You should treat `this.state` as immutable.
               *
               * There is no guarantee that `this.state` will be immediately updated, so
               * accessing `this.state` after calling this method may return the old value.
               *
               * @param {ReactClass} publicInstance The instance that should rerender.
               * @param {object} completeState Next state.
               * @param {?function} callback Called after component is updated.
               * @param {?string} callerName name of the calling function in the public API.
               * @internal
               */
              enqueueReplaceState: function enqueueReplaceState(
                publicInstance,
                completeState,
                callback,
                callerName
              ) {
                warnNoop(publicInstance, 'replaceState');
              },

              /**
               * Sets a subset of the state. This only exists because _pendingState is
               * internal. This provides a merging strategy that is not available to deep
               * properties which is confusing. TODO: Expose pendingState or don't use it
               * during the merge.
               *
               * @param {ReactClass} publicInstance The instance that should rerender.
               * @param {object} partialState Next partial state to be merged with state.
               * @param {?function} callback Called after component is updated.
               * @param {?string} Name of the calling function in the public API.
               * @internal
               */
              enqueueSetState: function enqueueSetState(
                publicInstance,
                partialState,
                callback,
                callerName
              ) {
                warnNoop(publicInstance, 'setState');
              }
            };
            /**
             * Base class helpers for the updating state of a component.
             */

            function Component(props, context, updater) {
              this.props = props;
              this.context = context;
              this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
              // renderer.

              this.updater = updater || ReactNoopUpdateQueue;
            }

            Component.prototype.isReactComponent = {};
            /**
             * Sets a subset of the state. Always use this to mutate
             * state. You should treat `this.state` as immutable.
             *
             * There is no guarantee that `this.state` will be immediately updated, so
             * accessing `this.state` after calling this method may return the old value.
             *
             * There is no guarantee that calls to `setState` will run synchronously,
             * as they may eventually be batched together.  You can provide an optional
             * callback that will be executed when the call to setState is actually
             * completed.
             *
             * When a function is provided to setState, it will be called at some point in
             * the future (not synchronously). It will be called with the up to date
             * component arguments (state, props, context). These values can be different
             * from this.* because your function may be called after receiveProps but before
             * shouldComponentUpdate, and this new state, props, and context will not yet be
             * assigned to this.
             *
             * @param {object|function} partialState Next partial state or function to
             *        produce next partial state to be merged with current state.
             * @param {?function} callback Called after state is updated.
             * @final
             * @protected
             */

            Component.prototype.setState = function(partialState, callback) {
              !(
                _typeof(partialState) === 'object' ||
                typeof partialState === 'function' ||
                partialState == null
              )
                ? invariant(
                    false,
                    'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'
                  )
                : void 0;
              this.updater.enqueueSetState(
                this,
                partialState,
                callback,
                'setState'
              );
            };
            /**
             * Forces an update. This should only be invoked when it is known with
             * certainty that we are **not** in a DOM transaction.
             *
             * You may want to call this when you know that some deeper aspect of the
             * component's state has changed but `setState` was not called.
             *
             * This will not invoke `shouldComponentUpdate`, but it will invoke
             * `componentWillUpdate` and `componentDidUpdate`.
             *
             * @param {?function} callback Called after update is complete.
             * @final
             * @protected
             */

            Component.prototype.forceUpdate = function(callback) {
              this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
            };
            /**
             * Deprecated APIs. These APIs used to exist on classic React classes but since
             * we would like to deprecate them, we're not going to move them over to this
             * modern base class. Instead, we define a getter that warns if it's accessed.
             */

            {
              var deprecatedAPIs = {
                isMounted: [
                  'isMounted',
                  'Instead, make sure to clean up subscriptions and pending requests in ' +
                    'componentWillUnmount to prevent memory leaks.'
                ],
                replaceState: [
                  'replaceState',
                  'Refactor your code to use setState instead (see ' +
                    'https://github.com/facebook/react/issues/3236).'
                ]
              };

              var defineDeprecationWarning = function defineDeprecationWarning(
                methodName,
                info
              ) {
                Object.defineProperty(Component.prototype, methodName, {
                  get: function get() {
                    lowPriorityWarning$1(
                      false,
                      '%s(...) is deprecated in plain JavaScript React classes. %s',
                      info[0],
                      info[1]
                    );
                    return undefined;
                  }
                });
              };

              for (var fnName in deprecatedAPIs) {
                if (deprecatedAPIs.hasOwnProperty(fnName)) {
                  defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
                }
              }
            }
            /**
             * Base class helpers for the updating state of a component.
             */

            function PureComponent(props, context, updater) {
              // Duplicated from Component.
              this.props = props;
              this.context = context;
              this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
              // renderer.

              this.updater = updater || ReactNoopUpdateQueue;
            }

            function ComponentDummy() {}

            ComponentDummy.prototype = Component.prototype;
            var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
            pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

            _assign(pureComponentPrototype, Component.prototype);

            pureComponentPrototype.isPureReactComponent = true;

            function AsyncComponent(props, context, updater) {
              // Duplicated from Component.
              this.props = props;
              this.context = context;
              this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
              // renderer.

              this.updater = updater || ReactNoopUpdateQueue;
            }

            var asyncComponentPrototype = (AsyncComponent.prototype = new ComponentDummy());
            asyncComponentPrototype.constructor = AsyncComponent; // Avoid an extra prototype jump for these methods.

            _assign(asyncComponentPrototype, Component.prototype);

            asyncComponentPrototype.unstable_isAsyncReactComponent = true;

            asyncComponentPrototype.render = function() {
              return this.props.children;
            };
            /**
             * Keeps track of the current owner.
             *
             * The current owner is the component who should own any components that are
             * currently being constructed.
             */

            var ReactCurrentOwner = {
              /**
               * @internal
               * @type {ReactComponent}
               */
              current: null
            };
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var RESERVED_PROPS = {
              key: true,
              ref: true,
              __self: true,
              __source: true
            };
            var specialPropKeyWarningShown;
            var specialPropRefWarningShown;

            function hasValidRef(config) {
              {
                if (hasOwnProperty.call(config, 'ref')) {
                  var getter = Object.getOwnPropertyDescriptor(config, 'ref')
                    .get;

                  if (getter && getter.isReactWarning) {
                    return false;
                  }
                }
              }
              return config.ref !== undefined;
            }

            function hasValidKey(config) {
              {
                if (hasOwnProperty.call(config, 'key')) {
                  var getter = Object.getOwnPropertyDescriptor(config, 'key')
                    .get;

                  if (getter && getter.isReactWarning) {
                    return false;
                  }
                }
              }
              return config.key !== undefined;
            }

            function defineKeyPropWarningGetter(props, displayName) {
              var warnAboutAccessingKey = function warnAboutAccessingKey() {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  warning(
                    false,
                    '%s: `key` is not a prop. Trying to access it will result ' +
                      'in `undefined` being returned. If you need to access the same ' +
                      'value within the child component, you should pass it as a different ' +
                      'prop. (https://fb.me/react-special-props)',
                    displayName
                  );
                }
              };

              warnAboutAccessingKey.isReactWarning = true;
              Object.defineProperty(props, 'key', {
                get: warnAboutAccessingKey,
                configurable: true
              });
            }

            function defineRefPropWarningGetter(props, displayName) {
              var warnAboutAccessingRef = function warnAboutAccessingRef() {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  warning(
                    false,
                    '%s: `ref` is not a prop. Trying to access it will result ' +
                      'in `undefined` being returned. If you need to access the same ' +
                      'value within the child component, you should pass it as a different ' +
                      'prop. (https://fb.me/react-special-props)',
                    displayName
                  );
                }
              };

              warnAboutAccessingRef.isReactWarning = true;
              Object.defineProperty(props, 'ref', {
                get: warnAboutAccessingRef,
                configurable: true
              });
            }
            /**
             * Factory method to create a new React element. This no longer adheres to
             * the class pattern, so do not use new to call it. Also, no instanceof check
             * will work. Instead test $$typeof field against Symbol.for('react.element') to check
             * if something is a React Element.
             *
             * @param {*} type
             * @param {*} key
             * @param {string|object} ref
             * @param {*} self A *temporary* helper to detect places where `this` is
             * different from the `owner` when React.createElement is called, so that we
             * can warn. We want to get rid of owner and replace string `ref`s with arrow
             * functions, and as long as `this` and owner are the same, there will be no
             * change in behavior.
             * @param {*} source An annotation object (added by a transpiler or otherwise)
             * indicating filename, line number, and/or other information.
             * @param {*} owner
             * @param {*} props
             * @internal
             */

            var ReactElement = function ReactElement(
              type,
              key,
              ref,
              self,
              source,
              owner,
              props
            ) {
              var element = {
                // This tag allow us to uniquely identify this as a React Element
                $$typeof: REACT_ELEMENT_TYPE,
                // Built-in properties that belong on the element
                type: type,
                key: key,
                ref: ref,
                props: props,
                // Record the component responsible for creating this element.
                _owner: owner
              };
              {
                // The validation flag is currently mutative. We put it on
                // an external backing store so that we can freeze the whole object.
                // This can be replaced with a WeakMap once they are implemented in
                // commonly used development environments.
                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
                // the validation flag non-enumerable (where possible, which should
                // include every environment we run tests in), so the test framework
                // ignores it.

                Object.defineProperty(element._store, 'validated', {
                  configurable: false,
                  enumerable: false,
                  writable: true,
                  value: false
                }); // self and source are DEV only properties.

                Object.defineProperty(element, '_self', {
                  configurable: false,
                  enumerable: false,
                  writable: false,
                  value: self
                }); // Two elements created in two different places should be considered
                // equal for testing purposes and therefore we hide it from enumeration.

                Object.defineProperty(element, '_source', {
                  configurable: false,
                  enumerable: false,
                  writable: false,
                  value: source
                });

                if (Object.freeze) {
                  Object.freeze(element.props);
                  Object.freeze(element);
                }
              }
              return element;
            };
            /**
             * Create and return a new ReactElement of the given type.
             * See https://reactjs.org/docs/react-api.html#createelement
             */

            function createElement(type, config, children) {
              var propName; // Reserved names are extracted

              var props = {};
              var key = null;
              var ref = null;
              var self = null;
              var source = null;

              if (config != null) {
                if (hasValidRef(config)) {
                  ref = config.ref;
                }

                if (hasValidKey(config)) {
                  key = '' + config.key;
                }

                self = config.__self === undefined ? null : config.__self;
                source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

                for (propName in config) {
                  if (
                    hasOwnProperty.call(config, propName) &&
                    !RESERVED_PROPS.hasOwnProperty(propName)
                  ) {
                    props[propName] = config[propName];
                  }
                }
              } // Children can be more than one argument, and those are transferred onto
              // the newly allocated props object.

              var childrenLength = arguments.length - 2;

              if (childrenLength === 1) {
                props.children = children;
              } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);

                for (var i = 0; i < childrenLength; i++) {
                  childArray[i] = arguments[i + 2];
                }

                {
                  if (Object.freeze) {
                    Object.freeze(childArray);
                  }
                }
                props.children = childArray;
              } // Resolve default props

              if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;

                for (propName in defaultProps) {
                  if (props[propName] === undefined) {
                    props[propName] = defaultProps[propName];
                  }
                }
              }

              {
                if (key || ref) {
                  if (
                    typeof props.$$typeof === 'undefined' ||
                    props.$$typeof !== REACT_ELEMENT_TYPE
                  ) {
                    var displayName =
                      typeof type === 'function'
                        ? type.displayName || type.name || 'Unknown'
                        : type;

                    if (key) {
                      defineKeyPropWarningGetter(props, displayName);
                    }

                    if (ref) {
                      defineRefPropWarningGetter(props, displayName);
                    }
                  }
                }
              }
              return ReactElement(
                type,
                key,
                ref,
                self,
                source,
                ReactCurrentOwner.current,
                props
              );
            }
            /**
             * Return a function that produces ReactElements of a given type.
             * See https://reactjs.org/docs/react-api.html#createfactory
             */

            function cloneAndReplaceKey(oldElement, newKey) {
              var newElement = ReactElement(
                oldElement.type,
                newKey,
                oldElement.ref,
                oldElement._self,
                oldElement._source,
                oldElement._owner,
                oldElement.props
              );
              return newElement;
            }
            /**
             * Clone and return a new ReactElement using element as the starting point.
             * See https://reactjs.org/docs/react-api.html#cloneelement
             */

            function cloneElement(element, config, children) {
              var propName; // Original props are copied

              var props = _assign({}, element.props); // Reserved names are extracted

              var key = element.key;
              var ref = element.ref; // Self is preserved since the owner is preserved.

              var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
              // transpiler, and the original source is probably a better indicator of the
              // true owner.

              var source = element._source; // Owner will be preserved, unless ref is overridden

              var owner = element._owner;

              if (config != null) {
                if (hasValidRef(config)) {
                  // Silently steal the ref from the parent.
                  ref = config.ref;
                  owner = ReactCurrentOwner.current;
                }

                if (hasValidKey(config)) {
                  key = '' + config.key;
                } // Remaining properties override existing props

                var defaultProps;

                if (element.type && element.type.defaultProps) {
                  defaultProps = element.type.defaultProps;
                }

                for (propName in config) {
                  if (
                    hasOwnProperty.call(config, propName) &&
                    !RESERVED_PROPS.hasOwnProperty(propName)
                  ) {
                    if (
                      config[propName] === undefined &&
                      defaultProps !== undefined
                    ) {
                      // Resolve default props
                      props[propName] = defaultProps[propName];
                    } else {
                      props[propName] = config[propName];
                    }
                  }
                }
              } // Children can be more than one argument, and those are transferred onto
              // the newly allocated props object.

              var childrenLength = arguments.length - 2;

              if (childrenLength === 1) {
                props.children = children;
              } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);

                for (var i = 0; i < childrenLength; i++) {
                  childArray[i] = arguments[i + 2];
                }

                props.children = childArray;
              }

              return ReactElement(
                element.type,
                key,
                ref,
                self,
                source,
                owner,
                props
              );
            }
            /**
             * Verifies the object is a ReactElement.
             * See https://reactjs.org/docs/react-api.html#isvalidelement
             * @param {?object} object
             * @return {boolean} True if `object` is a valid component.
             * @final
             */

            function isValidElement(object) {
              return (
                _typeof(object) === 'object' &&
                object !== null &&
                object.$$typeof === REACT_ELEMENT_TYPE
              );
            }

            var ReactDebugCurrentFrame = {};
            {
              // Component that is being worked on
              ReactDebugCurrentFrame.getCurrentStack = null;

              ReactDebugCurrentFrame.getStackAddendum = function() {
                var impl = ReactDebugCurrentFrame.getCurrentStack;

                if (impl) {
                  return impl();
                }

                return null;
              };
            }
            var SEPARATOR = '.';
            var SUBSEPARATOR = ':';
            /**
             * Escape and wrap key so it is safe to use as a reactid
             *
             * @param {string} key to be escaped.
             * @return {string} the escaped key.
             */

            function escape(key) {
              var escapeRegex = /[=:]/g;
              var escaperLookup = {
                '=': '=0',
                ':': '=2'
              };
              var escapedString = ('' + key).replace(escapeRegex, function(
                match
              ) {
                return escaperLookup[match];
              });
              return '$' + escapedString;
            }
            /**
             * TODO: Test that a single child and an array with one item have the same key
             * pattern.
             */

            var didWarnAboutMaps = false;
            var userProvidedKeyEscapeRegex = /\/+/g;

            function escapeUserProvidedKey(text) {
              return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
            }

            var POOL_SIZE = 10;
            var traverseContextPool = [];

            function getPooledTraverseContext(
              mapResult,
              keyPrefix,
              mapFunction,
              mapContext
            ) {
              if (traverseContextPool.length) {
                var traverseContext = traverseContextPool.pop();
                traverseContext.result = mapResult;
                traverseContext.keyPrefix = keyPrefix;
                traverseContext.func = mapFunction;
                traverseContext.context = mapContext;
                traverseContext.count = 0;
                return traverseContext;
              } else {
                return {
                  result: mapResult,
                  keyPrefix: keyPrefix,
                  func: mapFunction,
                  context: mapContext,
                  count: 0
                };
              }
            }

            function releaseTraverseContext(traverseContext) {
              traverseContext.result = null;
              traverseContext.keyPrefix = null;
              traverseContext.func = null;
              traverseContext.context = null;
              traverseContext.count = 0;

              if (traverseContextPool.length < POOL_SIZE) {
                traverseContextPool.push(traverseContext);
              }
            }
            /**
             * @param {?*} children Children tree container.
             * @param {!string} nameSoFar Name of the key path so far.
             * @param {!function} callback Callback to invoke with each child found.
             * @param {?*} traverseContext Used to pass information throughout the traversal
             * process.
             * @return {!number} The number of children in this subtree.
             */

            function traverseAllChildrenImpl(
              children,
              nameSoFar,
              callback,
              traverseContext
            ) {
              var type = _typeof(children);

              if (type === 'undefined' || type === 'boolean') {
                // All of the above are perceived as null.
                children = null;
              }

              var invokeCallback = false;

              if (children === null) {
                invokeCallback = true;
              } else {
                switch (type) {
                  case 'string':
                  case 'number':
                    invokeCallback = true;
                    break;

                  case 'object':
                    switch (children.$$typeof) {
                      case REACT_ELEMENT_TYPE:
                      case REACT_CALL_TYPE:
                      case REACT_RETURN_TYPE:
                      case REACT_PORTAL_TYPE:
                        invokeCallback = true;
                    }
                }
              }

              if (invokeCallback) {
                callback(
                  traverseContext,
                  children, // If it's the only child, treat the name as if it was wrapped in an array
                  // so that it's consistent if the number of children grows.
                  nameSoFar === ''
                    ? SEPARATOR + getComponentKey(children, 0)
                    : nameSoFar
                );
                return 1;
              }

              var child;
              var nextName;
              var subtreeCount = 0; // Count of children found in the current subtree.

              var nextNamePrefix =
                nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

              if (Array.isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                  child = children[i];
                  nextName = nextNamePrefix + getComponentKey(child, i);
                  subtreeCount += traverseAllChildrenImpl(
                    child,
                    nextName,
                    callback,
                    traverseContext
                  );
                }
              } else {
                var iteratorFn = getIteratorFn(children);

                if (typeof iteratorFn === 'function') {
                  {
                    // Warn about using Maps as children
                    if (iteratorFn === children.entries) {
                      warning(
                        didWarnAboutMaps,
                        'Using Maps as children is unsupported and will likely yield ' +
                          'unexpected results. Convert it to a sequence/iterable of keyed ' +
                          'ReactElements instead.%s',
                        ReactDebugCurrentFrame.getStackAddendum()
                      );
                      didWarnAboutMaps = true;
                    }
                  }
                  var iterator = iteratorFn.call(children);
                  var step;
                  var ii = 0;

                  while (!(step = iterator.next()).done) {
                    child = step.value;
                    nextName = nextNamePrefix + getComponentKey(child, ii++);
                    subtreeCount += traverseAllChildrenImpl(
                      child,
                      nextName,
                      callback,
                      traverseContext
                    );
                  }
                } else if (type === 'object') {
                  var addendum = '';
                  {
                    addendum =
                      ' If you meant to render a collection of children, use an array ' +
                      'instead.' +
                      ReactDebugCurrentFrame.getStackAddendum();
                  }
                  var childrenString = '' + children;
                  invariant(
                    false,
                    'Objects are not valid as a React child (found: %s).%s',
                    childrenString === '[object Object]'
                      ? 'object with keys {' +
                        Object.keys(children).join(', ') +
                        '}'
                      : childrenString,
                    addendum
                  );
                }
              }

              return subtreeCount;
            }
            /**
             * Traverses children that are typically specified as `props.children`, but
             * might also be specified through attributes:
             *
             * - `traverseAllChildren(this.props.children, ...)`
             * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
             *
             * The `traverseContext` is an optional argument that is passed through the
             * entire traversal. It can be used to store accumulations or anything else that
             * the callback might find relevant.
             *
             * @param {?*} children Children tree object.
             * @param {!function} callback To invoke upon traversing each child.
             * @param {?*} traverseContext Context for traversal.
             * @return {!number} The number of children in this subtree.
             */

            function traverseAllChildren(children, callback, traverseContext) {
              if (children == null) {
                return 0;
              }

              return traverseAllChildrenImpl(
                children,
                '',
                callback,
                traverseContext
              );
            }
            /**
             * Generate a key string that identifies a component within a set.
             *
             * @param {*} component A component that could contain a manual key.
             * @param {number} index Index that is used if a manual key is not provided.
             * @return {string}
             */

            function getComponentKey(component, index) {
              // Do some typechecking here since we call this blindly. We want to ensure
              // that we don't block potential future ES APIs.
              if (
                _typeof(component) === 'object' &&
                component !== null &&
                component.key != null
              ) {
                // Explicit key
                return escape(component.key);
              } // Implicit key determined by the index in the set

              return index.toString(36);
            }

            function forEachSingleChild(bookKeeping, child, name) {
              var func = bookKeeping.func,
                context = bookKeeping.context;
              func.call(context, child, bookKeeping.count++);
            }
            /**
             * Iterates through children that are typically specified as `props.children`.
             *
             * See https://reactjs.org/docs/react-api.html#react.children.foreach
             *
             * The provided forEachFunc(child, index) will be called for each
             * leaf child.
             *
             * @param {?*} children Children tree container.
             * @param {function(*, int)} forEachFunc
             * @param {*} forEachContext Context for forEachContext.
             */

            function forEachChildren(children, forEachFunc, forEachContext) {
              if (children == null) {
                return children;
              }

              var traverseContext = getPooledTraverseContext(
                null,
                null,
                forEachFunc,
                forEachContext
              );
              traverseAllChildren(
                children,
                forEachSingleChild,
                traverseContext
              );
              releaseTraverseContext(traverseContext);
            }

            function mapSingleChildIntoContext(bookKeeping, child, childKey) {
              var result = bookKeeping.result,
                keyPrefix = bookKeeping.keyPrefix,
                func = bookKeeping.func,
                context = bookKeeping.context;
              var mappedChild = func.call(context, child, bookKeeping.count++);

              if (Array.isArray(mappedChild)) {
                mapIntoWithKeyPrefixInternal(
                  mappedChild,
                  result,
                  childKey,
                  emptyFunction.thatReturnsArgument
                );
              } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                  mappedChild = cloneAndReplaceKey(
                    mappedChild, // Keep both the (mapped) and old keys if they differ, just as
                    // traverseAllChildren used to do for objects as children
                    keyPrefix +
                      (mappedChild.key &&
                      (!child || child.key !== mappedChild.key)
                        ? escapeUserProvidedKey(mappedChild.key) + '/'
                        : '') +
                      childKey
                  );
                }

                result.push(mappedChild);
              }
            }

            function mapIntoWithKeyPrefixInternal(
              children,
              array,
              prefix,
              func,
              context
            ) {
              var escapedPrefix = '';

              if (prefix != null) {
                escapedPrefix = escapeUserProvidedKey(prefix) + '/';
              }

              var traverseContext = getPooledTraverseContext(
                array,
                escapedPrefix,
                func,
                context
              );
              traverseAllChildren(
                children,
                mapSingleChildIntoContext,
                traverseContext
              );
              releaseTraverseContext(traverseContext);
            }
            /**
             * Maps children that are typically specified as `props.children`.
             *
             * See https://reactjs.org/docs/react-api.html#react.children.map
             *
             * The provided mapFunction(child, key, index) will be called for each
             * leaf child.
             *
             * @param {?*} children Children tree container.
             * @param {function(*, int)} func The map function.
             * @param {*} context Context for mapFunction.
             * @return {object} Object containing the ordered map of results.
             */

            function mapChildren(children, func, context) {
              if (children == null) {
                return children;
              }

              var result = [];
              mapIntoWithKeyPrefixInternal(
                children,
                result,
                null,
                func,
                context
              );
              return result;
            }
            /**
             * Count the number of children that are typically specified as
             * `props.children`.
             *
             * See https://reactjs.org/docs/react-api.html#react.children.count
             *
             * @param {?*} children Children tree container.
             * @return {number} The number of children.
             */

            function countChildren(children, context) {
              return traverseAllChildren(
                children,
                emptyFunction.thatReturnsNull,
                null
              );
            }
            /**
             * Flatten a children object (typically specified as `props.children`) and
             * return an array with appropriately re-keyed children.
             *
             * See https://reactjs.org/docs/react-api.html#react.children.toarray
             */

            function toArray(children) {
              var result = [];
              mapIntoWithKeyPrefixInternal(
                children,
                result,
                null,
                emptyFunction.thatReturnsArgument
              );
              return result;
            }
            /**
             * Returns the first child in a collection of children and verifies that there
             * is only one child in the collection.
             *
             * See https://reactjs.org/docs/react-api.html#react.children.only
             *
             * The current implementation of this function assumes that a single child gets
             * passed without a wrapper, but the purpose of this helper function is to
             * abstract away the particular structure of children.
             *
             * @param {?object} children Child collection structure.
             * @return {ReactElement} The first and only `ReactElement` contained in the
             * structure.
             */

            function onlyChild(children) {
              !isValidElement(children)
                ? invariant(
                    false,
                    'React.Children.only expected to receive a single React element child.'
                  )
                : void 0;
              return children;
            }

            var describeComponentFrame = function describeComponentFrame(
              name,
              source,
              ownerName
            ) {
              return (
                '\n    in ' +
                (name || 'Unknown') +
                (source
                  ? ' (at ' +
                    source.fileName.replace(/^.*[\\\/]/, '') +
                    ':' +
                    source.lineNumber +
                    ')'
                  : ownerName ? ' (created by ' + ownerName + ')' : '')
              );
            };

            function getComponentName(fiber) {
              var type = fiber.type;

              if (typeof type === 'string') {
                return type;
              }

              if (typeof type === 'function') {
                return type.displayName || type.name;
              }

              return null;
            }
            /**
             * ReactElementValidator provides a wrapper around a element factory
             * which validates the props passed to the element. This is intended to be
             * used only in DEV and could be replaced by a static type checker for languages
             * that support it.
             */

            {
              var currentlyValidatingElement = null;
              var propTypesMisspellWarningShown = false;

              var getDisplayName = function getDisplayName(element) {
                if (element == null) {
                  return '#empty';
                } else if (
                  typeof element === 'string' ||
                  typeof element === 'number'
                ) {
                  return '#text';
                } else if (typeof element.type === 'string') {
                  return element.type;
                } else if (element.type === REACT_FRAGMENT_TYPE) {
                  return 'React.Fragment';
                } else {
                  return (
                    element.type.displayName || element.type.name || 'Unknown'
                  );
                }
              };

              var getStackAddendum = function getStackAddendum() {
                var stack = '';

                if (currentlyValidatingElement) {
                  var name = getDisplayName(currentlyValidatingElement);
                  var owner = currentlyValidatingElement._owner;
                  stack += describeComponentFrame(
                    name,
                    currentlyValidatingElement._source,
                    owner && getComponentName(owner)
                  );
                }

                stack += ReactDebugCurrentFrame.getStackAddendum() || '';
                return stack;
              };

              var VALID_FRAGMENT_PROPS = new Map([
                ['children', true],
                ['key', true]
              ]);
            }

            function getDeclarationErrorAddendum() {
              if (ReactCurrentOwner.current) {
                var name = getComponentName(ReactCurrentOwner.current);

                if (name) {
                  return '\n\nCheck the render method of `' + name + '`.';
                }
              }

              return '';
            }

            function getSourceInfoErrorAddendum(elementProps) {
              if (
                elementProps !== null &&
                elementProps !== undefined &&
                elementProps.__source !== undefined
              ) {
                var source = elementProps.__source;
                var fileName = source.fileName.replace(/^.*[\\\/]/, '');
                var lineNumber = source.lineNumber;
                return (
                  '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.'
                );
              }

              return '';
            }
            /**
             * Warn if there's no key explicitly set on dynamic arrays of children or
             * object keys are not valid. This allows us to keep track of children between
             * updates.
             */

            var ownerHasKeyUseWarning = {};

            function getCurrentComponentErrorInfo(parentType) {
              var info = getDeclarationErrorAddendum();

              if (!info) {
                var parentName =
                  typeof parentType === 'string'
                    ? parentType
                    : parentType.displayName || parentType.name;

                if (parentName) {
                  info =
                    '\n\nCheck the top-level render call using <' +
                    parentName +
                    '>.';
                }
              }

              return info;
            }
            /**
             * Warn if the element doesn't have an explicit key assigned to it.
             * This element is in an array. The array could grow and shrink or be
             * reordered. All children that haven't already been validated are required to
             * have a "key" property assigned to it. Error statuses are cached so a warning
             * will only be shown once.
             *
             * @internal
             * @param {ReactElement} element Element that requires a key.
             * @param {*} parentType element's parent's type.
             */

            function validateExplicitKey(element, parentType) {
              if (
                !element._store ||
                element._store.validated ||
                element.key != null
              ) {
                return;
              }

              element._store.validated = true;
              var currentComponentErrorInfo = getCurrentComponentErrorInfo(
                parentType
              );

              if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
              }

              ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
              // property, it may be the creator of the child that's responsible for
              // assigning it a key.

              var childOwner = '';

              if (
                element &&
                element._owner &&
                element._owner !== ReactCurrentOwner.current
              ) {
                // Give the component that originally created this child.
                childOwner =
                  ' It was passed a child from ' +
                  getComponentName(element._owner) +
                  '.';
              }

              currentlyValidatingElement = element;
              {
                warning(
                  false,
                  'Each child in an array or iterator should have a unique "key" prop.' +
                    '%s%s See https://fb.me/react-warning-keys for more information.%s',
                  currentComponentErrorInfo,
                  childOwner,
                  getStackAddendum()
                );
              }
              currentlyValidatingElement = null;
            }
            /**
             * Ensure that every element either is passed in a static location, in an
             * array with an explicit keys property defined, or in an object literal
             * with valid key property.
             *
             * @internal
             * @param {ReactNode} node Statically passed child of any type.
             * @param {*} parentType node's parent's type.
             */

            function validateChildKeys(node, parentType) {
              if (_typeof(node) !== 'object') {
                return;
              }

              if (Array.isArray(node)) {
                for (var i = 0; i < node.length; i++) {
                  var child = node[i];

                  if (isValidElement(child)) {
                    validateExplicitKey(child, parentType);
                  }
                }
              } else if (isValidElement(node)) {
                // This element was passed in a valid location.
                if (node._store) {
                  node._store.validated = true;
                }
              } else if (node) {
                var iteratorFn = getIteratorFn(node);

                if (typeof iteratorFn === 'function') {
                  // Entry iterators used to provide implicit keys,
                  // but now we print a separate warning for them later.
                  if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;

                    while (!(step = iterator.next()).done) {
                      if (isValidElement(step.value)) {
                        validateExplicitKey(step.value, parentType);
                      }
                    }
                  }
                }
              }
            }
            /**
             * Given an element, validate that its props follow the propTypes definition,
             * provided by the type.
             *
             * @param {ReactElement} element
             */

            function validatePropTypes(element) {
              var componentClass = element.type;

              if (typeof componentClass !== 'function') {
                return;
              }

              var name = componentClass.displayName || componentClass.name;
              var propTypes = componentClass.propTypes;

              if (propTypes) {
                currentlyValidatingElement = element;
                checkPropTypes(
                  propTypes,
                  element.props,
                  'prop',
                  name,
                  getStackAddendum
                );
                currentlyValidatingElement = null;
              } else if (
                componentClass.PropTypes !== undefined &&
                !propTypesMisspellWarningShown
              ) {
                propTypesMisspellWarningShown = true;
                warning(
                  false,
                  'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?',
                  name || 'Unknown'
                );
              }

              if (typeof componentClass.getDefaultProps === 'function') {
                warning(
                  componentClass.getDefaultProps.isReactClassApproved,
                  'getDefaultProps is only used on classic React.createClass ' +
                    'definitions. Use a static property named `defaultProps` instead.'
                );
              }
            }
            /**
             * Given a fragment, validate that it can only be provided with fragment props
             * @param {ReactElement} fragment
             */

            function validateFragmentProps(fragment) {
              currentlyValidatingElement = fragment;
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (
                  var _iterator = Object.keys(fragment.props)[
                      Symbol.iterator
                    ](),
                    _step;
                  !(_iteratorNormalCompletion = (_step = _iterator.next())
                    .done);
                  _iteratorNormalCompletion = true
                ) {
                  var key = _step.value;

                  if (!VALID_FRAGMENT_PROPS.has(key)) {
                    warning(
                      false,
                      'Invalid prop `%s` supplied to `React.Fragment`. ' +
                        'React.Fragment can only have `key` and `children` props.%s',
                      key,
                      getStackAddendum()
                    );
                    break;
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator['return']) {
                    _iterator['return']();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              if (fragment.ref !== null) {
                warning(
                  false,
                  'Invalid attribute `ref` supplied to `React.Fragment`.%s',
                  getStackAddendum()
                );
              }

              currentlyValidatingElement = null;
            }

            function createElementWithValidation(type, props, children) {
              var validType =
                typeof type === 'string' ||
                typeof type === 'function' ||
                _typeof(type) === 'symbol' ||
                typeof type === 'number'; // We warn in this case but don't throw. We expect the element creation to
              // succeed and there will likely be errors in render.

              if (!validType) {
                var info = '';

                if (
                  type === undefined ||
                  (_typeof(type) === 'object' &&
                    type !== null &&
                    Object.keys(type).length === 0)
                ) {
                  info +=
                    ' You likely forgot to export your component from the file ' +
                    "it's defined in, or you might have mixed up default and named imports.";
                }

                var sourceInfo = getSourceInfoErrorAddendum(props);

                if (sourceInfo) {
                  info += sourceInfo;
                } else {
                  info += getDeclarationErrorAddendum();
                }

                info += getStackAddendum() || '';
                warning(
                  false,
                  'React.createElement: type is invalid -- expected a string (for ' +
                    'built-in components) or a class/function (for composite ' +
                    'components) but got: %s.%s',
                  type == null ? type : _typeof(type),
                  info
                );
              }

              var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
              // TODO: Drop this when these are no longer allowed as the type argument.

              if (element == null) {
                return element;
              } // Skip key warning if the type isn't valid since our key validation logic
              // doesn't expect a non-string/function type and can throw confusing errors.
              // We don't want exception behavior to differ between dev and prod.
              // (Rendering will throw with a helpful message and as soon as the type is
              // fixed, the key warnings will appear.)

              if (validType) {
                for (var i = 2; i < arguments.length; i++) {
                  validateChildKeys(arguments[i], type);
                }
              }

              if (_typeof(type) === 'symbol' && type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
              } else {
                validatePropTypes(element);
              }

              return element;
            }

            function createFactoryWithValidation(type) {
              var validatedFactory = createElementWithValidation.bind(
                null,
                type
              ); // Legacy hook TODO: Warn if this is accessed

              validatedFactory.type = type;
              {
                Object.defineProperty(validatedFactory, 'type', {
                  enumerable: false,
                  get: function get() {
                    lowPriorityWarning$1(
                      false,
                      'Factory.type is deprecated. Access the class directly ' +
                        'before passing it to createFactory.'
                    );
                    Object.defineProperty(this, 'type', {
                      value: type
                    });
                    return type;
                  }
                });
              }
              return validatedFactory;
            }

            function cloneElementWithValidation(element, props, children) {
              var newElement = cloneElement.apply(this, arguments);

              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], newElement.type);
              }

              validatePropTypes(newElement);
              return newElement;
            }

            var React = {
              Children: {
                map: mapChildren,
                forEach: forEachChildren,
                count: countChildren,
                toArray: toArray,
                only: onlyChild
              },
              Component: Component,
              PureComponent: PureComponent,
              unstable_AsyncComponent: AsyncComponent,
              Fragment: REACT_FRAGMENT_TYPE,
              createElement: createElementWithValidation,
              cloneElement: cloneElementWithValidation,
              createFactory: createFactoryWithValidation,
              isValidElement: isValidElement,
              version: ReactVersion,
              __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                ReactCurrentOwner: ReactCurrentOwner,
                // Used by renderers to avoid bundling object-assign twice in UMD bundles:
                assign: _assign
              }
            };
            {
              _assign(
                React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                {
                  // These should not be included in production.
                  ReactDebugCurrentFrame: ReactDebugCurrentFrame,
                  // Shim for React DOM 16.0.0 which still destructured (but not used) this.
                  // TODO: remove in React 17.0.
                  ReactComponentTreeHook: {}
                }
              );
            }
            var React$2 = Object.freeze({
              default: React
            });
            var React$3 = (React$2 && React) || React$2; // TODO: decide on the top-level export form.
            // This is hacky but makes it work with both Rollup and Jest.

            var react = React$3['default'] ? React$3['default'] : React$3;
            module.exports = react;
          })();
        }

        /***/
      },

    /***/ './node_modules/react/index.js':
      /*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';

        if (false) {
        } else {
          module.exports = __webpack_require__(
            /*! ./cjs/react.development.js */ './node_modules/react/cjs/react.development.js'
          );
        }

        /***/
      },

    /***/ './node_modules/styled-components/dist/styled-components.browser.es.js':
      /*!*****************************************************************************!*\
  !*** ./node_modules/styled-components/dist/styled-components.browser.es.js ***!
  \*****************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          Object.defineProperty(exports, '__esModule', {
            value: true
          });
          exports.isStyledComponent = isStyledComponent;
          exports.consolidateStreamedStyles = consolidateStreamedStyles;
          exports.default = exports.__DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = exports.StyleSheetManager = exports.ServerStyleSheet = exports.withTheme = exports.ThemeProvider = exports.injectGlobal = exports.keyframes = exports.css = void 0;

          var _isPlainObject = _interopRequireDefault(
            __webpack_require__(
              /*! is-plain-object */ './node_modules/is-plain-object/index.js'
            )
          );

          var _stylis = _interopRequireDefault(
            __webpack_require__(/*! stylis */ './node_modules/stylis/stylis.js')
          );

          var _stylisRuleSheet = _interopRequireDefault(
            __webpack_require__(
              /*! stylis-rule-sheet */ './node_modules/stylis-rule-sheet/index.js'
            )
          );

          var _react = _interopRequireWildcard(
            __webpack_require__(/*! react */ './node_modules/react/index.js')
          );

          var _propTypes = _interopRequireDefault(
            __webpack_require__(
              /*! prop-types */ './node_modules/prop-types/index.js'
            )
          );

          var _hoistNonReactStatics = _interopRequireDefault(
            __webpack_require__(
              /*! hoist-non-react-statics */ './node_modules/styled-components/node_modules/hoist-non-react-statics/index.js'
            )
          );

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};
                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }
              newObj.default = obj;
              return newObj;
            }
          }

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          /**
           * Copyright (c) 2013-present, Facebook, Inc.
           *
           * This source code is licensed under the MIT license found in the
           * LICENSE file in the root directory of this source tree.
           *
           * @typechecks
           */
          var _uppercasePattern = /([A-Z])/g;
          /**
           * Hyphenates a camelcased string, for example:
           *
           *   > hyphenate('backgroundColor')
           *   < "background-color"
           *
           * For CSS style names, use `hyphenateStyleName` instead which works properly
           * with all vendor prefixes, including `ms`.
           *
           * @param {string} string
           * @return {string}
           */

          function hyphenate$2(string) {
            return string.replace(_uppercasePattern, '-$1').toLowerCase();
          }

          var hyphenate_1 = hyphenate$2;
          var hyphenate = hyphenate_1;
          var msPattern = /^ms-/;
          /**
           * Hyphenates a camelcased CSS property name, for example:
           *
           *   > hyphenateStyleName('backgroundColor')
           *   < "background-color"
           *   > hyphenateStyleName('MozTransition')
           *   < "-moz-transition"
           *   > hyphenateStyleName('msTransition')
           *   < "-ms-transition"
           *
           * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
           * is converted to `-ms-`.
           *
           * @param {string} string
           * @return {string}
           */

          function hyphenateStyleName(string) {
            return hyphenate(string).replace(msPattern, '-ms-');
          }

          var hyphenateStyleName_1 = hyphenateStyleName; //

          var objToCss = function objToCss(obj, prevKey) {
            var css = Object.keys(obj)
              .filter(function(key) {
                var chunk = obj[key];
                return (
                  chunk !== undefined &&
                  chunk !== null &&
                  chunk !== false &&
                  chunk !== ''
                );
              })
              .map(function(key) {
                if ((0, _isPlainObject.default)(obj[key]))
                  return objToCss(obj[key], key);
                return hyphenateStyleName_1(key) + ': ' + obj[key] + ';';
              })
              .join(' ');
            return prevKey ? prevKey + ' {\n  ' + css + '\n}' : css;
          };

          var flatten = function flatten(chunks, executionContext) {
            return chunks.reduce(function(ruleSet, chunk) {
              /* Remove falsey values */
              if (
                chunk === undefined ||
                chunk === null ||
                chunk === false ||
                chunk === ''
              ) {
                return ruleSet;
              }
              /* Flatten ruleSet */

              if (Array.isArray(chunk)) {
                return [].concat(ruleSet, flatten(chunk, executionContext));
              }
              /* Handle other components */

              if (chunk.hasOwnProperty('styledComponentId')) {
                // $FlowFixMe not sure how to make this pass
                return [].concat(ruleSet, ['.' + chunk.styledComponentId]);
              }
              /* Either execute or defer the function */

              if (typeof chunk === 'function') {
                return executionContext
                  ? ruleSet.concat.apply(
                      ruleSet,
                      flatten([chunk(executionContext)], executionContext)
                    )
                  : ruleSet.concat(chunk);
              }
              /* Handle objects */

              return ruleSet.concat(
                // $FlowFixMe have to add %checks somehow to isPlainObject
                (0, _isPlainObject.default)(chunk)
                  ? objToCss(chunk)
                  : chunk.toString()
              );
            }, []);
          }; //
          // NOTE: This stylis instance is only used to split rules from SSR'd style tags

          var stylisSplitter = new _stylis.default({
            global: false,
            cascade: false,
            keyframe: false,
            prefix: false,
            compress: false,
            semicolon: true
          });
          var stylis = new _stylis.default({
            global: false,
            cascade: true,
            keyframe: false,
            prefix: true,
            compress: false,
            semicolon: false // NOTE: This means "autocomplete missing semicolons"
          }); // Wrap `insertRulePlugin to build a list of rules,
          // and then make our own plugin to return the rules. This
          // makes it easier to hook into the existing SSR architecture

          var parsingRules = []; // eslint-disable-next-line consistent-return

          var returnRulesPlugin = function returnRulesPlugin(context) {
            if (context === -2) {
              var parsedRules = parsingRules;
              parsingRules = [];
              return parsedRules;
            }
          };

          var parseRulesPlugin = (0, _stylisRuleSheet.default)(function(rule) {
            parsingRules.push(rule);
          });
          stylis.use([parseRulesPlugin, returnRulesPlugin]);
          stylisSplitter.use([parseRulesPlugin, returnRulesPlugin]);

          var stringifyRules = function stringifyRules(
            rules,
            selector,
            prefix
          ) {
            var flatCSS = rules.join('').replace(/^\s*\/\/.*$/gm, ''); // replace JS comments

            var cssStr =
              selector && prefix
                ? prefix + ' ' + selector + ' { ' + flatCSS + ' }'
                : flatCSS;
            return stylis(prefix || !selector ? '' : selector, cssStr);
          };

          var splitByRules = function splitByRules(css) {
            return stylisSplitter('', css);
          }; //

          function isStyledComponent(target /* : %checks */) {
            return (
              typeof target === 'function' &&
              typeof target.styledComponentId === 'string'
            );
          } //

          /* This function is DEPRECATED and will be removed on the next major version release.
 * It was needed to rehydrate all style blocks prepended to chunks before React
 * tries to rehydrate its HTML stream. Since the master StyleSheet will now detect
 * the use of streamed style tags and will perform the rehydration earlier when needed
 * this function will not be needed anymore */

          function consolidateStreamedStyles() {
            if (true) {
              // eslint-disable-next-line no-console
              console.warn(
                'styled-components automatically does streaming SSR rehydration now.\n' +
                  'Calling consolidateStreamedStyles manually is no longer necessary and a noop now.\n' +
                  '- Please remove the consolidateStreamedStyles call from your client.'
              );
            }
          } //

          /* eslint-disable no-bitwise */

          /* This is the "capacity" of our alphabet i.e. 2x26 for all letters plus their capitalised
 * counterparts */

          var charsLength = 52;
          /* start at 75 for 'a' until 'z' (25) and then start at 65 for capitalised letters */

          var getAlphabeticChar = function getAlphabeticChar(code) {
            return String.fromCharCode(code + (code > 25 ? 39 : 97));
          };
          /* input a number, usually a hash and convert it to base-52 */

          var generateAlphabeticName = function generateAlphabeticName(code) {
            var name = '';
            var x = void 0;
            /* get a char and divide by alphabet-length */

            for (x = code; x > charsLength; x = Math.floor(x / charsLength)) {
              name = getAlphabeticChar(x % charsLength) + name;
            }

            return getAlphabeticChar(x % charsLength) + name;
          }; //

          var interleave = function interleave(strings, interpolations) {
            return interpolations.reduce(
              function(array, interp, i) {
                return array.concat(interp, strings[i + 1]);
              },
              [strings[0]]
            );
          }; //

          var css = function css(strings) {
            for (
              var _len = arguments.length,
                interpolations = Array(_len > 1 ? _len - 1 : 0),
                _key = 1;
              _key < _len;
              _key++
            ) {
              interpolations[_key - 1] = arguments[_key];
            }

            return flatten(interleave(strings, interpolations));
          };

          exports.css = css;
          var stream = {}; //

          var SC_ATTR = 'data-styled-components';
          var SC_STREAM_ATTR = 'data-styled-streamed';
          var CONTEXT_KEY = '__styled-components-stylesheet__';
          var IS_BROWSER =
            typeof window !== 'undefined' && 'HTMLElement' in window;
          var DISABLE_SPEEDY =
            (typeof false === 'boolean' && false) ||
            'development' !== 'production'; //

          var SC_COMPONENT_ID = /^[^\S\n]*?\/\* sc-component-id:\s*(\S+)\s+\*\//gm;

          var extractComps = function extractComps(maybeCSS) {
            var css = '' + (maybeCSS || ''); // Definitely a string, and a clone

            var existingComponents = [];
            css.replace(SC_COMPONENT_ID, function(
              match,
              componentId,
              matchIndex
            ) {
              existingComponents.push({
                componentId: componentId,
                matchIndex: matchIndex
              });
              return match;
            });
            return existingComponents.map(function(_ref, i) {
              var componentId = _ref.componentId,
                matchIndex = _ref.matchIndex;
              var nextComp = existingComponents[i + 1];
              var cssFromDOM = nextComp
                ? css.slice(matchIndex, nextComp.matchIndex)
                : css.slice(matchIndex);
              return {
                componentId: componentId,
                cssFromDOM: cssFromDOM
              };
            });
          }; //

          /* eslint-disable camelcase, no-undef */

          var getNonce = function getNonce() {
            return true ? __webpack_require__.nc : undefined;
          }; //
          // Helper to call a given function, only once

          var once = function once(cb) {
            var called = false;
            return function() {
              if (!called) {
                called = true;
                cb();
              }
            };
          };

          var classCallCheck = function classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          };

          var createClass = (function() {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            return function(Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();

          var _extends =
            Object.assign ||
            function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];

                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }

              return target;
            };

          var inherits = function inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function, not ' +
                  _typeof(superClass)
              );
            }

            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          };

          var objectWithoutProperties = function objectWithoutProperties(
            obj,
            keys
          ) {
            var target = {};

            for (var i in obj) {
              if (keys.indexOf(i) >= 0) continue;
              if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
              target[i] = obj[i];
            }

            return target;
          };

          var possibleConstructorReturn = function possibleConstructorReturn(
            self,
            call
          ) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }

            return call &&
              (_typeof(call) === 'object' || typeof call === 'function')
              ? call
              : self;
          }; //

          /* These are helpers for the StyleTags to keep track of the injected
 * rule names for each (component) ID that they're keeping track of.
 * They're crucial for detecting whether a name has already been
 * injected.
 * (This excludes rehydrated names) */

          /* adds a new ID:name pairing to a names dictionary */

          var addNameForId = function addNameForId(names, id, name) {
            if (name) {
              // eslint-disable-next-line no-param-reassign
              var namesForId = names[id] || (names[id] = Object.create(null));
              namesForId[name] = true;
            }
          };
          /* resets an ID entirely by overwriting it in the dictionary */

          var resetIdNames = function resetIdNames(names, id) {
            // eslint-disable-next-line no-param-reassign
            names[id] = Object.create(null);
          };
          /* factory for a names dictionary checking the existance of an ID:name pairing */

          var hasNameForId = function hasNameForId(names) {
            return function(id, name) {
              return names[id] !== undefined && names[id][name];
            };
          };
          /* stringifies names for the html/element output */

          var stringifyNames = function stringifyNames(names) {
            var str = ''; // eslint-disable-next-line guard-for-in

            for (var id in names) {
              str += Object.keys(names[id]).join(' ') + ' ';
            }

            return str.trim();
          };
          /* clones the nested names dictionary */

          var cloneNames = function cloneNames(names) {
            var clone = Object.create(null); // eslint-disable-next-line guard-for-in

            for (var id in names) {
              clone[id] = _extends({}, names[id]);
            }

            return clone;
          }; //

          /* These are helpers that deal with the insertRule (aka speedy) API
 * They are used in the StyleTags and specifically the speedy tag
 */

          /* retrieve a sheet for a given style tag */

          var sheetForTag = function sheetForTag(tag) {
            // $FlowFixMe
            if (tag.sheet) return tag.sheet;
            /* Firefox quirk requires us to step through all stylesheets to find one owned by the given tag */

            var size = document.styleSheets.length;

            for (var i = 0; i < size; i += 1) {
              var sheet = document.styleSheets[i]; // $FlowFixMe

              if (sheet.ownerNode === tag) return sheet;
            }
            /* we should always be able to find a tag */

            throw new Error();
          };
          /* insert a rule safely and return whether it was actually injected */

          var safeInsertRule = function safeInsertRule(sheet, cssRule, index) {
            /* abort early if cssRule string is falsy */
            if (!cssRule) return false;
            var maxIndex = sheet.cssRules.length;

            try {
              /* use insertRule and cap passed index with maxIndex (no of cssRules) */
              sheet.insertRule(cssRule, index <= maxIndex ? index : maxIndex);
            } catch (err) {
              /* any error indicates an invalid rule */
              return false;
            }

            return true;
          };
          /* deletes `size` rules starting from `removalIndex` */

          var deleteRules = function deleteRules(sheet, removalIndex, size) {
            var lowerBound = removalIndex - size;

            for (var i = removalIndex; i >= lowerBound; i -= 1) {
              sheet.deleteRule(i);
            }
          }; //

          /* eslint-disable flowtype/object-type-delimiter */

          /* eslint-disable react/prop-types */

          /* this error is used for makeStyleTag */

          var parentNodeUnmountedErr = true
            ? "\nTrying to insert a new style tag, but the given Node is unmounted!\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n".trim()
            : undefined;
          /* this error is used for tags */

          var throwCloneTagErr = function throwCloneTagErr() {
            throw new Error(
              true
                ? '\nThe clone method cannot be used on the client!\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n'.trim()
                : undefined
            );
          };
          /* this marker separates component styles and is important for rehydration */

          var makeTextMarker = function makeTextMarker(id) {
            return '\n/* sc-component-id: ' + id + ' */\n';
          };
          /* add up all numbers in array up until and including the index */

          var addUpUntilIndex = function addUpUntilIndex(sizes, index) {
            var totalUpToIndex = 0;

            for (var i = 0; i <= index; i += 1) {
              totalUpToIndex += sizes[i];
            }

            return totalUpToIndex;
          };
          /* create a new style tag after lastEl */

          var makeStyleTag = function makeStyleTag(
            target,
            tagEl,
            insertBefore
          ) {
            var el = document.createElement('style');
            el.setAttribute(SC_ATTR, '');
            var nonce = getNonce();

            if (nonce) {
              el.setAttribute('nonce', nonce);
            }
            /* Work around insertRule quirk in EdgeHTML */

            el.appendChild(document.createTextNode(''));

            if (target && !tagEl) {
              /* Append to target when no previous element was passed */
              target.appendChild(el);
            } else {
              if (!tagEl || !target || !tagEl.parentNode) {
                throw new Error(parentNodeUnmountedErr);
              }
              /* Insert new style tag after the previous one */

              tagEl.parentNode.insertBefore(
                el,
                insertBefore ? tagEl : tagEl.nextSibling
              );
            }

            return el;
          };
          /* takes a css factory function and outputs an html styled tag factory */

          var wrapAsHtmlTag = function wrapAsHtmlTag(css, names) {
            return function(additionalAttrs) {
              var nonce = getNonce();
              var attrs = [
                nonce && 'nonce="' + nonce + '"',
                SC_ATTR + '="' + stringifyNames(names) + '"',
                additionalAttrs
              ];
              var htmlAttr = attrs.filter(Boolean).join(' ');
              return '<style ' + htmlAttr + '>' + css() + '</style>';
            };
          };
          /* takes a css factory function and outputs an element factory */

          var wrapAsElement = function wrapAsElement(css, names) {
            return function() {
              var _props;

              var props = ((_props = {}),
              (_props[SC_ATTR] = stringifyNames(names)),
              _props);
              var nonce = getNonce();

              if (nonce) {
                // $FlowFixMe
                props.nonce = nonce;
              } // eslint-disable-next-line react/no-danger

              return _react.default.createElement(
                'style',
                _extends({}, props, {
                  dangerouslySetInnerHTML: {
                    __html: css()
                  }
                })
              );
            };
          };

          var getIdsFromMarkersFactory = function getIdsFromMarkersFactory(
            markers
          ) {
            return function() {
              return Object.keys(markers);
            };
          };
          /* speedy tags utilise insertRule */

          var makeSpeedyTag = function makeSpeedyTag(el, getImportRuleTag) {
            var names = Object.create(null);
            var markers = Object.create(null);
            var sizes = [];
            var extractImport = getImportRuleTag !== undefined;
            /* indicates whther getImportRuleTag was called */

            var usedImportRuleTag = false;

            var insertMarker = function insertMarker(id) {
              var prev = markers[id];

              if (prev !== undefined) {
                return prev;
              }

              var marker = (markers[id] = sizes.length);
              sizes.push(0);
              resetIdNames(names, id);
              return marker;
            };

            var insertRules = function insertRules(id, cssRules, name) {
              var marker = insertMarker(id);
              var sheet = sheetForTag(el);
              var insertIndex = addUpUntilIndex(sizes, marker);
              var injectedRules = 0;
              var importRules = [];
              var cssRulesSize = cssRules.length;

              for (var i = 0; i < cssRulesSize; i += 1) {
                var cssRule = cssRules[i];
                var mayHaveImport = extractImport;
                /* @import rules are reordered to appear first */

                if (mayHaveImport && cssRule.indexOf('@import') !== -1) {
                  importRules.push(cssRule);
                } else if (
                  safeInsertRule(sheet, cssRule, insertIndex + injectedRules)
                ) {
                  mayHaveImport = false;
                  injectedRules += 1;
                }
              }

              if (extractImport && importRules.length > 0) {
                usedImportRuleTag = true; // $FlowFixMe

                getImportRuleTag().insertRules(id + '-import', importRules);
              }

              sizes[marker] += injectedRules;
              /* add up no of injected rules */

              addNameForId(names, id, name);
            };

            var removeRules = function removeRules(id) {
              var marker = markers[id];
              if (marker === undefined) return;
              var size = sizes[marker];
              var sheet = sheetForTag(el);
              var removalIndex = addUpUntilIndex(sizes, marker);
              deleteRules(sheet, removalIndex, size);
              sizes[marker] = 0;
              resetIdNames(names, id);

              if (extractImport && usedImportRuleTag) {
                // $FlowFixMe
                getImportRuleTag().removeRules(id + '-import');
              }
            };

            var css = function css() {
              var _sheetForTag = sheetForTag(el),
                cssRules = _sheetForTag.cssRules;

              var str = '';
              var i = 0; // eslint-disable-next-line guard-for-in

              for (var id in markers) {
                str += makeTextMarker(id);
                var end = markers[id] + i;

                for (; i < end; i += 1) {
                  str += cssRules[i].cssText;
                }
              }

              return str;
            };

            return {
              styleTag: el,
              getIds: getIdsFromMarkersFactory(markers),
              hasNameForId: hasNameForId(names),
              insertMarker: insertMarker,
              insertRules: insertRules,
              removeRules: removeRules,
              css: css,
              toHTML: wrapAsHtmlTag(css, names),
              toElement: wrapAsElement(css, names),
              clone: throwCloneTagErr
            };
          };

          var makeBrowserTag = function makeBrowserTag(el, getImportRuleTag) {
            var names = Object.create(null);
            var markers = Object.create(null);
            var extractImport = getImportRuleTag !== undefined;

            var makeTextNode = function makeTextNode(id) {
              return document.createTextNode(makeTextMarker(id));
            };
            /* indicates whther getImportRuleTag was called */

            var usedImportRuleTag = false;

            var insertMarker = function insertMarker(id) {
              var prev = markers[id];

              if (prev !== undefined) {
                return prev;
              }

              var marker = (markers[id] = makeTextNode(id));
              el.appendChild(marker);
              names[id] = Object.create(null);
              return marker;
            };

            var insertRules = function insertRules(id, cssRules, name) {
              var marker = insertMarker(id);
              var importRules = [];
              var cssRulesSize = cssRules.length;

              for (var i = 0; i < cssRulesSize; i += 1) {
                var rule = cssRules[i];
                var mayHaveImport = extractImport;

                if (mayHaveImport && rule.indexOf('@import') !== -1) {
                  importRules.push(rule);
                } else {
                  mayHaveImport = false;
                  var separator = i === cssRulesSize - 1 ? '' : ' ';
                  marker.appendData('' + rule + separator);
                }
              }

              addNameForId(names, id, name);

              if (extractImport && importRules.length > 0) {
                usedImportRuleTag = true; // $FlowFixMe

                getImportRuleTag().insertRules(id + '-import', importRules);
              }
            };

            var removeRules = function removeRules(id) {
              var marker = markers[id];
              if (marker === undefined) return;
              /* create new empty text node and replace the current one */

              var newMarker = makeTextNode(id);
              el.replaceChild(newMarker, marker);
              markers[id] = newMarker;
              resetIdNames(names, id);

              if (extractImport && usedImportRuleTag) {
                // $FlowFixMe
                getImportRuleTag().removeRules(id + '-import');
              }
            };

            var css = function css() {
              var str = ''; // eslint-disable-next-line guard-for-in

              for (var id in markers) {
                str += markers[id].data;
              }

              return str;
            };

            return {
              styleTag: el,
              getIds: getIdsFromMarkersFactory(markers),
              hasNameForId: hasNameForId(names),
              insertMarker: insertMarker,
              insertRules: insertRules,
              removeRules: removeRules,
              css: css,
              toHTML: wrapAsHtmlTag(css, names),
              toElement: wrapAsElement(css, names),
              clone: throwCloneTagErr
            };
          };

          var makeServerTagInternal = function makeServerTagInternal(
            namesArg,
            markersArg
          ) {
            var names = namesArg === undefined ? Object.create(null) : namesArg;
            var markers =
              markersArg === undefined ? Object.create(null) : markersArg;

            var insertMarker = function insertMarker(id) {
              var prev = markers[id];

              if (prev !== undefined) {
                return prev;
              }

              return (markers[id] = ['']);
            };

            var insertRules = function insertRules(id, cssRules, name) {
              var marker = insertMarker(id);
              marker[0] += cssRules.join(' ');
              addNameForId(names, id, name);
            };

            var removeRules = function removeRules(id) {
              var marker = markers[id];
              if (marker === undefined) return;
              marker[0] = '';
              resetIdNames(names, id);
            };

            var css = function css() {
              var str = ''; // eslint-disable-next-line guard-for-in

              for (var id in markers) {
                var cssForId = markers[id][0];

                if (cssForId) {
                  str += makeTextMarker(id) + cssForId;
                }
              }

              return str;
            };

            var clone = function clone() {
              var namesClone = cloneNames(names);
              var markersClone = Object.create(null); // eslint-disable-next-line guard-for-in

              for (var id in markers) {
                markersClone[id] = [markers[id][0]];
              }

              return makeServerTagInternal(namesClone, markersClone);
            };

            var tag = {
              styleTag: null,
              getIds: getIdsFromMarkersFactory(markers),
              hasNameForId: hasNameForId(names),
              insertMarker: insertMarker,
              insertRules: insertRules,
              removeRules: removeRules,
              css: css,
              toHTML: wrapAsHtmlTag(css, names),
              toElement: wrapAsElement(css, names),
              clone: clone
            };
            return tag;
          };

          var makeServerTag = function makeServerTag() {
            return makeServerTagInternal();
          };

          var makeTag = function makeTag(
            target,
            tagEl,
            forceServer,
            insertBefore,
            getImportRuleTag
          ) {
            if (IS_BROWSER && !forceServer) {
              var el = makeStyleTag(target, tagEl, insertBefore);

              if (DISABLE_SPEEDY) {
                return makeBrowserTag(el, getImportRuleTag);
              } else {
                return makeSpeedyTag(el, getImportRuleTag);
              }
            }

            return makeServerTag();
          };
          /* wraps a given tag so that rehydration is performed once when necessary */

          var makeRehydrationTag = function makeRehydrationTag(
            tag,
            els,
            extracted,
            names,
            immediateRehydration
          ) {
            /* rehydration function that adds all rules to the new tag */
            var rehydrate = once(function() {
              /* add all extracted components to the new tag */
              for (var i = 0; i < extracted.length; i += 1) {
                var _extracted$i = extracted[i],
                  componentId = _extracted$i.componentId,
                  cssFromDOM = _extracted$i.cssFromDOM;
                var cssRules = splitByRules(cssFromDOM);
                tag.insertRules(componentId, cssRules);
              }
              /* remove old HTMLStyleElements, since they have been rehydrated */

              for (var _i = 0; _i < els.length; _i += 1) {
                var el = els[_i];

                if (el.parentNode) {
                  el.parentNode.removeChild(el);
                }
              }
            });
            if (immediateRehydration) rehydrate();
            return _extends({}, tag, {
              /* add rehydration hook to insertion methods */
              insertMarker: function insertMarker(id) {
                rehydrate();
                return tag.insertMarker(id);
              },
              insertRules: function insertRules(id, cssRules, name) {
                rehydrate();
                return tag.insertRules(id, cssRules, name);
              }
            });
          }; //

          /* determine the maximum number of components before tags are sharded */

          var MAX_SIZE = void 0;

          if (IS_BROWSER) {
            /* in speedy mode we can keep a lot more rules in a sheet before a slowdown can be expected */
            MAX_SIZE = DISABLE_SPEEDY ? 40 : 1000;
          } else {
            /* for servers we do not need to shard at all */
            MAX_SIZE = -1;
          }

          var sheetRunningId = 0;
          var master = void 0;

          var StyleSheet = (function() {
            /* a map from ids to tags */

            /* deferred rules for a given id */

            /* this is used for not reinjecting rules via hasNameForId() */

            /* when rules for an id are removed using remove() we have to ignore rehydratedNames for it */

            /* a list of tags belonging to this StyleSheet */

            /* a tag for import rules */

            /* current capacity until a new tag must be created */

            /* children (aka clones) of this StyleSheet inheriting all and future injections */
            function StyleSheet() {
              var _this = this;

              var target =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : IS_BROWSER ? document.head : null;
              var forceServer =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : false;
              classCallCheck(this, StyleSheet);

              this.getImportRuleTag = function() {
                var importRuleTag = _this.importRuleTag;

                if (importRuleTag !== undefined) {
                  return importRuleTag;
                }

                var firstTag = _this.tags[0];
                var insertBefore = true;
                return (_this.importRuleTag = makeTag(
                  _this.target,
                  firstTag ? firstTag.styleTag : null,
                  _this.forceServer,
                  insertBefore
                ));
              };

              this.id = sheetRunningId += 1;
              this.sealed = false;
              this.forceServer = forceServer;
              this.target = forceServer ? null : target;
              this.tagMap = {};
              this.deferred = {};
              this.rehydratedNames = {};
              this.ignoreRehydratedNames = {};
              this.tags = [];
              this.capacity = 1;
              this.clones = [];
            }
            /* rehydrate all SSR'd style tags */

            StyleSheet.prototype.rehydrate = function rehydrate() {
              if (!IS_BROWSER || this.forceServer) {
                return this;
              }

              var els = [];
              var names = [];
              var extracted = [];
              var isStreamed = false;
              /* retrieve all of our SSR style elements from the DOM */

              var nodes = document.querySelectorAll('style[' + SC_ATTR + ']');
              var nodesSize = nodes.length;
              /* abort rehydration if no previous style tags were found */

              if (nodesSize === 0) {
                return this;
              }

              for (var i = 0; i < nodesSize; i += 1) {
                // $FlowFixMe: We can trust that all elements in this query are style elements
                var el = nodes[i];
                /* check if style tag is a streamed tag */

                isStreamed = !!el.getAttribute(SC_STREAM_ATTR) || isStreamed;
                /* retrieve all component names */

                var elNames = (el.getAttribute(SC_ATTR) || '')
                  .trim()
                  .split(/\s+/);
                var elNamesSize = elNames.length;

                for (var j = 0; j < elNamesSize; j += 1) {
                  var name = elNames[j];
                  /* add rehydrated name to sheet to avoid readding styles */

                  this.rehydratedNames[name] = true;
                  names.push(name);
                }
                /* extract all components and their CSS */

                extracted = extracted.concat(extractComps(el.textContent));
                /* store original HTMLStyleElement */

                els.push(el);
              }
              /* abort rehydration if nothing was extracted */

              var extractedSize = extracted.length;

              if (extractedSize === 0) {
                return this;
              }
              /* create a tag to be used for rehydration */

              var tag = this.makeTag(null);
              var rehydrationTag = makeRehydrationTag(
                tag,
                els,
                extracted,
                names,
                isStreamed
              );
              /* reset capacity and adjust MAX_SIZE by the initial size of the rehydration */

              this.capacity = Math.max(1, MAX_SIZE - extractedSize);
              this.tags.push(rehydrationTag);
              /* retrieve all component ids */

              for (var _j = 0; _j < extractedSize; _j += 1) {
                this.tagMap[extracted[_j].componentId] = rehydrationTag;
              }

              return this;
            };
            /* retrieve a "master" instance of StyleSheet which is typically used when no other is available
   * The master StyleSheet is targeted by injectGlobal, keyframes, and components outside of any
    * StyleSheetManager's context */

            /* reset the internal "master" instance */

            StyleSheet.reset = function reset() {
              var forceServer =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : false;
              master = new StyleSheet(undefined, forceServer).rehydrate();
            };
            /* adds "children" to the StyleSheet that inherit all of the parents' rules
   * while their own rules do not affect the parent */

            StyleSheet.prototype.clone = function clone() {
              var sheet = new StyleSheet(this.target, this.forceServer);
              /* add to clone array */

              this.clones.push(sheet);
              /* clone all tags */

              sheet.tags = this.tags.map(function(tag) {
                var ids = tag.getIds();
                var newTag = tag.clone();
                /* reconstruct tagMap */

                for (var i = 0; i < ids.length; i += 1) {
                  sheet.tagMap[ids[i]] = newTag;
                }

                return newTag;
              });
              /* clone other maps */

              sheet.rehydratedNames = _extends({}, this.rehydratedNames);
              sheet.deferred = _extends({}, this.deferred);
              return sheet;
            };
            /* force StyleSheet to create a new tag on the next injection */

            StyleSheet.prototype.sealAllTags = function sealAllTags() {
              this.capacity = 1;
              this.sealed = true;
            };

            StyleSheet.prototype.makeTag = function makeTag$$1(tag) {
              var lastEl = tag ? tag.styleTag : null;
              var insertBefore = false;
              return makeTag(
                this.target,
                lastEl,
                this.forceServer,
                insertBefore,
                this.getImportRuleTag
              );
            };
            /* get a tag for a given componentId, assign the componentId to one, or shard */

            StyleSheet.prototype.getTagForId = function getTagForId(id) {
              /* simply return a tag, when the componentId was already assigned one */
              var prev = this.tagMap[id];

              if (prev !== undefined && !this.sealed) {
                return prev;
              }

              var tag = this.tags[this.tags.length - 1];
              /* shard (create a new tag) if the tag is exhausted (See MAX_SIZE) */

              this.capacity -= 1;

              if (this.capacity === 0) {
                this.capacity = MAX_SIZE;
                this.sealed = false;
                tag = this.makeTag(tag);
                this.tags.push(tag);
              }

              return (this.tagMap[id] = tag);
            };
            /* mainly for injectGlobal to check for its id */

            StyleSheet.prototype.hasId = function hasId(id) {
              return this.tagMap[id] !== undefined;
            };
            /* caching layer checking id+name to already have a corresponding tag and injected rules */

            StyleSheet.prototype.hasNameForId = function hasNameForId(
              id,
              name
            ) {
              /* exception for rehydrated names which are checked separately */
              if (
                this.ignoreRehydratedNames[id] === undefined &&
                this.rehydratedNames[name]
              ) {
                return true;
              }

              var tag = this.tagMap[id];
              return tag !== undefined && tag.hasNameForId(id, name);
            };
            /* registers a componentId and registers it on its tag */

            StyleSheet.prototype.deferredInject = function deferredInject(
              id,
              cssRules
            ) {
              /* don't inject when the id is already registered */
              if (this.tagMap[id] !== undefined) return;
              var clones = this.clones;

              for (var i = 0; i < clones.length; i += 1) {
                clones[i].deferredInject(id, cssRules);
              }

              this.getTagForId(id).insertMarker(id);
              this.deferred[id] = cssRules;
            };
            /* injects rules for a given id with a name that will need to be cached */

            StyleSheet.prototype.inject = function inject(id, cssRules, name) {
              var clones = this.clones;

              for (var i = 0; i < clones.length; i += 1) {
                clones[i].inject(id, cssRules, name);
              }
              /* add deferred rules for component */

              var injectRules = cssRules;
              var deferredRules = this.deferred[id];

              if (deferredRules !== undefined) {
                injectRules = deferredRules.concat(injectRules);
                delete this.deferred[id];
              }

              var tag = this.getTagForId(id);
              tag.insertRules(id, injectRules, name);
            };
            /* removes all rules for a given id, which doesn't remove its marker but resets it */

            StyleSheet.prototype.remove = function remove(id) {
              var tag = this.tagMap[id];
              if (tag === undefined) return;
              var clones = this.clones;

              for (var i = 0; i < clones.length; i += 1) {
                clones[i].remove(id);
              }
              /* remove all rules from the tag */

              tag.removeRules(id);
              /* ignore possible rehydrated names */

              this.ignoreRehydratedNames[id] = true;
              /* delete possible deferred rules */

              delete this.deferred[id];
            };

            StyleSheet.prototype.toHTML = function toHTML() {
              return this.tags
                .map(function(tag) {
                  return tag.toHTML();
                })
                .join('');
            };

            StyleSheet.prototype.toReactElements = function toReactElements() {
              var id = this.id;
              return this.tags.map(function(tag, i) {
                var key = 'sc-' + id + '-' + i;
                return (0, _react.cloneElement)(tag.toElement(), {
                  key: key
                });
              });
            };

            createClass(StyleSheet, null, [
              {
                key: 'master',
                get: function get$$1() {
                  return master || (master = new StyleSheet().rehydrate());
                }
                /* NOTE: This is just for backwards-compatibility with jest-styled-components */
              },
              {
                key: 'instance',
                get: function get$$1() {
                  return StyleSheet.master;
                }
              }
            ]);
            return StyleSheet;
          })();

          var _StyleSheetManager$ch; //

          /* this error is used for makeStyleTag */

          var targetPropErr = true
            ? '\nThe StyleSheetManager expects a valid target or sheet prop!\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n'.trim()
            : undefined;

          var StyleSheetManager = (function(_Component) {
            inherits(StyleSheetManager, _Component);

            function StyleSheetManager() {
              classCallCheck(this, StyleSheetManager);
              return possibleConstructorReturn(
                this,
                _Component.apply(this, arguments)
              );
            }

            StyleSheetManager.prototype.getChildContext = function getChildContext() {
              var _ref;

              return (
                (_ref = {}), (_ref[CONTEXT_KEY] = this.sheetInstance), _ref
              );
            };

            StyleSheetManager.prototype.componentWillMount = function componentWillMount() {
              if (this.props.sheet) {
                this.sheetInstance = this.props.sheet;
              } else if (this.props.target) {
                this.sheetInstance = new StyleSheet(this.props.target);
              } else {
                throw new Error(targetPropErr);
              }
            };

            StyleSheetManager.prototype.render = function render() {
              /* eslint-disable react/prop-types */
              // Flow v0.43.1 will report an error accessing the `children` property,
              // but v0.47.0 will not. It is necessary to use a type cast instead of
              // a "fixme" comment to satisfy both Flow versions.
              return _react.default.Children.only(this.props.children);
            };

            return StyleSheetManager;
          })(_react.Component);

          exports.StyleSheetManager = StyleSheetManager;
          StyleSheetManager.childContextTypes = ((_StyleSheetManager$ch = {}),
          (_StyleSheetManager$ch[CONTEXT_KEY] = _propTypes.default.oneOfType([
            _propTypes.default.instanceOf(StyleSheet),
            _propTypes.default.instanceOf(ServerStyleSheet)
          ]).isRequired),
          _StyleSheetManager$ch);
          true
            ? (StyleSheetManager.propTypes = {
                sheet: _propTypes.default.oneOfType([
                  _propTypes.default.instanceOf(StyleSheet),
                  _propTypes.default.instanceOf(ServerStyleSheet)
                ]),
                target: _propTypes.default.shape({
                  appendChild: _propTypes.default.func.isRequired
                })
              })
            : undefined; //

          /* eslint-disable no-underscore-dangle */

          /* this error is used for makeStyleTag */

          var sheetClosedErr = true
            ? "\nCan't collect styles once you've consumed a ServerStyleSheet's styles!\nServerStyleSheet is a one off instance for each server-side render cycle.\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n".trim()
            : undefined;
          var streamBrowserErr = true
            ? 'Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.'
            : undefined;

          var ServerStyleSheet = (function() {
            function ServerStyleSheet() {
              classCallCheck(this, ServerStyleSheet);
              /* The master sheet might be reset, so keep a reference here */

              this.masterSheet = StyleSheet.master;
              this.instance = this.masterSheet.clone();
              this.closed = false;
            }

            ServerStyleSheet.prototype.complete = function complete() {
              if (!this.closed) {
                /* Remove closed StyleSheets from the master sheet */
                var index = this.masterSheet.clones.indexOf(this.instance);
                this.masterSheet.clones.splice(index, 1);
                this.closed = true;
              }
            };

            ServerStyleSheet.prototype.collectStyles = function collectStyles(
              children
            ) {
              if (this.closed) {
                throw new Error(sheetClosedErr);
              }

              return _react.default.createElement(
                StyleSheetManager,
                {
                  sheet: this.instance
                },
                children
              );
            };

            ServerStyleSheet.prototype.getStyleTags = function getStyleTags() {
              this.complete();
              return this.instance.toHTML();
            };

            ServerStyleSheet.prototype.getStyleElement = function getStyleElement() {
              this.complete();
              return this.instance.toReactElements();
            };

            ServerStyleSheet.prototype.interleaveWithNodeStream = function interleaveWithNodeStream(
              readableStream
            ) {
              var _this = this;

              {
                throw new Error(streamBrowserErr);
              }
              /* the tag index keeps track of which tags have already been emitted */

              var instance = this.instance;
              var instanceTagIndex = 0;
              var streamAttr = SC_STREAM_ATTR + '="true"';
              var ourStream = new stream.Readable(); // $FlowFixMe

              ourStream._read = function() {};

              readableStream.on('data', function(chunk) {
                var tags = instance.tags;
                var html = '';
                /* retrieve html for each new style tag */

                for (; instanceTagIndex < tags.length; instanceTagIndex += 1) {
                  var tag = tags[instanceTagIndex];
                  html += tag.toHTML(streamAttr);
                }
                /* force our StyleSheets to emit entirely new tags */

                instance.sealAllTags();
                /* prepend style html to chunk */

                ourStream.push(html + chunk);
              });
              readableStream.on('end', function() {
                _this.complete();

                ourStream.push(null);
              });
              readableStream.on('error', function(err) {
                _this.complete();

                ourStream.emit('error', err);
              });
              return ourStream;
            };

            return ServerStyleSheet;
          })(); //

          exports.ServerStyleSheet = ServerStyleSheet;
          var LIMIT = 200;

          var createWarnTooManyClasses = function createWarnTooManyClasses(
            displayName
          ) {
            var generatedClasses = {};
            var warningSeen = false;
            return function(className) {
              if (!warningSeen) {
                generatedClasses[className] = true;

                if (Object.keys(generatedClasses).length >= LIMIT) {
                  // Unable to find latestRule in test environment.

                  /* eslint-disable no-console, prefer-template */
                  console.warn(
                    'Over ' +
                      LIMIT +
                      ' classes were generated for component ' +
                      displayName +
                      '. \n' +
                      'Consider using the attrs method, together with a style object for frequently changed styles.\n' +
                      'Example:\n' +
                      '  const Component = styled.div.attrs({\n' +
                      '    style: ({ background }) => ({\n' +
                      '      background,\n' +
                      '    }),\n' +
                      '  })`width: 100%;`\n\n' +
                      '  <Component />'
                  );
                  warningSeen = true;
                  generatedClasses = {};
                }
              }
            };
          }; //

          /* eslint-disable max-len */

          /**
           * Trying to avoid the unknown-prop errors on styled components by filtering by
           * React's attribute whitelist.
           *
           * To regenerate this regex:
           *
           * 1. `npm i -g regexgen` (https://github.com/devongovett/regexgen)
           * 2. Run `regexgen` with the list of space-separated words below as input
           * 3. Surround the emitted regex with this: `/^(GENERATED_REGEX)$/` -- this will ensure a full string match
           *    and no false positives from partials
           **/

          /*
children dangerouslySetInnerHTML key ref autoFocus defaultValue valueLink defaultChecked checkedLink innerHTML suppressContentEditableWarning onFocusIn onFocusOut className onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onReset onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onAnimationStart onAnimationEnd onAnimationIteration onTransitionEnd onCopyCapture onCutCapture onPasteCapture onCompositionEndCapture onCompositionStartCapture onCompositionUpdateCapture onKeyDownCapture onKeyPressCapture onKeyUpCapture onFocusCapture onBlurCapture onChangeCapture onInputCapture onSubmitCapture onResetCapture onClickCapture onContextMenuCapture onDoubleClickCapture onDragCapture onDragEndCapture onDragEnterCapture onDragExitCapture onDragLeaveCapture onDragOverCapture onDragStartCapture onDropCapture onMouseDownCapture onMouseEnterCapture onMouseLeaveCapture onMouseMoveCapture onMouseOutCapture onMouseOverCapture onMouseUpCapture onSelectCapture onTouchCancelCapture onTouchEndCapture onTouchMoveCapture onTouchStartCapture onScrollCapture onWheelCapture onAbortCapture onCanPlayCapture onCanPlayThroughCapture onDurationChangeCapture onEmptiedCapture onEncryptedCapture onEndedCapture onErrorCapture onLoadedDataCapture onLoadedMetadataCapture onLoadStartCapture onPauseCapture onPlayCapture onPlayingCapture onProgressCapture onRateChangeCapture onSeekedCapture onSeekingCapture onStalledCapture onSuspendCapture onTimeUpdateCapture onVolumeChangeCapture onWaitingCapture onLoadCapture onAnimationStartCapture onAnimationEndCapture onAnimationIterationCapture onTransitionEndCapture accept acceptCharset accessKey action allowFullScreen allowTransparency alt as async autoComplete autoPlay capture cellPadding cellSpacing charSet challenge checked cite classID className cols colSpan content contentEditable contextMenu controlsList controls coords crossOrigin data dateTime default defer dir disabled download draggable encType form formAction formEncType formMethod formNoValidate formTarget frameBorder headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media mediaGroup method min minLength multiple muted name nonce noValidate open optimum pattern placeholder playsInline poster preload profile radioGroup readOnly referrerPolicy rel required reversed role rows rowSpan sandbox scope scoped scrolling seamless selected shape size sizes span spellCheck src srcDoc srcLang srcSet start step style summary tabIndex target title type useMap value width wmode wrap about datatype inlist prefix property resource typeof vocab autoCapitalize autoCorrect autoSave color itemProp itemScope itemType itemID itemRef results security unselectable accentHeight accumulate additive alignmentBaseline allowReorder alphabetic amplitude arabicForm ascent attributeName attributeType autoReverse azimuth baseFrequency baseProfile baselineShift bbox begin bias by calcMode capHeight clip clipPath clipRule clipPathUnits colorInterpolation colorInterpolationFilters colorProfile colorRendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominantBaseline dur dx dy edgeMode elevation enableBackground end exponent externalResourcesRequired fill fillOpacity fillRule filter filterRes filterUnits floodColor floodOpacity focusable fontFamily fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontWeight format from fx fy g1 g2 glyphName glyphOrientationHorizontal glyphOrientationVertical glyphRef gradientTransform gradientUnits hanging horizAdvX horizOriginX ideographic imageRendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lengthAdjust letterSpacing lightingColor limitingConeAngle local markerEnd markerMid markerStart markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical mode numOctaves offset opacity operator order orient orientation origin overflow overlinePosition overlineThickness paintOrder panose1 pathLength patternContentUnits patternTransform patternUnits pointerEvents points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY renderingIntent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shapeRendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stopColor stopOpacity strikethroughPosition strikethroughThickness string stroke strokeDasharray strokeDashoffset strokeLinecap strokeLinejoin strokeMiterlimit strokeOpacity strokeWidth surfaceScale systemLanguage tableValues targetX targetY textAnchor textDecoration textRendering textLength to transform u1 u2 underlinePosition underlineThickness unicode unicodeBidi unicodeRange unitsPerEm vAlphabetic vHanging vIdeographic vMathematical values vectorEffect version vertAdvY vertOriginX vertOriginY viewBox viewTarget visibility widths wordSpacing writingMode x xHeight x1 x2 xChannelSelector xlinkActuate xlinkArcrole xlinkHref xlinkRole xlinkShow xlinkTitle xlinkType xmlBase xmlns xmlnsXlink xmlLang xmlSpace y y1 y2 yChannelSelector z zoomAndPan
*/

          /* eslint-enable max-len */

          var ATTRIBUTE_REGEX = /^((?:s(?:uppressContentEditableWarn|croll|pac)|(?:shape|image|text)Render|(?:letter|word)Spac|vHang|hang)ing|(?:on(?:AnimationIteration|C(?:o(?:mposition(?:Update|Start|End)|ntextMenu|py)|anPlayThrough|anPlay|hange|lick|ut)|(?:(?:Duration|Volume|Rate)Chang|(?:MouseLea|(?:Touch|Mouse)Mo|DragLea)v|Paus)e|Loaded(?:Metad|D)ata|(?:Animation|Touch|Load|Drag)Start|(?:(?:T(?:ransition|ouch)|Animation)E|Suspe)nd|DoubleClick|(?:TouchCanc|Whe)el|(?:Mouse(?:Ent|Ov)e|Drag(?:Ent|Ov)e|Erro)r|TimeUpdate|(?:E(?:n(?:crypt|d)|mpti)|S(?:tall|eek))ed|MouseDown|P(?:rogress|laying)|(?:MouseOu|DragExi|S(?:elec|ubmi)|Rese|Inpu)t|KeyPress|DragEnd|Key(?:Down|Up)|(?:Wait|Seek)ing|(?:MouseU|Dro)p|Scroll|Paste|Focus|Abort|Drag|Play|Load|Blur)Captur|alignmentBaselin|(?:limitingConeAng|xlink(?:(?:Arcr|R)o|Tit)|s(?:urfaceSca|ty|ca)|unselectab|baseProfi|fontSty|(?:focus|dragg)ab|multip|profi|tit)l|d(?:ominantBaselin|efaultValu)|a(?:uto(?:Capitaliz|Revers|Sav)|dditiv)|(?:(?:formNoValid|xlinkActu|noValid|accumul|rot)a|autoComple|decelera)t|(?:(?:attribute|item)T|datat)yp|(?:attribute|glyph)Nam|playsInlin|(?:formE|e)ncTyp|(?:writing|input|edge)Mod|(?:xlinkTy|itemSco|keyTy|slo)p|(?:amplitu|mo)d|(?:xmlSpa|non)c|fillRul|(?:dateTi|na)m|r(?:esourc|ol)|xmlBas|wmod)e|(?:glyphOrientationHorizont|loc)al|(?:externalResourcesRequir|select|revers|mut)ed|c(?:o(?:lorInterpolationFilter|ord)s|o(?:lor(?:Interpolation)?|nt(?:rols|ent))|(?:ontentS(?:cript|tyle)Typ|o(?:ntentEditab|lorProfi)l|l(?:assNam|ipRul)|a(?:lcMod|ptur)|it)e|olorRendering|l(?:ipPathUnits|assID)|(?:ontrolsLis|apHeigh)t|h(?:eckedLink|a(?:llenge|rSet)|ildren|ecked)|ell(?:Spac|Padd)ing|o(?:ntextMenu|ls)|(?:rossOrigi|olSpa)n|lip(?:Path)?|ursor|[xy])|glyphOrientationVertical|d(?:angerouslySetInnerHTML|efaultChecked|ownload|isabled|isplay|[xy])|(?:s(?:trikethroughThickn|eaml)es|(?:und|ov)erlineThicknes|r(?:equiredExtension|adiu)|(?:requiredFeatur|tableValu|stitchTil|numOctav|filterR)e|key(?:(?:Splin|Tim)e|Param)|autoFocu|header|bia)s|(?:(?:st(?:rikethroughPosi|dDevia)|(?:und|ov)erlinePosi|(?:textDecor|elev)a|orienta)tio|(?:strokeLinejo|orig)i|formActio|zoomAndPa|onFocusI|directio|(?:vers|act)io|rowSpa|begi|ico)n|o(?:n(?:AnimationIteration|C(?:o(?:mposition(?:Update|Start|End)|ntextMenu|py)|anPlayThrough|anPlay|hange|lick|ut)|(?:(?:Duration|Volume|Rate)Chang|(?:MouseLea|(?:Touch|Mouse)Mo|DragLea)v|Paus)e|Loaded(?:Metad|D)ata|(?:Animation|Touch|Load|Drag)Start|(?:(?:T(?:ransition|ouch)|Animation)E|Suspe)nd|DoubleClick|(?:TouchCanc|Whe)el|(?:Mouse(?:Ent|Ov)e|Drag(?:Ent|Ov)e|Erro)r|TimeUpdate|(?:E(?:n(?:crypt|d)|mpti)|S(?:tall|eek))ed|MouseDown|P(?:rogress|laying)|(?:MouseOu|DragExi|S(?:elec|ubmi)|Rese|Inpu)t|KeyPress|DragEnd|Key(?:Down|Up)|(?:Wait|Seek)ing|(?:MouseU|Dro)p|Scroll|Paste|Focus|Abort|Drag|Play|Load|Blur)|rient)|p(?:reserveA(?:spectRatio|lpha)|ointsAt[X-Z]|anose1)|(?:patternContent|ma(?:sk(?:Content)?|rker)|primitive|gradient|pattern|filter)Units|(?:gradientT|patternT|t)ransform|(?:(?:allowTranspar|baseFrequ)enc|re(?:ferrerPolic|adOnl)|(?:(?:st(?:roke|op)O|floodO|fillO|o)pac|integr|secur)it|visibilit|fontFamil|accessKe|propert|summar)y|(?:strokeMiterlimi|(?:specularConsta|repeatCou|fontVaria)n|(?:(?:specularE|e)xpon|renderingInt|asc)en|d(?:iffuseConsta|esce)n|(?:fontSizeAdju|lengthAdju|manife)s|baselineShif|vectorEffec|(?:(?:mar(?:ker|gin)|x)H|accentH|fontW)eigh|a(?:utoCorrec|bou)|markerStar|onFocusOu|intercep|restar|forma|inlis|heigh|lis)t|(?:(?:st(?:rokeDasho|artO)|o)ffs|acceptChars|formTarg|viewTarg|srcS)et|(?:(?:enableBackgrou|markerE)n|s(?:p(?:readMetho|ee)|ee)|formMetho|m(?:arkerMi|etho)|preloa|kin)d|k(?:ernel(?:UnitLength|Matrix)|[1-4])|(?:[xy]ChannelSelect|lightingCol|textAnch|floodCol|stopCol|operat|htmlF)or|(?:allowFullScre|hidd)en|strokeDasharray|systemLanguage|(?:strokeLineca|itemPro|useMa|wra|loo)p|v(?:Mathematical|ert(?:Origin[XY]|AdvY)|alues|ocab)|(?:pointerEve|keyPoi)nts|unicodeRange|(?:(?:allowReord|placehold|frameBord|paintOrd|post|ord)e|repeatDu|d(?:efe|u))r|mathematical|(?:vI|i)deographic|h(?:oriz(?:Origin|Adv)X|ttpEquiv)|u(?:nicodeBidi|[12])|(?:fontStretc|hig)h|(?:(?:mar(?:ker|gin)W|strokeW)id|azimu)th|vAlphabetic|mediaGroup|spellCheck|(?:unitsPerE|optimu|fro)m|r(?:adioGroup|e(?:sults|f[XY]|l)|ows|[xy])|(?:xmlnsXl|valueL)ink|a(?:rabicForm|l(?:phabetic|t)|sync)|pathLength|(?:text|m(?:in|ax))Length|innerHTML|xlinkShow|(?:xlinkHr|glyphR)ef|r(?:e(?:quired|sult|f))?|o(?:verflow|pen)|(?:tabInde|(?:sand|b)bo|viewBo)x|(?:(?:href|xml|src)La|kerni)ng|f(?:o(?:ntSize|rm)|il(?:ter|l))|autoPlay|unicode|p(?:attern|oints)|t(?:arget[XY]|o)|i(?:temRef|n2|s)|divisor|d(?:efault|ata|ir)?|srcDoc|s(?:coped|te(?:m[hv]|p)|pan)|(?:width|size)s|(?:stri|la)ng|prefix|itemID|s(?:t(?:roke|art)|hape|cope|rc)|a(?:ccept|s)|t(?:arget|ype)|typeof|width|value|x(?:mlns)?|label|m(?:edia|a(?:sk|x)|in)|size|href|k(?:ey)?|end|low|x[12]|i[dn]|y[12]|g[12]|by|f[xy]|[yz])$/;
          /* From DOMProperty */

          var ATTRIBUTE_NAME_START_CHAR =
            ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
          var ATTRIBUTE_NAME_CHAR =
            ATTRIBUTE_NAME_START_CHAR +
            '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
          var isCustomAttribute = RegExp.prototype.test.bind(
            new RegExp('^(data|aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$')
          );

          var validAttr = function validAttr(name) {
            return (
              ATTRIBUTE_REGEX.test(name) ||
              isCustomAttribute(name.toLowerCase())
            );
          }; //

          function isTag(target /* : %checks */) {
            return typeof target === 'string';
          } //

          /* eslint-disable no-undef */

          function getComponentName(target) {
            return target.displayName || target.name || 'Component';
          } //

          var determineTheme = function determineTheme(
            props,
            fallbackTheme,
            defaultProps
          ) {
            // Props should take precedence over ThemeProvider, which should take precedence over
            // defaultProps, but React automatically puts defaultProps on props.

            /* eslint-disable react/prop-types */
            var isDefaultTheme =
              defaultProps && props.theme === defaultProps.theme;
            var theme =
              props.theme && !isDefaultTheme ? props.theme : fallbackTheme;
            /* eslint-enable */

            return theme;
          }; //

          var escapeRegex = /[[\].#*$><+~=|^:(),"'`-]+/g;
          var dashesAtEnds = /(^-|-$)/g;
          /**
           * TODO: Explore using CSS.escape when it becomes more available
           * in evergreen browsers.
           */

          function escape(str) {
            return str // Replace all possible CSS selectors
              .replace(escapeRegex, '-') // Remove extraneous hyphens at the start and end
              .replace(dashesAtEnds, '');
          } //

          /**
           * Creates a broadcast that can be listened to, i.e. simple event emitter
           *
           * @see https://github.com/ReactTraining/react-broadcast
           */

          var createBroadcast = function createBroadcast(initialState) {
            var listeners = {};
            var id = 0;
            var state = initialState;

            function publish(nextState) {
              state = nextState; // eslint-disable-next-line guard-for-in, no-restricted-syntax

              for (var key in listeners) {
                var listener = listeners[key];

                if (listener === undefined) {
                  // eslint-disable-next-line no-continue
                  continue;
                }

                listener(state);
              }
            }

            function subscribe(listener) {
              var currentId = id;
              listeners[currentId] = listener;
              id += 1;
              listener(state);
              return currentId;
            }

            function unsubscribe(unsubID) {
              listeners[unsubID] = undefined;
            }

            return {
              publish: publish,
              subscribe: subscribe,
              unsubscribe: unsubscribe
            };
          };

          var _ThemeProvider$childC;

          var _ThemeProvider$contex; //

          /* globals React$Element */
          // NOTE: DO NOT CHANGE, changing this is a semver major change!

          var CHANNEL = '__styled-components__';
          var CHANNEL_NEXT = CHANNEL + 'next__';

          var CONTEXT_CHANNEL_SHAPE = _propTypes.default.shape({
            getTheme: _propTypes.default.func,
            subscribe: _propTypes.default.func,
            unsubscribe: _propTypes.default.func
          });

          var warnChannelDeprecated = void 0;

          if (true) {
            warnChannelDeprecated = once(function() {
              // eslint-disable-next-line no-console
              console.error(
                'Warning: Usage of `context.' +
                  CHANNEL +
                  '` as a function is deprecated. It will be replaced with the object on `.context.' +
                  CHANNEL_NEXT +
                  '` in a future version.'
              );
            });
          }

          var isFunction = function isFunction(test) {
            return typeof test === 'function';
          };
          /**
           * Provide a theme to an entire react component tree via context and event listeners (have to do
           * both context and event emitter as pure components block context updates)
           */

          var ThemeProvider = (function(_Component) {
            inherits(ThemeProvider, _Component);

            function ThemeProvider() {
              classCallCheck(this, ThemeProvider);

              var _this = possibleConstructorReturn(
                this,
                _Component.call(this)
              );

              _this.unsubscribeToOuterId = -1;
              _this.getTheme = _this.getTheme.bind(_this);
              return _this;
            }

            ThemeProvider.prototype.componentWillMount = function componentWillMount() {
              var _this2 = this; // If there is a ThemeProvider wrapper anywhere around this theme provider, merge this theme
              // with the outer theme

              var outerContext = this.context[CHANNEL_NEXT];

              if (outerContext !== undefined) {
                this.unsubscribeToOuterId = outerContext.subscribe(function(
                  theme
                ) {
                  _this2.outerTheme = theme;

                  if (_this2.broadcast !== undefined) {
                    _this2.publish(_this2.props.theme);
                  }
                });
              }

              this.broadcast = createBroadcast(this.getTheme());
            };

            ThemeProvider.prototype.getChildContext = function getChildContext() {
              var _this3 = this,
                _babelHelpers$extends;

              return _extends(
                {},
                this.context,
                ((_babelHelpers$extends = {}),
                (_babelHelpers$extends[CHANNEL_NEXT] = {
                  getTheme: this.getTheme,
                  subscribe: this.broadcast.subscribe,
                  unsubscribe: this.broadcast.unsubscribe
                }),
                (_babelHelpers$extends[CHANNEL] = function(subscriber) {
                  if (true) {
                    warnChannelDeprecated();
                  } // Patch the old `subscribe` provide via `CHANNEL` for older clients.

                  var unsubscribeId = _this3.broadcast.subscribe(subscriber);

                  return function() {
                    return _this3.broadcast.unsubscribe(unsubscribeId);
                  };
                }),
                _babelHelpers$extends)
              );
            };

            ThemeProvider.prototype.componentWillReceiveProps = function componentWillReceiveProps(
              nextProps
            ) {
              if (this.props.theme !== nextProps.theme) {
                this.publish(nextProps.theme);
              }
            };

            ThemeProvider.prototype.componentWillUnmount = function componentWillUnmount() {
              if (this.unsubscribeToOuterId !== -1) {
                this.context[CHANNEL_NEXT].unsubscribe(
                  this.unsubscribeToOuterId
                );
              }
            }; // Get the theme from the props, supporting both (outerTheme) => {} as well as object notation

            ThemeProvider.prototype.getTheme = function getTheme(passedTheme) {
              var theme = passedTheme || this.props.theme;

              if (isFunction(theme)) {
                var mergedTheme = theme(this.outerTheme);

                if (
                  'development' !== 'production' &&
                  !(0, _isPlainObject.default)(mergedTheme)
                ) {
                  throw new Error(
                    true
                      ? '[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!'
                      : undefined
                  );
                }

                return mergedTheme;
              }

              if (!(0, _isPlainObject.default)(theme)) {
                throw new Error(
                  true
                    ? '[ThemeProvider] Please make your theme prop a plain object'
                    : undefined
                );
              }

              return _extends({}, this.outerTheme, theme);
            };

            ThemeProvider.prototype.publish = function publish(theme) {
              this.broadcast.publish(this.getTheme(theme));
            };

            ThemeProvider.prototype.render = function render() {
              if (!this.props.children) {
                return null;
              }

              return _react.default.Children.only(this.props.children);
            };

            return ThemeProvider;
          })(_react.Component);

          exports.ThemeProvider = ThemeProvider;
          ThemeProvider.childContextTypes = ((_ThemeProvider$childC = {}),
          (_ThemeProvider$childC[CHANNEL] = _propTypes.default.func),
          (_ThemeProvider$childC[CHANNEL_NEXT] = CONTEXT_CHANNEL_SHAPE),
          _ThemeProvider$childC);
          ThemeProvider.contextTypes = ((_ThemeProvider$contex = {}),
          (_ThemeProvider$contex[CHANNEL_NEXT] = CONTEXT_CHANNEL_SHAPE),
          _ThemeProvider$contex); //
          // HACK for generating all static styles without needing to allocate
          // an empty execution context every single time...

          var STATIC_EXECUTION_CONTEXT = {};

          var _StyledComponent = function _StyledComponent(
            ComponentStyle,
            constructWithOptions
          ) {
            var identifiers = {};
            /* We depend on components having unique IDs */

            var generateId = function generateId(
              _displayName,
              parentComponentId
            ) {
              var displayName =
                typeof _displayName !== 'string' ? 'sc' : escape(_displayName);
              var componentId = void 0;
              /**
               * only fall back to hashing the component injection order if
               * a proper displayName isn't provided by the babel plugin
               */

              if (!_displayName) {
                var nr = (identifiers[displayName] || 0) + 1;
                identifiers[displayName] = nr;
                componentId =
                  displayName +
                  '-' +
                  ComponentStyle.generateName(displayName + nr);
              } else {
                componentId =
                  displayName + '-' + ComponentStyle.generateName(displayName);
              }

              return parentComponentId !== undefined
                ? parentComponentId + '-' + componentId
                : componentId;
            };

            var BaseStyledComponent = (function(_Component) {
              inherits(BaseStyledComponent, _Component);

              function BaseStyledComponent() {
                var _temp, _this, _ret;

                classCallCheck(this, BaseStyledComponent);

                for (
                  var _len = arguments.length, args = Array(_len), _key = 0;
                  _key < _len;
                  _key++
                ) {
                  args[_key] = arguments[_key];
                }

                return (
                  (_ret = ((_temp = ((_this = possibleConstructorReturn(
                    this,
                    _Component.call.apply(_Component, [this].concat(args))
                  )),
                  _this)),
                  (_this.attrs = {}),
                  (_this.state = {
                    theme: null,
                    generatedClassName: ''
                  }),
                  (_this.unsubscribeId = -1),
                  _temp)),
                  possibleConstructorReturn(_this, _ret)
                );
              }

              BaseStyledComponent.prototype.unsubscribeFromContext = function unsubscribeFromContext() {
                if (this.unsubscribeId !== -1) {
                  this.context[CHANNEL_NEXT].unsubscribe(this.unsubscribeId);
                }
              };

              BaseStyledComponent.prototype.buildExecutionContext = function buildExecutionContext(
                theme,
                props
              ) {
                var attrs = this.constructor.attrs;

                var context = _extends({}, props, {
                  theme: theme
                });

                if (attrs === undefined) {
                  return context;
                }

                this.attrs = Object.keys(attrs).reduce(function(acc, key) {
                  var attr = attrs[key]; // eslint-disable-next-line no-param-reassign

                  acc[key] = typeof attr === 'function' ? attr(context) : attr;
                  return acc;
                }, {});
                return _extends({}, context, this.attrs);
              };

              BaseStyledComponent.prototype.generateAndInjectStyles = function generateAndInjectStyles(
                theme,
                props
              ) {
                var _constructor = this.constructor,
                  attrs = _constructor.attrs,
                  componentStyle = _constructor.componentStyle,
                  warnTooManyClasses = _constructor.warnTooManyClasses;
                var styleSheet = this.context[CONTEXT_KEY] || StyleSheet.master; // staticaly styled-components don't need to build an execution context object,
                // and shouldn't be increasing the number of class names

                if (componentStyle.isStatic && attrs === undefined) {
                  return componentStyle.generateAndInjectStyles(
                    STATIC_EXECUTION_CONTEXT,
                    styleSheet
                  );
                } else {
                  var executionContext = this.buildExecutionContext(
                    theme,
                    props
                  );
                  var className = componentStyle.generateAndInjectStyles(
                    executionContext,
                    styleSheet
                  );

                  if (
                    'development' !== 'production' &&
                    warnTooManyClasses !== undefined
                  ) {
                    warnTooManyClasses(className);
                  }

                  return className;
                }
              };

              BaseStyledComponent.prototype.componentWillMount = function componentWillMount() {
                var _this2 = this;

                var componentStyle = this.constructor.componentStyle;
                var styledContext = this.context[CHANNEL_NEXT]; // If this is a staticaly-styled component, we don't need to the theme
                // to generate or build styles.

                if (componentStyle.isStatic) {
                  var generatedClassName = this.generateAndInjectStyles(
                    STATIC_EXECUTION_CONTEXT,
                    this.props
                  );
                  this.setState({
                    generatedClassName: generatedClassName
                  }); // If there is a theme in the context, subscribe to the event emitter. This
                  // is necessary due to pure components blocking context updates, this circumvents
                  // that by updating when an event is emitted
                } else if (styledContext !== undefined) {
                  var subscribe = styledContext.subscribe;
                  this.unsubscribeId = subscribe(function(nextTheme) {
                    // This will be called once immediately
                    var theme = determineTheme(
                      _this2.props,
                      nextTheme,
                      _this2.constructor.defaultProps
                    );

                    var generatedClassName = _this2.generateAndInjectStyles(
                      theme,
                      _this2.props
                    );

                    _this2.setState({
                      theme: theme,
                      generatedClassName: generatedClassName
                    });
                  });
                } else {
                  // eslint-disable-next-line react/prop-types
                  var theme = this.props.theme || {};

                  var _generatedClassName = this.generateAndInjectStyles(
                    theme,
                    this.props
                  );

                  this.setState({
                    theme: theme,
                    generatedClassName: _generatedClassName
                  });
                }
              };

              BaseStyledComponent.prototype.componentWillReceiveProps = function componentWillReceiveProps(
                nextProps
              ) {
                var _this3 = this; // If this is a staticaly-styled component, we don't need to listen to
                // props changes to update styles

                var componentStyle = this.constructor.componentStyle;

                if (componentStyle.isStatic) {
                  return;
                }

                this.setState(function(oldState) {
                  var theme = determineTheme(
                    nextProps,
                    oldState.theme,
                    _this3.constructor.defaultProps
                  );

                  var generatedClassName = _this3.generateAndInjectStyles(
                    theme,
                    nextProps
                  );

                  return {
                    theme: theme,
                    generatedClassName: generatedClassName
                  };
                });
              };

              BaseStyledComponent.prototype.componentWillUnmount = function componentWillUnmount() {
                this.unsubscribeFromContext();
              };

              BaseStyledComponent.prototype.render = function render() {
                var _this4 = this; // eslint-disable-next-line react/prop-types

                var innerRef = this.props.innerRef;
                var generatedClassName = this.state.generatedClassName;
                var _constructor2 = this.constructor,
                  styledComponentId = _constructor2.styledComponentId,
                  target = _constructor2.target;
                var isTargetTag = isTag(target);
                var className = [
                  // eslint-disable-next-line react/prop-types
                  this.props.className,
                  styledComponentId,
                  this.attrs.className,
                  generatedClassName
                ]
                  .filter(Boolean)
                  .join(' ');

                var baseProps = _extends({}, this.attrs, {
                  className: className
                });

                if (isStyledComponent(target)) {
                  baseProps.innerRef = innerRef;
                } else {
                  baseProps.ref = innerRef;
                }

                var propsForElement = Object.keys(this.props).reduce(function(
                  acc,
                  propName
                ) {
                  // Don't pass through non HTML tags through to HTML elements
                  // always omit innerRef
                  if (
                    propName !== 'innerRef' &&
                    propName !== 'className' &&
                    (!isTargetTag || validAttr(propName))
                  ) {
                    // eslint-disable-next-line no-param-reassign
                    acc[propName] = _this4.props[propName];
                  }

                  return acc;
                },
                baseProps);
                return (0, _react.createElement)(target, propsForElement);
              };

              return BaseStyledComponent;
            })(_react.Component);

            var createStyledComponent = function createStyledComponent(
              target,
              options,
              rules
            ) {
              var _StyledComponent$cont;

              var _options$displayName = options.displayName,
                displayName =
                  _options$displayName === undefined
                    ? isTag(target)
                      ? 'styled.' + target
                      : 'Styled(' + getComponentName(target) + ')'
                    : _options$displayName,
                _options$componentId = options.componentId,
                componentId =
                  _options$componentId === undefined
                    ? generateId(options.displayName, options.parentComponentId)
                    : _options$componentId,
                _options$ParentCompon = options.ParentComponent,
                ParentComponent =
                  _options$ParentCompon === undefined
                    ? BaseStyledComponent
                    : _options$ParentCompon,
                extendingRules = options.rules,
                attrs = options.attrs;
              var styledComponentId =
                options.displayName && options.componentId
                  ? escape(options.displayName) + '-' + options.componentId
                  : componentId;
              var componentStyle = new ComponentStyle(
                extendingRules === undefined
                  ? rules
                  : extendingRules.concat(rules),
                attrs,
                styledComponentId
              );

              var StyledComponent = (function(_ParentComponent) {
                inherits(StyledComponent, _ParentComponent);

                function StyledComponent() {
                  classCallCheck(this, StyledComponent);
                  return possibleConstructorReturn(
                    this,
                    _ParentComponent.apply(this, arguments)
                  );
                }

                StyledComponent.withComponent = function withComponent(tag) {
                  var previousComponentId = options.componentId,
                    optionsToCopy = objectWithoutProperties(options, [
                      'componentId'
                    ]);
                  var newComponentId =
                    previousComponentId &&
                    previousComponentId +
                      '-' +
                      (isTag(tag) ? tag : escape(getComponentName(tag)));

                  var newOptions = _extends({}, optionsToCopy, {
                    componentId: newComponentId,
                    ParentComponent: StyledComponent
                  });

                  return createStyledComponent(tag, newOptions, rules);
                };

                createClass(StyledComponent, null, [
                  {
                    key: 'extend',
                    get: function get$$1() {
                      var rulesFromOptions = options.rules,
                        parentComponentId = options.componentId,
                        optionsToCopy = objectWithoutProperties(options, [
                          'rules',
                          'componentId'
                        ]);
                      var newRules =
                        rulesFromOptions === undefined
                          ? rules
                          : rulesFromOptions.concat(rules);

                      var newOptions = _extends({}, optionsToCopy, {
                        rules: newRules,
                        parentComponentId: parentComponentId,
                        ParentComponent: StyledComponent
                      });

                      return constructWithOptions(
                        createStyledComponent,
                        target,
                        newOptions
                      );
                    }
                  }
                ]);
                return StyledComponent;
              })(ParentComponent);

              StyledComponent.contextTypes = ((_StyledComponent$cont = {}),
              (_StyledComponent$cont[CHANNEL] = _propTypes.default.func),
              (_StyledComponent$cont[CHANNEL_NEXT] = CONTEXT_CHANNEL_SHAPE),
              (_StyledComponent$cont[
                CONTEXT_KEY
              ] = _propTypes.default.oneOfType([
                _propTypes.default.instanceOf(StyleSheet),
                _propTypes.default.instanceOf(ServerStyleSheet)
              ])),
              _StyledComponent$cont);
              StyledComponent.displayName = displayName;
              StyledComponent.styledComponentId = styledComponentId;
              StyledComponent.attrs = attrs;
              StyledComponent.componentStyle = componentStyle;
              StyledComponent.target = target;

              if (true) {
                StyledComponent.warnTooManyClasses = createWarnTooManyClasses(
                  displayName
                );
              }

              return StyledComponent;
            };

            return createStyledComponent;
          }; // Source: https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js

          function murmurhash(str) {
            var l = str.length | 0,
              h = l | 0,
              i = 0,
              k;

            while (l >= 4) {
              k =
                (str.charCodeAt(i) & 0xff) |
                ((str.charCodeAt(++i) & 0xff) << 8) |
                ((str.charCodeAt(++i) & 0xff) << 16) |
                ((str.charCodeAt(++i) & 0xff) << 24);
              k =
                (k & 0xffff) * 0x5bd1e995 +
                ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16);
              k ^= k >>> 24;
              k =
                (k & 0xffff) * 0x5bd1e995 +
                ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16);
              h =
                ((h & 0xffff) * 0x5bd1e995 +
                  ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^
                k;
              l -= 4;
              ++i;
            }

            switch (l) {
              case 3:
                h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

              case 2:
                h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

              case 1:
                h ^= str.charCodeAt(i) & 0xff;
                h =
                  (h & 0xffff) * 0x5bd1e995 +
                  ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16);
            }

            h ^= h >>> 13;
            h =
              (h & 0xffff) * 0x5bd1e995 +
              ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16);
            h ^= h >>> 15;
            return h >>> 0;
          } //

          var areStylesCacheable = IS_BROWSER;

          var isStaticRules = function isStaticRules(rules, attrs) {
            for (var i = 0; i < rules.length; i += 1) {
              var rule = rules[i]; // recursive case

              if (Array.isArray(rule) && !isStaticRules(rule)) {
                return false;
              } else if (
                typeof rule === 'function' &&
                !isStyledComponent(rule)
              ) {
                // functions are allowed to be static if they're just being
                // used to get the classname of a nested styled copmonent
                return false;
              }
            }

            if (attrs !== undefined) {
              // eslint-disable-next-line guard-for-in, no-restricted-syntax
              for (var key in attrs) {
                var value = attrs[key];

                if (typeof value === 'function') {
                  return false;
                }
              }
            }

            return true;
          };

          var isHRMEnabled =
            typeof module !== 'undefined' &&
            module.hot &&
            'development' !== 'production';
          /*
 ComponentStyle is all the CSS-specific stuff, not
 the React-specific stuff.
 */

          var _ComponentStyle = function _ComponentStyle(
            nameGenerator,
            flatten,
            stringifyRules
          ) {
            /* combines hashStr (murmurhash) and nameGenerator for convenience */
            var generateRuleHash = function generateRuleHash(str) {
              return nameGenerator(murmurhash(str));
            };

            var ComponentStyle = (function() {
              function ComponentStyle(rules, attrs, componentId) {
                classCallCheck(this, ComponentStyle);
                this.rules = rules;
                this.isStatic = !isHRMEnabled && isStaticRules(rules, attrs);
                this.componentId = componentId;

                if (!StyleSheet.master.hasId(componentId)) {
                  var placeholder = true
                    ? ['.' + componentId + ' {}']
                    : undefined;
                  StyleSheet.master.deferredInject(componentId, placeholder);
                }
              }
              /*
     * Flattens a rule set into valid CSS
     * Hashes it, wraps the whole chunk in a .hash1234 {}
     * Returns the hash to be injected on render()
     * */

              ComponentStyle.prototype.generateAndInjectStyles = function generateAndInjectStyles(
                executionContext,
                styleSheet
              ) {
                var isStatic = this.isStatic,
                  componentId = this.componentId,
                  lastClassName = this.lastClassName;

                if (
                  areStylesCacheable &&
                  isStatic &&
                  lastClassName !== undefined
                ) {
                  return lastClassName;
                }

                var flatCSS = flatten(this.rules, executionContext);
                var name = generateRuleHash(
                  this.componentId + flatCSS.join('')
                );

                if (!styleSheet.hasNameForId(componentId, name)) {
                  var css = stringifyRules(flatCSS, '.' + name);
                  styleSheet.inject(this.componentId, css, name);
                }

                this.lastClassName = name;
                return name;
              };

              ComponentStyle.generateName = function generateName(str) {
                return generateRuleHash(str);
              };

              return ComponentStyle;
            })();

            return ComponentStyle;
          }; //
          // Thanks to ReactDOMFactories for this handy list!

          var domElements = [
            'a',
            'abbr',
            'address',
            'area',
            'article',
            'aside',
            'audio',
            'b',
            'base',
            'bdi',
            'bdo',
            'big',
            'blockquote',
            'body',
            'br',
            'button',
            'canvas',
            'caption',
            'cite',
            'code',
            'col',
            'colgroup',
            'data',
            'datalist',
            'dd',
            'del',
            'details',
            'dfn',
            'dialog',
            'div',
            'dl',
            'dt',
            'em',
            'embed',
            'fieldset',
            'figcaption',
            'figure',
            'footer',
            'form',
            'h1',
            'h2',
            'h3',
            'h4',
            'h5',
            'h6',
            'head',
            'header',
            'hgroup',
            'hr',
            'html',
            'i',
            'iframe',
            'img',
            'input',
            'ins',
            'kbd',
            'keygen',
            'label',
            'legend',
            'li',
            'link',
            'main',
            'map',
            'mark',
            'marquee',
            'menu',
            'menuitem',
            'meta',
            'meter',
            'nav',
            'noscript',
            'object',
            'ol',
            'optgroup',
            'option',
            'output',
            'p',
            'param',
            'picture',
            'pre',
            'progress',
            'q',
            'rp',
            'rt',
            'ruby',
            's',
            'samp',
            'script',
            'section',
            'select',
            'small',
            'source',
            'span',
            'strong',
            'style',
            'sub',
            'summary',
            'sup',
            'table',
            'tbody',
            'td',
            'textarea',
            'tfoot',
            'th',
            'thead',
            'time',
            'title',
            'tr',
            'track',
            'u',
            'ul',
            'var',
            'video',
            'wbr', // SVG
            'circle',
            'clipPath',
            'defs',
            'ellipse',
            'foreignObject',
            'g',
            'image',
            'line',
            'linearGradient',
            'mask',
            'path',
            'pattern',
            'polygon',
            'polyline',
            'radialGradient',
            'rect',
            'stop',
            'svg',
            'text',
            'tspan'
          ]; //

          var _styled = function _styled(
            styledComponent,
            constructWithOptions
          ) {
            var styled = function styled(tag) {
              return constructWithOptions(styledComponent, tag);
            }; // Shorthands for all valid HTML Elements

            domElements.forEach(function(domElement) {
              styled[domElement] = styled(domElement);
            });
            return styled;
          }; //

          var replaceWhitespace = function replaceWhitespace(str) {
            return str.replace(/\s|\\n/g, '');
          };

          var _keyframes = function _keyframes(
            nameGenerator,
            stringifyRules,
            css
          ) {
            return function() {
              var styleSheet = StyleSheet.master;
              var rules = css.apply(undefined, arguments);
              var name = nameGenerator(
                murmurhash(replaceWhitespace(JSON.stringify(rules)))
              );
              var id = 'sc-keyframes-' + name;

              if (!styleSheet.hasNameForId(id, name)) {
                styleSheet.inject(
                  id,
                  stringifyRules(rules, name, '@keyframes'),
                  name
                );
              }

              return name;
            };
          }; //

          var _injectGlobal = function _injectGlobal(stringifyRules, css) {
            var injectGlobal = function injectGlobal() {
              var styleSheet = StyleSheet.master;
              var rules = css.apply(undefined, arguments);
              var hash = murmurhash(JSON.stringify(rules));
              var id = 'sc-global-' + hash;

              if (!styleSheet.hasId(id)) {
                styleSheet.inject(id, stringifyRules(rules));
              }
            };

            return injectGlobal;
          }; //

          var _constructWithOptions = function _constructWithOptions(css) {
            var constructWithOptions = function constructWithOptions(
              componentConstructor,
              tag
            ) {
              var options =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : {};

              if (typeof tag !== 'string' && typeof tag !== 'function') {
                throw new Error(
                  true
                    ? 'Cannot create styled-component for component: ' +
                      String(tag)
                    : undefined
                );
              }
              /* This is callable directly as a template function */
              // $FlowFixMe: Not typed to avoid destructuring arguments

              var templateFunction = function templateFunction() {
                return componentConstructor(
                  tag,
                  options,
                  css.apply(undefined, arguments)
                );
              };
              /* If config methods are called, wrap up a new template function and merge options */

              templateFunction.withConfig = function(config) {
                return constructWithOptions(
                  componentConstructor,
                  tag,
                  _extends({}, options, config)
                );
              };

              templateFunction.attrs = function(attrs) {
                return constructWithOptions(
                  componentConstructor,
                  tag,
                  _extends({}, options, {
                    attrs: _extends({}, options.attrs || {}, attrs)
                  })
                );
              };

              return templateFunction;
            };

            return constructWithOptions;
          }; //

          /* globals ReactClass */

          var wrapWithTheme = function wrapWithTheme(Component$$1) {
            var _WithTheme$contextTyp;

            var componentName =
              Component$$1.displayName || Component$$1.name || 'Component';
            var isStatelessFunctionalComponent =
              typeof Component$$1 === 'function' &&
              !(
                Component$$1.prototype &&
                'isReactComponent' in Component$$1.prototype
              ); // NOTE: We can't pass a ref to a stateless functional component

            var shouldSetInnerRef =
              isStyledComponent(Component$$1) || isStatelessFunctionalComponent;

            var WithTheme = (function(_React$Component) {
              inherits(WithTheme, _React$Component);

              function WithTheme() {
                var _temp, _this, _ret;

                classCallCheck(this, WithTheme);

                for (
                  var _len = arguments.length, args = Array(_len), _key = 0;
                  _key < _len;
                  _key++
                ) {
                  args[_key] = arguments[_key];
                }

                return (
                  (_ret = ((_temp = ((_this = possibleConstructorReturn(
                    this,
                    _React$Component.call.apply(
                      _React$Component,
                      [this].concat(args)
                    )
                  )),
                  _this)),
                  (_this.state = {}),
                  (_this.unsubscribeId = -1),
                  _temp)),
                  possibleConstructorReturn(_this, _ret)
                );
              } // NOTE: This is so that isStyledComponent passes for the innerRef unwrapping

              WithTheme.prototype.componentWillMount = function componentWillMount() {
                var _this2 = this;

                var defaultProps = this.constructor.defaultProps;
                var styledContext = this.context[CHANNEL_NEXT];
                var themeProp = determineTheme(
                  this.props,
                  undefined,
                  defaultProps
                );

                if (
                  styledContext === undefined &&
                  themeProp === undefined &&
                  'development' !== 'production'
                ) {
                  // eslint-disable-next-line no-console
                  console.warn(
                    '[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps'
                  );
                } else if (
                  styledContext === undefined &&
                  themeProp !== undefined
                ) {
                  this.setState({
                    theme: themeProp
                  });
                } else {
                  var subscribe = styledContext.subscribe;
                  this.unsubscribeId = subscribe(function(nextTheme) {
                    var theme = determineTheme(
                      _this2.props,
                      nextTheme,
                      defaultProps
                    );

                    _this2.setState({
                      theme: theme
                    });
                  });
                }
              };

              WithTheme.prototype.componentWillReceiveProps = function componentWillReceiveProps(
                nextProps
              ) {
                var defaultProps = this.constructor.defaultProps;
                this.setState(function(oldState) {
                  var theme = determineTheme(
                    nextProps,
                    oldState.theme,
                    defaultProps
                  );
                  return {
                    theme: theme
                  };
                });
              };

              WithTheme.prototype.componentWillUnmount = function componentWillUnmount() {
                if (this.unsubscribeId !== -1) {
                  this.context[CHANNEL_NEXT].unsubscribe(this.unsubscribeId);
                }
              };

              WithTheme.prototype.render = function render() {
                var props = _extends(
                  {
                    theme: this.state.theme
                  },
                  this.props
                );

                if (!shouldSetInnerRef) {
                  props.ref = props.innerRef;
                  delete props.innerRef;
                }

                return _react.default.createElement(Component$$1, props);
              };

              return WithTheme;
            })(_react.default.Component);

            WithTheme.displayName = 'WithTheme(' + componentName + ')';
            WithTheme.styledComponentId = 'withTheme';
            WithTheme.contextTypes = ((_WithTheme$contextTyp = {}),
            (_WithTheme$contextTyp[CHANNEL] = _propTypes.default.func),
            (_WithTheme$contextTyp[CHANNEL_NEXT] = CONTEXT_CHANNEL_SHAPE),
            _WithTheme$contextTyp);
            return (0, _hoistNonReactStatics.default)(WithTheme, Component$$1);
          }; //

          /* eslint-disable */

          exports.withTheme = wrapWithTheme;
          var __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = {
            StyleSheet: StyleSheet
          }; //

          /* Import singletons */

          /* Import singleton constructors */

          /* Import components */

          /* Import Higher Order Components */

          /* Warning if you've imported this file on React Native */

          exports.__DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS;

          if (
            'development' !== 'production' &&
            typeof navigator !== 'undefined' &&
            navigator.product === 'ReactNative'
          ) {
            // eslint-disable-next-line no-console
            console.warn(
              "It looks like you've imported 'styled-components' on React Native.\n" +
                "Perhaps you're looking to import 'styled-components/native'?\n" +
                'Read more about this at https://www.styled-components.com/docs/basics#react-native'
            );
          }
          /* Warning if there are several instances of styled-components */

          if ('development' !== 'production' && typeof window !== 'undefined') {
            window['__styled-components-init__'] =
              window['__styled-components-init__'] || 0;

            if (window['__styled-components-init__'] === 1) {
              // eslint-disable-next-line no-console
              console.warn(
                "It looks like there are several instances of 'styled-components' initialized in this application. " +
                  'This may cause dynamic styles not rendering properly, errors happening during rehydration process ' +
                  'and makes you application bigger without a good reason.\n\n' +
                  'See https://s-c.sh/2BAXzed for more info.'
              );
            }

            window['__styled-components-init__'] += 1;
          }
          /* Instantiate singletons */

          var ComponentStyle = _ComponentStyle(
            generateAlphabeticName,
            flatten,
            stringifyRules
          );

          var constructWithOptions = _constructWithOptions(css);

          var StyledComponent = _StyledComponent(
            ComponentStyle,
            constructWithOptions
          );
          /* Instantiate exported singletons */

          var keyframes = _keyframes(
            generateAlphabeticName,
            stringifyRules,
            css
          );

          exports.keyframes = keyframes;

          var injectGlobal = _injectGlobal(stringifyRules, css);

          exports.injectGlobal = injectGlobal;

          var styled = _styled(StyledComponent, constructWithOptions);

          var _default = styled;
          var _default2 = _default; //# sourceMappingURL=styled-components.browser.es.js.map

          exports.default = _default2;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              _uppercasePattern,
              '_uppercasePattern',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              hyphenate$2,
              'hyphenate$2',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              hyphenate_1,
              'hyphenate_1',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              hyphenate,
              'hyphenate',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              msPattern,
              'msPattern',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              hyphenateStyleName,
              'hyphenateStyleName',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              hyphenateStyleName_1,
              'hyphenateStyleName_1',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              objToCss,
              'objToCss',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              flatten,
              'flatten',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              stylisSplitter,
              'stylisSplitter',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              stylis,
              'stylis',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              parsingRules,
              'parsingRules',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              returnRulesPlugin,
              'returnRulesPlugin',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              parseRulesPlugin,
              'parseRulesPlugin',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              stringifyRules,
              'stringifyRules',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              splitByRules,
              'splitByRules',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              isStyledComponent,
              'isStyledComponent',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              consolidateStreamedStyles,
              'consolidateStreamedStyles',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              charsLength,
              'charsLength',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              getAlphabeticChar,
              'getAlphabeticChar',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              generateAlphabeticName,
              'generateAlphabeticName',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              interleave,
              'interleave',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              css,
              'css',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              stream,
              'stream',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              SC_ATTR,
              'SC_ATTR',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              SC_STREAM_ATTR,
              'SC_STREAM_ATTR',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              CONTEXT_KEY,
              'CONTEXT_KEY',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              IS_BROWSER,
              'IS_BROWSER',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              DISABLE_SPEEDY,
              'DISABLE_SPEEDY',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              SC_COMPONENT_ID,
              'SC_COMPONENT_ID',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              extractComps,
              'extractComps',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              getNonce,
              'getNonce',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              once,
              'once',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              classCallCheck,
              'classCallCheck',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              createClass,
              'createClass',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _extends,
              '_extends',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              inherits,
              'inherits',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              objectWithoutProperties,
              'objectWithoutProperties',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              possibleConstructorReturn,
              'possibleConstructorReturn',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              addNameForId,
              'addNameForId',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              resetIdNames,
              'resetIdNames',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              hasNameForId,
              'hasNameForId',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              stringifyNames,
              'stringifyNames',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              cloneNames,
              'cloneNames',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              sheetForTag,
              'sheetForTag',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              safeInsertRule,
              'safeInsertRule',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              deleteRules,
              'deleteRules',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              parentNodeUnmountedErr,
              'parentNodeUnmountedErr',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              throwCloneTagErr,
              'throwCloneTagErr',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              makeTextMarker,
              'makeTextMarker',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              addUpUntilIndex,
              'addUpUntilIndex',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              makeStyleTag,
              'makeStyleTag',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              wrapAsHtmlTag,
              'wrapAsHtmlTag',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              wrapAsElement,
              'wrapAsElement',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              getIdsFromMarkersFactory,
              'getIdsFromMarkersFactory',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              makeSpeedyTag,
              'makeSpeedyTag',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              makeBrowserTag,
              'makeBrowserTag',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              makeServerTagInternal,
              'makeServerTagInternal',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              makeServerTag,
              'makeServerTag',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              makeTag,
              'makeTag',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              makeRehydrationTag,
              'makeRehydrationTag',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              MAX_SIZE,
              'MAX_SIZE',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              sheetRunningId,
              'sheetRunningId',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              master,
              'master',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              StyleSheet,
              'StyleSheet',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _StyleSheetManager$ch,
              '_StyleSheetManager$ch',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              targetPropErr,
              'targetPropErr',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              StyleSheetManager,
              'StyleSheetManager',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              sheetClosedErr,
              'sheetClosedErr',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              streamBrowserErr,
              'streamBrowserErr',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              ServerStyleSheet,
              'ServerStyleSheet',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              LIMIT,
              'LIMIT',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              createWarnTooManyClasses,
              'createWarnTooManyClasses',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              ATTRIBUTE_REGEX,
              'ATTRIBUTE_REGEX',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              ATTRIBUTE_NAME_START_CHAR,
              'ATTRIBUTE_NAME_START_CHAR',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              ATTRIBUTE_NAME_CHAR,
              'ATTRIBUTE_NAME_CHAR',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              isCustomAttribute,
              'isCustomAttribute',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              validAttr,
              'validAttr',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              isTag,
              'isTag',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              getComponentName,
              'getComponentName',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              determineTheme,
              'determineTheme',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              escapeRegex,
              'escapeRegex',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              dashesAtEnds,
              'dashesAtEnds',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              escape,
              'escape',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              createBroadcast,
              'createBroadcast',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _ThemeProvider$childC,
              '_ThemeProvider$childC',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _ThemeProvider$contex,
              '_ThemeProvider$contex',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              CHANNEL,
              'CHANNEL',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              CHANNEL_NEXT,
              'CHANNEL_NEXT',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              CONTEXT_CHANNEL_SHAPE,
              'CONTEXT_CHANNEL_SHAPE',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              warnChannelDeprecated,
              'warnChannelDeprecated',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              isFunction,
              'isFunction',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              ThemeProvider,
              'ThemeProvider',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              STATIC_EXECUTION_CONTEXT,
              'STATIC_EXECUTION_CONTEXT',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _StyledComponent,
              '_StyledComponent',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              murmurhash,
              'murmurhash',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              areStylesCacheable,
              'areStylesCacheable',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              isStaticRules,
              'isStaticRules',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              isHRMEnabled,
              'isHRMEnabled',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _ComponentStyle,
              '_ComponentStyle',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              domElements,
              'domElements',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _styled,
              '_styled',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              replaceWhitespace,
              'replaceWhitespace',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _keyframes,
              '_keyframes',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _injectGlobal,
              '_injectGlobal',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _constructWithOptions,
              '_constructWithOptions',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              wrapWithTheme,
              'wrapWithTheme',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS,
              '__DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              ComponentStyle,
              'ComponentStyle',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              constructWithOptions,
              'constructWithOptions',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              StyledComponent,
              'StyledComponent',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              keyframes,
              'keyframes',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              injectGlobal,
              'injectGlobal',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              styled,
              'styled',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            reactHotLoader.register(
              _default,
              'default',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/dist/styled-components.browser.es.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/styled-components/node_modules/hoist-non-react-statics/index.js':
      /*!**************************************************************************************!*\
  !*** ./node_modules/styled-components/node_modules/hoist-non-react-statics/index.js ***!
  \**************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          /**
           * Copyright 2015, Yahoo! Inc.
           * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
           */

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var REACT_STATICS = {
            childContextTypes: true,
            contextTypes: true,
            defaultProps: true,
            displayName: true,
            getDefaultProps: true,
            mixins: true,
            propTypes: true,
            type: true
          };
          var KNOWN_STATICS = {
            name: true,
            length: true,
            prototype: true,
            caller: true,
            arguments: true,
            arity: true
          };
          var isGetOwnPropertySymbolsAvailable =
            typeof Object.getOwnPropertySymbols === 'function';

          module.exports = function hoistNonReactStatics(
            targetComponent,
            sourceComponent,
            customStatics
          ) {
            if (typeof sourceComponent !== 'string') {
              // don't hoist over string (html) components
              var keys = Object.getOwnPropertyNames(sourceComponent);
              /* istanbul ignore else */

              if (isGetOwnPropertySymbolsAvailable) {
                keys = keys.concat(
                  Object.getOwnPropertySymbols(sourceComponent)
                );
              }

              for (var i = 0; i < keys.length; ++i) {
                if (
                  !REACT_STATICS[keys[i]] &&
                  !KNOWN_STATICS[keys[i]] &&
                  (!customStatics || !customStatics[keys[i]])
                ) {
                  try {
                    targetComponent[keys[i]] = sourceComponent[keys[i]];
                  } catch (error) {}
                }
              }
            }

            return targetComponent;
          };

          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              REACT_STATICS,
              'REACT_STATICS',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/node_modules/hoist-non-react-statics/index.js'
            );
            reactHotLoader.register(
              KNOWN_STATICS,
              'KNOWN_STATICS',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/node_modules/hoist-non-react-statics/index.js'
            );
            reactHotLoader.register(
              isGetOwnPropertySymbolsAvailable,
              'isGetOwnPropertySymbolsAvailable',
              '/Users/markmurray/apps/react-slack-feedback/node_modules/styled-components/node_modules/hoist-non-react-statics/index.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../../../webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './node_modules/stylis-rule-sheet/index.js':
      /*!*************************************************!*\
  !*** ./node_modules/stylis-rule-sheet/index.js ***!
  \*************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

        function _typeof(obj) {
          if (
            typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === 'function' &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        (function(factory) {
          (false ? undefined : _typeof(exports)) === 'object' &&
          typeof module !== 'undefined'
            ? (module['exports'] = factory())
            : true
              ? !((__WEBPACK_AMD_DEFINE_FACTORY__ = factory()),
                (__WEBPACK_AMD_DEFINE_RESULT__ =
                  typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
                    ? __WEBPACK_AMD_DEFINE_FACTORY__.call(
                        exports,
                        __webpack_require__,
                        exports,
                        module
                      )
                    : __WEBPACK_AMD_DEFINE_FACTORY__),
                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                  (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
              : undefined;
        })(function() {
          'use strict';

          return function(insertRule) {
            var delimiter = '/*|*/';
            var needle = delimiter + '}';

            function toSheet(block) {
              if (block)
                try {
                  insertRule(block + '}');
                } catch (e) {}
            }

            return function ruleSheet(
              context,
              content,
              selectors,
              parents,
              line,
              column,
              length,
              ns,
              depth,
              at
            ) {
              switch (context) {
                // property
                case 1:
                  // @import
                  if (depth === 0 && content.charCodeAt(0) === 64)
                    return insertRule(content + ';'), '';
                  break;
                // selector

                case 2:
                  if (ns === 0) return content + delimiter;
                  break;
                // at-rule

                case 3:
                  switch (ns) {
                    // @font-face, @page
                    case 102:
                    case 112:
                      return insertRule(selectors[0] + content), '';

                    default:
                      return content + (at === 0 ? delimiter : '');
                  }

                case -2:
                  content.split(needle).forEach(toSheet);
              }
            };
          };
        });

        /***/
      },

    /***/ './node_modules/stylis/stylis.js':
      /*!***************************************!*\
  !*** ./node_modules/stylis/stylis.js ***!
  \***************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

        function _typeof(obj) {
          if (
            typeof Symbol === 'function' &&
            typeof Symbol.iterator === 'symbol'
          ) {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj &&
                typeof Symbol === 'function' &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj;
            };
          }
          return _typeof(obj);
        }

        /*
 *          __        ___
 *    _____/ /___  __/ (_)____
 *   / ___/ __/ / / / / / ___/
 *  (__  ) /_/ /_/ / / (__  )
 * /____/\__/\__, /_/_/____/
 *          /____/
 *
 * light - weight css preprocessor @licence MIT
 */
        (function(factory) {
          /* eslint-disable */
          (false ? undefined : _typeof(exports)) === 'object' &&
          typeof module !== 'undefined'
            ? (module['exports'] = factory(null))
            : true
              ? !((__WEBPACK_AMD_DEFINE_FACTORY__ = factory(null)),
                (__WEBPACK_AMD_DEFINE_RESULT__ =
                  typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function'
                    ? __WEBPACK_AMD_DEFINE_FACTORY__.call(
                        exports,
                        __webpack_require__,
                        exports,
                        module
                      )
                    : __WEBPACK_AMD_DEFINE_FACTORY__),
                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                  (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
              : undefined;
        })(
          /** @param {*=} options */
          function factory(options) {
            /* eslint-disable */
            'use strict';
            /**
             * Notes
             *
             * The ['<method name>'] pattern is used to support closure compiler
             * the jsdoc signatures are also used to the same effect
             *
             * ----
             *
             * int + int + int === n4 [faster]
             *
             * vs
             *
             * int === n1 && int === n2 && int === n3
             *
             * ----
             *
             * switch (int) { case ints...} [faster]
             *
             * vs
             *
             * if (int == 1 && int === 2 ...)
             *
             * ----
             *
             * The (first*n1 + second*n2 + third*n3) format used in the property parser
             * is a simple way to hash the sequence of characters
             * taking into account the index they occur in
             * since any number of 3 character sequences could produce duplicates.
             *
             * On the other hand sequences that are directly tied to the index of the character
             * resolve a far more accurate measure, it's also faster
             * to evaluate one condition in a switch statement
             * than three in an if statement regardless of the added math.
             *
             * This allows the vendor prefixer to be both small and fast.
             */

            var nullptn = /^\0+/g;
            /* matches leading null characters */

            var formatptn = /[\0\r\f]/g;
            /* matches new line, null and formfeed characters */

            var colonptn = /: */g;
            /* splits animation rules */

            var cursorptn = /zoo|gra/;
            /* assert cursor varient */

            var transformptn = /([,: ])(transform)/g;
            /* vendor prefix transform, older webkit */

            var animationptn = /,+\s*(?![^(]*[)])/g;
            /* splits multiple shorthand notation animations */

            var propertiesptn = / +\s*(?![^(]*[)])/g;
            /* animation properties */

            var elementptn = / *[\0] */g;
            /* selector elements */

            var selectorptn = /,\r+?/g;
            /* splits selectors */

            var andptn = /([\t\r\n ])*\f?&/g;
            /* match & */

            var escapeptn = /:global\(((?:[^\(\)\[\]]*|\[.*\]|\([^\(\)]*\))*)\)/g;
            /* matches :global(.*) */

            var invalidptn = /\W+/g;
            /* removes invalid characters from keyframes */

            var keyframeptn = /@(k\w+)\s*(\S*)\s*/;
            /* matches @keyframes $1 */

            var plcholdrptn = /::(place)/g;
            /* match ::placeholder varient */

            var readonlyptn = /:(read-only)/g;
            /* match :read-only varient */

            var beforeptn = /\s+(?=[{\];=:>])/g;
            /* matches \s before ] ; = : */

            var afterptn = /([[}=:>])\s+/g;
            /* matches \s after characters [ } = : */

            var tailptn = /(\{[^{]+?);(?=\})/g;
            /* matches tail semi-colons ;} */

            var whiteptn = /\s{2,}/g;
            /* matches repeating whitespace */

            var pseudoptn = /([^\(])(:+) */g;
            /* pseudo element */

            var writingptn = /[svh]\w+-[tblr]{2}/;
            /* match writing mode property values */

            var gradientptn = /([\w-]+t\()/g;
            /* match *gradient property */

            var supportsptn = /\(\s*(.*)\s*\)/g;
            /* match supports (groups) */

            var propertyptn = /([\s\S]*?);/g;
            /* match properties leading semicolon */

            var selfptn = /-self|flex-/g;
            /* match flex- and -self in align-self: flex-*; */

            var pseudofmt = /[^]*?(:[rp][el]a[\w-]+)[^]*/;
            /* extrats :readonly or :placholder from selector */

            var trimptn = /[ \t]+$/;
            /* match tail whitspace */

            var dimensionptn = /stretch|:\s*\w+\-(?:conte|avail)/;
            /* match max/min/fit-content, fill-available
  /* vendors */

            var webkit = '-webkit-';
            var moz = '-moz-';
            var ms = '-ms-';
            /* character codes */

            var SEMICOLON = 59;
            /* ; */

            var CLOSEBRACES = 125;
            /* } */

            var OPENBRACES = 123;
            /* { */

            var OPENPARENTHESES = 40;
            /* ( */

            var CLOSEPARENTHESES = 41;
            /* ) */

            var OPENBRACKET = 91;
            /* [ */

            var CLOSEBRACKET = 93;
            /* ] */

            var NEWLINE = 10;
            /* \n */

            var CARRIAGE = 13;
            /* \r */

            var TAB = 9;
            /* \t */

            var AT = 64;
            /* @ */

            var SPACE = 32;
            /*   */

            var AND = 38;
            /* & */

            var DASH = 45;
            /* - */

            var UNDERSCORE = 95;
            /* _ */

            var STAR = 42;
            /* * */

            var COMMA = 44;
            /* , */

            var COLON = 58;
            /* : */

            var SINGLEQUOTE = 39;
            /* ' */

            var DOUBLEQUOTE = 34;
            /* " */

            var FOWARDSLASH = 47;
            /* / */

            var GREATERTHAN = 62;
            /* > */

            var PLUS = 43;
            /* + */

            var TILDE = 126;
            /* ~ */

            var NULL = 0;
            /* \0 */

            var FORMFEED = 12;
            /* \f */

            var VERTICALTAB = 11;
            /* \v */

            /* special identifiers */

            var KEYFRAME = 107;
            /* k */

            var MEDIA = 109;
            /* m */

            var SUPPORTS = 115;
            /* s */

            var PLACEHOLDER = 112;
            /* p */

            var READONLY = 111;
            /* o */

            var IMPORT = 169;
            /* <at>i */

            var CHARSET = 163;
            /* <at>c */

            var DOCUMENT = 100;
            /* <at>d */

            var PAGE = 112;
            /* <at>p */

            var column = 1;
            /* current column */

            var line = 1;
            /* current line numebr */

            var pattern = 0;
            /* :pattern */

            var cascade = 1;
            /* #id h1 h2 vs h1#id h2#id  */

            var prefix = 1;
            /* vendor prefix */

            var escape = 1;
            /* escape :global() pattern */

            var compress = 0;
            /* compress output */

            var semicolon = 0;
            /* no/semicolon option */

            var preserve = 0;
            /* preserve empty selectors */

            /* empty reference */

            var array = [];
            /* plugins */

            var plugins = [];
            var plugged = 0;
            var should = null;
            /* plugin context */

            var POSTS = -2;
            var PREPS = -1;
            var UNKWN = 0;
            var PROPS = 1;
            var BLCKS = 2;
            var ATRUL = 3;
            /* plugin newline context */

            var unkwn = 0;
            /* keyframe animation */

            var keyed = 1;
            var key = '';
            /* selector namespace */

            var nscopealt = '';
            var nscope = '';
            /**
             * Compile
             *
             * @param {Array<string>} parent
             * @param {Array<string>} current
             * @param {string} body
             * @param {number} id
             * @param {number} depth
             * @return {string}
             */

            function compile(parent, current, body, id, depth) {
              var bracket = 0;
              /* brackets [] */

              var comment = 0;
              /* comments /* // or /* */

              var parentheses = 0;
              /* functions () */

              var quote = 0;
              /* quotes '', "" */

              var first = 0;
              /* first character code */

              var second = 0;
              /* second character code */

              var code = 0;
              /* current character code */

              var tail = 0;
              /* previous character code */

              var trail = 0;
              /* character before previous code */

              var peak = 0;
              /* previous non-whitespace code */

              var counter = 0;
              /* count sequence termination */

              var context = 0;
              /* track current context */

              var atrule = 0;
              /* track @at-rule context */

              var pseudo = 0;
              /* track pseudo token index */

              var caret = 0;
              /* current character index */

              var format = 0;
              /* control character formating context */

              var insert = 0;
              /* auto semicolon insertion */

              var invert = 0;
              /* inverted selector pattern */

              var length = 0;
              /* generic length address */

              var eof = body.length;
              /* end of file(length) */

              var eol = eof - 1;
              /* end of file(characters) */

              var char = '';
              /* current character */

              var chars = '';
              /* current buffer of characters */

              var child = '';
              /* next buffer of characters */

              var out = '';
              /* compiled body */

              var children = '';
              /* compiled children */

              var flat = '';
              /* compiled leafs */

              var selector;
              /* generic selector address */

              var result;
              /* generic address */
              // ...build body

              while (caret < eof) {
                code = body.charCodeAt(caret); // eof varient

                if (caret === eol) {
                  // last character + noop context, add synthetic padding for noop context to terminate
                  if (comment + quote + parentheses + bracket !== 0) {
                    if (comment !== 0) {
                      code = comment === FOWARDSLASH ? NEWLINE : FOWARDSLASH;
                    }

                    quote = parentheses = bracket = 0;
                    eof++;
                    eol++;
                  }
                }

                if (comment + quote + parentheses + bracket === 0) {
                  // eof varient
                  if (caret === eol) {
                    if (format > 0) {
                      chars = chars.replace(formatptn, '');
                    }

                    if (chars.trim().length > 0) {
                      switch (code) {
                        case SPACE:
                        case TAB:
                        case SEMICOLON:
                        case CARRIAGE:
                        case NEWLINE: {
                          break;
                        }

                        default: {
                          chars += body.charAt(caret);
                        }
                      }

                      code = SEMICOLON;
                    }
                  } // auto semicolon insertion

                  if (insert === 1) {
                    switch (code) {
                      // false flags
                      case OPENBRACES:
                      case CLOSEBRACES:
                      case SEMICOLON:
                      case DOUBLEQUOTE:
                      case SINGLEQUOTE:
                      case OPENPARENTHESES:
                      case CLOSEPARENTHESES:
                      case COMMA: {
                        insert = 0;
                      }
                      // ignore

                      case TAB:
                      case CARRIAGE:
                      case NEWLINE:
                      case SPACE: {
                        break;
                      }
                      // valid

                      default: {
                        insert = 0;
                        length = caret;
                        first = code;
                        caret--;
                        code = SEMICOLON;

                        while (length < eof) {
                          switch (body.charCodeAt(length++)) {
                            case NEWLINE:
                            case CARRIAGE:
                            case SEMICOLON: {
                              ++caret;
                              code = first;
                              length = eof;
                              break;
                            }

                            case COLON: {
                              if (format > 0) {
                                ++caret;
                                code = first;
                              }
                            }

                            case OPENBRACES: {
                              length = eof;
                            }
                          }
                        }
                      }
                    }
                  } // token varient

                  switch (code) {
                    case OPENBRACES: {
                      chars = chars.trim();
                      first = chars.charCodeAt(0);
                      counter = 1;
                      length = ++caret;

                      while (caret < eof) {
                        code = body.charCodeAt(caret);

                        switch (code) {
                          case OPENBRACES: {
                            counter++;
                            break;
                          }

                          case CLOSEBRACES: {
                            counter--;
                            break;
                          }
                        }

                        if (counter === 0) {
                          break;
                        }

                        caret++;
                      }

                      child = body.substring(length, caret);

                      if (first === NULL) {
                        first = (chars = chars
                          .replace(nullptn, '')
                          .trim()).charCodeAt(0);
                      }

                      switch (first) {
                        // @at-rule
                        case AT: {
                          if (format > 0) {
                            chars = chars.replace(formatptn, '');
                          }

                          second = chars.charCodeAt(1);

                          switch (second) {
                            case DOCUMENT:
                            case MEDIA:
                            case SUPPORTS:
                            case DASH: {
                              selector = current;
                              break;
                            }

                            default: {
                              selector = array;
                            }
                          }

                          child = compile(
                            current,
                            selector,
                            child,
                            second,
                            depth + 1
                          );
                          length = child.length; // preserve empty @at-rule

                          if (preserve > 0 && length === 0) {
                            length = chars.length;
                          } // execute plugins, @at-rule context

                          if (plugged > 0) {
                            selector = select(array, chars, invert);
                            result = proxy(
                              ATRUL,
                              child,
                              selector,
                              current,
                              line,
                              column,
                              length,
                              second,
                              depth,
                              id
                            );
                            chars = selector.join('');

                            if (result !== void 0) {
                              if (
                                (length = (child = result.trim()).length) === 0
                              ) {
                                second = 0;
                                child = '';
                              }
                            }
                          }

                          if (length > 0) {
                            switch (second) {
                              case SUPPORTS: {
                                chars = chars.replace(supportsptn, supports);
                              }

                              case DOCUMENT:
                              case MEDIA:
                              case DASH: {
                                child = chars + '{' + child + '}';
                                break;
                              }

                              case KEYFRAME: {
                                chars = chars.replace(
                                  keyframeptn,
                                  '$1 $2' + (keyed > 0 ? key : '')
                                );
                                child = chars + '{' + child + '}';

                                if (
                                  prefix === 1 ||
                                  (prefix === 2 && vendor('@' + child, 3))
                                ) {
                                  child = '@' + webkit + child + '@' + child;
                                } else {
                                  child = '@' + child;
                                }

                                break;
                              }

                              default: {
                                child = chars + child;

                                if (id === PAGE) {
                                  child = ((out += child), '');
                                }
                              }
                            }
                          } else {
                            child = '';
                          }

                          break;
                        }
                        // selector

                        default: {
                          child = compile(
                            current,
                            select(current, chars, invert),
                            child,
                            id,
                            depth + 1
                          );
                        }
                      }

                      children += child; // reset

                      context = 0;
                      insert = 0;
                      pseudo = 0;
                      format = 0;
                      invert = 0;
                      atrule = 0;
                      chars = '';
                      child = '';
                      code = body.charCodeAt(++caret);
                      break;
                    }

                    case CLOSEBRACES:
                    case SEMICOLON: {
                      chars = (format > 0
                        ? chars.replace(formatptn, '')
                        : chars
                      ).trim();

                      if ((length = chars.length) > 1) {
                        // monkey-patch missing colon
                        if (pseudo === 0) {
                          first = chars.charCodeAt(0); // first character is a letter or dash, buffer has a space character

                          if (first === DASH || (first > 96 && first < 123)) {
                            length = (chars = chars.replace(' ', ':')).length;
                          }
                        } // execute plugins, property context

                        if (plugged > 0) {
                          if (
                            (result = proxy(
                              PROPS,
                              chars,
                              current,
                              parent,
                              line,
                              column,
                              out.length,
                              id,
                              depth,
                              id
                            )) !== void 0
                          ) {
                            if (
                              (length = (chars = result.trim()).length) === 0
                            ) {
                              chars = '\0\0';
                            }
                          }
                        }

                        first = chars.charCodeAt(0);
                        second = chars.charCodeAt(1);

                        switch (first + second) {
                          case NULL: {
                            break;
                          }

                          case IMPORT:
                          case CHARSET: {
                            flat += chars + body.charAt(caret);
                            break;
                          }

                          default: {
                            if (chars.charCodeAt(length - 1) === COLON) break;
                            out += property(
                              chars,
                              first,
                              second,
                              chars.charCodeAt(2)
                            );
                          }
                        }
                      } // reset

                      context = 0;
                      insert = 0;
                      pseudo = 0;
                      format = 0;
                      invert = 0;
                      chars = '';
                      code = body.charCodeAt(++caret);
                      break;
                    }
                  }
                } // parse characters

                switch (code) {
                  case CARRIAGE:
                  case NEWLINE: {
                    // auto insert semicolon
                    if (
                      comment + quote + parentheses + bracket + semicolon ===
                      0
                    ) {
                      // valid non-whitespace characters that
                      // may precede a newline
                      switch (peak) {
                        case CLOSEPARENTHESES:
                        case SINGLEQUOTE:
                        case DOUBLEQUOTE:
                        case AT:
                        case TILDE:
                        case GREATERTHAN:
                        case STAR:
                        case PLUS:
                        case FOWARDSLASH:
                        case DASH:
                        case COLON:
                        case COMMA:
                        case SEMICOLON:
                        case OPENBRACES:
                        case CLOSEBRACES: {
                          break;
                        }

                        default: {
                          // current buffer has a colon
                          if (pseudo > 0) {
                            insert = 1;
                          }
                        }
                      }
                    } // terminate line comment

                    if (comment === FOWARDSLASH) {
                      comment = 0;
                    } else if (cascade + context === 0) {
                      format = 1;
                      chars += '\0';
                    } // execute plugins, newline context

                    if (plugged * unkwn > 0) {
                      proxy(
                        UNKWN,
                        chars,
                        current,
                        parent,
                        line,
                        column,
                        out.length,
                        id,
                        depth,
                        id
                      );
                    } // next line, reset column position

                    column = 1;
                    line++;
                    break;
                  }

                  case SEMICOLON:
                  case CLOSEBRACES: {
                    if (comment + quote + parentheses + bracket === 0) {
                      column++;
                      break;
                    }
                  }

                  default: {
                    // increment column position
                    column++; // current character

                    char = body.charAt(caret); // remove comments, escape functions, strings, attributes and prepare selectors

                    switch (code) {
                      case TAB:
                      case SPACE: {
                        if (quote + bracket + comment === 0) {
                          switch (tail) {
                            case COMMA:
                            case COLON:
                            case TAB:
                            case SPACE: {
                              char = '';
                              break;
                            }

                            default: {
                              if (code !== SPACE) {
                                char = ' ';
                              }
                            }
                          }
                        }

                        break;
                      }
                      // escape breaking control characters

                      case NULL: {
                        char = '\\0';
                        break;
                      }

                      case FORMFEED: {
                        char = '\\f';
                        break;
                      }

                      case VERTICALTAB: {
                        char = '\\v';
                        break;
                      }
                      // &

                      case AND: {
                        // inverted selector pattern i.e html &
                        if (quote + comment + bracket === 0 && cascade > 0) {
                          invert = 1;
                          format = 1;
                          char = '\f' + char;
                        }

                        break;
                      }
                      // ::p<l>aceholder, l
                      // :read-on<l>y, l

                      case 108: {
                        if (
                          quote + comment + bracket + pattern === 0 &&
                          pseudo > 0
                        ) {
                          switch (caret - pseudo) {
                            // ::placeholder
                            case 2: {
                              if (
                                tail === PLACEHOLDER &&
                                body.charCodeAt(caret - 3) === COLON
                              ) {
                                pattern = tail;
                              }
                            }
                            // :read-only

                            case 8: {
                              if (trail === READONLY) {
                                pattern = trail;
                              }
                            }
                          }
                        }

                        break;
                      }
                      // :<pattern>

                      case COLON: {
                        if (quote + comment + bracket === 0) {
                          pseudo = caret;
                        }

                        break;
                      }
                      // selectors

                      case COMMA: {
                        if (comment + parentheses + quote + bracket === 0) {
                          format = 1;
                          char += '\r';
                        }

                        break;
                      }
                      // quotes

                      case DOUBLEQUOTE: {
                        if (comment === 0) {
                          quote =
                            quote === code ? 0 : quote === 0 ? code : quote;
                        }

                        break;
                      }

                      case SINGLEQUOTE: {
                        if (comment === 0) {
                          quote =
                            quote === code ? 0 : quote === 0 ? code : quote;
                        }

                        break;
                      }
                      // attributes

                      case OPENBRACKET: {
                        if (quote + comment + parentheses === 0) {
                          bracket++;
                        }

                        break;
                      }

                      case CLOSEBRACKET: {
                        if (quote + comment + parentheses === 0) {
                          bracket--;
                        }

                        break;
                      }
                      // functions

                      case CLOSEPARENTHESES: {
                        if (quote + comment + bracket === 0) {
                          parentheses--;
                        }

                        break;
                      }

                      case OPENPARENTHESES: {
                        if (quote + comment + bracket === 0) {
                          if (context === 0) {
                            switch (tail * 2 + trail * 3) {
                              // :matches
                              case 533: {
                                break;
                              }
                              // :global, :not, :nth-child etc...

                              default: {
                                counter = 0;
                                context = 1;
                              }
                            }
                          }

                          parentheses++;
                        }

                        break;
                      }

                      case AT: {
                        if (
                          comment +
                            parentheses +
                            quote +
                            bracket +
                            pseudo +
                            atrule ===
                          0
                        ) {
                          atrule = 1;
                        }

                        break;
                      }
                      // block/line comments

                      case STAR:
                      case FOWARDSLASH: {
                        if (quote + bracket + parentheses > 0) {
                          break;
                        }

                        switch (comment) {
                          // initialize line/block comment context
                          case 0: {
                            switch (code * 2 + body.charCodeAt(caret + 1) * 3) {
                              // //
                              case 235: {
                                comment = FOWARDSLASH;
                                break;
                              }
                              // /*

                              case 220: {
                                length = caret;
                                comment = STAR;
                                break;
                              }
                            }

                            break;
                          }
                          // end block comment context

                          case STAR: {
                            if (code === FOWARDSLASH && tail === STAR) {
                              // /*<!> ... */, !
                              if (body.charCodeAt(length + 2) === 33) {
                                out += body.substring(length, caret + 1);
                              }

                              char = '';
                              comment = 0;
                            }
                          }
                        }
                      }
                    } // ignore comment blocks

                    if (comment === 0) {
                      // aggressive isolation mode, divide each individual selector
                      // including selectors in :not function but excluding selectors in :global function
                      if (
                        cascade + quote + bracket + atrule === 0 &&
                        id !== KEYFRAME &&
                        code !== SEMICOLON
                      ) {
                        switch (code) {
                          case COMMA:
                          case TILDE:
                          case GREATERTHAN:
                          case PLUS:
                          case CLOSEPARENTHESES:
                          case OPENPARENTHESES: {
                            if (context === 0) {
                              // outside of an isolated context i.e nth-child(<...>)
                              switch (tail) {
                                case TAB:
                                case SPACE:
                                case NEWLINE:
                                case CARRIAGE: {
                                  char = char + '\0';
                                  break;
                                }

                                default: {
                                  char =
                                    '\0' + char + (code === COMMA ? '' : '\0');
                                }
                              }

                              format = 1;
                            } else {
                              // within an isolated context, sleep untill it's terminated
                              switch (code) {
                                case OPENPARENTHESES: {
                                  context = ++counter;
                                  break;
                                }

                                case CLOSEPARENTHESES: {
                                  if ((context = --counter) === 0) {
                                    format = 1;
                                    char += '\0';
                                  }

                                  break;
                                }
                              }
                            }

                            break;
                          }

                          case TAB:
                          case SPACE: {
                            switch (tail) {
                              case NULL:
                              case OPENBRACES:
                              case CLOSEBRACES:
                              case SEMICOLON:
                              case COMMA:
                              case FORMFEED:
                              case TAB:
                              case SPACE:
                              case NEWLINE:
                              case CARRIAGE: {
                                break;
                              }

                              default: {
                                // ignore in isolated contexts
                                if (context === 0) {
                                  format = 1;
                                  char += '\0';
                                }
                              }
                            }
                          }
                        }
                      } // concat buffer of characters

                      chars += char; // previous non-whitespace character code

                      if (code !== SPACE && code !== TAB) {
                        peak = code;
                      }
                    }
                  }
                } // tail character codes

                trail = tail;
                tail = code; // visit every character

                caret++;
              }

              length = out.length; // preserve empty selector

              if (preserve > 0) {
                if (
                  length === 0 &&
                  children.length === 0 &&
                  (current[0].length === 0) === false
                ) {
                  if (
                    id !== MEDIA ||
                    (current.length === 1 &&
                      (cascade > 0 ? nscopealt : nscope) === current[0])
                  ) {
                    length = current.join(',').length + 2;
                  }
                }
              }

              if (length > 0) {
                // cascade isolation mode?
                selector =
                  cascade === 0 && id !== KEYFRAME ? isolate(current) : current; // execute plugins, block context

                if (plugged > 0) {
                  result = proxy(
                    BLCKS,
                    out,
                    selector,
                    parent,
                    line,
                    column,
                    length,
                    id,
                    depth,
                    id
                  );

                  if (result !== void 0 && (out = result).length === 0) {
                    return flat + out + children;
                  }
                }

                out = selector.join(',') + '{' + out + '}';

                if (prefix * pattern !== 0) {
                  if (prefix === 2 && !vendor(out, 2)) pattern = 0;

                  switch (pattern) {
                    // ::read-only
                    case READONLY: {
                      out = out.replace(readonlyptn, ':' + moz + '$1') + out;
                      break;
                    }
                    // ::placeholder

                    case PLACEHOLDER: {
                      out =
                        out.replace(plcholdrptn, '::' + webkit + 'input-$1') +
                        out.replace(plcholdrptn, '::' + moz + '$1') +
                        out.replace(plcholdrptn, ':' + ms + 'input-$1') +
                        out;
                      break;
                    }
                  }

                  pattern = 0;
                }
              }

              return flat + out + children;
            }
            /**
             * Select
             *
             * @param {Array<string>} parent
             * @param {string} current
             * @param {number} invert
             * @return {Array<string>}
             */

            function select(parent, current, invert) {
              var selectors = current.trim().split(selectorptn);
              var out = selectors;
              var length = selectors.length;
              var l = parent.length;

              switch (l) {
                // 0-1 parent selectors
                case 0:
                case 1: {
                  for (
                    var i = 0, selector = l === 0 ? '' : parent[0] + ' ';
                    i < length;
                    ++i
                  ) {
                    out[i] = scope(selector, out[i], invert, l).trim();
                  }

                  break;
                }
                // >2 parent selectors, nested

                default: {
                  for (var i = 0, j = 0, out = []; i < length; ++i) {
                    for (var k = 0; k < l; ++k) {
                      out[j++] = scope(
                        parent[k] + ' ',
                        selectors[i],
                        invert,
                        l
                      ).trim();
                    }
                  }
                }
              }

              return out;
            }
            /**
             * Scope
             *
             * @param {string} parent
             * @param {string} current
             * @param {number} invert
             * @param {number} level
             * @return {string}
             */

            function scope(parent, current, invert, level) {
              var selector = current;
              var code = selector.charCodeAt(0); // trim leading whitespace

              if (code < 33) {
                code = (selector = selector.trim()).charCodeAt(0);
              }

              switch (code) {
                // &
                case AND: {
                  switch (cascade + level) {
                    case 0:
                    case 1: {
                      if (parent.trim().length === 0) {
                        break;
                      }
                    }

                    default: {
                      return selector.replace(andptn, '$1' + parent.trim());
                    }
                  }

                  break;
                }
                // :

                case COLON: {
                  switch (selector.charCodeAt(1)) {
                    // g in :global
                    case 103: {
                      if (escape > 0 && cascade > 0) {
                        return selector
                          .replace(escapeptn, '$1')
                          .replace(andptn, '$1' + nscope);
                      }

                      break;
                    }

                    default: {
                      // :hover
                      return (
                        parent.trim() +
                        selector.replace(andptn, '$1' + parent.trim())
                      );
                    }
                  }
                }

                default: {
                  // html &
                  if (invert * cascade > 0 && selector.indexOf('\f') > 0) {
                    return selector.replace(
                      andptn,
                      (parent.charCodeAt(0) === COLON ? '' : '$1') +
                        parent.trim()
                    );
                  }
                }
              }

              return parent + selector;
            }
            /**
             * Property
             *
             * @param {string} input
             * @param {number} first
             * @param {number} second
             * @param {number} third
             * @return {string}
             */

            function property(input, first, second, third) {
              var index = 0;
              var out = input + ';';
              var hash = first * 2 + second * 3 + third * 4;
              var cache; // animation: a, n, i characters

              if (hash === 944) {
                return animation(out);
              } else if (prefix === 0 || (prefix === 2 && !vendor(out, 1))) {
                return out;
              } // vendor prefix

              switch (hash) {
                // text-decoration/text-size-adjust/text-shadow/text-align/text-transform: t, e, x
                case 1015: {
                  // text-shadow/text-align/text-transform, a
                  return out.charCodeAt(10) === 97 ? webkit + out + out : out;
                }
                // filter/fill f, i, l

                case 951: {
                  // filter, t
                  return out.charCodeAt(3) === 116 ? webkit + out + out : out;
                }
                // color/column, c, o, l

                case 963: {
                  // column, n
                  return out.charCodeAt(5) === 110 ? webkit + out + out : out;
                }
                // box-decoration-break, b, o, x

                case 1009: {
                  if (out.charCodeAt(4) !== 100) {
                    break;
                  }
                }
                // mask, m, a, s
                // clip-path, c, l, i

                case 969:
                case 942: {
                  return webkit + out + out;
                }
                // appearance: a, p, p

                case 978: {
                  return webkit + out + moz + out + out;
                }
                // hyphens: h, y, p
                // user-select: u, s, e

                case 1019:
                case 983: {
                  return webkit + out + moz + out + ms + out + out;
                }
                // background/backface-visibility, b, a, c

                case 883: {
                  // backface-visibility, -
                  return out.charCodeAt(8) === DASH ? webkit + out + out : out;
                }
                // flex: f, l, e

                case 932: {
                  if (out.charCodeAt(4) === DASH) {
                    switch (out.charCodeAt(5)) {
                      // flex-grow, g
                      case 103: {
                        return (
                          webkit +
                          'box-' +
                          out.replace('-grow', '') +
                          webkit +
                          out +
                          ms +
                          out.replace('grow', 'positive') +
                          out
                        );
                      }
                      // flex-shrink, s

                      case 115: {
                        return (
                          webkit +
                          out +
                          ms +
                          out.replace('shrink', 'negative') +
                          out
                        );
                      }
                      // flex-basis, b

                      case 98: {
                        return (
                          webkit +
                          out +
                          ms +
                          out.replace('basis', 'preferred-size') +
                          out
                        );
                      }
                    }
                  }

                  return webkit + out + ms + out + out;
                }
                // order: o, r, d

                case 964: {
                  return webkit + out + ms + 'flex' + '-' + out + out;
                }
                // justify-items/justify-content, j, u, s

                case 1023: {
                  // justify-content, c
                  if (out.charCodeAt(8) !== 99) {
                    break;
                  }

                  cache = out
                    .substring(out.indexOf(':', 15))
                    .replace('flex-', '')
                    .replace('space-between', 'justify');
                  return (
                    webkit +
                    'box-pack' +
                    cache +
                    webkit +
                    out +
                    ms +
                    'flex-pack' +
                    cache +
                    out
                  );
                }
                // cursor, c, u, r

                case 1005: {
                  return cursorptn.test(out)
                    ? out.replace(colonptn, ':' + webkit) +
                        out.replace(colonptn, ':' + moz) +
                        out
                    : out;
                }
                // writing-mode, w, r, i

                case 1000: {
                  cache = out.substring(13).trim();
                  index = cache.indexOf('-') + 1;

                  switch (cache.charCodeAt(0) + cache.charCodeAt(index)) {
                    // vertical-lr
                    case 226: {
                      cache = out.replace(writingptn, 'tb');
                      break;
                    }
                    // vertical-rl

                    case 232: {
                      cache = out.replace(writingptn, 'tb-rl');
                      break;
                    }
                    // horizontal-tb

                    case 220: {
                      cache = out.replace(writingptn, 'lr');
                      break;
                    }

                    default: {
                      return out;
                    }
                  }

                  return webkit + out + ms + cache + out;
                }
                // position: sticky

                case 1017: {
                  if (out.indexOf('sticky', 9) === -1) {
                    return out;
                  }
                }
                // display(flex/inline-flex/inline-box): d, i, s

                case 975: {
                  index = (out = input).length - 10;
                  cache = (out.charCodeAt(index) === 33
                    ? out.substring(0, index)
                    : out
                  )
                    .substring(input.indexOf(':', 7) + 1)
                    .trim();

                  switch ((hash =
                    cache.charCodeAt(0) + (cache.charCodeAt(7) | 0))) {
                    // inline-
                    case 203: {
                      // inline-box
                      if (cache.charCodeAt(8) < 111) {
                        break;
                      }
                    }
                    // inline-box/sticky

                    case 115: {
                      out = out.replace(cache, webkit + cache) + ';' + out;
                      break;
                    }
                    // inline-flex
                    // flex

                    case 207:
                    case 102: {
                      out =
                        out.replace(
                          cache,
                          webkit + (hash > 102 ? 'inline-' : '') + 'box'
                        ) +
                        ';' +
                        out.replace(cache, webkit + cache) +
                        ';' +
                        out.replace(cache, ms + cache + 'box') +
                        ';' +
                        out;
                    }
                  }

                  return out + ';';
                }
                // align-items, align-center, align-self: a, l, i, -

                case 938: {
                  if (out.charCodeAt(5) === DASH) {
                    switch (out.charCodeAt(6)) {
                      // align-items, i
                      case 105: {
                        cache = out.replace('-items', '');
                        return (
                          webkit +
                          out +
                          webkit +
                          'box-' +
                          cache +
                          ms +
                          'flex-' +
                          cache +
                          out
                        );
                      }
                      // align-self, s

                      case 115: {
                        return (
                          webkit +
                          out +
                          ms +
                          'flex-item-' +
                          out.replace(selfptn, '') +
                          out
                        );
                      }
                      // align-content

                      default: {
                        return (
                          webkit +
                          out +
                          ms +
                          'flex-line-pack' +
                          out
                            .replace('align-content', '')
                            .replace(selfptn, '') +
                          out
                        );
                      }
                    }
                  }

                  break;
                }
                // min/max

                case 973:
                case 989: {
                  // min-/max- height/width/block-size/inline-size
                  if (out.charCodeAt(3) !== DASH || out.charCodeAt(4) === 122) {
                    break;
                  }
                }
                // height/width: min-content / width: max-content

                case 931:
                case 953: {
                  if (dimensionptn.test(input) === true) {
                    // stretch
                    if (
                      (cache = input.substring(
                        input.indexOf(':') + 1
                      )).charCodeAt(0) === 115
                    )
                      return property(
                        input.replace('stretch', 'fill-available'),
                        first,
                        second,
                        third
                      ).replace(':fill-available', ':stretch');
                    else
                      return (
                        out.replace(cache, webkit + cache) +
                        out.replace(cache, moz + cache.replace('fill-', '')) +
                        out
                      );
                  }

                  break;
                }
                // transform, transition: t, r, a

                case 962: {
                  out =
                    webkit +
                    out +
                    (out.charCodeAt(5) === 102 ? ms + out : '') +
                    out; // transitions

                  if (
                    second + third === 211 &&
                    out.charCodeAt(13) === 105 &&
                    out.indexOf('transform', 10) > 0
                  ) {
                    return (
                      out
                        .substring(0, out.indexOf(';', 27) + 1)
                        .replace(transformptn, '$1' + webkit + '$2') + out
                    );
                  }

                  break;
                }
              }

              return out;
            }
            /**
             * Vendor
             *
             * @param {string} content
             * @param {number} context
             * @return {boolean}
             */

            function vendor(content, context) {
              var index = content.indexOf(context === 1 ? ':' : '{');
              var key = content.substring(0, context !== 3 ? index : 10);
              var value = content.substring(index + 1, content.length - 1);
              return should(
                context !== 2 ? key : key.replace(pseudofmt, '$1'),
                value,
                context
              );
            }
            /**
             * Supports
             *
             * @param {string} match
             * @param {string} group
             * @return {string}
             */

            function supports(match, group) {
              var out = property(
                group,
                group.charCodeAt(0),
                group.charCodeAt(1),
                group.charCodeAt(2)
              );
              return out !== group + ';'
                ? out.replace(propertyptn, ' or ($1)').substring(4)
                : '(' + group + ')';
            }
            /**
             * Animation
             *
             * @param {string} input
             * @return {string}
             */

            function animation(input) {
              var length = input.length;
              var index = input.indexOf(':', 9) + 1;
              var declare = input.substring(0, index).trim();
              var out = input.substring(index, length - 1).trim();

              switch (input.charCodeAt(9) * keyed) {
                case 0: {
                  break;
                }
                // animation-*, -

                case DASH: {
                  // animation-name, n
                  if (input.charCodeAt(10) !== 110) {
                    break;
                  }
                }
                // animation/animation-name

                default: {
                  // split in case of multiple animations
                  var list = out.split(((out = ''), animationptn));

                  for (
                    var i = 0, index = 0, length = list.length;
                    i < length;
                    index = 0, ++i
                  ) {
                    var value = list[i];
                    var items = value.split(propertiesptn);

                    while ((value = items[index])) {
                      var peak = value.charCodeAt(0);

                      if (
                        keyed === 1 && // letters
                        ((peak > AT && peak < 90) ||
                        (peak > 96 && peak < 123) ||
                        peak === UNDERSCORE || // dash but not in sequence i.e --
                          (peak === DASH && value.charCodeAt(1) !== DASH))
                      ) {
                        // not a number/function
                        switch (isNaN(parseFloat(value)) +
                          (value.indexOf('(') !== -1)) {
                          case 1: {
                            switch (value) {
                              // not a valid reserved keyword
                              case 'infinite':
                              case 'alternate':
                              case 'backwards':
                              case 'running':
                              case 'normal':
                              case 'forwards':
                              case 'both':
                              case 'none':
                              case 'linear':
                              case 'ease':
                              case 'ease-in':
                              case 'ease-out':
                              case 'ease-in-out':
                              case 'paused':
                              case 'reverse':
                              case 'alternate-reverse':
                              case 'inherit':
                              case 'initial':
                              case 'unset':
                              case 'step-start':
                              case 'step-end': {
                                break;
                              }

                              default: {
                                value += key;
                              }
                            }
                          }
                        }
                      }

                      items[index++] = value;
                    }

                    out += (i === 0 ? '' : ',') + items.join(' ');
                  }
                }
              }

              out = declare + out + ';';
              if (prefix === 1 || (prefix === 2 && vendor(out, 1)))
                return webkit + out + out;
              return out;
            }
            /**
             * Isolate
             *
             * @param {Array<string>} current
             */

            function isolate(current) {
              for (
                var i = 0,
                  length = current.length,
                  selector = Array(length),
                  padding,
                  element;
                i < length;
                ++i
              ) {
                // split individual elements in a selector i.e h1 h2 === [h1, h2]
                var elements = current[i].split(elementptn);
                var out = '';

                for (
                  var j = 0, size = 0, tail = 0, code = 0, l = elements.length;
                  j < l;
                  ++j
                ) {
                  // empty element
                  if ((size = (element = elements[j]).length) === 0 && l > 1) {
                    continue;
                  }

                  tail = out.charCodeAt(out.length - 1);
                  code = element.charCodeAt(0);
                  padding = '';

                  if (j !== 0) {
                    // determine if we need padding
                    switch (tail) {
                      case STAR:
                      case TILDE:
                      case GREATERTHAN:
                      case PLUS:
                      case SPACE:
                      case OPENPARENTHESES: {
                        break;
                      }

                      default: {
                        padding = ' ';
                      }
                    }
                  }

                  switch (code) {
                    case AND: {
                      element = padding + nscopealt;
                    }

                    case TILDE:
                    case GREATERTHAN:
                    case PLUS:
                    case SPACE:
                    case CLOSEPARENTHESES:
                    case OPENPARENTHESES: {
                      break;
                    }

                    case OPENBRACKET: {
                      element = padding + element + nscopealt;
                      break;
                    }

                    case COLON: {
                      switch (element.charCodeAt(1) * 2 +
                        element.charCodeAt(2) * 3) {
                        // :global
                        case 530: {
                          if (escape > 0) {
                            element = padding + element.substring(8, size - 1);
                            break;
                          }
                        }
                        // :hover, :nth-child(), ...

                        default: {
                          if (j < 1 || elements[j - 1].length < 1) {
                            element = padding + nscopealt + element;
                          }
                        }
                      }

                      break;
                    }

                    case COMMA: {
                      padding = '';
                    }

                    default: {
                      if (size > 1 && element.indexOf(':') > 0) {
                        element =
                          padding +
                          element.replace(pseudoptn, '$1' + nscopealt + '$2');
                      } else {
                        element = padding + element + nscopealt;
                      }
                    }
                  }

                  out += element;
                }

                selector[i] = out.replace(formatptn, '').trim();
              }

              return selector;
            }
            /**
             * Proxy
             *
             * @param {number} context
             * @param {string} content
             * @param {Array<string>} selectors
             * @param {Array<string>} parents
             * @param {number} line
             * @param {number} column
             * @param {number} length
             * @param {number} id
             * @param {number} depth
             * @param {number} at
             * @return {(string|void|*)}
             */

            function proxy(
              context,
              content,
              selectors,
              parents,
              line,
              column,
              length,
              id,
              depth,
              at
            ) {
              for (var i = 0, out = content, next; i < plugged; ++i) {
                switch ((next = plugins[i].call(
                  stylis,
                  context,
                  out,
                  selectors,
                  parents,
                  line,
                  column,
                  length,
                  id,
                  depth,
                  at
                ))) {
                  case void 0:
                  case false:
                  case true:
                  case null: {
                    break;
                  }

                  default: {
                    out = next;
                  }
                }
              }

              switch (out) {
                case void 0:
                case false:
                case true:
                case null:
                case content: {
                  break;
                }

                default: {
                  return out;
                }
              }
            }
            /**
             * Minify
             *
             * @param {(string|*)} output
             * @return {string}
             */

            function minify(output) {
              return output
                .replace(formatptn, '')
                .replace(beforeptn, '')
                .replace(afterptn, '$1')
                .replace(tailptn, '$1')
                .replace(whiteptn, ' ');
            }
            /**
             * Use
             *
             * @param {(Array<function(...?)>|function(...?)|number|void)?} plugin
             */

            function use(plugin) {
              switch (plugin) {
                case void 0:
                case null: {
                  plugged = plugins.length = 0;
                  break;
                }

                default: {
                  switch (plugin.constructor) {
                    case Array: {
                      for (var i = 0, length = plugin.length; i < length; ++i) {
                        use(plugin[i]);
                      }

                      break;
                    }

                    case Function: {
                      plugins[plugged++] = plugin;
                      break;
                    }

                    case Boolean: {
                      unkwn = !!plugin | 0;
                    }
                  }
                }
              }

              return use;
            }
            /**
             * Set
             *
             * @param {*} options
             */

            function set(options) {
              for (var name in options) {
                var value = options[name];

                switch (name) {
                  case 'keyframe':
                    keyed = value | 0;
                    break;

                  case 'global':
                    escape = value | 0;
                    break;

                  case 'cascade':
                    cascade = value | 0;
                    break;

                  case 'compress':
                    compress = value | 0;
                    break;

                  case 'semicolon':
                    semicolon = value | 0;
                    break;

                  case 'preserve':
                    preserve = value | 0;
                    break;

                  case 'prefix':
                    should = null;

                    if (!value) {
                      prefix = 0;
                    } else if (typeof value !== 'function') {
                      prefix = 1;
                    } else {
                      prefix = 2;
                      should = value;
                    }
                }
              }

              return set;
            }
            /**
             * Stylis
             *
             * @param {string} selector
             * @param {string} input
             * @return {*}
             */

            function stylis(selector, input) {
              if (this !== void 0 && this.constructor === stylis) {
                return factory(selector);
              } // setup

              var ns = selector;
              var code = ns.charCodeAt(0); // trim leading whitespace

              if (code < 33) {
                code = (ns = ns.trim()).charCodeAt(0);
              } // keyframe/animation namespace

              if (keyed > 0) {
                key = ns.replace(invalidptn, code === OPENBRACKET ? '' : '-');
              } // reset, used to assert if a plugin is moneky-patching the return value

              code = 1; // cascade/isolate

              if (cascade === 1) {
                nscope = ns;
              } else {
                nscopealt = ns;
              }

              var selectors = [nscope];
              var result; // execute plugins, pre-process context

              if (plugged > 0) {
                result = proxy(
                  PREPS,
                  input,
                  selectors,
                  selectors,
                  line,
                  column,
                  0,
                  0,
                  0,
                  0
                );

                if (result !== void 0 && typeof result === 'string') {
                  input = result;
                }
              } // build

              var output = compile(array, selectors, input, 0, 0); // execute plugins, post-process context

              if (plugged > 0) {
                result = proxy(
                  POSTS,
                  output,
                  selectors,
                  selectors,
                  line,
                  column,
                  output.length,
                  0,
                  0,
                  0
                ); // bypass minification

                if (
                  result !== void 0 &&
                  typeof (output = result) !== 'string'
                ) {
                  code = 0;
                }
              } // reset

              key = '';
              nscope = '';
              nscopealt = '';
              pattern = 0;
              line = 1;
              column = 1;
              return compress * code === 0 ? output : minify(output);
            }

            stylis['use'] = use;
            stylis['set'] = set;

            if (options !== void 0) {
              set(options);
            }

            return stylis;
          }
        );

        /***/
      },

    /***/ './node_modules/webpack/buildin/amd-options.js':
      /*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /* WEBPACK VAR INJECTION */ (function(__webpack_amd_options__) {
          /* globals __webpack_amd_options__ */
          module.exports = __webpack_amd_options__;

          /* WEBPACK VAR INJECTION */
        }.call(this, {}));

        /***/
      },

    /***/ './node_modules/webpack/buildin/module.js':
      /*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';

        module.exports = function(module) {
          if (!module.webpackPolyfill) {
            module.deprecate = function() {};

            module.paths = []; // module.parent = undefined by default

            if (!module.children) module.children = [];
            Object.defineProperty(module, 'loaded', {
              enumerable: true,
              get: function get() {
                return module.l;
              }
            });
            Object.defineProperty(module, 'id', {
              enumerable: true,
              get: function get() {
                return module.i;
              }
            });
            module.webpackPolyfill = 1;
          }

          return module;
        };

        /***/
      },

    /***/ './node_modules/whatwg-fetch/fetch.js':
      /*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';

        (function(self) {
          'use strict';

          if (self.fetch) {
            return;
          }

          var support = {
            searchParams: 'URLSearchParams' in self,
            iterable: 'Symbol' in self && 'iterator' in Symbol,
            blob:
              'FileReader' in self &&
              'Blob' in self &&
              (function() {
                try {
                  new Blob();
                  return true;
                } catch (e) {
                  return false;
                }
              })(),
            formData: 'FormData' in self,
            arrayBuffer: 'ArrayBuffer' in self
          };

          if (support.arrayBuffer) {
            var viewClasses = [
              '[object Int8Array]',
              '[object Uint8Array]',
              '[object Uint8ClampedArray]',
              '[object Int16Array]',
              '[object Uint16Array]',
              '[object Int32Array]',
              '[object Uint32Array]',
              '[object Float32Array]',
              '[object Float64Array]'
            ];

            var isDataView = function isDataView(obj) {
              return obj && DataView.prototype.isPrototypeOf(obj);
            };

            var isArrayBufferView =
              ArrayBuffer.isView ||
              function(obj) {
                return (
                  obj &&
                  viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
                );
              };
          }

          function normalizeName(name) {
            if (typeof name !== 'string') {
              name = String(name);
            }

            if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
              throw new TypeError('Invalid character in header field name');
            }

            return name.toLowerCase();
          }

          function normalizeValue(value) {
            if (typeof value !== 'string') {
              value = String(value);
            }

            return value;
          } // Build a destructive iterator for the value list

          function iteratorFor(items) {
            var iterator = {
              next: function next() {
                var value = items.shift();
                return {
                  done: value === undefined,
                  value: value
                };
              }
            };

            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator;
              };
            }

            return iterator;
          }

          function Headers(headers) {
            this.map = {};

            if (headers instanceof Headers) {
              headers.forEach(function(value, name) {
                this.append(name, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function(header) {
                this.append(header[0], header[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name) {
                this.append(name, headers[name]);
              }, this);
            }
          }

          Headers.prototype.append = function(name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue + ',' + value : value;
          };

          Headers.prototype['delete'] = function(name) {
            delete this.map[normalizeName(name)];
          };

          Headers.prototype.get = function(name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null;
          };

          Headers.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name));
          };

          Headers.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
          };

          Headers.prototype.forEach = function(callback, thisArg) {
            for (var name in this.map) {
              if (this.map.hasOwnProperty(name)) {
                callback.call(thisArg, this.map[name], name, this);
              }
            }
          };

          Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name) {
              items.push(name);
            });
            return iteratorFor(items);
          };

          Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
              items.push(value);
            });
            return iteratorFor(items);
          };

          Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name) {
              items.push([name, value]);
            });
            return iteratorFor(items);
          };

          if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
          }

          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError('Already read'));
            }

            body.bodyUsed = true;
          }

          function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
              reader.onload = function() {
                resolve(reader.result);
              };

              reader.onerror = function() {
                reject(reader.error);
              };
            });
          }

          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
          }

          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise;
          }

          function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);

            for (var i = 0; i < view.length; i++) {
              chars[i] = String.fromCharCode(view[i]);
            }

            return chars.join('');
          }

          function bufferClone(buf) {
            if (buf.slice) {
              return buf.slice(0);
            } else {
              var view = new Uint8Array(buf.byteLength);
              view.set(new Uint8Array(buf));
              return view.buffer;
            }
          }

          function Body() {
            this.bodyUsed = false;

            this._initBody = function(body) {
              this._bodyInit = body;

              if (!body) {
                this._bodyText = '';
              } else if (typeof body === 'string') {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (
                support.formData &&
                FormData.prototype.isPrototypeOf(body)
              ) {
                this._bodyFormData = body;
              } else if (
                support.searchParams &&
                URLSearchParams.prototype.isPrototypeOf(body)
              ) {
                this._bodyText = body.toString();
              } else if (
                support.arrayBuffer &&
                support.blob &&
                isDataView(body)
              ) {
                this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (
                support.arrayBuffer &&
                (ArrayBuffer.prototype.isPrototypeOf(body) ||
                  isArrayBufferView(body))
              ) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                throw new Error('unsupported BodyInit type');
              }

              if (!this.headers.get('content-type')) {
                if (typeof body === 'string') {
                  this.headers.set('content-type', 'text/plain;charset=UTF-8');
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set('content-type', this._bodyBlob.type);
                } else if (
                  support.searchParams &&
                  URLSearchParams.prototype.isPrototypeOf(body)
                ) {
                  this.headers.set(
                    'content-type',
                    'application/x-www-form-urlencoded;charset=UTF-8'
                  );
                }
              }
            };

            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this);

                if (rejected) {
                  return rejected;
                }

                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                  throw new Error('could not read FormData body as blob');
                } else {
                  return Promise.resolve(new Blob([this._bodyText]));
                }
              };

              this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                  return (
                    consumed(this) || Promise.resolve(this._bodyArrayBuffer)
                  );
                } else {
                  return this.blob().then(readBlobAsArrayBuffer);
                }
              };
            }

            this.text = function() {
              var rejected = consumed(this);

              if (rejected) {
                return rejected;
              }

              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(
                  readArrayBufferAsText(this._bodyArrayBuffer)
                );
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as text');
              } else {
                return Promise.resolve(this._bodyText);
              }
            };

            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode);
              };
            }

            this.json = function() {
              return this.text().then(JSON.parse);
            };

            return this;
          } // HTTP methods whose capitalization should be normalized

          var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

          function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
          }

          function Request(input, options) {
            options = options || {};
            var body = options.body;

            if (input instanceof Request) {
              if (input.bodyUsed) {
                throw new TypeError('Already read');
              }

              this.url = input.url;
              this.credentials = input.credentials;

              if (!options.headers) {
                this.headers = new Headers(input.headers);
              }

              this.method = input.method;
              this.mode = input.mode;

              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }

            this.credentials =
              options.credentials || this.credentials || 'omit';

            if (options.headers || !this.headers) {
              this.headers = new Headers(options.headers);
            }

            this.method = normalizeMethod(
              options.method || this.method || 'GET'
            );
            this.mode = options.mode || this.mode || null;
            this.referrer = null;

            if ((this.method === 'GET' || this.method === 'HEAD') && body) {
              throw new TypeError('Body not allowed for GET or HEAD requests');
            }

            this._initBody(body);
          }

          Request.prototype.clone = function() {
            return new Request(this, {
              body: this._bodyInit
            });
          };

          function decode(body) {
            var form = new FormData();
            body
              .trim()
              .split('&')
              .forEach(function(bytes) {
                if (bytes) {
                  var split = bytes.split('=');
                  var name = split.shift().replace(/\+/g, ' ');
                  var value = split.join('=').replace(/\+/g, ' ');
                  form.append(
                    decodeURIComponent(name),
                    decodeURIComponent(value)
                  );
                }
              });
            return form;
          }

          function parseHeaders(rawHeaders) {
            var headers = new Headers();
            rawHeaders.split(/\r?\n/).forEach(function(line) {
              var parts = line.split(':');
              var key = parts.shift().trim();

              if (key) {
                var value = parts.join(':').trim();
                headers.append(key, value);
              }
            });
            return headers;
          }

          Body.call(Request.prototype);

          function Response(bodyInit, options) {
            if (!options) {
              options = {};
            }

            this.type = 'default';
            this.status = 'status' in options ? options.status : 200;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText =
              'statusText' in options ? options.statusText : 'OK';
            this.headers = new Headers(options.headers);
            this.url = options.url || '';

            this._initBody(bodyInit);
          }

          Body.call(Response.prototype);

          Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers(this.headers),
              url: this.url
            });
          };

          Response.error = function() {
            var response = new Response(null, {
              status: 0,
              statusText: ''
            });
            response.type = 'error';
            return response;
          };

          var redirectStatuses = [301, 302, 303, 307, 308];

          Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError('Invalid status code');
            }

            return new Response(null, {
              status: status,
              headers: {
                location: url
              }
            });
          };

          self.Headers = Headers;
          self.Request = Request;
          self.Response = Response;

          self.fetch = function(input, init) {
            return new Promise(function(resolve, reject) {
              var request = new Request(input, init);
              var xhr = new XMLHttpRequest();

              xhr.onload = function() {
                var options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                };
                options.url =
                  'responseURL' in xhr
                    ? xhr.responseURL
                    : options.headers.get('X-Request-URL');
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
              };

              xhr.onerror = function() {
                reject(new TypeError('Network request failed'));
              };

              xhr.ontimeout = function() {
                reject(new TypeError('Network request failed'));
              };

              xhr.open(request.method, request.url, true);

              if (request.credentials === 'include') {
                xhr.withCredentials = true;
              }

              if ('responseType' in xhr && support.blob) {
                xhr.responseType = 'blob';
              }

              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
              xhr.send(
                typeof request._bodyInit === 'undefined'
                  ? null
                  : request._bodyInit
              );
            });
          };

          self.fetch.polyfill = true;
        })(typeof self !== 'undefined' ? self : void 0);

        /***/
      },

    /***/ './src/feedback.js':
      /*!*************************!*\
  !*** ./src/feedback.js ***!
  \*************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          Object.defineProperty(exports, '__esModule', {
            value: true
          });
          exports.default = void 0;

          var _react = _interopRequireWildcard(
            __webpack_require__(/*! react */ './node_modules/react/index.js')
          );

          var _propTypes = _interopRequireDefault(
            __webpack_require__(
              /*! prop-types */ './node_modules/prop-types/index.js'
            )
          );

          var _classnames = _interopRequireDefault(
            __webpack_require__(
              /*! classnames */ './node_modules/classnames/index.js'
            )
          );

          var _slackIcon = _interopRequireDefault(
            __webpack_require__(/*! ./slack-icon */ './src/slack-icon.js')
          );

          var _styles = __webpack_require__(/*! ./styles */ './src/styles.js');

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};
                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }
              newObj.default = obj;
              return newObj;
            }
          }

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function _typeof(obj) {
            if (
              typeof Symbol === 'function' &&
              typeof Symbol.iterator === 'symbol'
            ) {
              _typeof = function _typeof(obj) {
                return typeof obj;
              };
            } else {
              _typeof = function _typeof(obj) {
                return obj &&
                  typeof Symbol === 'function' &&
                  obj.constructor === Symbol &&
                  obj !== Symbol.prototype
                  ? 'symbol'
                  : typeof obj;
              };
            }
            return _typeof(obj);
          }

          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              var ownKeys = Object.keys(source);
              if (typeof Object.getOwnPropertySymbols === 'function') {
                ownKeys = ownKeys.concat(
                  Object.getOwnPropertySymbols(source).filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(
                      source,
                      sym
                    ).enumerable;
                  })
                );
              }
              ownKeys.forEach(function(key) {
                _defineProperty(target, key, source[key]);
              });
            }
            return target;
          }

          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
              });
            } else {
              obj[key] = value;
            }
            return obj;
          }

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ('value' in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          function _possibleConstructorReturn(self, call) {
            if (
              call &&
              (_typeof(call) === 'object' || typeof call === 'function')
            ) {
              return call;
            }
            return _assertThisInitialized(self);
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                'Super expression must either be null or a function'
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return self;
          }

          var Input = _styles.FormElement.withComponent('input');

          var Textarea = _styles.FormElement.withComponent('textarea');

          var types = [
            {
              value: 'bug',
              label: 'Bug'
            },
            {
              value: 'improvement',
              label: 'Improvement'
            },
            {
              value: 'feature',
              label: 'Feature Request'
            }
          ];

          var SlackFeedback =
            /*#__PURE__*/
            (function(_Component) {
              _inherits(SlackFeedback, _Component);

              function SlackFeedback(props) {
                var _this;

                _classCallCheck(this, SlackFeedback);

                _this = _possibleConstructorReturn(
                  this,
                  (
                    SlackFeedback.__proto__ ||
                    Object.getPrototypeOf(SlackFeedback)
                  ).call(this, props)
                );

                _this.toggle = function() {
                  if (_this.state.active) {
                    _this.close();
                  } else {
                    _this.activate();
                  }
                };

                _this.activate = function() {
                  _this.setState(function(_ref) {
                    var active = _ref.active;
                    return {
                      active: !active
                    };
                  });

                  document.addEventListener('click', _this.handleClickOutside);
                };

                _this.handleClickOutside = function(event) {
                  if (event.defaultPrevented) return;

                  if (!_this.SlackFeedback.contains(event.target)) {
                    _this.close();
                  }
                };

                _this.close = function() {
                  _this.setState({
                    active: false
                  });

                  document.removeEventListener(
                    'click',
                    _this.handleClickOutside
                  );
                };

                _this.toggleSendURL = function() {
                  _this.setState(function(_ref2) {
                    var sendURL = _ref2.sendURL;
                    return {
                      sendURL: !sendURL
                    };
                  });
                };

                _this.selectType = function(type) {
                  return function() {
                    _this.setState({
                      selectedType: type
                    });
                  };
                };

                _this.sent = function() {
                  _this.setState(
                    {
                      sending: false,
                      sent: true,
                      image: {},
                      error: false
                    },
                    function() {
                      _this.message.value = '';
                      setTimeout(function() {
                        _this.setState({
                          sent: false
                        });
                      }, _this.props.sentTimeout);
                    }
                  );
                };

                _this.error = function(err) {
                  _this.setState(
                    {
                      sending: false,
                      error: _this.determineErrorType(err)
                    },
                    function() {
                      setTimeout(function() {
                        _this.setState({
                          error: null
                        });
                      }, _this.props.errorTimeout);
                    }
                  );
                };

                _this.determineErrorType = function(err) {
                  if (!err) return 'Unexpected Error!';
                  if (typeof err === 'string') return err;

                  switch (err.status) {
                    case 400:
                      return 'Bad Request!';

                    case 403:
                      return 'Forbidden!';

                    case 404:
                      return 'Channel Not Found!';

                    case 410:
                      return 'Channel is Archived!';

                    case 500:
                      return 'Server Error!';

                    default:
                      return 'Unexpected Error!';
                  }
                };

                _this.send = function() {
                  var _this$state = _this.state,
                    selectedType = _this$state.selectedType,
                    sendURL = _this$state.sendURL,
                    image = _this$state.image;
                  var message = _this.message.value;
                  var level;

                  _this.setState({
                    sending: true
                  }); // Attach the curent URL

                  if (sendURL)
                    message += '\n <'.concat(document.location.href, '>'); // Slack accepts 3 color levels: danger (red), good (green) and warning (orange)

                  switch (selectedType) {
                    case 'Bug':
                      level = 'danger';
                      break;

                    case 'Feature':
                      level = 'good';
                      break;

                    case 'Improvement':
                      level = 'warning';
                      break;

                    default:
                      level = 'warning';
                      break;
                  }

                  var payload = {
                    channel: _this.props.channel,
                    username: _this.props.user,
                    icon_emoji: _this.props.emoji,
                    attachments: [
                      {
                        fallback: 'Feedback ('.concat(selectedType, ')'),
                        author_name: _this.props.user,
                        color: level,
                        title: selectedType,
                        title_link: document.location.href,
                        text: message,
                        footer: 'React Slack Feedback'
                      }
                    ]
                  }; // Attach the image (if available)

                  if (image.url) payload.attachments[0].image_url = image.url; // Submit the payload

                  _this.props.onSubmit.call(
                    _assertThisInitialized(_this),
                    payload
                  );
                };

                _this.attachImage = function(event) {
                  var files = event.target.files;
                  var file = files[0];
                  file.preview = window.URL.createObjectURL(file);

                  _this.setState(
                    {
                      image: file,
                      uploadingImage: true
                    },
                    function() {
                      _this.props.onImageUpload.call(
                        _assertThisInitialized(_this),
                        file
                      );
                    }
                  );
                };

                _this.uploadError = function(err) {
                  var errorMessage = 'Error uploading image!';

                  if (err && typeof err === 'string') {
                    errorMessage = err;
                  }

                  _this.setState(
                    {
                      uploadingImage: false,
                      error: errorMessage
                    },
                    function() {
                      _this.removeImage();

                      setTimeout(function() {
                        _this.setState({
                          error: null
                        });
                      }, _this.props.errorTimeout);
                    }
                  );
                };

                _this.imageUploaded = function(url) {
                  if (typeof url !== 'string') {
                    console.error(
                      '[SlackFeedback] `url` argument in `imageUploaded` method must be a string'
                    );

                    _this.removeImage();

                    return;
                  } // Merge the image URL with the file object,
                  // the resulting object will contain only the preview and the URL.
                  // Any file information will be lost

                  _this.setState(function(_ref3) {
                    var image = _ref3.image;
                    return {
                      uploadingImage: false,
                      image: _objectSpread({}, image, {
                        url: url
                      })
                    };
                  });
                };

                _this.renderImageUpload = function() {
                  if (_this.state.image.preview) {
                    return _this.renderImagePreview();
                  }

                  return _react.default.createElement(
                    _styles.ImageUpload,
                    null,
                    _react.default.createElement(
                      _styles.UploadButton,
                      {
                        for: 'imageUpload'
                      },
                      _this.props.imageUploadText
                    ),
                    _react.default.createElement(Input, {
                      type: 'file',
                      accept: 'image/*',
                      style: {
                        display: 'none'
                      },
                      onChange: function onChange(event) {
                        return _this.attachImage(event);
                      }
                    })
                  );
                };

                _this.removeImage = function(event) {
                  if (event) event.preventDefault();

                  _this.setState({
                    image: {},
                    uploadingImage: false
                  });
                };

                _this.renderImagePreview = function() {
                  var _this$state2 = _this.state,
                    image = _this$state2.image,
                    uploadingImage = _this$state2.uploadingImage;
                  if (!image.preview) return null;
                  return _react.default.createElement(
                    _styles.ImagePreview,
                    {
                      style: {
                        backgroundImage: 'url('.concat(image.preview, ')')
                      }
                    },
                    uploadingImage
                      ? _react.default.createElement(_styles.Loader, null)
                      : _react.default.createElement(
                          _styles.PreviewOverlay,
                          null,
                          _react.default.createElement(
                            'span',
                            {
                              onClick: _this.removeImage
                            },
                            'Remove'
                          )
                        )
                  );
                };

                _this.state = {
                  active: false,
                  sendURL: true,
                  sent: false,
                  error: false,
                  uploadingImage: false,
                  selectedType: 'Bug',
                  image: {}
                };
                return _this;
              }

              _createClass(SlackFeedback, [
                {
                  key: 'render',
                  value: function render() {
                    var _this2 = this;

                    var _state = this.state,
                      active = _state.active,
                      sending = _state.sending,
                      sent = _state.sent,
                      error = _state.error,
                      sendURL = _state.sendURL,
                      selectedType = _state.selectedType,
                      uploadingImage = _state.uploadingImage; // Do not show channel UI if no channel defined

                    var showChannel =
                      Boolean(this.props.channel) && this.props.showChannel;
                    var submitText = 'Send Feedback';
                    if (sent) submitText = 'Sent!';
                    if (sending && !sent) submitText = 'Sending Feedback...';
                    if (error) submitText = error; // Return nothing if the component has been disabled

                    if (this.props.disabled) return null;
                    return _react.default.createElement(
                      _styles.SlackFeedback,
                      {
                        ref: function ref(c) {
                          _this2.SlackFeedback = c;
                        },
                        className: (0, _classnames.default)({
                          active: active
                        })
                      },
                      _react.default.createElement(
                        _styles.Container,
                        {
                          ref: function ref(c) {
                            _this2.container = c;
                          },
                          className: (0, _classnames.default)('fadeInUp', {
                            active: active
                          }),
                          style: this.props.contentStyles
                        },
                        _react.default.createElement(
                          _styles.Header,
                          null,
                          this.props.title,
                          _react.default.createElement(
                            'div',
                            {
                              className: 'close',
                              onClick: this.close
                            },
                            this.props.closeButton
                          )
                        ),
                        _react.default.createElement(
                          _styles.Content,
                          null,
                          showChannel &&
                            _react.default.createElement(
                              _styles.Label,
                              null,
                              'Channel'
                            ),
                          _react.default.createElement(Input, {
                            value: this.props.channel,
                            disabled: true,
                            hidden: !showChannel
                          }),
                          _react.default.createElement(
                            _styles.Label,
                            null,
                            'Feedback Type'
                          ),
                          _react.default.createElement(
                            _styles.Tabs,
                            null,
                            types.map(function(type) {
                              return _react.default.createElement(
                                'li',
                                {
                                  key: type.value,
                                  onClick: _this2.selectType(type.label),
                                  className: (0, _classnames.default)({
                                    selected: selectedType === type.label
                                  })
                                },
                                type.label
                              );
                            })
                          ),
                          _react.default.createElement(
                            _styles.Label,
                            null,
                            'Your Message'
                          ),
                          _react.default.createElement(Textarea, {
                            ref: function ref(c) {
                              _this2.message = c;
                            },
                            placeholder: 'Message...'
                          }),
                          this.props.onImageUpload
                            ? this.renderImageUpload()
                            : null,
                          _react.default.createElement(
                            'div',
                            {
                              style: {
                                padding: '0.5em 0 1em'
                              }
                            },
                            _react.default.createElement(_styles.Checkbox, {
                              id: 'sendURL',
                              type: 'checkbox',
                              checked: sendURL,
                              onChange: this.toggleSendURL
                            }),
                            _react.default.createElement(
                              _styles.CheckboxLabel,
                              {
                                for: 'sendURL'
                              },
                              'Send URL with Feedback'
                            )
                          ),
                          _react.default.createElement(
                            _styles.SubmitButton,
                            {
                              className: (0, _classnames.default)({
                                sent: sent,
                                error: error,
                                disabled: sending || uploadingImage
                              }),
                              onClick: this.send
                            },
                            submitText
                          )
                        )
                      ),
                      _react.default.createElement(
                        _styles.Trigger,
                        {
                          style: this.props.triggerStyles,
                          className: (0, _classnames.default)({
                            active: active
                          }),
                          onClick: this.toggle
                        },
                        this.props.buttonText
                      )
                    );
                  }
                },
                {
                  key: '__reactstandin__regenerateByEval',
                  value: function __reactstandin__regenerateByEval(key, code) {
                    this[key] = eval(code);
                  }
                }
              ]);

              return SlackFeedback;
            })(_react.Component);

          SlackFeedback.propTypes = {
            channel: _propTypes.default.string,
            user: _propTypes.default.string,
            disabled: _propTypes.default.bool,
            emoji: _propTypes.default.string,
            buttonText: _propTypes.default.node,
            imageUploadText: _propTypes.default.string,
            triggerStyles: _propTypes.default.object,
            contentStyles: _propTypes.default.object,
            showChannel: _propTypes.default.bool,
            title: _propTypes.default.node,
            closeButton: _propTypes.default.node,
            errorTimeout: _propTypes.default.number,
            sentTimeout: _propTypes.default.number,
            onSubmit: _propTypes.default.func.isRequired,
            onImageUpload: _propTypes.default.func
          };

          var noop = function noop() {};

          SlackFeedback.defaultProps = {
            channel: '',
            user: 'Unknown User',
            disabled: false,
            emoji: ':speaking_head_in_silhouette:',
            buttonText: _react.default.createElement(
              'span',
              null,
              _react.default.createElement(_slackIcon.default, null),
              ' Slack Feedback'
            ),
            imageUploadText: 'Attach Image',
            triggerStyles: {},
            contentStyles: {},
            showChannel: true,
            title: _react.default.createElement(
              'span',
              null,
              _react.default.createElement(_slackIcon.default, null),
              ' Send Feedback to Slack'
            ),
            closeButton: 'close',
            errorTimeout: 8 * 1000,
            sentTimeout: 5 * 1000,
            onImageUpload: noop
          };
          var _default = SlackFeedback;
          var _default2 = _default;
          exports.default = _default2;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              Input,
              'Input',
              '/Users/markmurray/apps/react-slack-feedback/src/feedback.js'
            );
            reactHotLoader.register(
              Textarea,
              'Textarea',
              '/Users/markmurray/apps/react-slack-feedback/src/feedback.js'
            );
            reactHotLoader.register(
              types,
              'types',
              '/Users/markmurray/apps/react-slack-feedback/src/feedback.js'
            );
            reactHotLoader.register(
              SlackFeedback,
              'SlackFeedback',
              '/Users/markmurray/apps/react-slack-feedback/src/feedback.js'
            );
            reactHotLoader.register(
              noop,
              'noop',
              '/Users/markmurray/apps/react-slack-feedback/src/feedback.js'
            );
            reactHotLoader.register(
              _default,
              'default',
              '/Users/markmurray/apps/react-slack-feedback/src/feedback.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../node_modules/webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './src/index.js':
      /*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          var _react = _interopRequireDefault(
            __webpack_require__(/*! react */ './node_modules/react/index.js')
          );

          var _propTypes = _interopRequireDefault(
            __webpack_require__(
              /*! prop-types */ './node_modules/prop-types/index.js'
            )
          );

          var _reactDom = _interopRequireDefault(
            __webpack_require__(
              /*! react-dom */ './node_modules/react-dom/index.js'
            )
          );

          var _isomorphicFetch = _interopRequireDefault(
            __webpack_require__(
              /*! isomorphic-fetch */ './node_modules/isomorphic-fetch/fetch-npm-browserify.js'
            )
          );

          var _feedback = _interopRequireDefault(
            __webpack_require__(/*! ./feedback */ './src/feedback.js')
          );

          var _this = void 0;

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var App = function App(_ref) {
            var children = _ref.children;
            return _react.default.createElement('div', null, children);
          };

          App.propTypes = {
            children: _propTypes.default.node.isRequired
          };
          /**
           * Send payload to server
           * @method sendToSlack
           * @param  {Object} payload
           * @return {null}
           */

          var sendToSlack = function sendToSlack(payload) {
            (0, _isomorphicFetch.default)('/api/slack', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(payload)
            })
              .then(function(res) {
                return res.json();
              })
              .then(function(res) {
                if (res.status >= 200 && res.status < 300) {
                  _this.sent();
                } else {
                  _this.error(res);
                }
              });
          };
          /**
           * Upload image to server
           * @method uploadImage
           * @param  {File} file
           * @return {null}
           */

          var uploadImage = function uploadImage(file) {
            var form = new FormData();
            form.append('image', file);
            (0, _isomorphicFetch.default)('/api/upload', {
              method: 'POST',
              body: form
            })
              .then(function(res) {
                console.log(res.status, res.statusText);

                if (res.status < 200 || res.status >= 300) {
                  _this.uploadError(res.statusText);
                }

                return res.json();
              })
              .then(function(url) {
                return _this.imageUploaded(url);
              });
          };

          var root = document.getElementById('root');

          _reactDom.default.render(
            _react.default.createElement(
              App,
              null,
              _react.default.createElement(_feedback.default, {
                onSubmit: sendToSlack,
                onImageUpload: uploadImage,
                user: 'markmur',
                emoji: ':bug:',
                channel: '#feedback'
              })
            ),
            root
          );

          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              App,
              'App',
              '/Users/markmurray/apps/react-slack-feedback/src/index.js'
            );
            reactHotLoader.register(
              sendToSlack,
              'sendToSlack',
              '/Users/markmurray/apps/react-slack-feedback/src/index.js'
            );
            reactHotLoader.register(
              uploadImage,
              'uploadImage',
              '/Users/markmurray/apps/react-slack-feedback/src/index.js'
            );
            reactHotLoader.register(
              root,
              'root',
              '/Users/markmurray/apps/react-slack-feedback/src/index.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../node_modules/webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './src/slack-icon.js':
      /*!***************************!*\
  !*** ./src/slack-icon.js ***!
  \***************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          Object.defineProperty(exports, '__esModule', {
            value: true
          });
          exports.default = SlackIcon;

          var _react = _interopRequireDefault(
            __webpack_require__(/*! react */ './node_modules/react/index.js')
          );

          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          function SlackIcon() {
            return _react.default.createElement(
              'svg',
              {
                id: 'SlackIcon',
                width: '16px',
                height: '16px',
                viewBox: '0 0 256 256',
                version: '1.1',
                xmlns: 'http://www.w3.org/2000/svg',
                xmlnsXlink: 'http://www.w3.org/1999/xlink',
                preserveAspectRatio: 'xMidYMid'
              },
              _react.default.createElement(
                'g',
                null,
                _react.default.createElement('path', {
                  d:
                    'M165.963541,15.8384262 C162.07318,3.86308197 149.212328,-2.69009836 137.239082,1.20236066 C125.263738,5.09272131 118.710557,17.9535738 122.603016,29.9268197 L181.550164,211.292328 C185.597902,222.478689 197.682361,228.765377 209.282098,225.426885 C221.381246,221.943607 228.756984,209.093246 224.896,197.21023 C224.749115,196.756984 165.963541,15.8384262 165.963541,15.8384262',
                  fill: '#DFA22F'
                }),
                _react.default.createElement('path', {
                  d:
                    'M74.6260984,45.515541 C70.7336393,33.5422951 57.8727869,26.9891148 45.899541,30.8794754 C33.9241967,34.7698361 27.3710164,47.6306885 31.2634754,59.6060328 L90.210623,240.971541 C94.2583607,252.157902 106.34282,258.44459 117.942557,255.104 C130.041705,251.62282 137.417443,238.772459 133.556459,226.887344 C133.409574,226.436197 74.6260984,45.515541 74.6260984,45.515541',
                  fill: '#3CB187'
                }),
                _react.default.createElement('path', {
                  d:
                    'M240.161574,166.045377 C252.136918,162.155016 258.688,149.294164 254.797639,137.31882 C250.907279,125.345574 238.046426,118.792393 226.07318,122.682754 L44.7076721,181.632 C33.5213115,185.677639 27.234623,197.762098 30.5731148,209.361836 C34.0563934,221.460984 46.9067541,228.836721 58.7897705,224.975738 C59.2430164,224.828852 240.161574,166.045377 240.161574,166.045377',
                  fill: '#CE1E5B'
                }),
                _react.default.createElement('path', {
                  d:
                    'M82.507541,217.270557 C94.312918,213.434754 109.528131,208.491016 125.855475,203.186361 C122.019672,191.380984 117.075934,176.163672 111.76918,159.83423 L68.4191475,173.924721 L82.507541,217.270557',
                  fill: '#392538'
                }),
                _react.default.createElement('path', {
                  d:
                    'M173.847082,187.591344 C190.235279,182.267803 205.467279,177.31777 217.195016,173.507148 C213.359213,161.70177 208.413377,146.480262 203.106623,130.146623 L159.75659,144.237115 L173.847082,187.591344',
                  fill: '#BB242A'
                }),
                _react.default.createElement('path', {
                  d:
                    'M210.484459,74.7058361 C222.457705,70.8154754 229.010885,57.954623 225.120525,45.9792787 C221.230164,34.0060328 208.369311,27.4528525 196.393967,31.3432131 L15.028459,90.292459 C3.84209836,94.3380984 -2.44459016,106.422557 0.896,118.022295 C4.37718033,130.121443 17.227541,137.49718 29.1126557,133.636197 C29.5638033,133.489311 210.484459,74.7058361 210.484459,74.7058361',
                  fill: '#72C5CD'
                }),
                _react.default.createElement('path', {
                  d:
                    'M52.8220328,125.933115 C64.6274098,122.097311 79.8468197,117.151475 96.1762623,111.84682 C90.8527213,95.4565246 85.9026885,80.2245246 82.0920656,68.4946885 L38.731541,82.5872787 L52.8220328,125.933115',
                  fill: '#248C73'
                }),
                _react.default.createElement('path', {
                  d:
                    'M144.159475,96.256 C160.551869,90.9303607 175.785967,85.9803279 187.515803,82.1676066 C182.190164,65.7752131 177.240131,50.5390164 173.42741,38.807082 L130.068984,52.8996721 L144.159475,96.256',
                  fill: '#62803A'
                })
              )
            );
          }

          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              SlackIcon,
              'SlackIcon',
              '/Users/markmurray/apps/react-slack-feedback/src/slack-icon.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../node_modules/webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      },

    /***/ './src/styles.js':
      /*!***********************!*\
  !*** ./src/styles.js ***!
  \***********************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        'use strict';
        /* WEBPACK VAR INJECTION */ (function(module) {
          Object.defineProperty(exports, '__esModule', {
            value: true
          });
          exports.FormElement = exports.UploadButton = exports.Select = exports.ImagePreview = exports.ImageUpload = exports.PreviewOverlay = exports.SubmitButton = exports.Textarea = exports.Label = exports.CheckboxLabel = exports.Checkbox = exports.Tabs = exports.Trigger = exports.Icon = exports.Header = exports.Content = exports.Container = exports.Loader = exports.SlackFeedback = exports.animationFadeOutDown = exports.animationFadeInUp = void 0;

          var _styledComponents = _interopRequireWildcard(
            __webpack_require__(
              /*! styled-components */ './node_modules/styled-components/dist/styled-components.browser.es.js'
            )
          );

          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc =
                      Object.defineProperty && Object.getOwnPropertyDescriptor
                        ? Object.getOwnPropertyDescriptor(obj, key)
                        : {};
                    if (desc.get || desc.set) {
                      Object.defineProperty(newObj, key, desc);
                    } else {
                      newObj[key] = obj[key];
                    }
                  }
                }
              }
              newObj.default = obj;
              return newObj;
            }
          }

          (function() {
            var enterModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).enterModule;

            enterModule && enterModule(module);
          })();

          var fontStack =
            '-apple-system, BlinkMacSystemFont, Arial, Arial Unicode, "Helvetica Neue", Helvetica, "Hiragino Sans GB", "Microsoft YaHei", SimSun, sans-serif';
          var theme = {
            font: fontStack,
            border: '#d0d8e1',
            primary: '#0088ff',
            secondary: '#222c4f',
            background: '#f4f4f7',
            success: '#3dc86f',
            error: '#ec3c3c',
            text: '#858ba0',
            loader: {
              color: '#ffffff',
              size: '4em',
              width: '7px'
            }
          };
          var resets = (0, _styledComponents.css)([
            'box-shadow:none;color:inherit;margin:inherit;padding:inherit;'
          ]);
          var formStyles = (0, _styledComponents.css)(
            ['', ';box-sizing:border-box;'],
            resets
          );
          var fadeInUp = (0, _styledComponents.keyframes)([
            'from{opacity:0;transform:translate3d(0,10%,0);}to{opacity:1;transform:none;}'
          ]);
          var animationFadeInUp = (0, _styledComponents.css)(
            ['animation:', ' 0.4s ease;animation-fill-mode:both;'],
            fadeInUp
          );
          exports.animationFadeInUp = animationFadeInUp;
          var fadeOutDown = (0, _styledComponents.keyframes)([
            'from{opacity:1;transform:none;}to{opacity:0;display:none;transform:translate3d(0,10%,0);}'
          ]);
          var animationFadeOutDown = (0, _styledComponents.css)(
            ['animation:', ' 0.4s ease;animation-fill-mode:both;'],
            fadeOutDown
          );
          exports.animationFadeOutDown = animationFadeOutDown;
          var load = (0, _styledComponents.keyframes)([
            '0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}'
          ]);

          var SlackFeedback = _styledComponents.default.div.withConfig({
            displayName: 'styles__SlackFeedback'
          })(
            [
              'position:fixed;font-family:',
              ';z-index:99999998;bottom:12px;right:0;margin:1em;&.active{.SlackFeedback--container{display:block;}}*,*:before,*:after{box-sizing:border-box;}'
            ],
            theme.font
          );

          exports.SlackFeedback = SlackFeedback;

          var Loader = _styledComponents.default.div.withConfig({
            displayName: 'styles__Loader'
          })(
            [
              'margin:50px auto;font-size:10px;position:relative;text-indent:-9999em;border-top:',
              ' solid rgba(#ffffff,0.2);border-right:',
              ' solid rgba(#ffffff,0.2);border-bottom:',
              ' solid rgba(#ffffff,0.2);border-left:',
              ' solid ',
              ';transform:translateZ(0);animation:',
              ' 0.5s infinite linear;border-radius:50%;width:',
              ';height:',
              ';&:after{border-radius:50%;width:',
              ';height:',
              ';}'
            ],
            theme.loader.width,
            theme.loader.width,
            theme.loader.width,
            theme.loader.width,
            theme.loader.color,
            load,
            theme.loader.size,
            theme.loader.size,
            theme.loader.size,
            theme.loader.size
          );

          exports.Loader = Loader;

          var Container = _styledComponents.default.div.withConfig({
            displayName: 'styles__Container'
          })(
            [
              'background:',
              ';position:relative;z-index:999999999;border-radius:4px;margin-bottom:1.5em;width:360px;top:-2.5em;right:0;box-shadow:0 6px 30px 2px rgba(',
              ',0.3);.active{display:block;}'
            ],
            theme.background,
            theme.secondary
          );

          exports.Container = Container;

          var Header = _styledComponents.default.div.withConfig({
            displayName: 'styles__Header'
          })(
            [
              'display:flex;background:',
              ';padding:0.75em 1em;border-radius:3px 3px 0 0;font-size:14px;font-weight:300;align-items:center;color:#ffffff;> img{margin-right:0.5em;}> .close{cursor:pointer;opacity:0.7;margin-left:auto;font-size:11px;&:hover{opacity:1;}}'
            ],
            theme.secondary
          );

          exports.Header = Header;

          var Content = _styledComponents.default.div.withConfig({
            displayName: 'styles__Content'
          })(['padding:0.5em;']);

          exports.Content = Content;

          var Icon = _styledComponents.default.div.withConfig({
            displayName: 'styles__Icon'
          })(['margin-right:0.5em;']);

          exports.Icon = Icon;

          var Trigger = _styledComponents.default.div.withConfig({
            displayName: 'styles__Trigger'
          })(
            [
              'display:flex;position:absolute;right:0;bottom:0;align-items:center;background:#ffffff;color:',
              ';border:1px solid ',
              ';#ffffff-space:nowrap;padding:12px 1.25em;border-radius:30px;cursor:pointer;font-size:13px;font-weight:500;box-shadow:0 3px 12px 1px rgba(',
              ',0.1);transition:box-shadow 0.3s,transform 0.2s ease-in,color 0.2s;&:hover,&.active{box-shadow:0 6px 16px 2px rgba(#000000,0.2);transform:translateY(-3px);color:#5d606c;border-color:darken(',
              ',10%);}img{margin-right:8px;}'
            ],
            theme.text,
            theme.border,
            theme.secondary,
            theme.border
          );

          exports.Trigger = Trigger;

          var Tabs = _styledComponents.default.ul.withConfig({
            displayName: 'styles__Tabs'
          })(
            [
              'display:flex;list-style:none;padding:0;margin:0;margin-bottom:1em;> li{flex:1;background:rgba(#ffffff,0.6);color:#5d606c;text-align:center;padding:0.75em;font-size:13px;cursor:pointer;border:1px solid ',
              ';&.selected{border-color:#08f;background:#ffffff;color:#08f;position:relative;text-shadow:0 1px 6px rgba(',
              ',0.1);box-shadow:0 0 8px rgba(',
              ',0.2);}&:hover:not(.selected){border:1px solid darken(',
              ',8%);}&:first-of-type{border-radius:4px 0 0 4px;margin-right:-1px;}&:last-of-type{border-radius:0 4px 4px 0;margin-left:-1px;}}'
            ],
            theme.border,
            theme.primary,
            theme.primary,
            theme.border
          );

          exports.Tabs = Tabs;

          var ImageUpload = _styledComponents.default.div.withConfig({
            displayName: 'styles__ImageUpload'
          })(['> input{display:none;}']);

          exports.ImageUpload = ImageUpload;

          var UploadButton = _styledComponents.default.button.withConfig({
            displayName: 'styles__UploadButton'
          })(
            [
              'border:1px solid ',
              ';padding:0.75em 3em;text-align:center;font-size:13px;margin:auto;width:100%;display:table;color:darken(',
              ',5%);background:#ffffff;cursor:pointer;border-radius:4px;&:hover{border:1px solid darken(',
              ',7%);background:rgba(#ffffff,0.6);color:darken(',
              ',5%);}'
            ],
            theme.border,
            theme.text,
            theme.border,
            theme.text
          );

          exports.UploadButton = UploadButton;

          var Input = _styledComponents.default.input.withConfig({
            displayName: 'styles__Input'
          })(['margin-bottom:0.75em;color:', ';'], theme.text);

          var Textarea = _styledComponents.default.textarea.withConfig({
            displayName: 'styles__Textarea'
          })(['min-height:150px;']);

          exports.Textarea = Textarea;

          var Label = _styledComponents.default.label.withConfig({
            displayName: 'styles__Label'
          })(
            ['color:', ';display:block;font-size:11px;margin:5px 0;'],
            theme.primary
          );

          exports.Label = Label;

          var FormElement = _styledComponents.default.input.withConfig({
            displayName: 'styles__FormElement'
          })(
            [
              '',
              ';width:100%;color:#444;border:1px solid ',
              ';border-radius:3px;padding:0.5em;outline:none;font-size:14px;background:#ffffff;margin-bottom:0.5em;&:focus{border:1px solid ',
              ';box-shadow:0 0 8px rgba(',
              ',0.3);}&[disabled],&.disabled{opacity:0.8;pointer-events:none;color:darken(',
              ',13%);}'
            ],
            formStyles,
            theme.border,
            theme.primary,
            theme.primary,
            theme.text
          );

          exports.FormElement = FormElement;

          var Checkbox = _styledComponents.default.input.withConfig({
            displayName: 'styles__Checkbox'
          })(
            [
              '',
              ';appearance:checkbox;position:static;font-size:1.1em;&::before,&::after{content:none;}'
            ],
            formStyles
          );

          exports.Checkbox = Checkbox;

          var CheckboxLabel = _styledComponents.default.label.withConfig({
            displayName: 'styles__CheckboxLabel'
          })([
            'display:inline-block;margin-left:10px;color:inherit;font-size:13px;color:#858ba0;cursor:pointer;&:hover{color:darken(#858ba0,5%);}'
          ]);

          exports.CheckboxLabel = CheckboxLabel;

          var SubmitButton = _styledComponents.default.button.withConfig({
            displayName: 'styles__SubmitButton'
          })(
            [
              'display:block;width:100%;padding:1em 0.75em;text-align:center;background:',
              ';color:#ffffff;font-weight:400;outline:none;border:none;font-size:11px;text-transform:uppercase;letter-spacing:0.5px;border-radius:4px;cursor:pointer;transition:background 0.2s,box-shadow 0.2s;&[disabled],&.disabled{pointer-events:none;opacity:0.4;}&.sent{background:',
              ';pointer-events:none;}&.error{background:',
              ';pointer-events:none;}&:hover{background:lighten(',
              ',7%);box-shadow:0 2px 8px 2px rgba(',
              ',0.2);}'
            ],
            theme.primary,
            theme.success,
            theme.error,
            theme.primary,
            theme.primary
          );

          exports.SubmitButton = SubmitButton;

          var PreviewOverlay = _styledComponents.default.div.withConfig({
            displayName: 'styles__PreviewOverlay'
          })(
            [
              'position:absolute;top:0;right:0;bottom:0;left:0;text-align:center;background:rgba(',
              ',0.4);opacity:0;span{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);padding:1em 3em;font-size:12px;text-transform:uppercase;color:#ffffff;border-radius:4px;cursor:pointer;background:rgba(',
              ',0.6);transition:background 0.15s;&:hover{background:',
              ';}}'
            ],
            theme.secondary,
            theme.secondary,
            theme.primary
          );

          exports.PreviewOverlay = PreviewOverlay;

          var ImagePreview = _styledComponents.default.div.withConfig({
            displayName: 'styles__ImagePreview'
          })(
            [
              'background-size:cover;background-position:center center;position:relative;width:100%;height:140px;border-radius:4px;margin-bottom:5px;border:1px solid ',
              ';&:hover{.SlackFeedback--preview-overlay{opacity:1;}}'
            ],
            theme.border
          );

          exports.ImagePreview = ImagePreview;

          var Select = _styledComponents.default.div.withConfig({
            displayName: 'styles__Select'
          })(
            ['margin-bottom:0.5em;.Select-control{border:1px solid ', ';}'],
            theme.border
          );

          exports.Select = Select;
          (function() {
            var reactHotLoader = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).default;

            var leaveModule = __webpack_require__(
              /*! react-hot-loader */ './node_modules/react-hot-loader/index.js'
            ).leaveModule;

            if (!reactHotLoader) {
              return;
            }

            reactHotLoader.register(
              fontStack,
              'fontStack',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              theme,
              'theme',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              resets,
              'resets',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              formStyles,
              'formStyles',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              fadeInUp,
              'fadeInUp',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              animationFadeInUp,
              'animationFadeInUp',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              fadeOutDown,
              'fadeOutDown',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              animationFadeOutDown,
              'animationFadeOutDown',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              load,
              'load',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              SlackFeedback,
              'SlackFeedback',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Loader,
              'Loader',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Container,
              'Container',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Header,
              'Header',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Content,
              'Content',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Icon,
              'Icon',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Trigger,
              'Trigger',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Tabs,
              'Tabs',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              ImageUpload,
              'ImageUpload',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              UploadButton,
              'UploadButton',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Input,
              'Input',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Textarea,
              'Textarea',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Label,
              'Label',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              FormElement,
              'FormElement',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Checkbox,
              'Checkbox',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              CheckboxLabel,
              'CheckboxLabel',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              SubmitButton,
              'SubmitButton',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              PreviewOverlay,
              'PreviewOverlay',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              ImagePreview,
              'ImagePreview',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            reactHotLoader.register(
              Select,
              'Select',
              '/Users/markmurray/apps/react-slack-feedback/src/styles.js'
            );
            leaveModule(module);
          })();
          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../node_modules/webpack/buildin/module.js */ './node_modules/webpack/buildin/module.js'
          )(module)
        ));

        /***/
      }

    /******/
  }
);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNvYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzb21vcnBoaWMtZmV0Y2gvZmV0Y2gtbnBtLWJyb3dzZXJpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1ob3QtbG9hZGVyL2Rpc3QvcmVhY3QtaG90LWxvYWRlci5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaG90LWxvYWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvZGlzdC9zdHlsZWQtY29tcG9uZW50cy5icm93c2VyLmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxpcy1ydWxlLXNoZWV0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsaXMvc3R5bGlzLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZlZWRiYWNrLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2xhY2staWNvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzLmpzIl0sIm5hbWVzIjpbImhhc093biIsImhhc093blByb3BlcnR5IiwiY2xhc3NOYW1lcyIsImNsYXNzZXMiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJnIiwiYXJnVHlwZSIsInB1c2giLCJBcnJheSIsImlzQXJyYXkiLCJhcHBseSIsImtleSIsImNhbGwiLCJqb2luIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmluZSIsIndpbmRvdyIsImVtcHR5RnVuY3Rpb24iLCJyZXF1aXJlIiwiRXZlbnRMaXN0ZW5lciIsImxpc3RlbiIsInRhcmdldCIsImV2ZW50VHlwZSIsImNhbGxiYWNrIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImRldGFjaEV2ZW50IiwiY2FwdHVyZSIsImNvbnNvbGUiLCJlcnJvciIsInJlZ2lzdGVyRGVmYXVsdCIsImNhblVzZURPTSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIkV4ZWN1dGlvbkVudmlyb25tZW50IiwiY2FuVXNlV29ya2VycyIsIldvcmtlciIsImNhblVzZUV2ZW50TGlzdGVuZXJzIiwiY2FuVXNlVmlld3BvcnQiLCJzY3JlZW4iLCJpc0luV29ya2VyIiwiX2h5cGhlblBhdHRlcm4iLCJjYW1lbGl6ZSIsInN0cmluZyIsInJlcGxhY2UiLCJfIiwiY2hhcmFjdGVyIiwidG9VcHBlckNhc2UiLCJtc1BhdHRlcm4iLCJjYW1lbGl6ZVN0eWxlTmFtZSIsImlzVGV4dE5vZGUiLCJjb250YWluc05vZGUiLCJvdXRlck5vZGUiLCJpbm5lck5vZGUiLCJwYXJlbnROb2RlIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIm1ha2VFbXB0eUZ1bmN0aW9uIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNOdWxsIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsImVtcHR5T2JqZWN0IiwiT2JqZWN0IiwiZnJlZXplIiwiZm9jdXNOb2RlIiwibm9kZSIsImZvY3VzIiwiZSIsImdldEFjdGl2ZUVsZW1lbnQiLCJkb2MiLCJ1bmRlZmluZWQiLCJhY3RpdmVFbGVtZW50IiwiYm9keSIsIl91cHBlcmNhc2VQYXR0ZXJuIiwiaHlwaGVuYXRlIiwidG9Mb3dlckNhc2UiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJ2YWxpZGF0ZUZvcm1hdCIsImZvcm1hdCIsIkVycm9yIiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiYSIsImIiLCJjIiwiZCIsImYiLCJhcmdzIiwiYXJnSW5kZXgiLCJuYW1lIiwiZnJhbWVzVG9Qb3AiLCJpc05vZGUiLCJvYmplY3QiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJOb2RlIiwibm9kZVR5cGUiLCJub2RlTmFtZSIsInByb3RvdHlwZSIsImlzIiwieCIsInkiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5cyIsImtleXNCIiwid2FybmluZyIsInByaW50V2FybmluZyIsIl9sZW4iLCJfa2V5IiwibWVzc2FnZSIsImluZGV4T2YiLCJfbGVuMiIsIl9rZXkyIiwiY29uY2F0IiwiaXNPYmplY3QiLCJpc09iamVjdE9iamVjdCIsIm8iLCJ0b1N0cmluZyIsImlzUGxhaW5PYmplY3QiLCJjdG9yIiwicHJvdCIsImNvbnN0cnVjdG9yIiwidmFsIiwic2VsZiIsImZldGNoIiwiYmluZCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwiYXNzaWduIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJtYXAiLCJuIiwidGVzdDMiLCJzcGxpdCIsImZvckVhY2giLCJsZXR0ZXIiLCJlcnIiLCJzb3VyY2UiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsImV4Iiwic3RhY2siLCJpc1ZhbGlkRWxlbWVudCIsInRocm93T25EaXJlY3RBY2Nlc3MiLCJJVEVSQVRPUl9TWU1CT0wiLCJTeW1ib2wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJpdGVyYXRvckZuIiwiQU5PTllNT1VTIiwiUmVhY3RQcm9wVHlwZXMiLCJhcnJheSIsImNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyIiwiYm9vbCIsImZ1bmMiLCJudW1iZXIiLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJlbGVtZW50IiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiaW5zdGFuY2VPZiIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsIm9uZU9mIiwiY3JlYXRlRW51bVR5cGVDaGVja2VyIiwib25lT2ZUeXBlIiwiY3JlYXRlVW5pb25UeXBlQ2hlY2tlciIsInNoYXBlIiwiY3JlYXRlU2hhcGVUeXBlQ2hlY2tlciIsImV4YWN0IiwiY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlciIsIlByb3BUeXBlRXJyb3IiLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwibWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUiLCJtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCIsImNoZWNrVHlwZSIsImlzUmVxdWlyZWQiLCJwcm9wcyIsInByb3BOYW1lIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY2FjaGVLZXkiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFZhbHVlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0eXBlQ2hlY2tlciIsImV4cGVjdGVkQ2xhc3MiLCJleHBlY3RlZENsYXNzTmFtZSIsImFjdHVhbENsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsImV4cGVjdGVkVmFsdWVzIiwicHJvY2VzcyIsInZhbHVlc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsInNoYXBlVHlwZXMiLCJhbGxLZXlzIiwiZXZlcnkiLCJzdGVwIiwiZW50cmllcyIsIm5leHQiLCJkb25lIiwidmFsdWUiLCJlbnRyeSIsImlzU3ltYm9sIiwiUmVnRXhwIiwiRGF0ZSIsInR5cGUiLCJQcm9wVHlwZXMiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJmb3IiLCIkJHR5cGVvZiIsIlJlYWN0IiwiX2Fzc2lnbiIsIlJFU0VSVkVEX1BST1BTIiwiY2hpbGRyZW4iLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRDaGVja2VkIiwiaW5uZXJIVE1MIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIiwic3R5bGUiLCJjaGVja01hc2siLCJiaXRtYXNrIiwiRE9NUHJvcGVydHlJbmplY3Rpb24iLCJNVVNUX1VTRV9QUk9QRVJUWSIsIkhBU19CT09MRUFOX1ZBTFVFIiwiSEFTX05VTUVSSUNfVkFMVUUiLCJIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSIsIkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUiLCJIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUiLCJpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyIsImRvbVByb3BlcnR5Q29uZmlnIiwiSW5qZWN0aW9uIiwiUHJvcGVydGllcyIsIkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMiLCJET01BdHRyaWJ1dGVOYW1lcyIsIkRPTU11dGF0aW9uTWV0aG9kcyIsInByb3BlcnRpZXMiLCJsb3dlckNhc2VkIiwicHJvcENvbmZpZyIsInByb3BlcnR5SW5mbyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJwcm9wZXJ0eU5hbWUiLCJtdXRhdGlvbk1ldGhvZCIsIm11c3RVc2VQcm9wZXJ0eSIsImhhc0Jvb2xlYW5WYWx1ZSIsImhhc051bWVyaWNWYWx1ZSIsImhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlIiwiaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSIsImhhc1N0cmluZ0Jvb2xlYW5WYWx1ZSIsIkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiUk9PVF9BVFRSSUJVVEVfTkFNRSIsInNob3VsZFNldEF0dHJpYnV0ZSIsImlzUmVzZXJ2ZWRQcm9wIiwic2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlIiwiZ2V0UHJvcGVydHlJbmZvIiwicHJlZml4Iiwic2xpY2UiLCJpbmplY3Rpb24iLCJIVE1MRE9NUHJvcGVydHlDb25maWciLCJhbGxvd0Z1bGxTY3JlZW4iLCJhc3luYyIsImF1dG9Gb2N1cyIsImF1dG9QbGF5IiwiY2hlY2tlZCIsImNvbHMiLCJjb250ZW50RWRpdGFibGUiLCJjb250cm9scyIsImRlZmVyIiwiZGlzYWJsZWQiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImZvcm1Ob1ZhbGlkYXRlIiwiaGlkZGVuIiwibG9vcCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub1ZhbGlkYXRlIiwib3BlbiIsInBsYXlzSW5saW5lIiwicmVhZE9ubHkiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm93cyIsInJvd1NwYW4iLCJzY29wZWQiLCJzZWFtbGVzcyIsInNlbGVjdGVkIiwic2l6ZSIsInN0YXJ0Iiwic3BhbiIsInNwZWxsQ2hlY2siLCJ0YWJJbmRleCIsIml0ZW1TY29wZSIsImFjY2VwdENoYXJzZXQiLCJjbGFzc05hbWUiLCJodG1sRm9yIiwiaHR0cEVxdWl2IiwicmVtb3ZlQXR0cmlidXRlIiwiaGFzQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwidmFsaWRpdHkiLCJiYWRJbnB1dCIsIkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSQxIiwiTlMiLCJ4bGluayIsInhtbCIsIkFUVFJTIiwiU1ZHRE9NUHJvcGVydHlDb25maWciLCJhdXRvUmV2ZXJzZSIsImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQiLCJwcmVzZXJ2ZUFscGhhIiwieGxpbmtBY3R1YXRlIiwieGxpbmtBcmNyb2xlIiwieGxpbmtIcmVmIiwieGxpbmtSb2xlIiwieGxpbmtTaG93IiwieGxpbmtUaXRsZSIsInhsaW5rVHlwZSIsInhtbEJhc2UiLCJ4bWxMYW5nIiwieG1sU3BhY2UiLCJDQU1FTElaRSIsImNhcGl0YWxpemUiLCJ0b2tlbiIsIm9yaWdpbmFsIiwicmVhY3ROYW1lIiwiUmVhY3RFcnJvclV0aWxzIiwiX2NhdWdodEVycm9yIiwiX2hhc0NhdWdodEVycm9yIiwiX3JldGhyb3dFcnJvciIsIl9oYXNSZXRocm93RXJyb3IiLCJpbmplY3RFcnJvclV0aWxzIiwiaW5qZWN0ZWRFcnJvclV0aWxzIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrIiwiY29udGV4dCIsImludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvciIsImhhc0NhdWdodEVycm9yIiwiY2xlYXJDYXVnaHRFcnJvciIsInJldGhyb3dDYXVnaHRFcnJvciIsImZ1bmNBcmdzIiwiZGlzcGF0Y2hFdmVudCIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYiLCJkaWRFcnJvciIsImNhbGxDYWxsYmFjayIsImV2dFR5cGUiLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsIm9uRXJyb3IiLCJldmVudCIsImNvbG5vIiwibGluZW5vIiwiZXZ0IiwiaW5pdEV2ZW50IiwiZXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luTW9kdWxlIiwicGx1Z2luSW5kZXgiLCJwbHVnaW5zIiwiZXh0cmFjdEV2ZW50cyIsInB1Ymxpc2hlZEV2ZW50cyIsImV2ZW50VHlwZXMiLCJldmVudE5hbWUiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJkaXNwYXRjaENvbmZpZyIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIiwicGhhc2VOYW1lIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZSIsInB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lIiwicmVnaXN0cmF0aW9uTmFtZSIsInJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsImxvd2VyQ2FzZWROYW1lIiwicG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyIsIm9uZGJsY2xpY2siLCJpbmplY3RFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lIiwiaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyIsImlzT3JkZXJpbmdEaXJ0eSIsIkV2ZW50UGx1Z2luUmVnaXN0cnkiLCJnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImdldE5vZGVGcm9tSW5zdGFuY2UiLCJpbmplY3Rpb24kMiIsImluamVjdENvbXBvbmVudFRyZWUiLCJJbmplY3RlZCIsInZhbGlkYXRlRXZlbnREaXNwYXRjaGVzIiwiZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJkaXNwYXRjaEluc3RhbmNlcyIsIl9kaXNwYXRjaEluc3RhbmNlcyIsImxpc3RlbmVyc0lzQXJyIiwibGlzdGVuZXJzTGVuIiwiaW5zdGFuY2VzSXNBcnIiLCJpbnN0YW5jZXNMZW4iLCJleGVjdXRlRGlzcGF0Y2giLCJzaW11bGF0ZWQiLCJsaXN0ZW5lciIsImluc3QiLCJjdXJyZW50VGFyZ2V0IiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJhY2N1bXVsYXRlSW50byIsImN1cnJlbnQiLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJhcnIiLCJjYiIsInNjb3BlIiwiZXZlbnRRdWV1ZSIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSIsImlzUGVyc2lzdGVudCIsInJlbGVhc2UiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImlzSW50ZXJhY3RpdmUiLCJ0YWciLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImluamVjdGlvbiQxIiwiZ2V0TGlzdGVuZXIiLCJzdGF0ZU5vZGUiLCJ0b3BMZXZlbFR5cGUiLCJ0YXJnZXRJbnN0IiwibmF0aXZlRXZlbnQiLCJuYXRpdmVFdmVudFRhcmdldCIsImV2ZW50cyIsInBvc3NpYmxlUGx1Z2luIiwiZXh0cmFjdGVkRXZlbnRzIiwiZW5xdWV1ZUV2ZW50cyIsInByb2Nlc3NFdmVudFF1ZXVlIiwicHJvY2Vzc2luZ0V2ZW50UXVldWUiLCJFdmVudFBsdWdpbkh1YiIsIkluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJGdW5jdGlvbmFsQ29tcG9uZW50IiwiQ2xhc3NDb21wb25lbnQiLCJIb3N0Um9vdCIsIkhvc3RQb3J0YWwiLCJIb3N0Q29tcG9uZW50IiwiSG9zdFRleHQiLCJDYWxsQ29tcG9uZW50IiwiQ2FsbEhhbmRsZXJQaGFzZSIsIlJldHVybkNvbXBvbmVudCIsIkZyYWdtZW50IiwicmFuZG9tS2V5IiwiTWF0aCIsInJhbmRvbSIsImludGVybmFsSW5zdGFuY2VLZXkiLCJpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkiLCJwcmVjYWNoZUZpYmVyTm9kZSQxIiwiaG9zdEluc3QiLCJnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSIsInBhcmVudHMiLCJjbG9zZXN0IiwicG9wIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSQxIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSQxIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxIiwidXBkYXRlRmliZXJQcm9wcyQxIiwiUmVhY3RET01Db21wb25lbnRUcmVlIiwicHJlY2FjaGVGaWJlck5vZGUiLCJ1cGRhdGVGaWJlclByb3BzIiwiZ2V0UGFyZW50IiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpbnN0QSIsImluc3RCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwiYWx0ZXJuYXRlIiwiZ2V0UGFyZW50SW5zdGFuY2UiLCJ0cmF2ZXJzZVR3b1BoYXNlIiwiZm4iLCJwYXRoIiwidHJhdmVyc2VFbnRlckxlYXZlIiwiYXJnRnJvbSIsImFyZ1RvIiwiY29tbW9uIiwicGF0aEZyb20iLCJwYXRoVG8iLCJfYWx0ZXJuYXRlIiwiX2kiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInBoYXNlIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsIl90YXJnZXRJbnN0IiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQiLCJwYXJlbnRJbnN0IiwiYWNjdW11bGF0ZURpc3BhdGNoZXMiLCJpZ25vcmVkRGlyZWN0aW9uIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQiLCJhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMiLCJsZWF2ZSIsImVudGVyIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMiLCJFdmVudFByb3BhZ2F0b3JzIiwiY29udGVudEtleSIsImdldFRleHRDb250ZW50QWNjZXNzb3IiLCJkb2N1bWVudEVsZW1lbnQiLCJjb21wb3NpdGlvblN0YXRlIiwiX3Jvb3QiLCJfc3RhcnRUZXh0IiwiX2ZhbGxiYWNrVGV4dCIsImluaXRpYWxpemUiLCJnZXRUZXh0IiwicmVzZXQiLCJnZXREYXRhIiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSIsImlzUHJveHlTdXBwb3J0ZWQiLCJQcm94eSIsIkVWRU5UX1BPT0xfU0laRSIsInNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudFBoYXNlIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJ0aW1lU3RhbXAiLCJub3ciLCJkZWZhdWx0UHJldmVudGVkIiwiaXNUcnVzdGVkIiwiU3ludGhldGljRXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIkludGVyZmFjZSIsIm5vcm1hbGl6ZSIsInJldHVyblZhbHVlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsImRlc3RydWN0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsImdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24iLCJhdWdtZW50Q2xhc3MiLCJDbGFzcyIsIlN1cGVyIiwiRSIsImFkZEV2ZW50UG9vbGluZ1RvIiwiY29uc3RydWN0IiwiY3JlYXRlIiwidGhhdCIsInNldCIsInByb3AiLCJnZXRWYWwiLCJpc0Z1bmN0aW9uIiwiY29uZmlndXJhYmxlIiwiZ2V0IiwiYWN0aW9uIiwid2FybiIsInJlc3VsdCIsIndhcm5pbmdDb25kaXRpb24iLCJnZXRQb29sZWRFdmVudCIsIm5hdGl2ZUluc3QiLCJFdmVudENvbnN0cnVjdG9yIiwiZXZlbnRQb29sIiwiaW5zdGFuY2UiLCJyZWxlYXNlUG9vbGVkRXZlbnQiLCJnZXRQb29sZWQiLCJTeW50aGV0aWNFdmVudCQxIiwiQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSIsImRhdGEiLCJTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50IiwiZGlzcGF0Y2hNYXJrZXIiLCJJbnB1dEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljSW5wdXRFdmVudCIsIkVORF9LRVlDT0RFUyIsIlNUQVJUX0tFWUNPREUiLCJjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IiwiZG9jdW1lbnRNb2RlIiwiY2FuVXNlVGV4dElucHV0RXZlbnQiLCJpc1ByZXN0byIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwib3BlcmEiLCJ2ZXJzaW9uIiwicGFyc2VJbnQiLCJTUEFDRUJBUl9DT0RFIiwiU1BBQ0VCQVJfQ0hBUiIsImJlZm9yZUlucHV0IiwiYnViYmxlZCIsImNhcHR1cmVkIiwiY29tcG9zaXRpb25FbmQiLCJjb21wb3NpdGlvblN0YXJ0IiwiY29tcG9zaXRpb25VcGRhdGUiLCJoYXNTcGFjZUtleXByZXNzIiwiaXNLZXlwcmVzc0NvbW1hbmQiLCJjdHJsS2V5IiwiYWx0S2V5IiwibWV0YUtleSIsImdldENvbXBvc2l0aW9uRXZlbnRUeXBlIiwiaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQiLCJrZXlDb2RlIiwiaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kIiwiZ2V0RGF0YUZyb21DdXN0b21FdmVudCIsImRldGFpbCIsImlzQ29tcG9zaW5nIiwiZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQiLCJmYWxsYmFja0RhdGEiLCJjdXN0b21EYXRhIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsIndoaWNoIiwiY2hhcnMiLCJnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMiLCJjaGFyIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJCZWZvcmVJbnB1dEV2ZW50UGx1Z2luIiwiZmliZXJIb3N0Q29tcG9uZW50IiwiUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uIiwiaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudCIsImhvc3RDb21wb25lbnRJbXBsIiwicmVzdG9yZVRhcmdldCIsInJlc3RvcmVRdWV1ZSIsInJlc3RvcmVTdGF0ZU9mVGFyZ2V0IiwiaW50ZXJuYWxJbnN0YW5jZSIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUiLCJpbmplY3Rpb24kMyIsImVucXVldWVTdGF0ZVJlc3RvcmUiLCJyZXN0b3JlU3RhdGVJZk5lZWRlZCIsInF1ZXVlZFRhcmdldHMiLCJSZWFjdENvbnRyb2xsZWRDb21wb25lbnQiLCJmaWJlckJhdGNoZWRVcGRhdGVzIiwiYm9va2tlZXBpbmciLCJpc05lc3RpbmdCYXRjaGVkIiwiYmF0Y2hlZFVwZGF0ZXMiLCJSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbiIsImluamVjdEZpYmVyQmF0Y2hlZFVwZGF0ZXMiLCJfYmF0Y2hlZFVwZGF0ZXMiLCJpbmplY3Rpb24kNCIsInN1cHBvcnRlZElucHV0VHlwZXMiLCJjb2xvciIsImRhdGUiLCJkYXRldGltZSIsImVtYWlsIiwibW9udGgiLCJwYXNzd29yZCIsInJhbmdlIiwic2VhcmNoIiwidGVsIiwidGV4dCIsInRpbWUiLCJ1cmwiLCJ3ZWVrIiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiZWxlbSIsIkVMRU1FTlRfTk9ERSIsIlRFWFRfTk9ERSIsIkNPTU1FTlRfTk9ERSIsIkRPQ1VNRU5UX05PREUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiZ2V0RXZlbnRUYXJnZXQiLCJzcmNFbGVtZW50IiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJ1c2VIYXNGZWF0dXJlIiwiaW1wbGVtZW50YXRpb24iLCJoYXNGZWF0dXJlIiwiaXNFdmVudFN1cHBvcnRlZCIsImV2ZW50TmFtZVN1ZmZpeCIsImlzU3VwcG9ydGVkIiwiaXNDaGVja2FibGUiLCJnZXRUcmFja2VyIiwiX3ZhbHVlVHJhY2tlciIsImRldGFjaFRyYWNrZXIiLCJnZXRWYWx1ZUZyb21Ob2RlIiwidHJhY2tWYWx1ZU9uTm9kZSIsInZhbHVlRmllbGQiLCJkZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiY3VycmVudFZhbHVlIiwiZW51bWVyYWJsZSIsInRyYWNrZXIiLCJnZXRWYWx1ZSIsInNldFZhbHVlIiwic3RvcFRyYWNraW5nIiwidHJhY2siLCJ1cGRhdGVWYWx1ZUlmQ2hhbmdlZCIsImxhc3RWYWx1ZSIsIm5leHRWYWx1ZSIsImV2ZW50VHlwZXMkMSIsImNoYW5nZSIsImNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudCIsImFjdGl2ZUVsZW1lbnRJbnN0Iiwic2hvdWxkVXNlQ2hhbmdlRXZlbnQiLCJtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50IiwicnVuRXZlbnRJbkJhdGNoIiwiZ2V0SW5zdElmVmFsdWVDaGFuZ2VkIiwidGFyZ2V0Tm9kZSIsImdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCIsImlzSW5wdXRFdmVudFN1cHBvcnRlZCIsInN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImhhbmRsZVByb3BlcnR5Q2hhbmdlIiwic3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsIiwic2hvdWxkVXNlQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCIsImhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIiLCJzdGF0ZSIsIl93cmFwcGVyU3RhdGUiLCJjb250cm9sbGVkIiwiZ2V0QXR0cmlidXRlIiwiQ2hhbmdlRXZlbnRQbHVnaW4iLCJfaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJET01FdmVudFBsdWdpbk9yZGVyIiwiVUlFdmVudEludGVyZmFjZSIsInZpZXciLCJTeW50aGV0aWNVSUV2ZW50IiwibW9kaWZpZXJLZXlUb1Byb3AiLCJBbHQiLCJDb250cm9sIiwiTWV0YSIsIlNoaWZ0IiwibW9kaWZpZXJTdGF0ZUdldHRlciIsImtleUFyZyIsInN5bnRoZXRpY0V2ZW50IiwiZ2V0TW9kaWZpZXJTdGF0ZSIsImtleVByb3AiLCJnZXRFdmVudE1vZGlmaWVyU3RhdGUiLCJNb3VzZUV2ZW50SW50ZXJmYWNlIiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsInBhZ2VYIiwicGFnZVkiLCJzaGlmdEtleSIsImJ1dHRvbiIsImJ1dHRvbnMiLCJyZWxhdGVkVGFyZ2V0IiwiZnJvbUVsZW1lbnQiLCJ0b0VsZW1lbnQiLCJTeW50aGV0aWNNb3VzZUV2ZW50IiwiZXZlbnRUeXBlcyQyIiwibW91c2VFbnRlciIsIm1vdXNlTGVhdmUiLCJFbnRlckxlYXZlRXZlbnRQbHVnaW4iLCJ3aW4iLCJwYXJlbnRXaW5kb3ciLCJyZWxhdGVkIiwiZnJvbU5vZGUiLCJ0b05vZGUiLCJfcmVhY3RJbnRlcm5hbEZpYmVyIiwiaGFzIiwiUmVhY3RJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsImdldENvbXBvbmVudE5hbWUiLCJmaWJlciIsImRpc3BsYXlOYW1lIiwiTm9FZmZlY3QiLCJQZXJmb3JtZWRXb3JrIiwiUGxhY2VtZW50IiwiVXBkYXRlIiwiUGxhY2VtZW50QW5kVXBkYXRlIiwiRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkVyciIsIlJlZiIsIk1PVU5USU5HIiwiTU9VTlRFRCIsIlVOTU9VTlRFRCIsImlzRmliZXJNb3VudGVkSW1wbCIsImVmZmVjdFRhZyIsImlzRmliZXJNb3VudGVkIiwiaXNNb3VudGVkIiwiY29tcG9uZW50Iiwib3duZXIiLCJvd25lckZpYmVyIiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiYXNzZXJ0SXNNb3VudGVkIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJwYXJlbnRBIiwicGFyZW50QiIsImNoaWxkIiwic2libGluZyIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsImZpbmRDdXJyZW50SG9zdEZpYmVyIiwicGFyZW50IiwiY3VycmVudFBhcmVudCIsImZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyIsIkNBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSIsImNhbGxiYWNrQm9va2tlZXBpbmdQb29sIiwiZmluZFJvb3RDb250YWluZXJOb2RlIiwiY29udGFpbmVySW5mbyIsImdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyIsImFuY2VzdG9ycyIsInJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJoYW5kbGVUb3BMZXZlbEltcGwiLCJib29rS2VlcGluZyIsImFuY2VzdG9yIiwicm9vdCIsIl9oYW5kbGVUb3BMZXZlbCIsIl9lbmFibGVkIiwic2V0SGFuZGxlVG9wTGV2ZWwiLCJoYW5kbGVUb3BMZXZlbCIsInNldEVuYWJsZWQiLCJlbmFibGVkIiwiaXNFbmFibGVkIiwidHJhcEJ1YmJsZWRFdmVudCIsImhhbmRsZXJCYXNlTmFtZSIsInRyYXBDYXB0dXJlZEV2ZW50IiwiUmVhY3RET01FdmVudExpc3RlbmVyIiwibWFrZVByZWZpeE1hcCIsInN0eWxlUHJvcCIsInByZWZpeGVzIiwidmVuZG9yUHJlZml4ZXMiLCJhbmltYXRpb25lbmQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJhbmltYXRpb25zdGFydCIsInRyYW5zaXRpb25lbmQiLCJwcmVmaXhlZEV2ZW50TmFtZXMiLCJhbmltYXRpb24iLCJ0cmFuc2l0aW9uIiwiZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUiLCJwcmVmaXhNYXAiLCJ0b3BMZXZlbFR5cGVzJDEiLCJ0b3BBYm9ydCIsInRvcEFuaW1hdGlvbkVuZCIsInRvcEFuaW1hdGlvbkl0ZXJhdGlvbiIsInRvcEFuaW1hdGlvblN0YXJ0IiwidG9wQmx1ciIsInRvcENhbmNlbCIsInRvcENhblBsYXkiLCJ0b3BDYW5QbGF5VGhyb3VnaCIsInRvcENoYW5nZSIsInRvcENsaWNrIiwidG9wQ2xvc2UiLCJ0b3BDb21wb3NpdGlvbkVuZCIsInRvcENvbXBvc2l0aW9uU3RhcnQiLCJ0b3BDb21wb3NpdGlvblVwZGF0ZSIsInRvcENvbnRleHRNZW51IiwidG9wQ29weSIsInRvcEN1dCIsInRvcERvdWJsZUNsaWNrIiwidG9wRHJhZyIsInRvcERyYWdFbmQiLCJ0b3BEcmFnRW50ZXIiLCJ0b3BEcmFnRXhpdCIsInRvcERyYWdMZWF2ZSIsInRvcERyYWdPdmVyIiwidG9wRHJhZ1N0YXJ0IiwidG9wRHJvcCIsInRvcER1cmF0aW9uQ2hhbmdlIiwidG9wRW1wdGllZCIsInRvcEVuY3J5cHRlZCIsInRvcEVuZGVkIiwidG9wRXJyb3IiLCJ0b3BGb2N1cyIsInRvcElucHV0IiwidG9wS2V5RG93biIsInRvcEtleVByZXNzIiwidG9wS2V5VXAiLCJ0b3BMb2FkZWREYXRhIiwidG9wTG9hZCIsInRvcExvYWRlZE1ldGFkYXRhIiwidG9wTG9hZFN0YXJ0IiwidG9wTW91c2VEb3duIiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGFzdGUiLCJ0b3BQYXVzZSIsInRvcFBsYXkiLCJ0b3BQbGF5aW5nIiwidG9wUHJvZ3Jlc3MiLCJ0b3BSYXRlQ2hhbmdlIiwidG9wU2Nyb2xsIiwidG9wU2Vla2VkIiwidG9wU2Vla2luZyIsInRvcFNlbGVjdGlvbkNoYW5nZSIsInRvcFN0YWxsZWQiLCJ0b3BTdXNwZW5kIiwidG9wVGV4dElucHV0IiwidG9wVGltZVVwZGF0ZSIsInRvcFRvZ2dsZSIsInRvcFRvdWNoQ2FuY2VsIiwidG9wVG91Y2hFbmQiLCJ0b3BUb3VjaE1vdmUiLCJ0b3BUb3VjaFN0YXJ0IiwidG9wVHJhbnNpdGlvbkVuZCIsInRvcFZvbHVtZUNoYW5nZSIsInRvcFdhaXRpbmciLCJ0b3BXaGVlbCIsIkJyb3dzZXJFdmVudENvbnN0YW50cyIsInRvcExldmVsVHlwZXMiLCJydW5FdmVudFF1ZXVlSW5CYXRjaCIsImFscmVhZHlMaXN0ZW5pbmdUbyIsInJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciIsInRvcExpc3RlbmVyc0lES2V5IiwiZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQiLCJtb3VudEF0IiwibGlzdGVuVG8iLCJjb250ZW50RG9jdW1lbnRIYW5kbGUiLCJpc0xpc3RlbmluZyIsImRlcGVuZGVuY3kiLCJpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzIiwiZ2V0TGVhZk5vZGUiLCJmaXJzdENoaWxkIiwiZ2V0U2libGluZ05vZGUiLCJuZXh0U2libGluZyIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJvZmZzZXQiLCJub2RlU3RhcnQiLCJub2RlRW5kIiwidGV4dENvbnRlbnQiLCJnZXRPZmZzZXRzIiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwicmFuZ2VDb3VudCIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUkJDEiLCJmb2N1c09mZnNldCIsImdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzIiwiaW5kZXhXaXRoaW5BbmNob3IiLCJpbmRleFdpdGhpbkZvY3VzIiwib3V0ZXIiLCJub2RlVmFsdWUiLCJzZXRPZmZzZXRzIiwib2Zmc2V0cyIsIm1pbiIsImV4dGVuZCIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInNldEVuZCIsImlzSW5Eb2N1bWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsImdldFNlbGVjdGlvbiQxIiwicmVzdG9yZVNlbGVjdGlvbiIsInByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24iLCJjdXJGb2N1c2VkRWxlbSIsInByaW9yRm9jdXNlZEVsZW0iLCJwcmlvclNlbGVjdGlvblJhbmdlIiwic2V0U2VsZWN0aW9uIiwibGVmdCIsInNjcm9sbExlZnQiLCJ0b3AiLCJzY3JvbGxUb3AiLCJpbmZvIiwiaW5wdXQiLCJzZWxlY3Rpb25TdGFydCIsInNlbGVjdGlvbkVuZCIsInNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCIsImV2ZW50VHlwZXMkMyIsInNlbGVjdCIsImFjdGl2ZUVsZW1lbnQkMSIsImFjdGl2ZUVsZW1lbnRJbnN0JDEiLCJsYXN0U2VsZWN0aW9uIiwibW91c2VEb3duIiwiY29uc3RydWN0U2VsZWN0RXZlbnQiLCJjdXJyZW50U2VsZWN0aW9uIiwiU2VsZWN0RXZlbnRQbHVnaW4iLCJBbmltYXRpb25FdmVudEludGVyZmFjZSIsImFuaW1hdGlvbk5hbWUiLCJlbGFwc2VkVGltZSIsInBzZXVkb0VsZW1lbnQiLCJTeW50aGV0aWNBbmltYXRpb25FdmVudCIsIkNsaXBib2FyZEV2ZW50SW50ZXJmYWNlIiwiY2xpcGJvYXJkRGF0YSIsIlN5bnRoZXRpY0NsaXBib2FyZEV2ZW50IiwiRm9jdXNFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJnZXRFdmVudENoYXJDb2RlIiwiY2hhckNvZGUiLCJub3JtYWxpemVLZXkiLCJFc2MiLCJTcGFjZWJhciIsIkxlZnQiLCJVcCIsIlJpZ2h0IiwiRG93biIsIkRlbCIsIldpbiIsIk1lbnUiLCJBcHBzIiwiU2Nyb2xsIiwiTW96UHJpbnRhYmxlS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJnZXRFdmVudEtleSIsIktleWJvYXJkRXZlbnRJbnRlcmZhY2UiLCJyZXBlYXQiLCJsb2NhbGUiLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiRHJhZ0V2ZW50SW50ZXJmYWNlIiwiZGF0YVRyYW5zZmVyIiwiU3ludGhldGljRHJhZ0V2ZW50IiwiVG91Y2hFdmVudEludGVyZmFjZSIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwiVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljVHJhbnNpdGlvbkV2ZW50IiwiV2hlZWxFdmVudEludGVyZmFjZSIsImRlbHRhWCIsIndoZWVsRGVsdGFYIiwiZGVsdGFZIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhIiwiZGVsdGFaIiwiZGVsdGFNb2RlIiwiU3ludGhldGljV2hlZWxFdmVudCIsImV2ZW50VHlwZXMkNCIsInRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyIsImNhcGl0YWxpemVkRXZlbnQiLCJvbkV2ZW50IiwidG9wRXZlbnQiLCJrbm93bkhUTUxUb3BMZXZlbFR5cGVzIiwiU2ltcGxlRXZlbnRQbHVnaW4iLCJlbmFibGVBc3luY1N1YnRyZWVBUEkiLCJlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NIiwiZW5hYmxlQ3JlYXRlUm9vdCIsImVuYWJsZVVzZXJUaW1pbmdBUEkiLCJlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIiLCJlbmFibGVOb29wUmVjb25jaWxlciIsImVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyIiwiZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIiwidmFsdWVTdGFjayIsImZpYmVyU3RhY2siLCJpbmRleCIsImNyZWF0ZUN1cnNvciIsImN1cnNvciIsInJlc2V0JDEiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZGVzY3JpYmVGaWJlciIsIl9kZWJ1Z093bmVyIiwiX2RlYnVnU291cmNlIiwiZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlciIsIndvcmtJblByb2dyZXNzIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lIiwiUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0iLCJyZXNldEN1cnJlbnRGaWJlciIsImdldEN1cnJlbnRTdGFjayIsInNldEN1cnJlbnRGaWJlciIsInNldEN1cnJlbnRQaGFzZSIsInJlYWN0RW1vamkiLCJ3YXJuaW5nRW1vamkiLCJzdXBwb3J0c1VzZXJUaW1pbmciLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJjbGVhck1hcmtzIiwibWVhc3VyZSIsImNsZWFyTWVhc3VyZXMiLCJjdXJyZW50RmliZXIiLCJjdXJyZW50UGhhc2UiLCJjdXJyZW50UGhhc2VGaWJlciIsImlzQ29tbWl0dGluZyIsImhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCIsImhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlIiwiY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCIsImVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0IiwiaXNXYWl0aW5nRm9yQ2FsbGJhY2siLCJsYWJlbHNJbkN1cnJlbnRDb21taXQiLCJTZXQiLCJmb3JtYXRNYXJrTmFtZSIsIm1hcmtOYW1lIiwiZm9ybWF0TGFiZWwiLCJsYWJlbCIsIndhcm5pbmckJDEiLCJzdWZmaXgiLCJiZWdpbk1hcmsiLCJjbGVhck1hcmsiLCJlbmRNYXJrIiwiZm9ybWF0dGVkTWFya05hbWUiLCJmb3JtYXR0ZWRMYWJlbCIsImdldEZpYmVyTWFya05hbWUiLCJkZWJ1Z0lEIiwiZ2V0RmliZXJMYWJlbCIsImJlZ2luRmliZXJNYXJrIiwiX2RlYnVnSUQiLCJhZGQiLCJjbGVhckZpYmVyTWFyayIsImVuZEZpYmVyTWFyayIsInNob3VsZElnbm9yZUZpYmVyIiwiY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCIsInBhdXNlVGltZXJzIiwiX2RlYnVnSXNDdXJyZW50bHlUaW1pbmciLCJyZXN1bWVUaW1lcnNSZWN1cnNpdmVseSIsInJlc3VtZVRpbWVycyIsInJlY29yZEVmZmVjdCIsInJlY29yZFNjaGVkdWxlVXBkYXRlIiwic3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lciIsInN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lciIsImRpZEV4cGlyZSIsInN0YXJ0V29ya1RpbWVyIiwiY2FuY2VsV29ya1RpbWVyIiwic3RvcFdvcmtUaW1lciIsInN0b3BGYWlsZWRXb3JrVGltZXIiLCJzdGFydFBoYXNlVGltZXIiLCJzdG9wUGhhc2VUaW1lciIsInN0YXJ0V29ya0xvb3BUaW1lciIsIm5leHRVbml0T2ZXb3JrIiwic3RvcFdvcmtMb29wVGltZXIiLCJpbnRlcnJ1cHRlZEJ5Iiwic3RhcnRDb21taXRUaW1lciIsImNsZWFyIiwic3RvcENvbW1pdFRpbWVyIiwic3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyIiwic3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIiLCJjb3VudCIsInN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyIiwic3RvcENvbW1pdExpZmVDeWNsZXNUaW1lciIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJoYXNPd25Db250ZXh0IiwiaXNDb250ZXh0UHJvdmlkZXIiLCJjYWNoZUNvbnRleHQiLCJ1bm1hc2tlZENvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0IiwiZ2V0TWFza2VkQ29udGV4dCIsImNvbnRleHRUeXBlcyIsImhhc0NvbnRleHRDaGFuZ2VkIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJjaGlsZENvbnRleHRUeXBlcyIsInBvcENvbnRleHRQcm92aWRlciIsInBvcFRvcExldmVsQ29udGV4dE9iamVjdCIsInB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QiLCJkaWRDaGFuZ2UiLCJwcm9jZXNzQ2hpbGRDb250ZXh0IiwicGFyZW50Q29udGV4dCIsImdldENoaWxkQ29udGV4dCIsImNoaWxkQ29udGV4dCIsImNvbnRleHRLZXkiLCJwdXNoQ29udGV4dFByb3ZpZGVyIiwibWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsImludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIiLCJtZXJnZWRDb250ZXh0IiwicmVzZXRDb250ZXh0IiwiZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQiLCJOb1dvcmsiLCJTeW5jIiwiTmV2ZXIiLCJVTklUX1NJWkUiLCJNQUdJQ19OVU1CRVJfT0ZGU0VUIiwibXNUb0V4cGlyYXRpb25UaW1lIiwibXMiLCJleHBpcmF0aW9uVGltZVRvTXMiLCJleHBpcmF0aW9uVGltZSIsImNlaWxpbmciLCJudW0iLCJwcmVjaXNpb24iLCJjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldCIsImN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkluTXMiLCJidWNrZXRTaXplTXMiLCJOb0NvbnRleHQiLCJBc3luY1VwZGF0ZXMiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsIm5vbkV4dGVuc2libGVPYmplY3QiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImRlYnVnQ291bnRlciIsIkZpYmVyTm9kZSIsImludGVybmFsQ29udGV4dFRhZyIsInJlZiIsInBlbmRpbmdQcm9wcyIsIm1lbW9pemVkUHJvcHMiLCJ1cGRhdGVRdWV1ZSIsIm1lbW9pemVkU3RhdGUiLCJuZXh0RWZmZWN0IiwiZmlyc3RFZmZlY3QiLCJsYXN0RWZmZWN0IiwiY3JlYXRlRmliZXIiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiY3JlYXRlV29ya0luUHJvZ3Jlc3MiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsIl9vd25lciIsIl9zb3VyY2UiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImVsZW1lbnRzIiwiY3JlYXRlRmliZXJGcm9tVGV4dCIsImNvbnRlbnQiLCJjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbiIsImNyZWF0ZUZpYmVyRnJvbUNhbGwiLCJoYW5kbGVyIiwiY3JlYXRlRmliZXJGcm9tUmV0dXJuIiwicmV0dXJuTm9kZSIsImNyZWF0ZUZpYmVyRnJvbVBvcnRhbCIsInBvcnRhbCIsInBlbmRpbmdDaGlsZHJlbiIsImNyZWF0ZUZpYmVyUm9vdCIsImh5ZHJhdGUiLCJ1bmluaXRpYWxpemVkRmliZXIiLCJyZW1haW5pbmdFeHBpcmF0aW9uVGltZSIsImlzUmVhZHlGb3JDb21taXQiLCJmaW5pc2hlZFdvcmsiLCJwZW5kaW5nQ29udGV4dCIsIm5leHRTY2hlZHVsZWRSb290Iiwib25Db21taXRGaWJlclJvb3QiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsImhhc0xvZ2dlZEVycm9yIiwiY2F0Y2hFcnJvcnMiLCJpbmplY3RJbnRlcm5hbHMiLCJpbnRlcm5hbHMiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJob29rIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJyZW5kZXJlcklEIiwiaW5qZWN0Iiwib25Db21taXRSb290Iiwib25Db21taXRVbm1vdW50IiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImNyZWF0ZVVwZGF0ZVF1ZXVlIiwiYmFzZVN0YXRlIiwicXVldWUiLCJmaXJzdCIsImxhc3QiLCJjYWxsYmFja0xpc3QiLCJoYXNGb3JjZVVwZGF0ZSIsImlzSW5pdGlhbGl6ZWQiLCJpc1Byb2Nlc3NpbmciLCJpbnNlcnRVcGRhdGVJbnRvUXVldWUiLCJ1cGRhdGUiLCJpbnNlcnRVcGRhdGVJbnRvRmliZXIiLCJhbHRlcm5hdGVGaWJlciIsInF1ZXVlMSIsInF1ZXVlMiIsImdldFVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiZ2V0U3RhdGVGcm9tVXBkYXRlIiwicHJldlN0YXRlIiwicGFydGlhbFN0YXRlIiwidXBkYXRlRm4iLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJyZW5kZXJFeHBpcmF0aW9uVGltZSIsImN1cnJlbnRRdWV1ZSIsImRvbnRNdXRhdGVQcmV2U3RhdGUiLCJkaWRTa2lwIiwidXBkYXRlRXhwaXJhdGlvblRpbWUiLCJfcGFydGlhbFN0YXRlIiwiaXNSZXBsYWNlIiwiaXNGb3JjZWQiLCJfY2FsbGJhY2tMaXN0IiwiY29tbWl0Q2FsbGJhY2tzIiwiX2NhbGxiYWNrIiwiZmFrZUludGVybmFsSW5zdGFuY2UiLCJkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJjYWxsZXJOYW1lIiwiUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50Iiwic2NoZWR1bGVXb3JrIiwiY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciIsIm1lbW9pemVQcm9wcyIsIm1lbW9pemVTdGF0ZSIsInVwZGF0ZXIiLCJlbnF1ZXVlU2V0U3RhdGUiLCJuZXh0Q2FsbGJhY2siLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsIm5ld0NvbnRleHQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJzaG91bGRVcGRhdGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsImNoZWNrQ2xhc3NJbnN0YW5jZSIsInJlbmRlclByZXNlbnQiLCJyZW5kZXIiLCJub0dldEluaXRpYWxTdGF0ZU9uRVM2IiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJub0dldERlZmF1bHRQcm9wc09uRVM2IiwiZ2V0RGVmYXVsdFByb3BzIiwibm9JbnN0YW5jZVByb3BUeXBlcyIsInByb3BUeXBlcyIsIm5vSW5zdGFuY2VDb250ZXh0VHlwZXMiLCJub0NvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsIm5vQ29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFVubW91bnQiLCJub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsIm5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJoYXNNdXRhdGVkUHJvcHMiLCJub0luc3RhbmNlRGVmYXVsdFByb3BzIiwiZGVmYXVsdFByb3BzIiwicmVzZXRJbnB1dFBvaW50ZXJzIiwiYWRvcHRDbGFzc0luc3RhbmNlIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJuZWVkc0NvbnRleHQiLCJjYWxsQ29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbE1vdW50IiwiY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibW91bnRDbGFzc0luc3RhbmNlIiwicmVmcyIsInVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCIsImNvbXBvbmVudERpZE1vdW50IiwidXBkYXRlQ2xhc3NJbnN0YW5jZSIsIm9sZENvbnRleHQiLCJuZXdVbm1hc2tlZENvbnRleHQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiaGFzU3ltYm9sIiwiUkVBQ1RfQ0FMTF9UWVBFIiwiUkVBQ1RfUkVUVVJOX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJtYXliZUl0ZXJhdG9yIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxIiwiZGlkV2FybkFib3V0TWFwcyIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsIm93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyIsIndhcm5Gb3JNaXNzaW5nS2V5IiwiX3N0b3JlIiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImlzQXJyYXkkMSIsImNvZXJjZVJlZiIsIm1peGVkUmVmIiwic3RyaW5nUmVmIiwiX3N0cmluZ1JlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsInJldHVybkZpYmVyIiwibmV3Q2hpbGQiLCJhZGRlbmR1bSIsIndhcm5PbkZ1bmN0aW9uVHlwZSIsIkNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImNoaWxkVG9EZWxldGUiLCJkZWxldGVSZW1haW5pbmdDaGlsZHJlbiIsImN1cnJlbnRGaXJzdENoaWxkIiwibWFwUmVtYWluaW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkcmVuIiwiTWFwIiwiZXhpc3RpbmdDaGlsZCIsInVzZUZpYmVyIiwiY2xvbmUiLCJwbGFjZUNoaWxkIiwibmV3RmliZXIiLCJsYXN0UGxhY2VkSW5kZXgiLCJuZXdJbmRleCIsIm9sZEluZGV4IiwicGxhY2VTaW5nbGVDaGlsZCIsInVwZGF0ZVRleHROb2RlIiwiY3JlYXRlZCIsImV4aXN0aW5nIiwidXBkYXRlRWxlbWVudCIsInVwZGF0ZUNhbGwiLCJ1cGRhdGVSZXR1cm4iLCJ1cGRhdGVQb3J0YWwiLCJ1cGRhdGVGcmFnbWVudCIsImZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsIl9jcmVhdGVkNCIsIl9jcmVhdGVkNSIsIl9jcmVhdGVkNiIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIl9tYXRjaGVkRmliZXI0IiwiX21hdGNoZWRGaWJlcjUiLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJfbmV3RmliZXIiLCJfbmV3RmliZXIyIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvciIsIm5ld0NoaWxkcmVuSXRlcmFibGUiLCJwb3NzaWJsZU1hcCIsIl9uZXdDaGlsZHJlbiIsIl9zdGVwIiwiX25ld0ZpYmVyMyIsIl9uZXdGaWJlcjQiLCJyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZSIsInJlY29uY2lsZVNpbmdsZUVsZW1lbnQiLCJfY3JlYXRlZDciLCJyZWNvbmNpbGVTaW5nbGVDYWxsIiwicmVjb25jaWxlU2luZ2xlUmV0dXJuIiwicmVjb25jaWxlU2luZ2xlUG9ydGFsIiwicmVjb25jaWxlQ2hpbGRGaWJlcnMiLCJfaXNNb2NrRnVuY3Rpb24iLCJtb3VudENoaWxkRmliZXJzIiwiY2xvbmVDaGlsZEZpYmVycyIsImN1cnJlbnRDaGlsZCIsIndhcm5lZEFib3V0U3RhdGVsZXNzUmVmcyIsIlJlYWN0RmliZXJCZWdpbldvcmsiLCJjb25maWciLCJob3N0Q29udGV4dCIsImh5ZHJhdGlvbkNvbnRleHQiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsInVzZVN5bmNTY2hlZHVsaW5nIiwic2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSIsInB1c2hIb3N0Q29udGV4dCIsInB1c2hIb3N0Q29udGFpbmVyIiwiZW50ZXJIeWRyYXRpb25TdGF0ZSIsInJlc2V0SHlkcmF0aW9uU3RhdGUiLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsIl9SZWFjdEZpYmVyQ2xhc3NDb21wbyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwicmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsIm1hcmtSZWYiLCJ1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibmV4dFByb3BzIiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJoYXNDb250ZXh0IiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJwdXNoSG9zdFJvb3RDb250ZXh0IiwidXBkYXRlSG9zdFJvb3QiLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwicHJldlByb3BzIiwiaXNEaXJlY3RUZXh0Q2hpbGQiLCJ1cGRhdGVIb3N0VGV4dCIsIm1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIndhcm5pbmdLZXkiLCJkZWJ1Z1NvdXJjZSIsInVwZGF0ZUNhbGxDb21wb25lbnQiLCJuZXh0Q2FsbCIsInVwZGF0ZVBvcnRhbENvbXBvbmVudCIsImJhaWxvdXRPbkxvd1ByaW9yaXR5IiwibmV4dFN0YXRlIiwiYmVnaW5Xb3JrIiwiYmVnaW5GYWlsZWRXb3JrIiwiUmVhY3RGaWJlckNvbXBsZXRlV29yayIsImNyZWF0ZUluc3RhbmNlIiwiY3JlYXRlVGV4dEluc3RhbmNlIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJwcmVwYXJlVXBkYXRlIiwibXV0YXRpb24iLCJwZXJzaXN0ZW5jZSIsImdldFJvb3RIb3N0Q29udGFpbmVyIiwicG9wSG9zdENvbnRleHQiLCJnZXRIb3N0Q29udGV4dCIsInBvcEhvc3RDb250YWluZXIiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UiLCJwb3BIeWRyYXRpb25TdGF0ZSIsIm1hcmtVcGRhdGUiLCJhcHBlbmRBbGxSZXR1cm5zIiwicmV0dXJucyIsIm1vdmVDYWxsVG9IYW5kbGVyUGhhc2UiLCJhcHBlbmRBbGxDaGlsZHJlbiIsInVwZGF0ZUhvc3RDb250YWluZXIiLCJ1cGRhdGVQYXlsb2FkIiwicm9vdENvbnRhaW5lckluc3RhbmNlIiwib2xkVGV4dCIsIm5ld1RleHQiLCJjbG9uZUluc3RhbmNlIiwiY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQiLCJmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuIiwiYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciIsImNvbnRhaW5lckNoaWxkU2V0IiwicG9ydGFsT3JSb290IiwiY2hpbGRyZW5VbmNoYW5nZWQiLCJjb250YWluZXIiLCJuZXdDaGlsZFNldCIsImN1cnJlbnRJbnN0YW5jZSIsInJlY3ljbGFibGVJbnN0YW5jZSIsIm5ld0luc3RhbmNlIiwiY3VycmVudEhvc3RDb250ZXh0IiwiY29tcGxldGVXb3JrIiwiZmliZXJSb290IiwiX2N1cnJlbnRIb3N0Q29udGV4dCIsIndhc0h5ZHJhdGVkIiwiX2luc3RhbmNlIiwiX3Jvb3RDb250YWluZXJJbnN0YW5jZSIsIl9jdXJyZW50SG9zdENvbnRleHQyIiwiX3dhc0h5ZHJhdGVkIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrJDIiLCJoYXNDYXVnaHRFcnJvciQxIiwiY2xlYXJDYXVnaHRFcnJvciQxIiwiUmVhY3RGaWJlckNvbW1pdFdvcmsiLCJjYXB0dXJlRXJyb3IiLCJnZXRQdWJsaWNJbnN0YW5jZSIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciIsImNvbXBvbmVudFdpbGxVbm1vdW50Iiwic2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwidW5tb3VudEVycm9yIiwic2FmZWx5RGV0YWNoUmVmIiwicmVmRXJyb3IiLCJjb21taXRMaWZlQ3ljbGVzIiwiX3VwZGF0ZVF1ZXVlIiwiX2luc3RhbmNlMiIsImNvbW1pdE1vdW50IiwiY29tbWl0QXR0YWNoUmVmIiwiY29tbWl0RGV0YWNoUmVmIiwiY3VycmVudFJlZiIsImNvbW1pdFVubW91bnQiLCJjb21taXROZXN0ZWRVbm1vdW50cyIsInVubW91bnRIb3N0Q29tcG9uZW50cyIsImVtcHR5UG9ydGFsQ29udGFpbmVyIiwiZGV0YWNoRmliZXIiLCJjb21taXRDb250YWluZXIiLCJyZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4iLCJlbXB0eUNoaWxkU2V0IiwiX3BlbmRpbmdDaGlsZHJlbiIsImNvbW1pdFJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRQbGFjZW1lbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJjb21taXRVcGRhdGUiLCJyZXNldFRleHRDb250ZW50IiwiY29tbWl0VGV4dFVwZGF0ZSIsImFwcGVuZENoaWxkIiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImluc2VydEJlZm9yZSIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsInNpYmxpbmdzIiwicGFyZW50RmliZXIiLCJpc0NvbnRhaW5lciIsImJlZm9yZSIsImN1cnJlbnRQYXJlbnRJc1ZhbGlkIiwiY3VycmVudFBhcmVudElzQ29udGFpbmVyIiwiZmluZFBhcmVudCIsInRleHRJbnN0YW5jZSIsIk5PX0NPTlRFWFQiLCJSZWFjdEZpYmVySG9zdENvbnRleHQiLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsInJlcXVpcmVkQ29udGV4dCIsInJvb3RJbnN0YW5jZSIsIm5leHRSb290SW5zdGFuY2UiLCJuZXh0Um9vdENvbnRleHQiLCJuZXh0Q29udGV4dCIsInJlc2V0SG9zdENvbnRhaW5lciIsIlJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0IiwiaHlkcmF0aW9uIiwiY2FuSHlkcmF0ZUluc3RhbmNlIiwiY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiaHlkcmF0ZUluc3RhbmNlIiwiaHlkcmF0ZVRleHRJbnN0YW5jZSIsImRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UiLCJkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlIiwiZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlIiwiZGlkTm90SHlkcmF0ZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiaXNIeWRyYXRpbmciLCJwYXJlbnRJbnN0YW5jZSIsImRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZSIsImluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UiLCJwYXJlbnRDb250YWluZXIiLCJwYXJlbnRUeXBlIiwicGFyZW50UHJvcHMiLCJfdHlwZSIsIl9wcm9wcyIsIl90ZXh0IiwidHJ5SHlkcmF0ZSIsIm5leHRJbnN0YW5jZSIsInBvcFRvTmV4dEhvc3RQYXJlbnQiLCJSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uIiwiZGVidWdUb29sIiwiUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xIiwiZGVmYXVsdFNob3dEaWFsb2ciLCJjYXB0dXJlZEVycm9yIiwic2hvd0RpYWxvZyIsImxvZ0NhcHR1cmVkRXJyb3IiLCJsb2dFcnJvciIsInN1cHByZXNzTG9nZ2luZyIsInN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmciLCJjb21wb25lbnRTdGFjayIsImVycm9yQm91bmRhcnlOYW1lIiwiZXJyb3JCb3VuZGFyeUZvdW5kIiwid2lsbFJldHJ5IiwiY29tcG9uZW50TmFtZU1lc3NhZ2UiLCJlcnJvckJvdW5kYXJ5TWVzc2FnZSIsImNvbWJpbmVkTWVzc2FnZSIsImludm9rZUd1YXJkZWRDYWxsYmFjayQxIiwiZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uIiwiZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0IiwiZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50Iiwid2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQiLCJ3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyIsIlJlYWN0RmliZXJTY2hlZHVsZXIiLCJfUmVhY3RGaWJlckJlZ2luV29yayIsIl9SZWFjdEZpYmVyQ29tcGxldGVXbyIsIl9SZWFjdEZpYmVyQ29tbWl0V29yayIsInNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayIsImNhbmNlbERlZmVycmVkQ2FsbGJhY2siLCJwcmVwYXJlRm9yQ29tbWl0IiwicmVzZXRBZnRlckNvbW1pdCIsInN0YXJ0VGltZSIsIm1vc3RSZWNlbnRDdXJyZW50VGltZSIsImV4cGlyYXRpb25Db250ZXh0IiwiaXNXb3JraW5nIiwibmV4dFJvb3QiLCJuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUiLCJjYXB0dXJlZEVycm9ycyIsImZhaWxlZEJvdW5kYXJpZXMiLCJjb21taXRQaGFzZUJvdW5kYXJpZXMiLCJmaXJzdFVuY2F1Z2h0RXJyb3IiLCJkaWRGYXRhbCIsImlzVW5tb3VudGluZyIsInJlc2V0Q29udGV4dFN0YWNrIiwiY29tbWl0QWxsSG9zdEVmZmVjdHMiLCJwcmltYXJ5RWZmZWN0VGFnIiwiX2N1cnJlbnQiLCJfY3VycmVudDIiLCJjb21taXRBbGxMaWZlQ3ljbGVzIiwiY29tbWl0RXJyb3JIYW5kbGluZyIsImNvbW1pdFJvb3QiLCJfZXJyb3IiLCJfZGlkRXJyb3IiLCJfZXJyb3IyIiwib25Db21taXRXb3JrIiwic2NoZWR1bGVFcnJvclJlY292ZXJ5IiwiX2Vycm9yMyIsIm9uVW5jYXVnaHRFcnJvciIsInJlbWFpbmluZ1RpbWUiLCJyZXNldEV4cGlyYXRpb25UaW1lIiwicmVuZGVyVGltZSIsIm5ld0V4cGlyYXRpb25UaW1lIiwiY29tcGxldGVVbml0T2ZXb3JrIiwic2libGluZ0ZpYmVyIiwib25Db21wbGV0ZVdvcmsiLCJwZXJmb3JtVW5pdE9mV29yayIsIm9uQmVnaW5Xb3JrIiwicGVyZm9ybUZhaWxlZFVuaXRPZldvcmsiLCJ3b3JrTG9vcCIsInNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrIiwic2hvdWxkWWllbGQiLCJoYXNDYXB0dXJlZEVycm9yIiwicmVuZGVyUm9vdENhdGNoQmxvY2siLCJmYWlsZWRXb3JrIiwiYm91bmRhcnkiLCJ1bndpbmRDb250ZXh0cyIsInJlbmRlclJvb3QiLCJ1bmNhdWdodEVycm9yIiwiaXNGYWlsZWRCb3VuZGFyeSIsImNvbXBvbmVudERpZENhdGNoIiwiX2NvbXBvbmVudFN0YWNrIiwiX2NvbXBvbmVudE5hbWUiLCJlcnJvckJvdW5kYXJ5IiwiZWZmZWN0ZnVsRmliZXIiLCJjb21wdXRlQXN5bmNFeHBpcmF0aW9uIiwicmVjYWxjdWxhdGVDdXJyZW50VGltZSIsImV4cGlyYXRpb25NcyIsInNjaGVkdWxlV29ya0ltcGwiLCJjaGVja1Jvb3ROZWVkc0NsZWFyaW5nIiwiaXNFcnJvclJlY292ZXJ5IiwicmVxdWVzdFdvcmsiLCJkZWZlcnJlZFVwZGF0ZXMiLCJwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0Iiwic3luY1VwZGF0ZXMiLCJmaXJzdFNjaGVkdWxlZFJvb3QiLCJsYXN0U2NoZWR1bGVkUm9vdCIsImNhbGxiYWNrRXhwaXJhdGlvblRpbWUiLCJjYWxsYmFja0lEIiwiaXNSZW5kZXJpbmciLCJuZXh0Rmx1c2hlZFJvb3QiLCJuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIiwiZGVhZGxpbmVEaWRFeHBpcmUiLCJoYXNVbmhhbmRsZWRFcnJvciIsInVuaGFuZGxlZEVycm9yIiwiZGVhZGxpbmUiLCJpc0JhdGNoaW5nVXBkYXRlcyIsImlzVW5iYXRjaGluZ1VwZGF0ZXMiLCJORVNURURfVVBEQVRFX0xJTUlUIiwibmVzdGVkVXBkYXRlQ291bnQiLCJ0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yayIsInNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbiIsImN1cnJlbnRNcyIsInRpbWVvdXQiLCJwZXJmb3JtQXN5bmNXb3JrIiwicGVyZm9ybVdvcmtPblJvb3QiLCJwZXJmb3JtV29yayIsImZpbmRIaWdoZXN0UHJpb3JpdHlSb290IiwiaGlnaGVzdFByaW9yaXR5V29yayIsImhpZ2hlc3RQcmlvcml0eVJvb3QiLCJwcmV2aW91c1NjaGVkdWxlZFJvb3QiLCJwcmV2aW91c0ZsdXNoZWRSb290IiwiZGwiLCJtaW5FeHBpcmF0aW9uVGltZSIsIl9lcnJvcjQiLCJfZmluaXNoZWRXb3JrIiwidGltZVJlbWFpbmluZyIsInByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMiLCJ1bmJhdGNoZWRVcGRhdGVzIiwiZmx1c2hTeW5jIiwiZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyIsImdldENvbnRleHRGb3JTdWJ0cmVlIiwicGFyZW50Q29tcG9uZW50IiwiUmVhY3RGaWJlclJlY29uY2lsZXIkMSIsIl9SZWFjdEZpYmVyU2NoZWR1bGVyIiwic2NoZWR1bGVUb3BMZXZlbFVwZGF0ZSIsImZpbmRIb3N0SW5zdGFuY2UiLCJob3N0RmliZXIiLCJjcmVhdGVDb250YWluZXIiLCJ1cGRhdGVDb250YWluZXIiLCJvbk1vdW50Q29udGFpbmVyIiwib25Vbm1vdW50Q29udGFpbmVyIiwib25VcGRhdGVDb250YWluZXIiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJjb250YWluZXJGaWJlciIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiZGV2VG9vbHNDb25maWciLCJmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyIiwiUmVhY3RGaWJlclJlY29uY2lsZXIkMiIsImRlZmF1bHQiLCJSZWFjdEZpYmVyUmVjb25jaWxlciQzIiwicmVhY3RSZWNvbmNpbGVyIiwiY3JlYXRlUG9ydGFsJDEiLCJSZWFjdFZlcnNpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyIsInJJQyIsImNJQyIsImZyYW1lQ2FsbGJhY2siLCJzZXRUaW1lb3V0IiwiSW5maW5pdHkiLCJ0aW1lb3V0SUQiLCJjbGVhclRpbWVvdXQiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwic2NoZWR1bGVkUklDQ2FsbGJhY2siLCJpc0lkbGVTY2hlZHVsZWQiLCJ0aW1lb3V0VGltZSIsImlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQiLCJmcmFtZURlYWRsaW5lIiwicHJldmlvdXNGcmFtZVRpbWUiLCJhY3RpdmVGcmFtZVRpbWUiLCJmcmFtZURlYWRsaW5lT2JqZWN0IiwiZGlkVGltZW91dCIsInJlbWFpbmluZyIsIm1lc3NhZ2VLZXkiLCJpZGxlVGljayIsImFuaW1hdGlvblRpY2siLCJyYWZUaW1lIiwibmV4dEZyYW1lVGltZSIsInBvc3RNZXNzYWdlIiwib3B0aW9ucyIsImxvd1ByaW9yaXR5V2FybmluZyIsImxvd1ByaW9yaXR5V2FybmluZyQxIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsInRlc3QiLCJzaG91bGRJZ25vcmVWYWx1ZSIsImlzTmFOIiwiZ2V0VmFsdWVGb3JQcm9wZXJ0eSIsImV4cGVjdGVkIiwic3RyaW5nVmFsdWUiLCJnZXRWYWx1ZUZvckF0dHJpYnV0ZSIsInNldFZhbHVlRm9yUHJvcGVydHkiLCJkZWxldGVWYWx1ZUZvclByb3BlcnR5IiwibmFtZXNwYWNlIiwic2V0QXR0cmlidXRlTlMiLCJzZXRWYWx1ZUZvckF0dHJpYnV0ZSIsImRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlIiwiUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMiLCJoYXNSZWFkT25seVZhbHVlIiwiY2hlY2tib3giLCJpbWFnZSIsInJhZGlvIiwic3VibWl0Iiwib25DaGFuZ2UiLCJ0YWdOYW1lIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUiLCJkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkIiwiZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCIsImRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQiLCJpc0NvbnRyb2xsZWQiLCJ1c2VzQ2hlY2tlZCIsImdldEhvc3RQcm9wcyIsImhvc3RQcm9wcyIsIm1heCIsImluaXRpYWxWYWx1ZSIsImluaXRpYWxDaGVja2VkIiwiaW5pdFdyYXBwZXJTdGF0ZSIsInVwZGF0ZUNoZWNrZWQiLCJ1cGRhdGVXcmFwcGVyIiwidmFsdWVBc051bWJlciIsInBhcnNlRmxvYXQiLCJwb3N0TW91bnRXcmFwcGVyIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxIiwidXBkYXRlTmFtZWRDb3VzaW5zIiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJncm91cCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvdGhlck5vZGUiLCJmb3JtIiwib3RoZXJQcm9wcyIsImZsYXR0ZW5DaGlsZHJlbiIsIkNoaWxkcmVuIiwidmFsaWRhdGVQcm9wcyIsInBvc3RNb3VudFdyYXBwZXIkMSIsImdldEhvc3RQcm9wcyQxIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDMiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsInZhbHVlUHJvcE5hbWVzIiwiY2hlY2tTZWxlY3RQcm9wVHlwZXMiLCJ1cGRhdGVPcHRpb25zIiwic2V0RGVmYXVsdFNlbGVjdGVkIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZWxlY3RlZFZhbHVlIiwiZGVmYXVsdFNlbGVjdGVkIiwiX3NlbGVjdGVkVmFsdWUiLCJfaTIiLCJnZXRIb3N0UHJvcHMkMiIsImluaXRXcmFwcGVyU3RhdGUkMSIsIndhc011bHRpcGxlIiwicG9zdE1vdW50V3JhcHBlciQyIiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUiLCJkaWRXYXJuVmFsRGVmYXVsdFZhbCIsImdldEhvc3RQcm9wcyQzIiwiaW5pdFdyYXBwZXJTdGF0ZSQyIiwidXBkYXRlV3JhcHBlciQxIiwibmV3VmFsdWUiLCJwb3N0TW91bnRXcmFwcGVyJDMiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMiLCJIVE1MX05BTUVTUEFDRSQxIiwiTUFUSF9OQU1FU1BBQ0UiLCJTVkdfTkFNRVNQQUNFIiwiTmFtZXNwYWNlcyIsImh0bWwiLCJtYXRobWwiLCJzdmciLCJnZXRJbnRyaW5zaWNOYW1lc3BhY2UiLCJnZXRDaGlsZE5hbWVzcGFjZSIsInBhcmVudE5hbWVzcGFjZSIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJNU0FwcCIsImV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uIiwiYXJnMCIsImFyZzEiLCJhcmcyIiwiYXJnMyIsInJldXNhYmxlU1ZHQ29udGFpbmVyIiwic2V0SW5uZXJIVE1MIiwibmFtZXNwYWNlVVJJIiwic3ZnTm9kZSIsInNldFRleHRDb250ZW50IiwibGFzdENoaWxkIiwiaXNVbml0bGVzc051bWJlciIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiYm9yZGVySW1hZ2VPdXRzZXQiLCJib3JkZXJJbWFnZVNsaWNlIiwiYm9yZGVySW1hZ2VXaWR0aCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImNvbHVtbnMiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsImNoYXJBdCIsInN1YnN0cmluZyIsImRhbmdlcm91c1N0eWxlVmFsdWUiLCJpc0N1c3RvbVByb3BlcnR5IiwiaXNFbXB0eSIsInRyaW0iLCJ3YXJuVmFsaWRTdHlsZSIsImJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiIsImJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiIsIndhcm5lZFN0eWxlTmFtZXMiLCJ3YXJuZWRTdHlsZVZhbHVlcyIsIndhcm5lZEZvck5hTlZhbHVlIiwid2FybmVkRm9ySW5maW5pdHlWYWx1ZSIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwid2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uIiwid2FyblN0eWxlVmFsdWVJc05hTiIsIndhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSIsImlzRmluaXRlIiwid2FyblZhbGlkU3R5bGUkMSIsImNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyIsInN0eWxlcyIsInNlcmlhbGl6ZWQiLCJkZWxpbWl0ZXIiLCJzdHlsZU5hbWUiLCJzdHlsZVZhbHVlIiwic2V0VmFsdWVGb3JTdHlsZXMiLCJzZXRQcm9wZXJ0eSIsIm9taXR0ZWRDbG9zZVRhZ3MiLCJhcmVhIiwiYmFzZSIsImJyIiwiY29sIiwiZW1iZWQiLCJociIsImltZyIsImtleWdlbiIsImxpbmsiLCJtZXRhIiwicGFyYW0iLCJ3YnIiLCJ2b2lkRWxlbWVudFRhZ3MiLCJtZW51aXRlbSIsIkhUTUwkMSIsImFzc2VydFZhbGlkUHJvcHMiLCJpc0N1c3RvbUNvbXBvbmVudCIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyIsInJBUklBIiwickFSSUFDYW1lbCIsImdldFN0YWNrQWRkZW5kdW0iLCJ2YWxpZGF0ZVByb3BlcnR5IiwiYXJpYU5hbWUiLCJjb3JyZWN0TmFtZSIsInN0YW5kYXJkTmFtZSIsIndhcm5JbnZhbGlkQVJJQVByb3BzIiwiaW52YWxpZFByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwiZGlkV2FyblZhbHVlTnVsbCIsImdldFN0YWNrQWRkZW5kdW0kMSIsInZhbGlkYXRlUHJvcGVydGllcyQxIiwicG9zc2libGVTdGFuZGFyZE5hbWVzIiwiYWNjZXB0IiwiYWNjZXB0Y2hhcnNldCIsImFjY2Vzc2tleSIsImFsbG93ZnVsbHNjcmVlbiIsImFsdCIsImFzIiwiYXV0b2NhcGl0YWxpemUiLCJhdXRvY29tcGxldGUiLCJhdXRvY29ycmVjdCIsImF1dG9mb2N1cyIsImF1dG9wbGF5IiwiYXV0b3NhdmUiLCJjZWxscGFkZGluZyIsImNlbGxzcGFjaW5nIiwiY2hhbGxlbmdlIiwiY2hhcnNldCIsImNpdGUiLCJjbGFzc2lkIiwiY2xhc3NuYW1lIiwiY29sc3BhbiIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiY29udHJvbHNsaXN0IiwiY29vcmRzIiwiY3Jvc3NvcmlnaW4iLCJkYW5nZXJvdXNseXNldGlubmVyaHRtbCIsImRlZmF1bHRjaGVja2VkIiwiZGVmYXVsdHZhbHVlIiwiZGlyIiwiZW5jdHlwZSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWdoIiwiaHJlZiIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpZCIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsIml0ZW1pZCIsIml0ZW1wcm9wIiwiaXRlbXJlZiIsIml0ZW1zY29wZSIsIml0ZW10eXBlIiwia2V5cGFyYW1zIiwia2V5dHlwZSIsImtpbmQiLCJsYW5nIiwibGlzdCIsImxvdyIsIm1hbmlmZXN0IiwibWFyZ2lud2lkdGgiLCJtYXJnaW5oZWlnaHQiLCJtYXhsZW5ndGgiLCJtZWRpYSIsIm1lZGlhZ3JvdXAiLCJtZXRob2QiLCJtaW5sZW5ndGgiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvZ3JvdXAiLCJyZWFkb25seSIsInJlZmVycmVycG9saWN5IiwicmVsIiwicm9sZSIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2Nyb2xsaW5nIiwic2l6ZXMiLCJzcGVsbGNoZWNrIiwic3JjIiwic3JjZG9jIiwic3JjbGFuZyIsInNyY3NldCIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInRpdGxlIiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yaW50ZXJwb2xhdGlvbiIsImNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnMiLCJjb2xvcnByb2ZpbGUiLCJjb2xvcnJlbmRlcmluZyIsImNvbnRlbnRzY3JpcHR0eXBlIiwiY29udGVudHN0eWxldHlwZSIsImN4IiwiY3kiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVyIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZ4IiwiZnkiLCJnMSIsImcyIiwiZ2x5cGhuYW1lIiwiZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWwiLCJnbHlwaG9yaWVudGF0aW9udmVydGljYWwiLCJnbHlwaHJlZiIsImdyYWRpZW50dHJhbnNmb3JtIiwiZ3JhZGllbnR1bml0cyIsImhhbmdpbmciLCJob3JpemFkdngiLCJob3Jpem9yaWdpbngiLCJpZGVvZ3JhcGhpYyIsImltYWdlcmVuZGVyaW5nIiwiaW4yIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazEiLCJrMiIsImszIiwiazQiLCJrIiwia2VybmVsbWF0cml4Iiwia2VybmVsdW5pdGxlbmd0aCIsImtlcm5pbmciLCJrZXlwb2ludHMiLCJrZXlzcGxpbmVzIiwia2V5dGltZXMiLCJsZW5ndGhhZGp1c3QiLCJsZXR0ZXJzcGFjaW5nIiwibGlnaHRpbmdjb2xvciIsImxpbWl0aW5nY29uZWFuZ2xlIiwibG9jYWwiLCJtYXJrZXJlbmQiLCJtYXJrZXJoZWlnaHQiLCJtYXJrZXJtaWQiLCJtYXJrZXJzdGFydCIsIm1hcmtlcnVuaXRzIiwibWFya2Vyd2lkdGgiLCJtYXNrIiwibWFza2NvbnRlbnR1bml0cyIsIm1hc2t1bml0cyIsIm1hdGhlbWF0aWNhbCIsIm1vZGUiLCJudW1vY3RhdmVzIiwib3BlcmF0b3IiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJmbG93Iiwib3ZlcmxpbmVwb3NpdGlvbiIsIm92ZXJsaW5ldGhpY2tuZXNzIiwicGFpbnRvcmRlciIsInBhbm9zZTEiLCJwYXRobGVuZ3RoIiwicGF0dGVybmNvbnRlbnR1bml0cyIsInBhdHRlcm50cmFuc2Zvcm0iLCJwYXR0ZXJudW5pdHMiLCJwb2ludGVyZXZlbnRzIiwicG9pbnRzIiwicG9pbnRzYXR4IiwicG9pbnRzYXR5IiwicG9pbnRzYXR6IiwicHJlc2VydmVhbHBoYSIsInByZXNlcnZlYXNwZWN0cmF0aW8iLCJwcmltaXRpdmV1bml0cyIsInByb3BlcnR5IiwiciIsInJhZGl1cyIsInJlZngiLCJyZWZ5IiwicmVuZGVyaW5naW50ZW50IiwicmVwZWF0Y291bnQiLCJyZXBlYXRkdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIiwicmVzb3VyY2UiLCJyZXN0YXJ0IiwicmVzdWx0cyIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlY3VyaXR5Iiwic2VlZCIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRyYW5zZm9ybSIsInUxIiwidTIiLCJ1bmRlcmxpbmVwb3NpdGlvbiIsInVuZGVybGluZXRoaWNrbmVzcyIsInVuaWNvZGUiLCJ1bmljb2RlYmlkaSIsInVuaWNvZGVyYW5nZSIsInVuaXRzcGVyZW0iLCJ1bnNlbGVjdGFibGUiLCJ2YWxwaGFiZXRpYyIsInZlY3RvcmVmZmVjdCIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4Y2hhbm5lbHNlbGVjdG9yIiwieGhlaWdodCIsInhsaW5rYWN0dWF0ZSIsInhsaW5rYXJjcm9sZSIsInhsaW5raHJlZiIsInhsaW5rcm9sZSIsInhsaW5rc2hvdyIsInhsaW5rdGl0bGUiLCJ4bGlua3R5cGUiLCJ4bWxiYXNlIiwieG1sbGFuZyIsInhtbG5zIiwieG1sbnN4bGluayIsInhtbHNwYWNlIiwieTEiLCJ5MiIsInljaGFubmVsc2VsZWN0b3IiLCJ6Iiwiem9vbWFuZHBhbiIsImdldFN0YWNrQWRkZW5kdW0kMiIsIndhcm5lZFByb3BlcnRpZXMkMSIsImhhc093blByb3BlcnR5JDEiLCJFVkVOVF9OQU1FX1JFR0VYIiwiSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYIiwickFSSUEkMSIsInJBUklBQ2FtZWwkMSIsInZhbGlkYXRlUHJvcGVydHkkMSIsImNhblVzZUV2ZW50U3lzdGVtIiwiaXNSZXNlcnZlZCIsIndhcm5Vbmtub3duUHJvcGVydGllcyIsInVua25vd25Qcm9wcyIsInZhbGlkYXRlUHJvcGVydGllcyQyIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIiLCJkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiIsImRpZFdhcm5TaGFkeURPTSIsIkRBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIiwiU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIiwiU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSIsIkFVVE9GT0NVUyIsIkNISUxEUkVOIiwiU1RZTEUiLCJIVE1MIiwiSFRNTF9OQU1FU1BBQ0UiLCJ3YXJuZWRVbmtub3duVGFncyIsImRpYWxvZyIsInZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQiLCJOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgiLCJOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgiLCJub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUiLCJtYXJrdXAiLCJtYXJrdXBTdHJpbmciLCJ3YXJuRm9yVGV4dERpZmZlcmVuY2UiLCJzZXJ2ZXJUZXh0IiwiY2xpZW50VGV4dCIsIm5vcm1hbGl6ZWRDbGllbnRUZXh0Iiwibm9ybWFsaXplZFNlcnZlclRleHQiLCJ3YXJuRm9yUHJvcERpZmZlcmVuY2UiLCJzZXJ2ZXJWYWx1ZSIsImNsaWVudFZhbHVlIiwibm9ybWFsaXplZENsaWVudFZhbHVlIiwibm9ybWFsaXplZFNlcnZlclZhbHVlIiwid2FybkZvckV4dHJhQXR0cmlidXRlcyIsImF0dHJpYnV0ZU5hbWVzIiwibmFtZXMiLCJ3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIiLCJub3JtYWxpemVIVE1MIiwidGVzdEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJlbnN1cmVMaXN0ZW5pbmdUbyIsInJvb3RDb250YWluZXJFbGVtZW50IiwiaXNEb2N1bWVudE9yRnJhZ21lbnQiLCJnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIiLCJtZWRpYUV2ZW50cyIsInRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50Iiwib25jbGljayIsInNldEluaXRpYWxET01Qcm9wZXJ0aWVzIiwiZG9tRWxlbWVudCIsImlzQ3VzdG9tQ29tcG9uZW50VGFnIiwicHJvcEtleSIsIm5leHRQcm9wIiwibmV4dEh0bWwiLCJjYW5TZXRUZXh0Q29udGVudCIsInVwZGF0ZURPTVByb3BlcnRpZXMiLCJ3YXNDdXN0b21Db21wb25lbnRUYWciLCJjcmVhdGVFbGVtZW50JDEiLCJkaXYiLCJjcmVhdGVUZXh0Tm9kZSQxIiwiY3JlYXRlVGV4dE5vZGUiLCJzZXRJbml0aWFsUHJvcGVydGllcyQxIiwicmF3UHJvcHMiLCJzaGFkeVJvb3QiLCJvbkNsaWNrIiwiZGlmZlByb3BlcnRpZXMkMSIsImxhc3RSYXdQcm9wcyIsIm5leHRSYXdQcm9wcyIsImxhc3RQcm9wcyIsInN0eWxlVXBkYXRlcyIsImxhc3RTdHlsZSIsImxhc3RQcm9wIiwibGFzdEh0bWwiLCJ1cGRhdGVQcm9wZXJ0aWVzJDEiLCJkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEiLCJleHRyYUF0dHJpYnV0ZU5hbWVzIiwiYXR0cmlidXRlcyIsInJhd0h0bWwiLCJzZXJ2ZXJIVE1MIiwiZXhwZWN0ZWRIVE1MIiwiZXhwZWN0ZWRTdHlsZSIsIm93bk5hbWVzcGFjZSIsImRpZmZIeWRyYXRlZFRleHQkMSIsInRleHROb2RlIiwiaXNEaWZmZXJlbnQiLCJ3YXJuRm9yVW5tYXRjaGVkVGV4dCQxIiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxIiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxIiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMSIsIlJlYWN0RE9NRmliZXJDb21wb25lbnQiLCJzZXRJbml0aWFsUHJvcGVydGllcyIsImRpZmZQcm9wZXJ0aWVzIiwidXBkYXRlUHJvcGVydGllcyIsImRpZmZIeWRyYXRlZFByb3BlcnRpZXMiLCJkaWZmSHlkcmF0ZWRUZXh0Iiwid2FybkZvclVubWF0Y2hlZFRleHQiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50Iiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiIsInZhbGlkYXRlRE9NTmVzdGluZyIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJ1cGRhdGVkQW5jZXN0b3JJbmZvJDEiLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJwYXJlbnRUYWciLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRUZXh0IiwicGFyZW50SW5mbyIsImludmFsaWRQYXJlbnQiLCJpbnZhbGlkQW5jZXN0b3IiLCJpbnZhbGlkUGFyZW50T3JBbmNlc3RvciIsImFuY2VzdG9yVGFnIiwid2FybktleSIsInRhZ0Rpc3BsYXlOYW1lIiwid2hpdGVzcGFjZUluZm8iLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZEluQ29udGV4dCIsInZhbGlkYXRlRE9NTmVzdGluZyQxIiwiU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkciLCJldmVudHNFbmFibGVkIiwic2VsZWN0aW9uSW5mb3JtYXRpb24iLCJpc1ZhbGlkQ29udGFpbmVyIiwiZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyIiwic2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljIiwicm9vdEVsZW1lbnQiLCJzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50IiwiRE9NUmVuZGVyZXIiLCJ2YWxpZGF0ZWRUYWciLCJfYW5jZXN0b3JJbmZvIiwicGFyZW50SG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dERldiIsIl9uYW1lc3BhY2UiLCJfYW5jZXN0b3JJbmZvMiIsImludGVybmFsSW5zdGFuY2VIYW5kbGUiLCJob3N0Q29udGV4dERldiIsIm93bkFuY2VzdG9ySW5mbyIsIl9faHRtbCIsImJlZm9yZUNoaWxkIiwid2FybmVkQWJvdXRIeWRyYXRlQVBJIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJmb3JjZUh5ZHJhdGUiLCJfcmVhY3RSb290Q29udGFpbmVyIiwiaG9zdEluc3RhbmNlIiwiaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCIsInJvb3RFbCIsImhhc05vblJvb3RSZWFjdENoaWxkIiwic2hvdWxkSHlkcmF0ZSIsIndhcm5lZCIsInJvb3RTaWJsaW5nIiwibmV3Um9vdCIsImNyZWF0ZVBvcnRhbCIsIlJlYWN0Um9vdCIsInVubW91bnQiLCJSZWFjdERPTSIsImZpbmRET01Ob2RlIiwiY29tcG9uZW50T3JFbGVtZW50Iiwid2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsImNvbnRhaW5lck5vZGUiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwicmVuZGVyZWRCeURpZmZlcmVudFJlYWN0IiwiX3Jvb3RFbCIsImlzQ29udGFpbmVyUmVhY3RSb290IiwidW5zdGFibGVfY3JlYXRlUG9ydGFsIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJ1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXMiLCJjcmVhdGVSb290IiwiZm91bmREZXZUb29scyIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwicHJvdG9jb2wiLCJSZWFjdERPTSQyIiwiUmVhY3RET00kMyIsInJlYWN0RG9tIiwiY2hlY2tEQ0UiLCJfaW50ZXJvcERlZmF1bHQiLCJjbGFzc0NhbGxDaGVjayIsInQiLCJpbmhlcml0cyIsIndyaXRhYmxlIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiUmVmZXJlbmNlRXJyb3IiLCJBcHBDb250YWluZXIiLCJvbmx5IiwiaG90X3Byb2QiLCJhcmVDb21wb25lbnRzRXF1YWwiLCJzZXRDb25maWciLCJob3QiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJjb21wbGV0ZVN0YXRlIiwic2V0U3RhdGUiLCJmb3JjZVVwZGF0ZSIsImRlcHJlY2F0ZWRBUElzIiwicmVwbGFjZVN0YXRlIiwiZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nIiwibWV0aG9kTmFtZSIsImZuTmFtZSIsIlB1cmVDb21wb25lbnQiLCJDb21wb25lbnREdW1teSIsInB1cmVDb21wb25lbnRQcm90b3R5cGUiLCJBc3luY0NvbXBvbmVudCIsImFzeW5jQ29tcG9uZW50UHJvdG90eXBlIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiaGFzVmFsaWRSZWYiLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5IiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIlJlYWN0RWxlbWVudCIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImNsb25lQW5kUmVwbGFjZUtleSIsIm9sZEVsZW1lbnQiLCJuZXdLZXkiLCJuZXdFbGVtZW50IiwiX3NlbGYiLCJjbG9uZUVsZW1lbnQiLCJpbXBsIiwiU0VQQVJBVE9SIiwiU1VCU0VQQVJBVE9SIiwiZXNjYXBlIiwiZXNjYXBlUmVnZXgiLCJlc2NhcGVyTG9va3VwIiwiZXNjYXBlZFN0cmluZyIsIm1hdGNoIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJQT09MX1NJWkUiLCJ0cmF2ZXJzZUNvbnRleHRQb29sIiwiZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0IiwibWFwUmVzdWx0Iiwia2V5UHJlZml4IiwibWFwRnVuY3Rpb24iLCJtYXBDb250ZXh0IiwidHJhdmVyc2VDb250ZXh0IiwicmVsZWFzZVRyYXZlcnNlQ29udGV4dCIsInRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsIiwibmFtZVNvRmFyIiwiaW52b2tlQ2FsbGJhY2siLCJnZXRDb21wb25lbnRLZXkiLCJuZXh0TmFtZSIsInN1YnRyZWVDb3VudCIsIm5leHROYW1lUHJlZml4IiwiaWkiLCJjaGlsZHJlblN0cmluZyIsInRyYXZlcnNlQWxsQ2hpbGRyZW4iLCJmb3JFYWNoU2luZ2xlQ2hpbGQiLCJmb3JFYWNoQ2hpbGRyZW4iLCJmb3JFYWNoRnVuYyIsImZvckVhY2hDb250ZXh0IiwibWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsImNoaWxkS2V5IiwibWFwcGVkQ2hpbGQiLCJtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsIiwiZXNjYXBlZFByZWZpeCIsIm1hcENoaWxkcmVuIiwiY291bnRDaGlsZHJlbiIsInRvQXJyYXkiLCJvbmx5Q2hpbGQiLCJjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiZ2V0RGlzcGxheU5hbWUiLCJWQUxJRF9GUkFHTUVOVF9QUk9QUyIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZWxlbWVudFByb3BzIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJjb21wb25lbnRDbGFzcyIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24iLCJfZGlkSXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yIiwiY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsImNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbiIsInZhbGlkYXRlZEZhY3RvcnkiLCJjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsInVuc3RhYmxlX0FzeW5jQ29tcG9uZW50IiwiY3JlYXRlRmFjdG9yeSIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJSZWFjdCQyIiwiUmVhY3QkMyIsInJlYWN0IiwiaHlwaGVuYXRlJDIiLCJoeXBoZW5hdGVfMSIsImh5cGhlbmF0ZVN0eWxlTmFtZV8xIiwib2JqVG9Dc3MiLCJvYmoiLCJwcmV2S2V5IiwiY3NzIiwiY2h1bmsiLCJmbGF0dGVuIiwiY2h1bmtzIiwiZXhlY3V0aW9uQ29udGV4dCIsInJlZHVjZSIsInJ1bGVTZXQiLCJzdHlsZWRDb21wb25lbnRJZCIsInN0eWxpc1NwbGl0dGVyIiwiU3R5bGlzIiwiZ2xvYmFsIiwiY2FzY2FkZSIsImtleWZyYW1lIiwiY29tcHJlc3MiLCJzZW1pY29sb24iLCJzdHlsaXMiLCJwYXJzaW5nUnVsZXMiLCJyZXR1cm5SdWxlc1BsdWdpbiIsInBhcnNlZFJ1bGVzIiwicGFyc2VSdWxlc1BsdWdpbiIsInJ1bGUiLCJ1c2UiLCJzdHJpbmdpZnlSdWxlcyIsInJ1bGVzIiwic2VsZWN0b3IiLCJmbGF0Q1NTIiwiY3NzU3RyIiwic3BsaXRCeVJ1bGVzIiwiaXNTdHlsZWRDb21wb25lbnQiLCJjb25zb2xpZGF0ZVN0cmVhbWVkU3R5bGVzIiwiY2hhcnNMZW5ndGgiLCJnZXRBbHBoYWJldGljQ2hhciIsImNvZGUiLCJnZW5lcmF0ZUFscGhhYmV0aWNOYW1lIiwiZmxvb3IiLCJpbnRlcmxlYXZlIiwic3RyaW5ncyIsImludGVycG9sYXRpb25zIiwiaW50ZXJwIiwic3RyZWFtIiwiU0NfQVRUUiIsIlNDX1NUUkVBTV9BVFRSIiwiQ09OVEVYVF9LRVkiLCJJU19CUk9XU0VSIiwiRElTQUJMRV9TUEVFRFkiLCJTQ19DT01QT05FTlRfSUQiLCJleHRyYWN0Q29tcHMiLCJtYXliZUNTUyIsImV4aXN0aW5nQ29tcG9uZW50cyIsImNvbXBvbmVudElkIiwibWF0Y2hJbmRleCIsIl9yZWYiLCJuZXh0Q29tcCIsImNzc0Zyb21ET00iLCJnZXROb25jZSIsIm9uY2UiLCJjYWxsZWQiLCJDb25zdHJ1Y3RvciIsImNyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9leHRlbmRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwib2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJhZGROYW1lRm9ySWQiLCJuYW1lc0ZvcklkIiwicmVzZXRJZE5hbWVzIiwiaGFzTmFtZUZvcklkIiwic3RyaW5naWZ5TmFtZXMiLCJzdHIiLCJjbG9uZU5hbWVzIiwic2hlZXRGb3JUYWciLCJzaGVldCIsInN0eWxlU2hlZXRzIiwib3duZXJOb2RlIiwic2FmZUluc2VydFJ1bGUiLCJjc3NSdWxlIiwibWF4SW5kZXgiLCJjc3NSdWxlcyIsImluc2VydFJ1bGUiLCJkZWxldGVSdWxlcyIsInJlbW92YWxJbmRleCIsImxvd2VyQm91bmQiLCJkZWxldGVSdWxlIiwicGFyZW50Tm9kZVVubW91bnRlZEVyciIsInRocm93Q2xvbmVUYWdFcnIiLCJtYWtlVGV4dE1hcmtlciIsImFkZFVwVW50aWxJbmRleCIsInRvdGFsVXBUb0luZGV4IiwibWFrZVN0eWxlVGFnIiwidGFnRWwiLCJlbCIsIndyYXBBc0h0bWxUYWciLCJhZGRpdGlvbmFsQXR0cnMiLCJhdHRycyIsImh0bWxBdHRyIiwiQm9vbGVhbiIsIndyYXBBc0VsZW1lbnQiLCJnZXRJZHNGcm9tTWFya2Vyc0ZhY3RvcnkiLCJtYXJrZXJzIiwibWFrZVNwZWVkeVRhZyIsImdldEltcG9ydFJ1bGVUYWciLCJleHRyYWN0SW1wb3J0IiwidXNlZEltcG9ydFJ1bGVUYWciLCJpbnNlcnRNYXJrZXIiLCJwcmV2IiwibWFya2VyIiwiaW5zZXJ0UnVsZXMiLCJpbnNlcnRJbmRleCIsImluamVjdGVkUnVsZXMiLCJpbXBvcnRSdWxlcyIsImNzc1J1bGVzU2l6ZSIsIm1heUhhdmVJbXBvcnQiLCJyZW1vdmVSdWxlcyIsIl9zaGVldEZvclRhZyIsImNzc1RleHQiLCJzdHlsZVRhZyIsImdldElkcyIsInRvSFRNTCIsIm1ha2VCcm93c2VyVGFnIiwibWFrZVRleHROb2RlIiwic2VwYXJhdG9yIiwiYXBwZW5kRGF0YSIsIm5ld01hcmtlciIsInJlcGxhY2VDaGlsZCIsIm1ha2VTZXJ2ZXJUYWdJbnRlcm5hbCIsIm5hbWVzQXJnIiwibWFya2Vyc0FyZyIsImNzc0ZvcklkIiwibmFtZXNDbG9uZSIsIm1hcmtlcnNDbG9uZSIsIm1ha2VTZXJ2ZXJUYWciLCJtYWtlVGFnIiwiZm9yY2VTZXJ2ZXIiLCJtYWtlUmVoeWRyYXRpb25UYWciLCJlbHMiLCJleHRyYWN0ZWQiLCJpbW1lZGlhdGVSZWh5ZHJhdGlvbiIsInJlaHlkcmF0ZSIsIl9leHRyYWN0ZWQkaSIsIk1BWF9TSVpFIiwic2hlZXRSdW5uaW5nSWQiLCJtYXN0ZXIiLCJTdHlsZVNoZWV0IiwiX3RoaXMiLCJoZWFkIiwiaW1wb3J0UnVsZVRhZyIsImZpcnN0VGFnIiwidGFncyIsInNlYWxlZCIsInRhZ01hcCIsImRlZmVycmVkIiwicmVoeWRyYXRlZE5hbWVzIiwiaWdub3JlUmVoeWRyYXRlZE5hbWVzIiwiY2FwYWNpdHkiLCJjbG9uZXMiLCJpc1N0cmVhbWVkIiwibm9kZXMiLCJub2Rlc1NpemUiLCJlbE5hbWVzIiwiZWxOYW1lc1NpemUiLCJqIiwiZXh0cmFjdGVkU2l6ZSIsInJlaHlkcmF0aW9uVGFnIiwiX2oiLCJpZHMiLCJuZXdUYWciLCJzZWFsQWxsVGFncyIsIm1ha2VUYWckJDEiLCJsYXN0RWwiLCJnZXRUYWdGb3JJZCIsImhhc0lkIiwiZGVmZXJyZWRJbmplY3QiLCJpbmplY3RSdWxlcyIsImRlZmVycmVkUnVsZXMiLCJ0b1JlYWN0RWxlbWVudHMiLCJnZXQkJDEiLCJfU3R5bGVTaGVldE1hbmFnZXIkY2giLCJ0YXJnZXRQcm9wRXJyIiwiU3R5bGVTaGVldE1hbmFnZXIiLCJfQ29tcG9uZW50Iiwic2hlZXRJbnN0YW5jZSIsIlNlcnZlclN0eWxlU2hlZXQiLCJzaGVldENsb3NlZEVyciIsInN0cmVhbUJyb3dzZXJFcnIiLCJtYXN0ZXJTaGVldCIsImNsb3NlZCIsImNvbXBsZXRlIiwic3BsaWNlIiwiY29sbGVjdFN0eWxlcyIsImdldFN0eWxlVGFncyIsImdldFN0eWxlRWxlbWVudCIsImludGVybGVhdmVXaXRoTm9kZVN0cmVhbSIsInJlYWRhYmxlU3RyZWFtIiwiaW5zdGFuY2VUYWdJbmRleCIsInN0cmVhbUF0dHIiLCJvdXJTdHJlYW0iLCJSZWFkYWJsZSIsIl9yZWFkIiwib24iLCJlbWl0IiwiTElNSVQiLCJjcmVhdGVXYXJuVG9vTWFueUNsYXNzZXMiLCJnZW5lcmF0ZWRDbGFzc2VzIiwid2FybmluZ1NlZW4iLCJBVFRSSUJVVEVfUkVHRVgiLCJpc0N1c3RvbUF0dHJpYnV0ZSIsInZhbGlkQXR0ciIsImlzVGFnIiwiZGV0ZXJtaW5lVGhlbWUiLCJmYWxsYmFja1RoZW1lIiwiaXNEZWZhdWx0VGhlbWUiLCJ0aGVtZSIsImRhc2hlc0F0RW5kcyIsImNyZWF0ZUJyb2FkY2FzdCIsImluaXRpYWxTdGF0ZSIsImxpc3RlbmVycyIsInB1Ymxpc2giLCJzdWJzY3JpYmUiLCJjdXJyZW50SWQiLCJ1bnN1YnNjcmliZSIsInVuc3ViSUQiLCJfVGhlbWVQcm92aWRlciRjaGlsZEMiLCJfVGhlbWVQcm92aWRlciRjb250ZXgiLCJDSEFOTkVMIiwiQ0hBTk5FTF9ORVhUIiwiQ09OVEVYVF9DSEFOTkVMX1NIQVBFIiwiZ2V0VGhlbWUiLCJ3YXJuQ2hhbm5lbERlcHJlY2F0ZWQiLCJUaGVtZVByb3ZpZGVyIiwidW5zdWJzY3JpYmVUb091dGVySWQiLCJfdGhpczIiLCJvdXRlckNvbnRleHQiLCJvdXRlclRoZW1lIiwiYnJvYWRjYXN0IiwiX3RoaXMzIiwiX2JhYmVsSGVscGVycyRleHRlbmRzIiwic3Vic2NyaWJlciIsInVuc3Vic2NyaWJlSWQiLCJwYXNzZWRUaGVtZSIsIm1lcmdlZFRoZW1lIiwiU1RBVElDX0VYRUNVVElPTl9DT05URVhUIiwiX1N0eWxlZENvbXBvbmVudCIsIkNvbXBvbmVudFN0eWxlIiwiY29uc3RydWN0V2l0aE9wdGlvbnMiLCJpZGVudGlmaWVycyIsImdlbmVyYXRlSWQiLCJfZGlzcGxheU5hbWUiLCJwYXJlbnRDb21wb25lbnRJZCIsIm5yIiwiZ2VuZXJhdGVOYW1lIiwiQmFzZVN0eWxlZENvbXBvbmVudCIsIl90ZW1wIiwiX3JldCIsImdlbmVyYXRlZENsYXNzTmFtZSIsInVuc3Vic2NyaWJlRnJvbUNvbnRleHQiLCJidWlsZEV4ZWN1dGlvbkNvbnRleHQiLCJhY2MiLCJhdHRyIiwiZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMiLCJfY29uc3RydWN0b3IiLCJjb21wb25lbnRTdHlsZSIsIndhcm5Ub29NYW55Q2xhc3NlcyIsInN0eWxlU2hlZXQiLCJpc1N0YXRpYyIsInN0eWxlZENvbnRleHQiLCJuZXh0VGhlbWUiLCJfZ2VuZXJhdGVkQ2xhc3NOYW1lIiwiX3RoaXM0IiwiaW5uZXJSZWYiLCJfY29uc3RydWN0b3IyIiwiaXNUYXJnZXRUYWciLCJiYXNlUHJvcHMiLCJwcm9wc0ZvckVsZW1lbnQiLCJjcmVhdGVTdHlsZWRDb21wb25lbnQiLCJfU3R5bGVkQ29tcG9uZW50JGNvbnQiLCJfb3B0aW9ucyRkaXNwbGF5TmFtZSIsIl9vcHRpb25zJGNvbXBvbmVudElkIiwiX29wdGlvbnMkUGFyZW50Q29tcG9uIiwiUGFyZW50Q29tcG9uZW50IiwiZXh0ZW5kaW5nUnVsZXMiLCJTdHlsZWRDb21wb25lbnQiLCJfUGFyZW50Q29tcG9uZW50Iiwid2l0aENvbXBvbmVudCIsInByZXZpb3VzQ29tcG9uZW50SWQiLCJvcHRpb25zVG9Db3B5IiwibmV3Q29tcG9uZW50SWQiLCJuZXdPcHRpb25zIiwicnVsZXNGcm9tT3B0aW9ucyIsIm5ld1J1bGVzIiwibXVybXVyaGFzaCIsImwiLCJoIiwiY2hhckNvZGVBdCIsImFyZVN0eWxlc0NhY2hlYWJsZSIsImlzU3RhdGljUnVsZXMiLCJpc0hSTUVuYWJsZWQiLCJfQ29tcG9uZW50U3R5bGUiLCJuYW1lR2VuZXJhdG9yIiwiZ2VuZXJhdGVSdWxlSGFzaCIsImxhc3RDbGFzc05hbWUiLCJkb21FbGVtZW50cyIsIl9zdHlsZWQiLCJzdHlsZWRDb21wb25lbnQiLCJzdHlsZWQiLCJyZXBsYWNlV2hpdGVzcGFjZSIsIl9rZXlmcmFtZXMiLCJfaW5qZWN0R2xvYmFsIiwiaW5qZWN0R2xvYmFsIiwiaGFzaCIsIl9jb25zdHJ1Y3RXaXRoT3B0aW9ucyIsImNvbXBvbmVudENvbnN0cnVjdG9yIiwidGVtcGxhdGVGdW5jdGlvbiIsIndpdGhDb25maWciLCJ3cmFwV2l0aFRoZW1lIiwiQ29tcG9uZW50JCQxIiwiX1dpdGhUaGVtZSRjb250ZXh0VHlwIiwiaXNTdGF0ZWxlc3NGdW5jdGlvbmFsQ29tcG9uZW50Iiwic2hvdWxkU2V0SW5uZXJSZWYiLCJXaXRoVGhlbWUiLCJfUmVhY3QkQ29tcG9uZW50IiwidGhlbWVQcm9wIiwiX19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0hBVU5URURfQllfU1BPT0tZX0dIT1NUUyIsInByb2R1Y3QiLCJrZXlmcmFtZXMiLCJSRUFDVF9TVEFUSUNTIiwibWl4aW5zIiwiS05PV05fU1RBVElDUyIsImNhbGxlciIsImFyaXR5IiwiaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUiLCJob2lzdE5vblJlYWN0U3RhdGljcyIsInRhcmdldENvbXBvbmVudCIsInNvdXJjZUNvbXBvbmVudCIsImN1c3RvbVN0YXRpY3MiLCJmYWN0b3J5IiwibmVlZGxlIiwidG9TaGVldCIsImJsb2NrIiwicnVsZVNoZWV0Iiwic2VsZWN0b3JzIiwibGluZSIsImNvbHVtbiIsIm5zIiwiYXQiLCJudWxscHRuIiwiZm9ybWF0cHRuIiwiY29sb25wdG4iLCJjdXJzb3JwdG4iLCJ0cmFuc2Zvcm1wdG4iLCJhbmltYXRpb25wdG4iLCJwcm9wZXJ0aWVzcHRuIiwiZWxlbWVudHB0biIsInNlbGVjdG9ycHRuIiwiYW5kcHRuIiwiZXNjYXBlcHRuIiwiaW52YWxpZHB0biIsImtleWZyYW1lcHRuIiwicGxjaG9sZHJwdG4iLCJyZWFkb25seXB0biIsImJlZm9yZXB0biIsImFmdGVycHRuIiwidGFpbHB0biIsIndoaXRlcHRuIiwicHNldWRvcHRuIiwid3JpdGluZ3B0biIsImdyYWRpZW50cHRuIiwic3VwcG9ydHNwdG4iLCJwcm9wZXJ0eXB0biIsInNlbGZwdG4iLCJwc2V1ZG9mbXQiLCJ0cmltcHRuIiwiZGltZW5zaW9ucHRuIiwid2Via2l0IiwibW96IiwiU0VNSUNPTE9OIiwiQ0xPU0VCUkFDRVMiLCJPUEVOQlJBQ0VTIiwiT1BFTlBBUkVOVEhFU0VTIiwiQ0xPU0VQQVJFTlRIRVNFUyIsIk9QRU5CUkFDS0VUIiwiQ0xPU0VCUkFDS0VUIiwiTkVXTElORSIsIkNBUlJJQUdFIiwiVEFCIiwiQVQiLCJTUEFDRSIsIkFORCIsIkRBU0giLCJVTkRFUlNDT1JFIiwiU1RBUiIsIkNPTU1BIiwiQ09MT04iLCJTSU5HTEVRVU9URSIsIkRPVUJMRVFVT1RFIiwiRk9XQVJEU0xBU0giLCJHUkVBVEVSVEhBTiIsIlBMVVMiLCJUSUxERSIsIk5VTEwiLCJGT1JNRkVFRCIsIlZFUlRJQ0FMVEFCIiwiS0VZRlJBTUUiLCJNRURJQSIsIlNVUFBPUlRTIiwiUExBQ0VIT0xERVIiLCJSRUFET05MWSIsIklNUE9SVCIsIkNIQVJTRVQiLCJET0NVTUVOVCIsIlBBR0UiLCJwcmVzZXJ2ZSIsInBsdWdnZWQiLCJzaG91bGQiLCJQT1NUUyIsIlBSRVBTIiwiVU5LV04iLCJQUk9QUyIsIkJMQ0tTIiwiQVRSVUwiLCJ1bmt3biIsImtleWVkIiwibnNjb3BlYWx0IiwibnNjb3BlIiwiY29tcGlsZSIsImJyYWNrZXQiLCJjb21tZW50IiwicGFyZW50aGVzZXMiLCJxdW90ZSIsInNlY29uZCIsInRhaWwiLCJ0cmFpbCIsInBlYWsiLCJjb3VudGVyIiwiYXRydWxlIiwicHNldWRvIiwiY2FyZXQiLCJpbnNlcnQiLCJpbnZlcnQiLCJlb2YiLCJlb2wiLCJvdXQiLCJmbGF0IiwicHJveHkiLCJzdXBwb3J0cyIsInZlbmRvciIsImlzb2xhdGUiLCJsZXZlbCIsInRoaXJkIiwiY2FjaGUiLCJkZWNsYXJlIiwiaXRlbXMiLCJwYWRkaW5nIiwibWluaWZ5Iiwib3V0cHV0IiwicGx1Z2luIiwiRnVuY3Rpb24iLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsInN1cHBvcnQiLCJzZWFyY2hQYXJhbXMiLCJpdGVyYWJsZSIsImJsb2IiLCJCbG9iIiwiZm9ybURhdGEiLCJhcnJheUJ1ZmZlciIsInZpZXdDbGFzc2VzIiwiaXNEYXRhVmlldyIsIkRhdGFWaWV3IiwiaXNQcm90b3R5cGVPZiIsImlzQXJyYXlCdWZmZXJWaWV3IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJub3JtYWxpemVOYW1lIiwibm9ybWFsaXplVmFsdWUiLCJpdGVyYXRvckZvciIsInNoaWZ0IiwiSGVhZGVycyIsImFwcGVuZCIsImhlYWRlciIsIm9sZFZhbHVlIiwidGhpc0FyZyIsImNvbnN1bWVkIiwiYm9keVVzZWQiLCJQcm9taXNlIiwicmVqZWN0IiwiZmlsZVJlYWRlclJlYWR5IiwicmVhZGVyIiwicmVzb2x2ZSIsIm9ubG9hZCIsIm9uZXJyb3IiLCJyZWFkQmxvYkFzQXJyYXlCdWZmZXIiLCJGaWxlUmVhZGVyIiwicHJvbWlzZSIsInJlYWRBc0FycmF5QnVmZmVyIiwicmVhZEJsb2JBc1RleHQiLCJyZWFkQXNUZXh0IiwicmVhZEFycmF5QnVmZmVyQXNUZXh0IiwiYnVmIiwiVWludDhBcnJheSIsImJ1ZmZlckNsb25lIiwiYnl0ZUxlbmd0aCIsImJ1ZmZlciIsIkJvZHkiLCJfaW5pdEJvZHkiLCJfYm9keUluaXQiLCJfYm9keVRleHQiLCJfYm9keUJsb2IiLCJGb3JtRGF0YSIsIl9ib2R5Rm9ybURhdGEiLCJVUkxTZWFyY2hQYXJhbXMiLCJfYm9keUFycmF5QnVmZmVyIiwicmVqZWN0ZWQiLCJ0aGVuIiwiZGVjb2RlIiwianNvbiIsInBhcnNlIiwibWV0aG9kcyIsIm5vcm1hbGl6ZU1ldGhvZCIsInVwY2FzZWQiLCJSZXF1ZXN0IiwiY3JlZGVudGlhbHMiLCJyZWZlcnJlciIsImJ5dGVzIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGFyc2VIZWFkZXJzIiwicmF3SGVhZGVycyIsInBhcnRzIiwiUmVzcG9uc2UiLCJib2R5SW5pdCIsInN0YXR1cyIsIm9rIiwic3RhdHVzVGV4dCIsInJlc3BvbnNlIiwicmVkaXJlY3RTdGF0dXNlcyIsInJlZGlyZWN0IiwiUmFuZ2VFcnJvciIsImluaXQiLCJyZXF1ZXN0IiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZVVSTCIsInJlc3BvbnNlVGV4dCIsIm9udGltZW91dCIsIndpdGhDcmVkZW50aWFscyIsInJlc3BvbnNlVHlwZSIsInNldFJlcXVlc3RIZWFkZXIiLCJzZW5kIiwicG9seWZpbGwiLCJJbnB1dCIsIkZvcm1FbGVtZW50IiwiVGV4dGFyZWEiLCJ0eXBlcyIsIlNsYWNrRmVlZGJhY2siLCJ0b2dnbGUiLCJhY3RpdmUiLCJjbG9zZSIsImFjdGl2YXRlIiwiaGFuZGxlQ2xpY2tPdXRzaWRlIiwidG9nZ2xlU2VuZFVSTCIsInNlbmRVUkwiLCJzZWxlY3RUeXBlIiwic2VsZWN0ZWRUeXBlIiwic2VudCIsInNlbmRpbmciLCJzZW50VGltZW91dCIsImRldGVybWluZUVycm9yVHlwZSIsImVycm9yVGltZW91dCIsInBheWxvYWQiLCJjaGFubmVsIiwidXNlcm5hbWUiLCJ1c2VyIiwiaWNvbl9lbW9qaSIsImVtb2ppIiwiYXR0YWNobWVudHMiLCJmYWxsYmFjayIsImF1dGhvcl9uYW1lIiwidGl0bGVfbGluayIsImZvb3RlciIsImltYWdlX3VybCIsIm9uU3VibWl0IiwiYXR0YWNoSW1hZ2UiLCJmaWxlcyIsImZpbGUiLCJwcmV2aWV3IiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwidXBsb2FkaW5nSW1hZ2UiLCJvbkltYWdlVXBsb2FkIiwidXBsb2FkRXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJyZW1vdmVJbWFnZSIsImltYWdlVXBsb2FkZWQiLCJyZW5kZXJJbWFnZVVwbG9hZCIsInJlbmRlckltYWdlUHJldmlldyIsImltYWdlVXBsb2FkVGV4dCIsImJhY2tncm91bmRJbWFnZSIsInNob3dDaGFubmVsIiwic3VibWl0VGV4dCIsImNvbnRlbnRTdHlsZXMiLCJjbG9zZUJ1dHRvbiIsInRyaWdnZXJTdHlsZXMiLCJidXR0b25UZXh0Iiwibm9vcCIsIkFwcCIsInNlbmRUb1NsYWNrIiwicmVzIiwidXBsb2FkSW1hZ2UiLCJsb2ciLCJnZXRFbGVtZW50QnlJZCIsIlNsYWNrSWNvbiIsImZvbnRTdGFjayIsImZvbnQiLCJib3JkZXIiLCJwcmltYXJ5Iiwic2Vjb25kYXJ5IiwiYmFja2dyb3VuZCIsInN1Y2Nlc3MiLCJsb2FkZXIiLCJyZXNldHMiLCJmb3JtU3R5bGVzIiwiZmFkZUluVXAiLCJhbmltYXRpb25GYWRlSW5VcCIsImZhZGVPdXREb3duIiwiYW5pbWF0aW9uRmFkZU91dERvd24iLCJsb2FkIiwiTG9hZGVyIiwiQ29udGFpbmVyIiwiSGVhZGVyIiwiQ29udGVudCIsIkljb24iLCJUcmlnZ2VyIiwiVGFicyIsInVsIiwiSW1hZ2VVcGxvYWQiLCJVcGxvYWRCdXR0b24iLCJ0ZXh0YXJlYSIsIkxhYmVsIiwiQ2hlY2tib3giLCJDaGVja2JveExhYmVsIiwiU3VibWl0QnV0dG9uIiwiUHJldmlld092ZXJsYXkiLCJJbWFnZVByZXZpZXciLCJTZWxlY3QiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtB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anMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgdmFyIGRvYyA9IG9iamVjdCA/IG9iamVjdC5vd25lckRvY3VtZW50IHx8IG9iamVjdCA6IGRvY3VtZW50O1xuICB2YXIgZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgZGVmYXVsdFZpZXcuTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIGRlZmF1bHRWaWV3Lk5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7IiwiLyohXG4gKiBpcy1wbGFpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpc29iamVjdCcpO1xuXG5mdW5jdGlvbiBpc09iamVjdE9iamVjdChvKSB7XG4gIHJldHVybiBpc09iamVjdChvKSA9PT0gdHJ1ZVxuICAgICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIHZhciBjdG9yLHByb3Q7XG5cbiAgaWYgKGlzT2JqZWN0T2JqZWN0KG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgaWYgKHR5cGVvZiBjdG9yICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdE9iamVjdChwcm90KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNb3N0IGxpa2VseSBhIHBsYWluIE9iamVjdFxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvKiFcbiAqIGlzb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pc29iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSh2YWwpID09PSBmYWxzZTtcbn07XG4iLCIvLyB0aGUgd2hhdHdnLWZldGNoIHBvbHlmaWxsIGluc3RhbGxzIHRoZSBmZXRjaCgpIGZ1bmN0aW9uXG4vLyBvbiB0aGUgZ2xvYmFsIG9iamVjdCAod2luZG93IG9yIHNlbGYpXG4vL1xuLy8gUmV0dXJuIHRoYXQgYXMgdGhlIGV4cG9ydCBmb3IgdXNlIGluIFdlYnBhY2ssIEJyb3dzZXJpZnkgZXRjLlxucmVxdWlyZSgnd2hhdHdnLWZldGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHNlbGYuZmV0Y2guYmluZChzZWxmKTtcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxuLy8gVGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYmUgYWxsIGxvd2VyY2FzZSB0byBhbGxvdyBmb3Jcbi8vIGNhc2UgaW5zZW5zaXRpdmUgY2hlY2tzXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiB0cnVlLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgaW5uZXJIVE1MOiB0cnVlLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgc3R5bGU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuICBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCBcImluamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdSdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnJXMnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5IGluamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlIGluamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCBcIkRPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlc1wiLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG5cbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBEb3duY2FzZSByZWZlcmVuY2VzIHRvIHdoaXRlbGlzdCBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBtZW1iZXJzaGlwXG4gICAgICAvLyB3aXRob3V0IGNhc2Utc2Vuc2l0aXZpdHkuIFRoaXMgYWxsb3dzIHRoZSB3aGl0ZWxpc3QgdG8gcGljayB1cFxuICAgICAgLy8gYGFsbG93ZnVsbHNjcmVlbmAsIHdoaWNoIHNob3VsZCBiZSB3cml0dGVuIHVzaW5nIHRoZSBwcm9wZXJ0eSBjb25maWd1cmF0aW9uXG4gICAgICAvLyBmb3IgYGFsbG93RnVsbHNjcmVlbmBcbiAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xuXG5cbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcblxuLyoqXG4gKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAqXG4gKiBhdHRyaWJ1dGVOYW1lOlxuICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICogYXR0cmlidXRlTmFtZXNwYWNlXG4gKiBwcm9wZXJ0eU5hbWU6XG4gKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAqIG11dGF0aW9uTWV0aG9kOlxuICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gKiAgIGluaXRpYWwgcmVuZGVyLlxuICogbXVzdFVzZVByb3BlcnR5OlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICovXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIHdyaXRlYWJsZSBhdHRyaWJ1dGUuXG4gKiBAbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzU3RyaW5nQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlO1xuICB9XG4gIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gIHJldHVybiBwcmVmaXggPT09ICdkYXRhLScgfHwgcHJlZml4ID09PSAnYXJpYS0nO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHdpdGhpbiB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzXG4gKiByZXNlcnZlZCBmb3IgaW50ZXJuYWwgUmVhY3Qgb3BlcmF0aW9ucy4gVGhlc2UgcHJvcGVydGllcyBzaG91bGRcbiAqIG5vdCBiZSBzZXQgb24gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIG5hbWUgaXMgd2l0aGluIHJlc2VydmVkIHByb3BzXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpIHtcbiAgcmV0dXJuIFJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KG5hbWUpO1xufVxuXG52YXIgaW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IGluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuICAvLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICAvLyBuYW1lIHdhcm5pbmdzLlxuICBQcm9wZXJ0aWVzOiB7XG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBzcGVjaWZpZXMgdGFyZ2V0IGNvbnRleHQgZm9yIGxpbmtzIHdpdGggYHByZWxvYWRgIHR5cGVcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuICAgIC8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbiAgICBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29udGVudEVkaXRhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICAvLyBzdXBwb3J0IGZvciBwcm9qZWN0aW5nIHJlZ3VsYXIgRE9NIEVsZW1lbnRzIHZpYSBWMSBuYW1lZCBzbG90cyAoIHNoYWRvdyBkb20gKVxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBTdHlsZSBtdXN0IGJlIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBhdHRyaWJ1dGUgbGlzdC4gUmVhY3QgY29tcG9uZW50c1xuICAgIC8vIGV4cGVjdCBhIHN0eWxlIG9iamVjdFxuICAgIHN0eWxlOiAwLFxuICAgIC8vIEtlZXAgaXQgaW4gdGhlIHdoaXRlbGlzdCBiZWNhdXNlIGl0IGlzIGNhc2Utc2Vuc2l0aXZlIGZvciBTVkcuXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gaXRlbVNjb3BlIGlzIGZvciBmb3IgTWljcm9kYXRhIHN1cHBvcnQuXG4gICAgLy8gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gVGhlc2UgYXR0cmlidXRlcyBtdXN0IHN0YXkgaW4gdGhlIHdoaXRlLWxpc3QgYmVjYXVzZSB0aGV5IGhhdmVcbiAgICAvLyBkaWZmZXJlbnQgYXR0cmlidXRlIG5hbWVzIChzZWUgRE9NQXR0cmlidXRlTmFtZXMgYmVsb3cpXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgLy8gQXR0cmlidXRlcyB3aXRoIG11dGF0aW9uIG1ldGhvZHMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHdoaXRlbGlzdFxuICAgIC8vIFNldCB0aGUgc3RyaW5nIGJvb2xlYW4gZmxhZyB0byBhbGxvdyB0aGUgYmVoYXZpb3JcbiAgICB2YWx1ZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NTXV0YXRpb25NZXRob2RzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXIgaW5wdXRzIGdldCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gc29tZSBlZGdlIGNhc2VzIGluXG4gICAgICAvLyBDaHJvbWUuIExldCBldmVyeXRoaW5nIGVsc2UgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgYXMgbm9ybWFsLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzI2lzc3VlY29tbWVudC0yMzYwNzQzMjZcbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2YWx1ZScpID09PSBmYWxzZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWxpZGl0eSAmJiAhbm9kZS52YWxpZGl0eS5iYWRJbnB1dCAmJiBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgICAgICAvLyBEb24ndCBhc3NpZ24gYW4gYXR0cmlidXRlIGlmIHZhbGlkYXRpb24gcmVwb3J0cyBiYWRcbiAgICAgICAgLy8gaW5wdXQuIENocm9tZSB3aWxsIGNsZWFyIHRoZSB2YWx1ZS4gQWRkaXRpb25hbGx5LCBkb24ndFxuICAgICAgICAvLyBvcGVyYXRlIG9uIGlucHV0cyB0aGF0IGhhdmUgZm9jdXMsIG90aGVyd2lzZSBDaHJvbWUgbWlnaHRcbiAgICAgICAgLy8gc3RyaXAgb2ZmIHRyYWlsaW5nIGRlY2ltYWwgcGxhY2VzIGFuZCBjYXVzZSB0aGUgdXNlcidzXG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvbiB0byBqdW1wIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGlucHV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBSZWFjdERPTUlucHV0LCB3ZSBoYXZlIGFuIG9uQmx1ciBldmVudCB0aGF0IHdpbGwgdHJpZ2dlclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFnYWluIHdoZW4gZm9jdXMgaXMgbG9zdC5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLFxuICogbmFtZXNwYWNpbmcsIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC5cbiAqXG4gKiBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gKiB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICogbmFtZSB3YXJuaW5ncy5cbiAqXG4gKiBTVkcgQXR0cmlidXRlcyBMaXN0OlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9hdHRpbmRleC5odG1sXG4gKiBTTUlMIFNwZWM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvc21pbFxuICovXG52YXIgQVRUUlMgPSBbJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3gtaGVpZ2h0JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbG5zOnhsaW5rJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddO1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgcHJlc2VydmVBbHBoYTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDFcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfVxufTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5BVFRSUy5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgcmVhY3ROYW1lID0gb3JpZ2luYWwucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG5cbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1tyZWFjdE5hbWVdID0gMDtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNbcmVhY3ROYW1lXSA9IG9yaWdpbmFsO1xufSk7XG5cbmluamVjdGlvbi5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVycm9yVXRpbHM6IGZ1bmN0aW9uIChpbmplY3RlZEVycm9yVXRpbHMpIHtcbiAgICAgICEodHlwZW9mIGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW5qZWN0ZWQgaW52b2tlR3VhcmRlZENhbGxiYWNrKCkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpIDogdm9pZCAwO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAgICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gICAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gICAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAgICogVE9ETzogU2VlIGlmIF9jYXVnaHRFcnJvciBhbmQgX3JldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAoIVJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0aHJvd0NhdWdodEVycm9yLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICBoYXNDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yO1xuICB9LFxuXG4gIGNsZWFyQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvcjtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7XG5cbiAgICAgIC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcgKyBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgKyAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgKyAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICsgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgKyAneW91ciBicm93c2VyLiBUcnkgdHJpZ2dlcmluZyB0aGUgZXJyb3IgaW4gcHJvZHVjdGlvbiBtb2RlLCAnICsgJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJyArICdhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciByZXRocm93Q2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBsdWdpbnM6IHBsdWdpbnMsXG5cdGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXHRyZWdpc3RyYXRpb25OYW1lTW9kdWxlczogcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cdHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG5cdHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMsXG5cdGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cdGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59KTtcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG52YXIgaW5qZWN0aW9uJDIgPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1xuICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlO1xuXG4gICAge1xuICAgICAgd2FybmluZyhnZXROb2RlRnJvbUluc3RhbmNlICYmIGdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cblxuXG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbntcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24kMSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGxpc3RlbmVyO1xuXG4gIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XG4gIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmICghc3RhdGVOb2RlKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuICBpZiAoIXByb3BzKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsaXN0ZW5lciA9IHByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAhKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICpcbiAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbnF1ZXVlRXZlbnRzKGV2ZW50cykge1xuICBpZiAoZXZlbnRzKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0V2ZW50UXVldWUoc2ltdWxhdGVkKSB7XG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxudmFyIEV2ZW50UGx1Z2luSHViID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDEsXG5cdGdldExpc3RlbmVyOiBnZXRMaXN0ZW5lcixcblx0ZXh0cmFjdEV2ZW50czogZXh0cmFjdEV2ZW50cyxcblx0ZW5xdWV1ZUV2ZW50czogZW5xdWV1ZUV2ZW50cyxcblx0cHJvY2Vzc0V2ZW50UXVldWU6IHByb2Nlc3NFdmVudFF1ZXVlXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgQ2FsbENvbXBvbmVudCA9IDc7XG52YXIgQ2FsbEhhbmRsZXJQaGFzZSA9IDg7XG52YXIgUmV0dXJuQ29tcG9uZW50ID0gOTtcbnZhciBGcmFnbWVudCA9IDEwO1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZSQxKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0ID0gdm9pZCAwO1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzJDEobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gcHJvcHM7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSBPYmplY3QuZnJlZXplKHtcblx0cHJlY2FjaGVGaWJlck5vZGU6IHByZWNhY2hlRmliZXJOb2RlJDEsXG5cdGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcblx0Z2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLFxuXHRnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlJDEsXG5cdGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSxcblx0dXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wcyQxXG59KTtcblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0WydyZXR1cm4nXTtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gIHJldHVybiBnZXRQYXJlbnQoaW5zdCk7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgJ2NhcHR1cmVkJywgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghZnJvbSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChmcm9tID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgYWx0ZXJuYXRlID0gZnJvbS5hbHRlcm5hdGU7XG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGdldFBhcmVudChmcm9tKTtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCF0bykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0byA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIF9hbHRlcm5hdGUgPSB0by5hbHRlcm5hdGU7XG4gICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwgJiYgX2FsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gZ2V0UGFyZW50KHRvKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yICh2YXIgX2kgPSBwYXRoVG8ubGVuZ3RoOyBfaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9bX2ldLCAnY2FwdHVyZWQnLCBhcmdUbyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW4gYVxuICogc2luZ2xlIG9uZS5cbiAqL1xuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAge1xuICAgIHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIHRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGluc3QgJiYgZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcblx0YWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1xufSk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG4vKipcbiAqIFRoaXMgaGVscGVyIG9iamVjdCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgY29tcG9zaXRpb25TdGF0ZSA9IHtcbiAgX3Jvb3Q6IG51bGwsXG4gIF9zdGFydFRleHQ6IG51bGwsXG4gIF9mYWxsYmFja1RleHQ6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGlmIChjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQpIHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xuICB9XG5cbiAgdmFyIHN0YXJ0O1xuICB2YXIgc3RhcnRWYWx1ZSA9IGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dDtcbiAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gIHZhciBlbmQ7XG4gIHZhciBlbmRWYWx1ZSA9IGdldFRleHQoKTtcbiAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgaWYgKCd2YWx1ZScgaW4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290LnZhbHVlO1xuICB9XG4gIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG59XG5cbi8qIGVzbGludCB2YWxpZC10eXBlb2Y6IDAgKi9cblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW3Nob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzW2ldXSA9IG51bGw7XG4gICAgfVxuICAgIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmF0aXZlRXZlbnQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCduYXRpdmVFdmVudCcsIG51bGwpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncHJldmVudERlZmF1bHQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdwcmV2ZW50RGVmYXVsdCcsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbikpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcbiAgYWRkRXZlbnRQb29saW5nVG8oQ2xhc3MpO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgXCIgKyBcInNlZWluZyB0aGlzLCB5b3UncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiBcIiArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG5cbmFkZEV2ZW50UG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50KTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSB7P29iamVjdH0gZ2V0VmFsXG4gKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgKyBcInlvdSdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuIFwiICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICAhKGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBldmVudCBpbnN0YW5jZSAgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IHZvaWQgMDtcbiAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoIDwgRVZFTlRfUE9PTF9TSVpFKSB7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucHVzaChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRQb29saW5nVG8oRXZlbnRDb25zdHJ1Y3Rvcikge1xuICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbCA9IFtdO1xuICBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZCA9IGdldFBvb2xlZEV2ZW50O1xuICBFdmVudENvbnN0cnVjdG9yLnJlbGVhc2UgPSByZWxlYXNlUG9vbGVkRXZlbnQ7XG59XG5cbnZhciBTeW50aGV0aWNFdmVudCQxID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5UHJlc3MnLCAndG9wVGV4dElucHV0JywgJ3RvcFBhc3RlJ11cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25VcGRhdGUnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblVwZGF0ZSc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIHN0YXR1cywgaWYgYW55LlxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFpc0NvbXBvc2luZyAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VG9wTGV2ZWxUeXBlc30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxuLy8gVXNlIHRvIHJlc3RvcmUgY29udHJvbGxlZCBzdGF0ZSBhZnRlciBhIGNoYW5nZSBldmVudCBoYXMgZmlyZWQuXG5cbnZhciBmaWJlckhvc3RDb21wb25lbnQgPSBudWxsO1xuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OiBmdW5jdGlvbiAoaG9zdENvbXBvbmVudEltcGwpIHtcbiAgICAvLyBUaGUgZmliZXIgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgZHluYW1pYyBkaXNwYXRjaCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gaW5qZWN0IHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmaWJlckhvc3RDb21wb25lbnQgPSBob3N0Q29tcG9uZW50SW1wbDtcbiAgfVxufTtcblxudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIC8vIFVubW91bnRlZFxuICAgIHJldHVybjtcbiAgfVxuICAhKGZpYmVySG9zdENvbXBvbmVudCAmJiB0eXBlb2YgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRmliZXIgbmVlZHMgdG8gYmUgaW5qZWN0ZWQgdG8gaGFuZGxlIGEgZmliZXIgdGFyZ2V0IGZvciBjb250cm9sbGVkIGV2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSk7XG4gIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbn1cblxudmFyIGluamVjdGlvbiQzID0gUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uO1xuXG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRhcmdldCA9IHJlc3RvcmVUYXJnZXQ7XG4gIHZhciBxdWV1ZWRUYXJnZXRzID0gcmVzdG9yZVF1ZXVlO1xuICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMyxcblx0ZW5xdWV1ZVN0YXRlUmVzdG9yZTogZW5xdWV1ZVN0YXRlUmVzdG9yZSxcblx0cmVzdG9yZVN0YXRlSWZOZWVkZWQ6IHJlc3RvcmVTdGF0ZUlmTmVlZGVkXG59KTtcblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgZmliZXJCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG5cbnZhciBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzTmVzdGluZ0JhdGNoZWQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS4gVGhlcmVmb3JlLCB3ZSBhZGQgdGhlIHRhcmdldCB0b1xuICAgIC8vIGEgcXVldWUgb2Ygd29yay5cbiAgICByZXR1cm4gZmliZXJCYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpO1xuICB9XG4gIGlzTmVzdGluZ0JhdGNoZWQgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gICAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbiAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCgpO1xuICB9XG59XG5cbnZhciBSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKF9iYXRjaGVkVXBkYXRlcykge1xuICAgIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBfYmF0Y2hlZFVwZGF0ZXM7XG4gIH1cbn07XG5cbnZhciBpbmplY3Rpb24kNCA9IFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSBURVhUX05PREUgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQ2hlY2thYmxlKG5vZGUpKSB7XG4gICAgdmFsdWUgPSBub2RlLmNoZWNrZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyAnY2hlY2tlZCcgOiAndmFsdWUnO1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGV2ZW50VHlwZXMkMSA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnQpO1xuICBwcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICB2YXIgdmFsdWUgPSAnJyArIG5vZGUudmFsdWU7XG4gIGlmIChub2RlLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAhPT0gdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDEsXG5cbiAgX2lzSW5wdXRFdmVudFN1cHBvcnRlZDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXRJbnN0LCB0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBET01FdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgcGFnZVg6IG51bGwsXG4gIHBhZ2VZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogbnVsbCxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cblxuLyoqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXI7XG59XG5cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyID0gdmFsdWU7XG59XG5cbnZhciBSZWFjdEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXM6XG52YXIgTm9FZmZlY3QgPSAwOyAvLyAgICAgICAgICAgMGIwMDAwMDAwMFxudmFyIFBlcmZvcm1lZFdvcmsgPSAxOyAvLyAgICAgIDBiMDAwMDAwMDFcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gMjsgLy8gICAgICAgICAgMGIwMDAwMDAxMFxudmFyIFVwZGF0ZSA9IDQ7IC8vICAgICAgICAgICAgIDBiMDAwMDAxMDBcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSA2OyAvLyAwYjAwMDAwMTEwXG52YXIgRGVsZXRpb24gPSA4OyAvLyAgICAgICAgICAgMGIwMDAwMTAwMFxudmFyIENvbnRlbnRSZXNldCA9IDE2OyAvLyAgICAgIDBiMDAwMTAwMDBcbnZhciBDYWxsYmFjayA9IDMyOyAvLyAgICAgICAgICAwYjAwMTAwMDAwXG52YXIgRXJyID0gNjQ7IC8vICAgICAgICAgICAgICAgMGIwMTAwMDAwMFxudmFyIFJlZiA9IDEyODsgLy8gICAgICAgICAgICAgIDBiMTAwMDAwMDBcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAhKGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgICEoc3RhdGUgIT09IFVOTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgaWYgKHN0YXRlID09PSBNT1VOVElORykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGFbJ3JldHVybiddO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QSA/IHBhcmVudEEuYWx0ZXJuYXRlIDogbnVsbDtcbiAgICBpZiAoIXBhcmVudEEgfHwgIXBhcmVudEIpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhWydyZXR1cm4nXSAhPT0gYlsncmV0dXJuJ10pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICAhZGlkRmluZENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoYS5hbHRlcm5hdGUgPT09IGIpID8gaW52YXJpYW50KGZhbHNlLCAnUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzXFwnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuICAhKGEudGFnID09PSBIb3N0Um9vdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3RbJ3JldHVybiddKSB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBib29rS2VlcGluZy50YXJnZXRJbnN0O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgaWYgKCFhbmNlc3Rvcikge1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciByb290ID0gZmluZFJvb3RDb250YWluZXJOb2RlKGFuY2VzdG9yKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyb290KTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBfaGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xudmFyIF9oYW5kbGVUb3BMZXZlbCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gc2V0SGFuZGxlVG9wTGV2ZWwoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG59XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldEluc3QudGFnID09PSAnbnVtYmVyJyAmJiAhaXNGaWJlck1vdW50ZWQodGFyZ2V0SW5zdCkpIHtcbiAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gIH1cblxuICB2YXIgYm9va0tlZXBpbmcgPSBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICBiYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0Z2V0IF9oYW5kbGVUb3BMZXZlbCAoKSB7IHJldHVybiBfaGFuZGxlVG9wTGV2ZWw7IH0sXG5cdHNldEhhbmRsZVRvcExldmVsOiBzZXRIYW5kbGVUb3BMZXZlbCxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqXG4gKiBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2VcbiAqIHRyYXAgYXQgYSBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZFxuICogY2F1c2UgZHVwbGljYXRlIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZS5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMkMSA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWQ6ICdsb2FkJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG52YXIgQnJvd3NlckV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzJDFcbn07XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBlbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuLyoqXG4gKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cyA9IGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xufVxuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEJyb3dzZXJFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RET01FdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0XG4gKiAgICBwbHVnZ2FibGUgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluXG4gKiAgICB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyAoJycgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICpcbiAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAqXG4gKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG5cbiAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDYW5jZWwnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjYW5jZWwnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDYW5jZWwnLCAnY2FuY2VsJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2FuY2VsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENsb3NlJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnY2xvc2UnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDbG9zZScsICdjbG9zZScsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcENsb3NlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlcy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcExldmVsVHlwZXNbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgfVxuXG4gICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBvdXRlck5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUkJDEgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZSQkMS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpO1xufVxuXG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSQkMSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZvY3VzTm9kZSQkMSAmJiAoZm9jdXNPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBlbmQgPSBsZW5ndGggKyBmb2N1c09mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICBsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLmZpcnN0Q2hpbGQpID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG4gICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gb3V0ZXJOb2RlKSB7XG4gICAgICAgIC8vIElmIGBvdXRlck5vZGVgIGhhcyBjaGlsZHJlbiwgdGhpcyBpcyBhbHdheXMgdGhlIHNlY29uZCB0aW1lIHZpc2l0aW5nXG4gICAgICAgIC8vIGl0LiBJZiBpdCBoYXMgbm8gY2hpbGRyZW4sIHRoaXMgaXMgc3RpbGwgdGhlIGZpcnN0IGxvb3AsIGFuZCB0aGUgb25seVxuICAgICAgICAvLyB2YWxpZCBzZWxlY3Rpb24gaXMgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGJvdGggZXF1YWwgdG8gdGhpcyBub2RlXG4gICAgICAgIC8vIGFuZCBib3RoIG9mZnNldHMgMCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGhhdmUgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5uZXh0U2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gc3RhcnRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID09PSBzdGFydE1hcmtlci5vZmZzZXQgJiYgc2VsZWN0aW9uLmZvY3VzTm9kZSA9PT0gZW5kTWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0ID09PSBlbmRNYXJrZXIub2Zmc2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKSB7XG4gIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24kMShmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICovXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9XG5cbiAgICAvLyBGb2N1c2luZyBhIG5vZGUgY2FuIGNoYW5nZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLCB3aGljaCBpcyB1bmRlc2lyYWJsZVxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuICAgIHdoaWxlIChhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgICBlbGVtZW50OiBhbmNlc3RvcixcbiAgICAgICAgICBsZWZ0OiBhbmNlc3Rvci5zY3JvbGxMZWZ0LFxuICAgICAgICAgIHRvcDogYW5jZXN0b3Iuc2Nyb2xsVG9wXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5mbyA9IGFuY2VzdG9yc1tpXTtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxMZWZ0ID0gaW5mby5sZWZ0O1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbFRvcCA9IGluZm8udG9wO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb24gPSB2b2lkIDA7XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG59XG5cbi8qKlxuICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gKiB0aGUgaW5wdXQuXG4gKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0LFxuICAgICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyQzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uU2VsZWN0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25TZWxlY3RDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29udGV4dE1lbnUnLCAndG9wRm9jdXMnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nLCAndG9wTW91c2VVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50JDEgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50JDEgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50JDEpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QkMSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG5cbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0ID8gbmF0aXZlRXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBuYXRpdmVFdmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IG5hdGl2ZUV2ZW50VGFyZ2V0IDogbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUcmFjayB3aGV0aGVyIGFsbCBsaXN0ZW5lcnMgZXhpc3RzIGZvciB0aGlzIHBsdWdpbi4gSWYgbm9uZSBleGlzdCwgd2UgZG9cbiAgICAvLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbiAgICBpZiAoIWRvYyB8fCAhaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcygnb25TZWxlY3QnLCBkb2MpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIERvbid0IGZpcmUgdGhlIGV2ZW50IHdoaWxlIHRoZSB1c2VyIGlzIGRyYWdnaW5nLiBUaGlzIG1hdGNoZXMgdGhlXG4gICAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlICd0b3BTZWxlY3Rpb25DaGFuZ2UnOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGFuaW1hdGlvbk5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQW5pbWF0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LCBBbmltYXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQsIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzJDQgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhbmNlbCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2Nsb3NlJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b2dnbGUnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hFbmQnLCAndG91Y2hNb3ZlJywgJ3RvdWNoU3RhcnQnLCAndHJhbnNpdGlvbkVuZCcsICd2b2x1bWVDaGFuZ2UnLCAnd2FpdGluZycsICd3aGVlbCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICB2YXIgdG9wRXZlbnQgPSAndG9wJyArIGNhcGl0YWxpemVkRXZlbnQ7XG5cbiAgdmFyIHR5cGUgPSB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IG9uRXZlbnQsXG4gICAgICBjYXB0dXJlZDogb25FdmVudCArICdDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wRXZlbnRdXG4gIH07XG4gIGV2ZW50VHlwZXMkNFtldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG4vLyBPbmx5IHVzZWQgaW4gREVWIGZvciBleGhhdXN0aXZlbmVzcyB2YWxpZGF0aW9uLlxudmFyIGtub3duSFRNTFRvcExldmVsVHlwZXMgPSBbJ3RvcEFib3J0JywgJ3RvcENhbmNlbCcsICd0b3BDYW5QbGF5JywgJ3RvcENhblBsYXlUaHJvdWdoJywgJ3RvcENsb3NlJywgJ3RvcER1cmF0aW9uQ2hhbmdlJywgJ3RvcEVtcHRpZWQnLCAndG9wRW5jcnlwdGVkJywgJ3RvcEVuZGVkJywgJ3RvcEVycm9yJywgJ3RvcElucHV0JywgJ3RvcEludmFsaWQnLCAndG9wTG9hZCcsICd0b3BMb2FkZWREYXRhJywgJ3RvcExvYWRlZE1ldGFkYXRhJywgJ3RvcExvYWRTdGFydCcsICd0b3BQYXVzZScsICd0b3BQbGF5JywgJ3RvcFBsYXlpbmcnLCAndG9wUHJvZ3Jlc3MnLCAndG9wUmF0ZUNoYW5nZScsICd0b3BSZXNldCcsICd0b3BTZWVrZWQnLCAndG9wU2Vla2luZycsICd0b3BTdGFsbGVkJywgJ3RvcFN1Ym1pdCcsICd0b3BTdXNwZW5kJywgJ3RvcFRpbWVVcGRhdGUnLCAndG9wVG9nZ2xlJywgJ3RvcFZvbHVtZUNoYW5nZScsICd0b3BXYWl0aW5nJ107XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQ0LFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDbGljayc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wRG91YmxlQ2xpY2snOlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlTW92ZSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgIC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3V0JzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlT3Zlcic6XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcERyYWcnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VuZCc6XG4gICAgICBjYXNlICd0b3BEcmFnRW50ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ0V4aXQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0xlYXZlJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdTdGFydCc6XG4gICAgICBjYXNlICd0b3BEcm9wJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUb3VjaENhbmNlbCc6XG4gICAgICBjYXNlICd0b3BUb3VjaEVuZCc6XG4gICAgICBjYXNlICd0b3BUb3VjaE1vdmUnOlxuICAgICAgY2FzZSAndG9wVG91Y2hTdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkVuZCc6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25JdGVyYXRpb24nOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVHJhbnNpdGlvbkVuZCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wU2Nyb2xsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wV2hlZWwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb3B5JzpcbiAgICAgIGNhc2UgJ3RvcEN1dCc6XG4gICAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGtub3duSFRNTFRvcExldmVsVHlwZXMuaW5kZXhPZih0b3BMZXZlbFR5cGUpID09PSAtMSkge1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4gVGhpcyB3YXJuaW5nICcgKyAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgdG9wTGV2ZWxUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudCQxO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59O1xuXG5zZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCk7XG5cbi8qKlxuICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKi9cbmluamVjdGlvbiQxLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRE9NRXZlbnRQbHVnaW5PcmRlcik7XG5pbmplY3Rpb24kMi5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG5cbi8qKlxuICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gKiB0aGVtKS5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG52YXIgZW5hYmxlQXN5bmNTdWJ0cmVlQVBJID0gdHJ1ZTtcbnZhciBlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NID0gZmFsc2U7XG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVDcmVhdGVSb290ID0gZmFsc2U7XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIE11dGF0aW5nIG1vZGUgKFJlYWN0IERPTSwgUmVhY3QgQVJULCBSZWFjdCBOYXRpdmUpOlxudmFyIGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciA9IHRydWU7XG4vLyBFeHBlcmltZW50YWwgbm9vcCBtb2RlIChjdXJyZW50bHkgdW51c2VkKTpcbnZhciBlbmFibGVOb29wUmVjb25jaWxlciA9IGZhbHNlO1xuLy8gRXhwZXJpbWVudGFsIHBlcnNpc3RlbnQgbW9kZSAoQ1MpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcblxue1xuICB2YXIgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleF0pIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXNldCQxKCkge1xuICB3aGlsZSAoaW5kZXggPiAtMSkge1xuICAgIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbmRleC0tO1xuICB9XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcik7XG4gICAgICB2YXIgb3duZXJOYW1lID0gbnVsbDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICBvd25lck5hbWUgPSBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSB3b3JrLWluLXByb2dyZXNzIGZpYmVyIGFuZFxuLy8gb25seSBkdXJpbmcgYmVnaW4gb3IgY29tcGxldGUgcGhhc2UuIERvIG5vdCBjYWxsIGl0IHVuZGVyIGFueSBvdGhlclxuLy8gY2lyY3Vtc3RhbmNlcy5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluZm8gPSAnJztcbiAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgZG8ge1xuICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAvLyBPdGhlcndpc2UgdGhpcyByZXR1cm4gcG9pbnRlciBtaWdodCBwb2ludCB0byB0aGUgd3JvbmcgdHJlZTpcbiAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gIH0gd2hpbGUgKG5vZGUpO1xuICByZXR1cm4gaW5mbztcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShvd25lcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50O1xuICAgIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG4gICAgcmV0dXJuIGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmliZXIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBudWxsO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ID0gZmliZXI7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UGhhc2UocGhhc2UpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IHBoYXNlO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlciA9IHtcbiAgY3VycmVudDogbnVsbCxcbiAgcGhhc2U6IG51bGwsXG4gIHJlc2V0Q3VycmVudEZpYmVyOiByZXNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudEZpYmVyOiBzZXRDdXJyZW50RmliZXIsXG4gIHNldEN1cnJlbnRQaGFzZTogc2V0Q3VycmVudFBoYXNlLFxuICBnZXRDdXJyZW50RmliZXJPd25lck5hbWU6IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSxcbiAgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTogZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bVxufTtcblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gJ1xcdTI2OUInO1xudmFyIHdhcm5pbmdFbW9qaSA9ICdcXHUyNkQ0JztcbnZhciBzdXBwb3J0c1VzZXJUaW1pbmcgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG4vLyBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZmliZXIgc28gdGhhdCB3ZSBrbm93IHRoZSBwYXRoIHRvIHVud2luZCBvbiBwYXVzZS5cbi8vIFRPRE86IHRoaXMgbG9va3MgdGhlIHNhbWUgYXMgbmV4dFVuaXRPZldvcmsgaW4gc2NoZWR1bGVyLiBDYW4gd2UgdW5pZnkgdGhlbT9cbnZhciBjdXJyZW50RmliZXIgPSBudWxsO1xuLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB1c2VyIGNvZGUsIHdoaWNoIGZpYmVyIGFuZCBtZXRob2QgaXMgaXQ/XG4vLyBSZXVzaW5nIGBjdXJyZW50RmliZXJgIHdvdWxkIGJlIGNvbmZ1c2luZyBmb3IgdGhpcyBiZWNhdXNlIHVzZXIgY29kZSBmaWJlclxuLy8gY2FuIGNoYW5nZSBkdXJpbmcgY29tbWl0IHBoYXNlIHRvbywgYnV0IHdlIGRvbid0IG5lZWQgdG8gdW53aW5kIGl0IChzaW5jZVxuLy8gbGlmZWN5Y2xlcyBpbiB0aGUgY29tbWl0IHBoYXNlIGRvbid0IHJlc2VtYmxlIGEgdHJlZSkuXG52YXIgY3VycmVudFBoYXNlID0gbnVsbDtcbnZhciBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4vLyBEaWQgbGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGUgYW4gdXBkYXRlPyBUaGlzIGlzIG9mdGVuIGEgcGVyZm9ybWFuY2UgcHJvYmxlbSxcbi8vIHNvIHdlIHdpbGwga2VlcCB0cmFjayBvZiBpdCwgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcG9ydC5cbi8vIFRyYWNrIGNvbW1pdHMgY2F1c2VkIGJ5IGNhc2NhZGluZyB1cGRhdGVzLlxudmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xudmFyIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG52YXIgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG52YXIgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xudmFyIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmckJDEpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmckJDEgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyQkMSA/ICcgV2FybmluZzogJyArIHdhcm5pbmckJDEgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmckJDEpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICBjbGVhckZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlKTtcbiAgfVxuICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG59O1xuXG52YXIgcGF1c2VUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFN0b3BzIGFsbCBjdXJyZW50bHkgYWN0aXZlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlc3VtZWRcbiAgLy8gaWYgd2UgY29udGludWUgaW4gYSBsYXRlciBkZWZlcnJlZCBsb29wIGZyb20gdGhlIHNhbWUgdW5pdCBvZiB3b3JrLlxuICB2YXIgZmliZXIgPSBjdXJyZW50RmliZXI7XG4gIHdoaWxlIChmaWJlcikge1xuICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgZmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnNSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICBpZiAoZmliZXJbJ3JldHVybiddICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoZmliZXJbJ3JldHVybiddKTtcbiAgfVxuICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICBiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlc3VtZXMgYWxsIG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGR1cmluZyB0aGUgbGFzdCBkZWZlcnJlZCBsb29wLlxuICBpZiAoY3VycmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoY3VycmVudEZpYmVyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0KCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkU2NoZWR1bGVVcGRhdGUoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsTW91bnQnICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAhaXNXYWl0aW5nRm9yQ2FsbGJhY2spIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIGJlZ2luTWFyaygnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gZGlkRXhwaXJlID8gJ1JlYWN0IHdhcyBibG9ja2VkIGJ5IG1haW4gdGhyZWFkJyA6IG51bGw7XG4gICAgICBlbmRNYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIHRoaXMgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtZW1iZXIgd2Ugc2hvdWxkbid0IGNvbXBsZXRlIG1lYXN1cmVtZW50IGZvciB0aGlzIGZpYmVyLlxuICAgIC8vIE90aGVyd2lzZSBmbGFtZWNoYXJ0IHdpbGwgYmUgZGVlcCBldmVuIGZvciBzbWFsbCB1cGRhdGVzLlxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgY2xlYXJGaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wRmFpbGVkV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIHZhciB3YXJuaW5nJCQxID0gJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIHRoaXMgZXJyb3IgYm91bmRhcnknO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCBwaGFzZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQoKTtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBwaGFzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBmaWJlcjtcbiAgICBjdXJyZW50UGhhc2UgPSBwaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUGhhc2VUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmluZyQkMSA9IGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID8gJ1NjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnIDogbnVsbDtcbiAgICAgIGVuZEZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgY3VycmVudEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gVGhpcyBpcyB0b3AgbGV2ZWwgY2FsbC5cbiAgICAvLyBBbnkgb3RoZXIgbWVhc3VyZW1lbnRzIGFyZSBwZXJmb3JtZWQgd2l0aGluLlxuICAgIGJlZ2luTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJyk7XG4gICAgLy8gUmVzdW1lIGFueSBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGluIHByb2dyZXNzIGR1cmluZyB0aGUgbGFzdCBsb29wLlxuICAgIHJlc3VtZVRpbWVycygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kczogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJywgbnVsbCk7XG4gIH1cbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKGhhc093bkNvbnRleHQpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID09PSB1bm1hc2tlZENvbnRleHQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgIShjb250ZXh0U3RhY2tDdXJzb3IuY3Vyc29yID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ2dldENoaWxkQ29udGV4dCcpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJywgY29udGV4dEtleSkgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDb250ZXh0KCkge1xuICBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBlbXB0eU9iamVjdDtcbiAgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgIShpc0ZpYmVyTW91bnRlZChmaWJlcikgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG59XG5cbnZhciBOb1dvcmsgPSAwOyAvLyBUT0RPOiBVc2UgYW4gb3BhcXVlIHR5cGUgb25jZSBFU0xpbnQgZXQgYWwgc3VwcG9ydCB0aGUgc3ludGF4XG5cbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IDIxNDc0ODM2NDc7IC8vIE1heCBpbnQzMjogTWF0aC5wb3coMiwgMzEpIC0gMVxuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAobXMgLyBVTklUX1NJWkUgfCAwKSArIE1BR0lDX05VTUJFUl9PRkZTRVQ7XG59XG5cbmZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSkge1xuICByZXR1cm4gKGV4cGlyYXRpb25UaW1lIC0gTUFHSUNfTlVNQkVSX09GRlNFVCkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIGNlaWxpbmcoY3VycmVudFRpbWUgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNVcGRhdGVzID0gMTtcblxue1xuICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG4gICAgXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG57XG4gIHZhciBkZWJ1Z0NvdW50ZXIgPSAxO1xufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZykge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDtcblxuICAvLyBGaWJlclxuICB0aGlzWydyZXR1cm4nXSA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcblxuICB0aGlzLnJlZiA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcblxuICB0aGlzLmludGVybmFsQ29udGV4dFRhZyA9IGludGVybmFsQ29udGV4dFRhZztcblxuICAvLyBFZmZlY3RzXG4gIHRoaXMuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHRoaXMubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgdGhpcy5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIGN1cnJlbnQua2V5LCBjdXJyZW50LmludGVybmFsQ29udGV4dFRhZyk7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgPSBjdXJyZW50Ll9kZWJ1Z0lEO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gTm9FZmZlY3Q7XG5cbiAgICAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuICB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gY3VycmVudC5zaWJsaW5nO1xuICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFJvb3QsIG51bGwsIE5vQ29udGV4dCk7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gdm9pZCAwO1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZSxcbiAgICAgIGtleSA9IGVsZW1lbnQua2V5O1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZpYmVyID0gc2hvdWxkQ29uc3RydWN0KHR5cGUpID8gY3JlYXRlRmliZXIoQ2xhc3NDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSA6IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICBmaWJlci50eXBlID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgdHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgIC8vIEN1cnJlbnRseSBhc3N1bWVkIHRvIGJlIGEgY29udGludWF0aW9uIGFuZCB0aGVyZWZvcmUgaXMgYSBmaWJlciBhbHJlYWR5LlxuICAgIC8vIFRPRE86IFRoZSB5aWVsZCBzeXN0ZW0gaXMgY3VycmVudGx5IGJyb2tlbiBmb3IgdXBkYXRlcyBpbiBzb21lIGNhc2VzLlxuICAgIC8vIFRoZSByZWlmaWVkIHlpZWxkIHN0b3JlcyBhIGZpYmVyLCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmaWJlciB0aGF0IGlzO1xuICAgIC8vIHRoZSBjdXJyZW50IG9yIGEgd29ya0luUHJvZ3Jlc3M/IFdoZW4gdGhlIGNvbnRpbnVhdGlvbiBnZXRzIHJlbmRlcmVkIGhlcmVcbiAgICAvLyB3ZSBkb24ndCBrbm93IGlmIHdlIGNhbiByZXVzZSB0aGF0IGZpYmVyIG9yIGlmIHdlIG5lZWQgdG8gY2xvbmUgaXQuXG4gICAgLy8gVGhlcmUgaXMgcHJvYmFibHkgYSBjbGV2ZXIgd2F5IHRvIHJlc3RydWN0dXJlIHRoaXMuXG4gICAgZmliZXIgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB7XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudHM7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb250ZW50O1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBOb0NvbnRleHQpO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUNhbGwoY2FsbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihDYWxsQ29tcG9uZW50LCBjYWxsLmtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIudHlwZSA9IGNhbGwuaGFuZGxlcjtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gY2FsbDtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihSZXR1cm5Db21wb25lbnQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwb3J0YWwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gfHwgW107XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gIC8vIEN5Y2xpYyBjb25zdHJ1Y3Rpb24uIFRoaXMgY2hlYXRzIHRoZSB0eXBlIHN5c3RlbSByaWdodCBub3cgYmVjYXVzZVxuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcigpO1xuICB2YXIgcm9vdCA9IHtcbiAgICBjdXJyZW50OiB1bmluaXRpYWxpemVkRmliZXIsXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBpc1JlYWR5Rm9yQ29tbWl0OiBmYWxzZSxcbiAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgY29udGV4dDogbnVsbCxcbiAgICBwZW5kaW5nQ29udGV4dDogbnVsbCxcbiAgICBoeWRyYXRlOiBoeWRyYXRlLFxuICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gIH07XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodHJ1ZSAmJiAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG4gIGlmIChob29rLmlzRGlzYWJsZWQpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgcmVhbCBwcm9wZXJ0eSBvbiB0aGUgaG9vaywgYnV0IGl0IGNhbiBiZSBzZXQgdG8gb3B0IG91dFxuICAgIC8vIG9mIERldlRvb2xzIGludGVncmF0aW9uIGFuZCBhc3NvY2lhdGVkIHdhcm5pbmdzIGFuZCBsb2dzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzg3N1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJSb290KHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclVubW91bnQoZmliZXIpO1xuICB9XG59XG5cbntcbiAgdmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbn1cblxuLy8gQ2FsbGJhY2tzIGFyZSBub3QgdmFsaWRhdGVkIHVudGlsIGludm9jYXRpb25cblxuXG4vLyBTaW5nbHkgbGlua2VkLWxpc3Qgb2YgdXBkYXRlcy4gV2hlbiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkLCBpdCBpcyBhZGRlZCB0b1xuLy8gdGhlIHF1ZXVlIG9mIHRoZSBjdXJyZW50IGZpYmVyIGFuZCB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhlIHR3byBxdWV1ZXNcbi8vIGFyZSBzZXBhcmF0ZSBidXQgdGhleSBzaGFyZSBhIHBlcnNpc3RlbnQgc3RydWN0dXJlLlxuLy9cbi8vIER1cmluZyByZWNvbmNpbGlhdGlvbiwgdXBkYXRlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLFxuLy8gYnV0IHRoZXkgcmVtYWluIG9uIHRoZSBjdXJyZW50IGZpYmVyLiBUaGF0IGVuc3VyZXMgdGhhdCBpZiBhIHdvcmstaW4tcHJvZ3Jlc3Ncbi8vIGlzIGFib3J0ZWQsIHRoZSBhYm9ydGVkIHVwZGF0ZXMgYXJlIHJlY292ZXJlZCBieSBjbG9uaW5nIGZyb20gY3VycmVudC5cbi8vXG4vLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhbHdheXMgYSBzdWJzZXQgb2YgdGhlIGN1cnJlbnQgcXVldWUuXG4vL1xuLy8gV2hlbiB0aGUgdHJlZSBpcyBjb21taXR0ZWQsIHRoZSB3b3JrLWluLXByb2dyZXNzIGJlY29tZXMgdGhlIGN1cnJlbnQuXG5cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoYmFzZVN0YXRlKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGJhc2VTdGF0ZSxcbiAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGZpcnN0OiBudWxsLFxuICAgIGxhc3Q6IG51bGwsXG4gICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZSxcbiAgICBpc0luaXRpYWxpemVkOiBmYWxzZVxuICB9O1xuICB7XG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdCA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3QgPSBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3QubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0ID0gdXBkYXRlO1xuICB9XG4gIGlmIChxdWV1ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHF1ZXVlLmV4cGlyYXRpb25UaW1lID4gdXBkYXRlLmV4cGlyYXRpb25UaW1lKSB7XG4gICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpIHtcbiAgLy8gV2UnbGwgaGF2ZSBhdCBsZWFzdCBvbmUgYW5kIGF0IG1vc3QgdHdvIGRpc3RpbmN0IHVwZGF0ZSBxdWV1ZXMuXG4gIHZhciBhbHRlcm5hdGVGaWJlciA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAgIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgfVxuXG4gIHZhciBxdWV1ZTIgPSB2b2lkIDA7XG4gIGlmIChhbHRlcm5hdGVGaWJlciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHF1ZXVlMiA9IG51bGw7XG4gIH1cbiAgcXVldWUyID0gcXVldWUyICE9PSBxdWV1ZTEgPyBxdWV1ZTIgOiBudWxsO1xuXG4gIC8vIFdhcm4gaWYgYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGVyIGZ1bmN0aW9uLlxuICB7XG4gICAgaWYgKChxdWV1ZTEuaXNQcm9jZXNzaW5nIHx8IHF1ZXVlMiAhPT0gbnVsbCAmJiBxdWV1ZTIuaXNQcm9jZXNzaW5nKSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgcXVldWUsIGFkZCB0aGUgdXBkYXRlIHRvIHRoYXQgcXVldWUgYW5kIGV4aXQuXG4gIGlmIChxdWV1ZTIgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGVpdGhlciBxdWV1ZSBpcyBlbXB0eSwgd2UgbmVlZCB0byBhZGQgdG8gYm90aCBxdWV1ZXMuXG4gIGlmIChxdWV1ZTEubGFzdCA9PT0gbnVsbCB8fCBxdWV1ZTIubGFzdCA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMiwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBib3RoIGxpc3RzIGFyZSBub3QgZW1wdHksIHRoZSBsYXN0IHVwZGF0ZSBpcyB0aGUgc2FtZSBmb3IgYm90aCBsaXN0c1xuICAvLyBiZWNhdXNlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy4gU28sIHdlIHNob3VsZCBvbmx5IGFwcGVuZCB0byBvbmUgb2ZcbiAgLy8gdGhlIGxpc3RzLlxuICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0YCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgcXVldWUyLmxhc3QgPSB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTm9Xb3JrO1xuICB9XG4gIHJldHVybiB1cGRhdGVRdWV1ZS5leHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IHVwZGF0ZS5wYXJ0aWFsU3RhdGU7XG4gIGlmICh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHVwZGF0ZUZuID0gcGFydGlhbFN0YXRlO1xuXG4gICAgLy8gSW52b2tlIHNldFN0YXRlIGNhbGxiYWNrIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVGbi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFydGlhbFN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC51cGRhdGVRdWV1ZSA9PT0gcXVldWUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBleHBpcmF0aW9uVGltZTogY3VycmVudFF1ZXVlLmV4cGlyYXRpb25UaW1lLFxuICAgICAgZmlyc3Q6IGN1cnJlbnRRdWV1ZS5maXJzdCxcbiAgICAgIGxhc3Q6IGN1cnJlbnRRdWV1ZS5sYXN0LFxuICAgICAgaXNJbml0aWFsaXplZDogY3VycmVudFF1ZXVlLmlzSW5pdGlhbGl6ZWQsXG4gICAgICAvLyBUaGVzZSBmaWVsZHMgYXJlIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHRoZXkgd2VyZSBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAgIC8vIFJlc2V0IHRoZW0uXG4gICAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFNldCB0aGlzIGZsYWcgc28gd2UgY2FuIHdhcm4gaWYgc2V0U3RhdGUgaXMgY2FsbGVkIGluc2lkZSB0aGUgdXBkYXRlXG4gICAgLy8gZnVuY3Rpb24gb2YgYW5vdGhlciBzZXRTdGF0ZS5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuIElmIHdlIHNraXAgb3ZlciBhbnkgdXBkYXRlcywgd2UnbGxcbiAgLy8gaW5jcmVhc2UgdGhpcyBhY2NvcmRpbmdseS5cbiAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVE9ETzogV2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBiYXNlIHN0YXRlIHdpbGwgYmUgdW50aWwgd2UgYmVnaW4gd29yay5cbiAgLy8gSXQgZGVwZW5kcyBvbiB3aGljaCBmaWJlciBpcyB0aGUgbmV4dCBjdXJyZW50LiBJbml0aWFsaXplIHdpdGggYW4gZW1wdHlcbiAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAvLyBoYXBweSB3aXRoIHRoaXMgYXBwcm9hY2guXG4gIHZhciBzdGF0ZSA9IHZvaWQgMDtcbiAgaWYgKHF1ZXVlLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgcXVldWUuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgdmFyIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICB2YXIgdXBkYXRlID0gcXVldWUuZmlyc3Q7XG4gIHZhciBkaWRTa2lwID0gZmFsc2U7XG4gIHdoaWxlICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHF1ZXVlLmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPiB1cGRhdGVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgICAgZGlkU2tpcCA9IHRydWU7XG4gICAgICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICAgICAgfVxuICAgICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAgIC8vIElmIG5vIHByZXZpb3VzIHVwZGF0ZXMgd2VyZSBza2lwcGVkLCBkcm9wIHRoaXMgdXBkYXRlIGZyb20gdGhlIHF1ZXVlIGJ5XG4gICAgLy8gYWR2YW5jaW5nIHRoZSBoZWFkIG9mIHRoZSBsaXN0LlxuICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgcXVldWUuZmlyc3QgPSB1cGRhdGUubmV4dDtcbiAgICAgIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIHRoZSB1cGRhdGVcbiAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAodXBkYXRlLmlzUmVwbGFjZSkge1xuICAgICAgc3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcGFydGlhbFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBpZiAoX3BhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAoZG9udE11dGF0ZVByZXZTdGF0ZSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWU6IElkayBob3cgdG8gdHlwZSB0aGlzIHByb3Blcmx5LlxuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbih7fSwgc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlID0gX2Fzc2lnbihzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLmlzRm9yY2VkKSB7XG4gICAgICBxdWV1ZS5oYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIEFwcGVuZCB0byBsaXN0IG9mIGNhbGxiYWNrcy5cbiAgICAgIHZhciBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICAgICAgaWYgKF9jYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgX2NhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdCA9IFtdO1xuICAgICAgfVxuICAgICAgX2NhbGxiYWNrTGlzdC5wdXNoKHVwZGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKHF1ZXVlLmNhbGxiYWNrTGlzdCAhPT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfSBlbHNlIGlmIChxdWV1ZS5maXJzdCA9PT0gbnVsbCAmJiAhcXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHkuIFdlIGNhbiByZXNldCBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoIWRpZFNraXApIHtcbiAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBObyBsb25nZXIgcHJvY2Vzc2luZy5cbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gIGlmIChjYWxsYmFja0xpc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2V0IHRoZSBsaXN0IHRvIG51bGwgdG8gbWFrZSBzdXJlIHRoZXkgZG9uJ3QgZ2V0IGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cbiAgcXVldWUuY2FsbGJhY2tMaXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdXBkYXRlID0gY2FsbGJhY2tMaXN0W2ldO1xuICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgLy8gVGhpcyB1cGRhdGUgbWlnaHQgYmUgcHJvY2Vzc2VkIGFnYWluLiBDbGVhciB0aGUgY2FsbGJhY2sgc28gaXQncyBvbmx5XG4gICAgLy8gY2FsbGVkIG9uY2UuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gbnVsbDtcbiAgICAhKHR5cGVvZiBfY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgX2NhbGxiYWNrKSA6IHZvaWQgMDtcbiAgICBfY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuXFwndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG52YXIgUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpIHtcbiAgLy8gQ2xhc3MgY29tcG9uZW50IHN0YXRlIHVwZGF0ZXJcbiAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBwYXJ0aWFsU3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdyZXBsYWNlU3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHN0YXRlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9LFxuICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgICAgaXNGb3JjZWQ6IHRydWUsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpIHtcbiAgICBpZiAob2xkUHJvcHMgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpIHtcbiAgICAgIC8vIElmIHRoZSB3b3JrSW5Qcm9ncmVzcyBhbHJlYWR5IGhhcyBhbiBVcGRhdGUgZWZmZWN0LCByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBub0dldEluaXRpYWxTdGF0ZU9uRVM2ID0gIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdGFuY2Uuc3RhdGU7XG4gICAgICB3YXJuaW5nKG5vR2V0SW5pdGlhbFN0YXRlT25FUzYsICdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9ICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkO1xuICAgICAgd2FybmluZyhub0dldERlZmF1bHRQcm9wc09uRVM2LCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VQcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlQ29udGV4dFR5cGVzID0gIWluc3RhbmNlLmNvbnRleHRUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZUNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAmJiB0eXBlLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBub0NvbXBvbmVudERpZFVubW91bnQgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRVbm1vdW50LCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhaGFzTXV0YXRlZFByb3BzLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMgPSAhaW5zdGFuY2UuZGVmYXVsdFByb3BzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlRGVmYXVsdFByb3BzLCAnU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKHN0YXRlICYmICh0eXBlb2Ygc3RhdGUgIT09ICdvYmplY3QnIHx8IGlzQXJyYXkoc3RhdGUpKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm5pbmcodHlwZW9mIHdvcmtJblByb2dyZXNzLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuICAgIGlmIChuZWVkc0NvbnRleHQpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgfVxuXG4gICAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuICBmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuXG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICFwcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIG11c3QgYmUgcGVuZGluZyBwcm9wcyBmb3IgYW4gaW5pdGlhbCBtb3VudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBzdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIHdvcmtJblByb2dyZXNzLnR5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW50ZXJuYWxDb250ZXh0VGFnIHw9IEFzeW5jVXBkYXRlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uIGEgcHJlZXhpc3RpbmcgY2xhc3MgaW5zdGFuY2UuIFJldHVybnMgZmFsc2UgaWYgYSByZXN1bWVkIHJlbmRlclxuICAvLyBjb3VsZCBiZSByZXVzZWQuXG4gIC8vIGZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgLy8gICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIC8vICAgcHJpb3JpdHlMZXZlbDogUHJpb3JpdHlMZXZlbCxcbiAgLy8gKTogYm9vbGVhbiB7XG4gIC8vICAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgLy8gICBsZXQgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAvLyAgIGxldCBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgLy8gICBpZiAoIW5ld1Byb3BzKSB7XG4gIC8vICAgICAvLyBJZiB0aGVyZSBpc24ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgLy8gICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAvLyAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAvLyAgICAgaW52YXJpYW50KFxuICAvLyAgICAgICBuZXdQcm9wcyAhPSBudWxsLFxuICAvLyAgICAgICAnVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBwZW5kaW5nIG9yIG1lbW9pemVkIHByb3BzLiBUaGlzIGVycm9yIGlzICcgK1xuICAvLyAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG4gIC8vICAgY29uc3QgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgLy8gICBjb25zdCBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAvLyAgIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAvLyAgIGNvbnN0IG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAvLyAgIGlmIChcbiAgLy8gICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmXG4gIC8vICAgICAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpXG4gIC8vICAgKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlIGJlZm9yZSBjYWxsaW5nIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAvLyAgIGNvbnN0IHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBUT0RPOiBTaG91bGQgd2UgZGVhbCB3aXRoIGEgc2V0U3RhdGUgdGhhdCBoYXBwZW5lZCBhZnRlciB0aGUgbGFzdFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgYmVmb3JlIHRoaXMgY29tcG9uZW50V2lsbE1vdW50PyBQcm9iYWJseVxuICAvLyAgIC8vIHVuc3VwcG9ydGVkIGFueXdheS5cblxuICAvLyAgIGlmIChcbiAgLy8gICAgICFjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gICAgIC8vIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dC5cbiAgLy8gICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBwb2ludGVycyBub3cgc28gdGhhdCB0aGV5IGFyZSBjb3JyZWN0IHdoZW4gd2UgY2FsbFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudFxuICAvLyAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIC8vICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgbWF5IGhhdmUgY2FsbGVkIHNldFN0YXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vICAgICBjb25zdCBuZXdVcGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgICAgaWYgKG5ld1VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICAgIG5ld1VwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICAgICk7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgLy8gICB9XG5cbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cblxuICAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAgICAgbmV3UHJvcHMgPSBvbGRQcm9wcztcbiAgICAgICEobmV3UHJvcHMgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIG5leHQgc3RhdGUgdXNpbmcgdGhlIG1lbW9pemVkIHN0YXRlIGFuZCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gVE9ETzogUHJldmlvdXMgc3RhdGUgY2FuIGJlIG51bGwuXG4gICAgdmFyIG5ld1N0YXRlID0gdm9pZCAwO1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgICAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzKTtcbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2U6IGFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIC8vIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICB1cGRhdGVDbGFzc0luc3RhbmNlOiB1cGRhdGVDbGFzc0luc3RhbmNlXG4gIH07XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB2YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3QgPSB2b2lkIDA7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IHZvaWQgMDtcbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgICAgIWluc3QgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmICVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICAgIHZhciBzdHJpbmdSZWYgPSAnJyArIG1peGVkUmVmO1xuICAgICAgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHJlZnNbc3RyaW5nUmVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZzW3N0cmluZ1JlZl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgISh0eXBlb2YgbWl4ZWRSZWYgPT09ICdzdHJpbmcnKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLicpIDogdm9pZCAwO1xuICAgICAgIWVsZW1lbnQuX293bmVyID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoJXMpIGJ1dCBubyBvd25lciB3YXMgc2V0LiBZb3UgbWF5IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZC4gKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peGVkUmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChyZXR1cm5GaWJlci50eXBlICE9PSAndGV4dGFyZWEnKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAge1xuICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZCkgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbignLCAnKSArICd9JyA6IG5ld0NoaWxkLCBhZGRlbmR1bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKCkge1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcblxuICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgd2FybmluZyhmYWxzZSwgJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xufVxuXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGFsc28gY29tcGFyZSBoYW5kbGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldXNlP1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50LCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgICBfY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDIucmVmID0gY29lcmNlUmVmKG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tQ2FsbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDNbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4obmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0LnR5cGUgPSBuZXdDaGlsZC52YWx1ZTtcbiAgICAgICAgICAgIF9jcmVhdGVkNFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNSA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ1O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkNiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQ2WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQ2O1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGFcbiAgICAgICAgICAgIC8vIHlpZWxkLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAgICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgcmV0dXJucywgdGhleSBtYXRjaC5cbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyNCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI0LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI1ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI1LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJXMnLCBrZXksIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RocyBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cblxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cblxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAge1xuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcG9zc2libGVNYXAgPSBuZXdDaGlsZHJlbkl0ZXJhYmxlO1xuICAgICAgICBpZiAocG9zc2libGVNYXAuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEobmV3Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmICghb2xkRmliZXIpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA6IGNoaWxkLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ3ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ3WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gY2FsbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gQ2FsbENvbXBvbmVudCkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcmV0dXJuTm9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24geWllbGRzIHNpbmNlIHRoZXkncmUgc3RhdGVsZXNzLlxuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgZXhpc3RpbmcudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwgJiYgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSAmJiBuZXdDaGlsZC5rZXkgPT09IG51bGwpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB0aGUgbmV3IGNoaWxkIGlzIHVuZGVmaW5lZCwgYW5kIHRoZSByZXR1cm4gZmliZXIgaXMgYSBjb21wb3NpdGVcbiAgICAgIC8vIGNvbXBvbmVudCwgdGhyb3cgYW4gZXJyb3IuIElmIEZpYmVyIHJldHVybiB0eXBlcyBhcmUgZGlzYWJsZWQsXG4gICAgICAvLyB3ZSBhbHJlYWR5IHRocmV3IGFib3ZlLlxuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICEoY3VycmVudCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gY3VycmVudC5jaGlsZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cbiAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbnZhciBSZWFjdEZpYmVyQmVnaW5Xb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcikge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUgPSBjb25maWcuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTtcbiAgdmFyIHB1c2hIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGV4dCxcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250YWluZXI7XG4gIHZhciBlbnRlckh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5lbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQucmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJDbGFzc0NvbXBvID0gUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50KHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpLFxuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5tb3VudENsYXNzSW5zdGFuY2UsXG4gICAgICB1cGRhdGVDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnVwZGF0ZUNsYXNzSW5zdGFuY2U7XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgYW5kIHVzZSByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgZGlyZWN0bHkuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG5cbiAgICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwgJiYgKCFjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBicmluZ2luZyBmbi5zaG91bGRDb21wb25lbnRVcGRhdGUoKSBiYWNrLlxuICAgICAgLy8gSXQgdXNlZCB0byBiZSBoZXJlLlxuICAgIH1cblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbihuZXh0UHJvcHMsIGNvbnRleHQpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgICAvLyBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KSB7XG4gICAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIC8vIFJlcmVuZGVyXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gICAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG51bGwsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChwcmV2U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgICAgLy8gbm8gd29yayB0aGF0IGV4cGlyZXMgYXQgdGhpcyB0aW1lLlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIGVsZW1lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAgICAgLy8gcm9vdC5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIHN0YXRlKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIHVwZGF0ZSBxdWV1ZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHRoZSByb290IGhhcyBubyBwcm9wcy5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgIShuZXh0UHJvcHMgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuXG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAocHJldlByb3BzICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICAgIGlmIChyZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgJiYgIXVzZVN5bmNTY2hlZHVsaW5nICYmIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKSkge1xuICAgICAgLy8gRG93bi1wcmlvcml0aXplIHRoZSBjaGlsZHJlbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gTmV2ZXI7XG4gICAgICAvLyBCYWlsb3V0IGFuZCBjb21lIGJhY2sgdG8gdGhpcyBmaWJlciBsYXRlci5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB9XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICEoY3VycmVudCA9PT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgaGF2ZSBtb3VudGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciB2YWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChmbi5wcm90b3R5cGUgJiYgdHlwZW9mIGZuLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB2YWx1ZSA9IGZuKHByb3BzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgaGFzQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uYWxDb21wb25lbnQ7XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuaW5nKCFDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMsICclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uYWwgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAgdmFyIG93bmVyTmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lKCk7XG4gICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgICAgIHZhciBkZWJ1Z1NvdXJjZSA9IHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZTtcbiAgICAgICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArICc6JyArIGRlYnVnU291cmNlLmxpbmVOdW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldKSB7XG4gICAgICAgICAgICB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJXMlcycsIGluZm8sIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDYWxsID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDYWxsID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENhbGwgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDYWxsID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDYWxsKSB7XG4gICAgICBuZXh0Q2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAvLyBUT0RPOiBXaGVuIGJhaWxpbmcgb3V0LCB3ZSBtaWdodCBuZWVkIHRvIHJldHVybiB0aGUgc3RhdGVOb2RlIGluc3RlYWRcbiAgICAgIC8vIG9mIHRoZSBjaGlsZC4gVG8gY2hlY2sgaXQgZm9yIHdvcmsuXG4gICAgICAvLyByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDYWxsLmNoaWxkcmVuO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBpcyBhIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGJ1dCB1c2luZ1xuICAgIC8vIHN0YXRlTm9kZSB0byBzdG9yZSB0aGUgY2hpbGQuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENhbGwpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgLypcbiAgZnVuY3Rpb24gcmV1c2VDaGlsZHJlbkVmZmVjdHMocmV0dXJuRmliZXIgOiBGaWJlciwgZmlyc3RDaGlsZCA6IEZpYmVyKSB7XG4gICAgbGV0IGNoaWxkID0gZmlyc3RDaGlsZDtcbiAgICBkbyB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZmlyc3QgYW5kIGxhc3QgZWZmZWN0IG9mIHRoZSBwYXJlbnQgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjaGlsZHJlbidzIGZpcnN0IGFuZCBsYXN0IGVmZmVjdC5cbiAgICAgIGlmICghcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5sYXN0RWZmZWN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkLmxhc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgfVxuICAqL1xuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAgIC8vIG1vcmUgd29yayB0byBkby4gSG93ZXZlciwgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHNlcGFyYXRpb24gb2YgdGhpc1xuICAgIC8vIEZpYmVyJ3MgcHJpb3JpdHkgYW5kIGl0cyBjaGlsZHJlbiB5ZXQgLSB3ZSBkb24ndCBrbm93IHdpdGhvdXQgZG9pbmcgbG90c1xuICAgIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gICAgLy8gYmFpbCBvdXQgaGVyZSBpZiB0aGUgY2hpbGRyZW4gaGFzIG5vIG1vcmUgd29yayBhdCB0aGlzIHByaW9yaXR5IGxldmVsLlxuICAgIC8vIGlmICh3b3JrSW5Qcm9ncmVzcy5wcmlvcml0eU9mQ2hpbGRyZW4gPD0gcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgLy8gICAvLyBjb21taXR0ZWQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGV5IGdldCBwcm9wZXJseSB0cmFuc2ZlcnJlZCB1cC5cbiAgICAvLyAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBIYW5kbGUgSG9zdENvbXBvbmVudCB0YWdzIGhlcmUgYXMgd2VsbCBhbmQgY2FsbCBwdXNoSG9zdENvbnRleHQoKT9cbiAgICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gICAgLy8gSG93IGNhbiB0aGF0IGhhcHBlbj8gSG93IGlzIHRoaXMgbm90IGJlaW5nIGNsb25lZD9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuICBmdW5jdGlvbiBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAgIC8vIGlzIGhhbmRsZWQgYnkgcHJvY2Vzc1VwZGF0ZVF1ZXVlLlxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlc3RhcnQuIFJlc2V0IHRoZSB0YWcgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCBzaW5jZSB0aGlzIGlzIG5vdyB0aGUgc2FtZS5cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBBIHJldHVybiBjb21wb25lbnQgaXMganVzdCBhIHBsYWNlaG9sZGVyLCB3ZSBjYW4ganVzdCBydW4gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gbmV4dCBvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGhlcmUgdG8gYXZvaWQgYSBwdXNoL3BvcCBjb250ZXh0IG1pc21hdGNoLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gZXJyb3IgZWZmZWN0IHNvIHdlIGNhbiBoYW5kbGUgdGhlIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IEVycjtcblxuICAgIC8vIFRoaXMgaXMgYSB3ZWlyZCBjYXNlIHdoZXJlIHdlIGRvIFwicmVzdW1lXCIgd29yayDigJQgd29yayB0aGF0IGZhaWxlZCBvblxuICAgIC8vIG91ciBmaXJzdCBhdHRlbXB0LiBCZWNhdXNlIHdlIG5vIGxvbmdlciBoYXZlIGEgbm90aW9uIG9mIFwicHJvZ3Jlc3NlZFxuICAgIC8vIGRlbGV0aW9ucyxcIiByZXNldCB0aGUgY2hpbGQgdG8gdGhlIGN1cnJlbnQgY2hpbGQgdG8gbWFrZSBzdXJlIHdlIGRlbGV0ZVxuICAgIC8vIGl0IGFnYWluLiBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcywgcGVyaGFwcyBkdXJpbmcgYSBtb3JlXG4gICAgLy8gZ2VuZXJhbCBvdmVyaGF1bCBvZiBlcnJvciBoYW5kbGluZy5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGJhaWwgb3V0LCB3ZSdyZSBnb2luZyBiZSByZWNvbXB1dGluZyBvdXIgY2hpbGRyZW4gc28gd2UgbmVlZFxuICAgIC8vIHRvIGRyb3Agb3VyIGVmZmVjdCBsaXN0LlxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIC8vIFVubW91bnQgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYXMgaWYgdGhlIGNvbXBvbmVudCByZW5kZXJlZCBudWxsXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbldvcms6IGJlZ2luV29yayxcbiAgICBiZWdpbkZhaWxlZFdvcms6IGJlZ2luRmFpbGVkV29ya1xuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJDb21wbGV0ZVdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCkge1xuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSBjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgcHJlcGFyZVVwZGF0ZSA9IGNvbmZpZy5wcmVwYXJlVXBkYXRlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcbiAgdmFyIGdldFJvb3RIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQuZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgZ2V0SG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5nZXRIb3N0Q29udGV4dCxcbiAgICAgIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYW4gVXBkYXRlQW5kUGxhY2VtZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFsbFJldHVybnMocmV0dXJucywgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZVsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQSBjYWxsIGNhbm5vdCBoYXZlIGhvc3QgY29tcG9uZW50IGNoaWxkcmVuLicpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybnMucHVzaChub2RlLnR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgIWNhbGwgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gY2FsbC5oYW5kbGVyO1xuICAgIHZhciBwcm9wcyA9IGNhbGwucHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IGZuKHByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG4gICAgICB2YXIgY2xvbmVJbnN0YW5jZSA9IHBlcnNpc3RlbmNlLmNsb25lSW5zdGFuY2UsXG4gICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5jcmVhdGVDb250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG5cbiAgICAgIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuXG4gICAgICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICAgICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICAgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIHVwZGF0ZVBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ05vb3AgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gR2V0IHRoZSBsYXRlc3QgcHJvcHMuXG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXdQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgIT09IE5ldmVyIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gUmVzZXQgdGhlIHBlbmRpbmcgcHJvcHMsIHVubGVzcyB0aGlzIHdhcyBhIGRvd24tcHJpb3JpdGl6YXRpb24uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGFyZSBsZWF2aW5nIHRoaXMgc3VidHJlZSwgc28gcG9wIGNvbnRleHQgaWYgYW55LlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuICAgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0Miwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBSZXNldCB0aGUgdGFnIHRvIG5vdyBiZSBhIGZpcnN0IHBoYXNlIGNhbGwuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcblxuXG4gIHZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICBzdGFydFBoYXNlVGltZXIoY3VycmVudCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuICB9O1xuXG4gIC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsID8gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJlZihnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuICAvLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuICAvLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuICBmdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHJlY3Vyc2l2ZS5cbiAgICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIgJiYgbXV0YXRpb24pIHtcbiAgICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyICYmIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TmVzdGVkVW5tb3VudHMocm9vdCkge1xuICAgIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAgIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gICAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAgIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICAgIW11dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSByb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCkge1xuICAgIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gICAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gICAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAgIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gICAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgICBjdXJyZW50WydyZXR1cm4nXSA9IG51bGw7XG4gICAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZVsncmV0dXJuJ10gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXV0YXRpb24pIHtcbiAgICB2YXIgY29tbWl0Q29udGFpbmVyID0gdm9pZCAwO1xuICAgIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgdmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0O1xuXG4gICAgICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgcG9ydGFsID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgfHwgZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXRQbGFjZW1lbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXREZWxldGlvbjogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICAgICAgICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjb21taXRXb3JrOiBmdW5jdGlvbiAoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlczogY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQ6IGNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uOiBjb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcms6IGNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWY6IGNvbW1pdERldGFjaFJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgfVxufTtcblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIFJlYWN0RmliZXJIb3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldENoaWxkSG9zdENvbnRleHQgPSBjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cblxuICB2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuXG4gICAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcblxuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIb3N0Q29udGFpbmVyKCkge1xuICAgIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0SG9zdENvbnRleHQ6IGdldEhvc3RDb250ZXh0LFxuICAgIGdldFJvb3RIb3N0Q29udGFpbmVyOiBnZXRSb290SG9zdENvbnRhaW5lcixcbiAgICBwb3BIb3N0Q29udGFpbmVyOiBwb3BIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250ZXh0OiBwb3BIb3N0Q29udGV4dCxcbiAgICBwdXNoSG9zdENvbnRhaW5lcjogcHVzaEhvc3RDb250YWluZXIsXG4gICAgcHVzaEhvc3RDb250ZXh0OiBwdXNoSG9zdENvbnRleHQsXG4gICAgcmVzZXRIb3N0Q29udGFpbmVyOiByZXNldEhvc3RDb250YWluZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgaHlkcmF0aW9uID0gY29uZmlnLmh5ZHJhdGlvbjtcblxuICAvLyBJZiB0aGlzIGRvZXNuJ3QgaGF2ZSBoeWRyYXRpb24gbW9kZS5cblxuICBpZiAoIWh5ZHJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwb3BIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSBoeWRyYXRpb24uZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSBoeWRyYXRpb24uZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RIeWRyYXRlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlO1xuXG4gIC8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG4gIHZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIHZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSk7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gICAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICBjaGlsZFRvRGVsZXRlWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAgIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAgIC8vIHJlY3JlYXRlZC5cbiAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gICAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIpO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgICAgLy8gdHJlZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgICAvLyBzaWJsaW5ncy5cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uXG4gICAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBlbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IHJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBwb3BIeWRyYXRpb25TdGF0ZVxuICB9O1xufTtcblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbnZhciBkZWZhdWx0U2hvd0RpYWxvZyA9IGZ1bmN0aW9uIChjYXB0dXJlZEVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNob3dEaWFsb2cgPSBkZWZhdWx0U2hvd0RpYWxvZztcblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0RpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbiAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlcnJvciAmJiBlcnJvci5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICBpZiAoc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIHdpbGxSZXRyeSA9IGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5O1xuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCcgKyBjb21wb25lbnROYW1lICsgJz4gY29tcG9uZW50OicgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6JztcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggJyArICgndXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1RoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLlxcbicgKyAnUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9ICcnICsgY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBjb21wb25lbnRTdGFjayArICdcXG5cXG4nICsgKCcnICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nICcgKyAnY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCBzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCAnICsgJ29yIGZvcmNlVXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgJyArICdjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHZhciB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgICAgICAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW5kZXInOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgXCJgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIFwiICsgJ2JlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yIHNpZGUtZWZmZWN0cyBhcmUgJyArICdhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYGNvbXBvbmVudFdpbGxNb3VudGAuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0RmliZXJTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBob3N0Q29udGV4dCA9IFJlYWN0RmliZXJIb3N0Q29udGV4dChjb25maWcpO1xuICB2YXIgaHlkcmF0aW9uQ29udGV4dCA9IFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0KGNvbmZpZyk7XG4gIHZhciBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICByZXNldEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5yZXNldEhvc3RDb250YWluZXI7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQmVnaW5Xb3JrID0gUmVhY3RGaWJlckJlZ2luV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpLFxuICAgICAgYmVnaW5Xb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5Xb3JrLFxuICAgICAgYmVnaW5GYWlsZWRXb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5GYWlsZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbXBsZXRlV28gPSBSZWFjdEZpYmVyQ29tcGxldGVXb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpLFxuICAgICAgY29tcGxldGVXb3JrID0gX1JlYWN0RmliZXJDb21wbGV0ZVdvLmNvbXBsZXRlV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21taXRXb3JrID0gUmVhY3RGaWJlckNvbW1pdFdvcmsoY29uZmlnLCBjYXB0dXJlRXJyb3IpLFxuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRSZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0UGxhY2VtZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yayA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRXb3JrLFxuICAgICAgY29tbWl0TGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIG5vdyA9IGNvbmZpZy5ub3csXG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5jYW5jZWxEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBwcmVwYXJlRm9yQ29tbWl0ID0gY29uZmlnLnByZXBhcmVGb3JDb21taXQsXG4gICAgICByZXNldEFmdGVyQ29tbWl0ID0gY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgY3VycmVudCB0aW1lIGluIG1zLlxuXG4gIHZhciBzdGFydFRpbWUgPSBub3coKTtcbiAgdmFyIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZSgwKTtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBleHBpcmF0aW9uIHRpbWUgdGhhdCBpbmNvbWluZyB1cGRhdGVzIHNob3VsZCB1c2UuIChJZiB0aGlzXG4gIC8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbiAgLy8gdXBkYXRlcyBpbiBzeW5jIG1vZGUuKVxuICB2YXIgZXhwaXJhdGlvbkNvbnRleHQgPSBOb1dvcms7XG5cbiAgdmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgdmFyIG5leHRSb290ID0gbnVsbDtcbiAgLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxuICB2YXIgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGNhcHR1cmVkIGFuIGVycm9yIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkLlxuICAvLyBXb3JrIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGNvbGxlY3Rpb24gYWZ0ZXIgY29tcG9uZW50RGlkQ2F0Y2ggaXMgY2FsbGVkLlxuICB2YXIgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGZhaWxlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2ggb2Ygd29yay5cbiAgLy8gVGhpcyBpcyBhIGRpZmZlcmVudCBzZXQgdGhhbiBjYXB0dXJlZEVycm9ycywgYmVjYXVzZSBpdCBpcyBub3QgcmVzZXQgdW50aWxcbiAgLy8gdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoaXMgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSBlcnJvcnMgY29ycmVjdGx5IGlmIGFcbiAgLy8gc3VidHJlZSBmYWlscyBtb3JlIHRoYW4gb25jZS5cbiAgdmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAvLyBFcnJvciBib3VuZGFyaWVzIHRoYXQgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSBjdXJyZW50IGNvbW1pdC5cbiAgdmFyIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gIHZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gIHZhciBpc1VubW91bnRpbmcgPSBmYWxzZTtcblxuICAvLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbiAgdmFyIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlc2V0Q29udGV4dFN0YWNrKCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFja1xuICAgIHJlc2V0JDEoKTtcbiAgICAvLyBSZXNldCB0aGUgY3Vyc29yc1xuICAgIHJlc2V0Q29udGV4dCgpO1xuICAgIHJlc2V0SG9zdENvbnRhaW5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgICB9XG4gICAgICByZWNvcmRFZmZlY3QoKTtcblxuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gICAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgICAvLyBwb3NzaWJsZSBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgIC8vIGVmZmVjdCB0YWcgYW5kIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuICAgICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+KENhbGxiYWNrIHwgRXJyIHwgQ29udGVudFJlc2V0IHwgUmVmIHwgUGVyZm9ybWVkV29yayk7XG4gICAgICBzd2l0Y2ggKHByaW1hcnlFZmZlY3RUYWcpIHtcbiAgICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkXG4gICAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAgIC8vIHRvIGtpbGwgdGhpcy5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIEVycikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0RXJyb3JIYW5kbGluZyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSb290KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhpcyBzbyB0aGF0IGNhcHR1cmVFcnJvciBjYW4gY29sbGVjdCBhbnkgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgY2FwdHVyZSBhbiBlcnJvciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhlIHJlYXNvbiB0aGVzZSBhcmVuJ3RcbiAgICAvLyBsb2NhbCB0byB0aGlzIGZ1bmN0aW9uIGlzIGJlY2F1c2UgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIGNXVSBhcmVcbiAgICAvLyBjYXB0dXJlZCBlbHNld2hlcmUsIHRvIHByZXZlbnQgdGhlIHVubW91bnQgZnJvbSBiZWluZyBpbnRlcnJ1cHRlZC5cbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICEocm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmspID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyByZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gdm9pZCAwO1xuICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZlxuICAgICAgLy8gaXQgaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9XG5cbiAgICBwcmVwYXJlRm9yQ29tbWl0KCk7XG5cbiAgICAvLyBDb21taXQgYWxsIHRoZSBzaWRlLWVmZmVjdHMgd2l0aGluIGEgdHJlZS4gV2UnbGwgZG8gdGhpcyBpbiB0d28gcGFzc2VzLlxuICAgIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gICAgLy8gcmVmIHVubW91bnRzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdCgpO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgY29tbWl0QWxsTGlmZUN5Y2xlcywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgX2RpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgc3RvcENvbW1pdFRpbWVyKCk7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbW1pdFdvcmsoZmluaXNoZWRXb3JrKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBjYXVnaHQgYW55IGVycm9ycyBkdXJpbmcgdGhpcyBjb21taXQsIHNjaGVkdWxlIHRoZWlyIGJvdW5kYXJpZXNcbiAgICAvLyB0byB1cGRhdGUuXG4gICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcykge1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmZvckVhY2goc2NoZWR1bGVFcnJvclJlY292ZXJ5KTtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9lcnJvcjMgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgb25VbmNhdWdodEVycm9yKF9lcnJvcjMpO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdUaW1lID0gcm9vdC5jdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuXG4gICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZ1RpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gICAgaWYgKHJlbmRlclRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gVGhlIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IGFyZSBoaWRkZW4uIERvbid0IGJ1YmJsZSB0aGVpclxuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcGVuZGluZyB1cGRhdGVzLlxuICAgIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IENhbGxzIG5lZWQgdG8gdmlzaXQgc3RhdGVOb2RlXG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC5leHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gY2hpbGQuZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gY2hpbGQuZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3NbJ3JldHVybiddO1xuICAgICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICAgIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAvLyBzaWRlLWVmZmVjdHMuIFdlIGNhbiBwZXJmb3JtIGNlcnRhaW4gc2lkZS1lZmZlY3RzIGVhcmxpZXIgaWZcbiAgICAgICAgLy8gbmVlZGVkLCBieSBkb2luZyBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZWZmZWN0IGxpc3QuIFdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgLy8gcmV1c2luZyBjaGlsZHJlbiB3ZSdsbCBzY2hlZHVsZSB0aGlzIGVmZmVjdCBvbnRvIGl0c2VsZiBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBhdCB0aGUgZW5kLlxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0IGxpc3QuXG4gICAgICAgIC8vIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZSBjb21taXR0ZWQuXG4gICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBiZWdpbkZhaWxlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgdW5oYW5kbGVkIGVycm9ycywgc3dpdGNoIHRvIHRoZSBzbG93IHdvcmsgbG9vcC5cbiAgICAgIC8vIFRPRE86IEhvdyB0byBhdm9pZCB0aGlzIGNoZWNrIGluIHRoZSBmYXN0IHBhdGg/IE1heWJlIHRoZSByZW5kZXJlclxuICAgICAgLy8gY291bGQga2VlcCB0cmFjayBvZiB3aGljaCByb290cyBoYXZlIHVuaGFuZGxlZCBlcnJvcnMgYW5kIGNhbGwgYVxuICAgICAgLy8gZm9ya2VkIHZlcnNpb24gb2YgcmVuZGVyUm9vdC5cbiAgICAgIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNsb3dXb3JrTG9vcFRoYXRDaGVja3NGb3JGYWlsZWRXb3JrKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA8PSBtb3N0UmVjZW50Q3VycmVudFRpbWUpIHtcbiAgICAgIC8vIEZsdXNoIGFsbCBleHBpcmVkIHdvcmsuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGhhc0NhcHR1cmVkRXJyb3IobmV4dFVuaXRPZldvcmspKSB7XG4gICAgICAgICAgLy8gVXNlIGEgZm9ya2VkIHZlcnNpb24gb2YgcGVyZm9ybVVuaXRPZldvcmtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdENhdGNoQmxvY2socm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UncmUgZ29pbmcgdG8gcmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IuXG4gICAgLy8gQ29uY2VwdHVhbGx5LCB3ZSdyZSB1bndpbmRpbmcgdGhlIHN0YWNrLiBXZSBuZWVkIHRvIHVud2luZCB0aGVcbiAgICAvLyBjb250ZXh0IHN0YWNrLCB0b28uXG4gICAgdW53aW5kQ29udGV4dHMoZmFpbGVkV29yaywgYm91bmRhcnkpO1xuXG4gICAgLy8gUmVzdGFydCB0aGUgZXJyb3IgYm91bmRhcnkgdXNpbmcgYSBmb3JrZWQgdmVyc2lvbiBvZlxuICAgIC8vIHBlcmZvcm1Vbml0T2ZXb3JrIHRoYXQgZGVsZXRlcyB0aGUgYm91bmRhcnkncyBjaGlsZHJlbi4gVGhlIGVudGlyZVxuICAgIC8vIGZhaWxlZCBzdWJyZWUgd2lsbCBiZSB1bm1vdW50ZWQuIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCBhIHNwZWNpYWxcbiAgICAvLyBsaWZlY3ljbGUgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGUgZXJyb3IgYm91bmRhcnksIHdoaWNoIHRyaWdnZXJzXG4gICAgLy8gYSByZS1yZW5kZXIuXG4gICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhib3VuZGFyeSk7XG5cbiAgICAvLyBDb250aW51ZSB3b3JraW5nLlxuICAgIHdvcmtMb29wKGV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzV29ya2luZyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuXG4gICAgLy8gV2UncmUgYWJvdXQgdG8gbXV0YXRlIHRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUuIElmIHRoZSByb290IHdhcyBwZW5kaW5nXG4gICAgLy8gY29tbWl0LCBpdCBubyBsb25nZXIgaXM6IHdlJ2xsIG5lZWQgdG8gY29tcGxldGUgaXQgYWdhaW4uXG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBzdGFydGluZyBmcm9tIGEgZnJlc2ggc3RhY2ssIG9yIGlmIHdlJ3JlIHJlc3VtaW5nIGZyb21cbiAgICAvLyBwcmV2aW91c2x5IHlpZWxkZWQgd29yay5cbiAgICBpZiAocm9vdCAhPT0gbmV4dFJvb3QgfHwgZXhwaXJhdGlvblRpbWUgIT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSB8fCBuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgLy8gUmVzZXQgdGhlIHN0YWNrIGFuZCBzdGFydCB3b3JraW5nIGZyb20gdGhlIHJvb3QuXG4gICAgICByZXNldENvbnRleHRTdGFjaygpO1xuICAgICAgbmV4dFJvb3QgPSByb290O1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspO1xuXG4gICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIGVycm9yID0gbnVsbDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCB3b3JrTG9vcCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHdoaWxlIChkaWRFcnJvcikge1xuICAgICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICAgIC8vIFRoaXMgd2FzIGEgZmF0YWwgZXJyb3IuIERvbid0IGF0dGVtcHQgdG8gcmVjb3ZlciBmcm9tIGl0LlxuICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWlsZWRXb3JrID0gbmV4dFVuaXRPZldvcms7XG4gICAgICBpZiAoZmFpbGVkV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBBbiBlcnJvciB3YXMgdGhyb3duIGJ1dCB0aGVyZSdzIG5vIGN1cnJlbnQgdW5pdCBvZiB3b3JrLiBUaGlzIGNhblxuICAgICAgICAvLyBoYXBwZW4gZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiQ2FwdHVyZVwiIHRoZSBlcnJvciBieSBmaW5kaW5nIHRoZSBuZWFyZXN0IGJvdW5kYXJ5LiBJZiB0aGVyZSBpcyBub1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIHdlIHVzZSB0aGUgcm9vdC5cbiAgICAgIHZhciBib3VuZGFyeSA9IGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcik7XG4gICAgICAhKGJvdW5kYXJ5ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhlIGVycm9yIHdlIGp1c3QgY2FwdHVyZWQgd2FzIGEgZmF0YWwgZXJyb3IuIFRoaXMgaGFwcGVuc1xuICAgICAgICAvLyB3aGVuIHRoZSBlcnJvciBwcm9wYWdhdGVzIHRvIHRoZSByb290IG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgcmVuZGVyUm9vdENhdGNoQmxvY2ssIG51bGwsIHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSdyZSBmaW5pc2hlZCB3b3JraW5nLiBFeGl0IHRoZSBlcnJvciBsb29wLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHVuY2F1Z2h0RXJyb3IgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG5cbiAgICAvLyBXZSdyZSBkb25lIHBlcmZvcm1pbmcgd29yay4gVGltZSB0byBjbGVhbiB1cC5cbiAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5KTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBkaWRGYXRhbCA9IGZhbHNlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgICBpZiAodW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgb25VbmNhdWdodEVycm9yKHVuY2F1Z2h0RXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiByb290LmlzUmVhZHlGb3JDb21taXQgPyByb290LmN1cnJlbnQuYWx0ZXJuYXRlIDogbnVsbDtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLCBvciBudWxsIGlmIHRoZSBlcnJvciBpcyBpZ25vcmVkXG4gIGZ1bmN0aW9uIGNhcHR1cmVFcnJvcihmYWlsZWRXb3JrLCBlcnJvcikge1xuICAgIC8vIEl0IGlzIG5vIGxvbmdlciB2YWxpZCBiZWNhdXNlIHdlIGV4aXRlZCB0aGUgdXNlciBjb2RlLlxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LlxuICAgIHZhciBib3VuZGFyeSA9IG51bGw7XG5cbiAgICAvLyBQYXNzZWQgdG8gbG9nQ2FwdHVyZWRFcnJvcigpXG4gICAgdmFyIGVycm9yQm91bmRhcnlGb3VuZCA9IGZhbHNlO1xuICAgIHZhciB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuXG4gICAgLy8gSG9zdCBjb250YWluZXJzIGFyZSBhIHNwZWNpYWwgY2FzZS4gSWYgdGhlIGZhaWxlZCB3b3JrIGl0c2VsZiBpcyBhIGhvc3RcbiAgICAvLyBjb250YWluZXIsIHRoZW4gaXQgYWN0cyBhcyBpdHMgb3duIGJvdW5kYXJ5LiBJbiBhbGwgb3RoZXIgY2FzZXMsIHdlXG4gICAgLy8gaWdub3JlIHRoZSB3b3JrIGl0c2VsZiBhbmQgb25seSBzZWFyY2ggdGhyb3VnaCB0aGUgcGFyZW50cy5cbiAgICBpZiAoZmFpbGVkV29yay50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBib3VuZGFyeSA9IGZhaWxlZFdvcms7XG5cbiAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KGZhaWxlZFdvcmspKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vdCBhbHJlYWR5IGZhaWxlZCwgdGhlcmUgbXVzdCBoYXZlIGJlZW4gYW4gZXJyb3Igd2hlblxuICAgICAgICAvLyBhdHRlbXB0aW5nIHRvIHVubW91bnQgaXQuIFRoaXMgaXMgYSB3b3JzdC1jYXNlIHNjZW5hcmlvIGFuZFxuICAgICAgICAvLyBzaG91bGQgb25seSBiZSBwb3NzaWJsZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IGZhaWxlZFdvcmtbJ3JldHVybiddO1xuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgYm91bmRhcnkgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWUobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIEZvdW5kIGFuIGVycm9yIGJvdW5kYXJ5IVxuICAgICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICAgICAgd2lsbFJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgLy8gVHJlYXQgdGhlIHJvb3QgbGlrZSBhIG5vLW9wIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgYm91bmRhcnkgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkobm9kZSkpIHtcbiAgICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgaW4gYSBmYWlsZWQgc3RhdGUuXG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZywgdGhhdCBtZWFucyB0aGlzIGVycm9yIHdhc1xuICAgICAgICAgIC8vIHRocm93biB3aGlsZSB1bm1vdW50aW5nIGEgZmFpbGVkIHN1YnRyZWUuIFdlIHNob3VsZCBpZ25vcmVcbiAgICAgICAgICAvLyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKGlzVW5tb3VudGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIGNvbW1pdCBwaGFzZSwgd2Ugc2hvdWxkIGNoZWNrIHRvIHNlZSBpZlxuICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhpcyBjb21taXQuXG4gICAgICAgICAgLy8gVGhpcyBjYXNlIGV4aXN0cyBiZWNhdXNlIG11bHRpcGxlIGVycm9ycyBjYW4gYmUgdGhyb3duIGR1cmluZ1xuICAgICAgICAgIC8vIGEgc2luZ2xlIGNvbW1pdCB3aXRob3V0IGludGVycnVwdGlvbi5cbiAgICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzICE9PSBudWxsICYmIChjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUpIHx8IG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZS5hbHRlcm5hdGUpKSkge1xuICAgICAgICAgICAgLy8gSWYgc28sIHdlIHNob3VsZCBpZ25vcmUgdGhpcyBlcnJvci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBlcnJvciBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5IC3igJQgd2Uga2VlcCBsb29raW5nLlxuICAgICAgICAgIGJvdW5kYXJ5ID0gbnVsbDtcbiAgICAgICAgICB3aWxsUmV0cnkgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0byB0aGUgY29sbGVjdGlvbiBvZiBmYWlsZWQgYm91bmRhcmllcy4gVGhpcyBsZXRzIHVzIGtub3cgdGhhdFxuICAgICAgLy8gc3Vic2VxdWVudCBlcnJvcnMgaW4gdGhpcyBzdWJ0cmVlIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgZmFpbGVkQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuXG4gICAgICAvLyBUaGlzIG1ldGhvZCBpcyB1bnNhZmUgb3V0c2lkZSBvZiB0aGUgYmVnaW4gYW5kIGNvbXBsZXRlIHBoYXNlcy5cbiAgICAgIC8vIFdlIG1pZ2h0IGJlIGluIHRoZSBjb21taXQgcGhhc2Ugd2hlbiBhbiBlcnJvciBpcyBjYXB0dXJlZC5cbiAgICAgIC8vIFRoZSByaXNrIGlzIHRoYXQgdGhlIHJldHVybiBwYXRoIGZyb20gdGhpcyBGaWJlciBtYXkgbm90IGJlIGFjY3VyYXRlLlxuICAgICAgLy8gVGhhdCByaXNrIGlzIGFjY2VwdGFibGUgZ2l2ZW4gdGhlIGJlbmVmaXQgb2YgcHJvdmlkaW5nIHVzZXJzIG1vcmUgY29udGV4dC5cbiAgICAgIHZhciBfY29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZhaWxlZFdvcmspO1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmYWlsZWRXb3JrKTtcblxuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGNhcHR1cmVkIGVycm9ycy4gVGhpcyBpcyBzdG9yZWQgYXMgYSBnbG9iYWxcbiAgICAgIC8vIG1hcCBvZiBlcnJvcnMgYW5kIHRoZWlyIGNvbXBvbmVudCBzdGFjayBsb2NhdGlvbiBrZXllZCBieSB0aGUgYm91bmRhcmllc1xuICAgICAgLy8gdGhhdCBjYXB0dXJlIHRoZW0uIFdlIG1vc3RseSB1c2UgdGhpcyBNYXAgYXMgYSBTZXQ7IGl0J3MgYSBNYXAgb25seSB0b1xuICAgICAgLy8gYXZvaWQgYWRkaW5nIGEgZmllbGQgdG8gRmliZXIgdG8gc3RvcmUgdGhlIGVycm9yLlxuICAgICAgaWYgKGNhcHR1cmVkRXJyb3JzID09PSBudWxsKSB7XG4gICAgICAgIGNhcHR1cmVkRXJyb3JzID0gbmV3IE1hcCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogX2NvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBfY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeTogZXJyb3JCb3VuZGFyeUZvdW5kID8gYm91bmRhcnkuc3RhdGVOb2RlIDogbnVsbCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kOiBlcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lOiBlcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgd2lsbFJldHJ5OiB3aWxsUmV0cnlcbiAgICAgIH07XG5cbiAgICAgIGNhcHR1cmVkRXJyb3JzLnNldChib3VuZGFyeSwgY2FwdHVyZWRFcnJvcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFByZXZlbnQgY3ljbGUgaWYgbG9nQ2FwdHVyZWRFcnJvcigpIHRocm93cy5cbiAgICAgICAgLy8gQSBjeWNsZSBtYXkgc3RpbGwgb2NjdXIgaWYgbG9nQ2FwdHVyZWRFcnJvciByZW5kZXJzIGEgY29tcG9uZW50IHRoYXQgdGhyb3dzLlxuICAgICAgICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZSAmJiBlLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gICAgICAgIGlmICghc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCBkZWZlciBzY2hlZHVsaW5nIGFuIHVwZGF0ZSBvbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5IHVudGlsIGFmdGVyIHRoZSBjb21taXQgaXMgY29tcGxldGVcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2NoZWR1bGUgYW4gdXBkYXRlIG5vdy5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyBhY3R1YWxseSBuZWNlc3NhcnkgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2U/IElzIGl0XG4gICAgICAgIC8vIHBvc3NpYmxlIHRvIHVud2luZCBhbmQgY29udGludWUgcmVuZGVyaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5LFxuICAgICAgICAvLyB3aXRob3V0IGNvcnJ1cHRpbmcgaW50ZXJuYWwgc3RhdGU/XG4gICAgICAgIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShib3VuZGFyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfSBlbHNlIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIG5vIGJvdW5kYXJ5IGlzIGZvdW5kLCB3ZSdsbCBuZWVkIHRvIHRocm93IHRoZSBlcnJvclxuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ2FwdHVyZWRFcnJvcihmaWJlcikge1xuICAgIC8vIFRPRE86IGNhcHR1cmVkRXJyb3JzIHNob3VsZCBzdG9yZSB0aGUgYm91bmRhcnkgaW5zdGFuY2UsIHRvIGF2b2lkIG5lZWRpbmdcbiAgICAvLyB0byBjaGVjayB0aGUgYWx0ZXJuYXRlLlxuICAgIHJldHVybiBjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCAmJiAoY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgY2FwdHVyZWRFcnJvcnMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWlsZWRCb3VuZGFyeShmaWJlcikge1xuICAgIC8vIFRPRE86IGZhaWxlZEJvdW5kYXJpZXMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWRcbiAgICAvLyBuZWVkaW5nIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBmaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRFcnJvckhhbmRsaW5nKGVmZmVjdGZ1bEZpYmVyKSB7XG4gICAgdmFyIGNhcHR1cmVkRXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGNhcHR1cmVkRXJyb3JzICE9PSBudWxsKSB7XG4gICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICBpZiAoY2FwdHVyZWRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIGlmIChlZmZlY3RmdWxGaWJlci5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBlZmZlY3RmdWxGaWJlciA9IGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yID0gY2FwdHVyZWRFcnJvcnMuZ2V0KGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgICAgICBjYXB0dXJlZEVycm9yc1snZGVsZXRlJ10oZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjYXB0dXJlZEVycm9yICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnTm8gZXJyb3IgZm9yIGdpdmVuIHVuaXQgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHN3aXRjaCAoZWZmZWN0ZnVsRmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBlZmZlY3RmdWxGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgY29tcG9uZW50U3RhY2s6IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2tcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBbGxvdyB0aGUgYm91bmRhcnkgdG8gaGFuZGxlIHRoZSBlcnJvciwgdXN1YWxseSBieSBzY2hlZHVsaW5nXG4gICAgICAgIC8vIGFuIHVwZGF0ZSB0byBpdHNlbGZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goY2FwdHVyZWRFcnJvci5lcnJvciwgaW5mbyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVud2luZENvbnRleHRzKGZyb20sIHRvKSB7XG4gICAgdmFyIG5vZGUgPSBmcm9tO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gdG8gfHwgbm9kZS5hbHRlcm5hdGUgPT09IHRvKSB7XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIobm9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcihub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCkge1xuICAgIC8vIEdpdmVuIHRoZSBjdXJyZW50IGNsb2NrIHRpbWUsIHJldHVybnMgYW4gZXhwaXJhdGlvbiB0aW1lLiBXZSB1c2Ugcm91bmRpbmdcbiAgICAvLyB0byBiYXRjaCBsaWtlIHVwZGF0ZXMgdG9nZXRoZXIuXG4gICAgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiB+MTAwMG1zLiAxMjAwbXMgbWF4LlxuICAgIHZhciBjdXJyZW50VGltZSA9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gMTAwMDtcbiAgICB2YXIgYnVja2V0U2l6ZU1zID0gMjAwO1xuICAgIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbk1zLCBidWNrZXRTaXplTXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcikge1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICBpZiAoZXhwaXJhdGlvbkNvbnRleHQgIT09IE5vV29yaykge1xuICAgICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIH0gZWxzZSBpZiAoaXNXb3JraW5nKSB7XG4gICAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAgIC8vIGJ5IGRlZmF1bHQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZXMgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugc2hvdWxkIGV4cGlyZSBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gICAgICAgIC8vIHRoZSB3b3JrIHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAgIC8vIHBlcmZvcm1pbmcgd29yay4gQ2FsY3VsYXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmICh1c2VTeW5jU2NoZWR1bGluZyAmJiAhKGZpYmVyLmludGVybmFsQ29udGV4dFRhZyAmIEFzeW5jVXBkYXRlcykpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICghaXNXb3JraW5nICYmIHJvb3QgPT09IG5leHRSb290ICYmIGV4cGlyYXRpb25UaW1lIDwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBSZXN0YXJ0IHRoZSByb290IGZyb20gdGhlIHRvcC5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGludGVycnVwdGlvbi4gKFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLilcbiAgICAgICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgICAgfVxuICAgICAgbmV4dFJvb3QgPSBudWxsO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBpc0Vycm9yUmVjb3ZlcnkpIHtcbiAgICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIGVhY2ggbm9kZSdzXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoZmliZXIpIHtcbiAgICBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBTeW5jLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIHZhciBtcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gU3luYztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4gIC8vIHJlbmRlcmVycy4gSSdsbCBkbyB0aGlzIGluIGEgZm9sbG93LXVwLlxuXG4gIC8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG4gIHZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICB2YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuXG4gIHZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgY2FsbGJhY2tJRCA9IC0xO1xuICB2YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgdmFyIG5leHRGbHVzaGVkUm9vdCA9IG51bGw7XG4gIHZhciBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbiAgdmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gIHZhciB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gIHZhciBkZWFkbGluZSA9IG51bGw7XG5cbiAgdmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIHZhciBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuICB2YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDEwMDA7XG4gIHZhciBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cbiAgdmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FsbGJhY2tFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICAgIGlmIChleHBpcmF0aW9uVGltZSA+IGNhbGxiYWNrRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIHN1ZmZpY2llbnQgdGltZW91dC4gRXhpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIGluc3VmZmljaWVudCB0aW1lb3V0LiBDYW5jZWwgYW5kIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gbmV3IG9uZS5cbiAgICAgICAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjayhjYWxsYmFja0lEKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGNhbGxiYWNrIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZy4gRG9uJ3Qgc3RhcnQgYSBuZXcgb25lLlxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHRpbWVvdXQgZm9yIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGN1cnJlbnRNcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvbk1zIC0gY3VycmVudE1zO1xuXG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIGNhbGxiYWNrSUQgPSBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yaywgeyB0aW1lb3V0OiB0aW1lb3V0IH0pO1xuICB9XG5cbiAgLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbiAgLy8gSXQncyB1cCB0byB0aGUgcmVuZGVyZXIgdG8gY2FsbCByZW5kZXJSb290IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cbiAgZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgICAvLyBDaGVjayBpZiB0aGlzIHJvb3QgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzY2hlZHVsZS5cbiAgICBpZiAocm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgYnV0IGl0cyBwcmlvcml0eSBtYXkgaGF2ZSBpbmNyZWFzZWQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgZXhwaXJhdGlvblRpbWUgPCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LlxuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAgIC8vIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJhdGNoLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcykge1xuICAgICAgLy8gRmx1c2ggd29yayBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaC5cbiAgICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAgIC8vIC4uLnVubGVzcyB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlcywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmx1c2ggaXQgbm93LlxuICAgICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIFN5bmMgYW5kIHVzZSBjdXJyZW50IHRpbWU/XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5V29yayA9IE5vV29yaztcbiAgICB2YXIgaGlnaGVzdFByaW9yaXR5Um9vdCA9IG51bGw7XG5cbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICAgICAgICAvLyBUaGlzIHJvb3Qgbm8gbG9uZ2VyIGhhcyB3b3JrLiBSZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGVyLlxuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyBjaGVjayBpcyByZWR1ZGFudCwgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGJyYW5jaFxuICAgICAgICAgIC8vIGJlbG93IHdoZXJlIHdlIHNldCBsYXN0U2NoZWR1bGVkUm9vdCB0byBudWxsLCBldmVuIHRob3VnaCB3ZSBicmVha1xuICAgICAgICAgIC8vIGZyb20gdGhlIGxvb3AgcmlnaHQgYWZ0ZXIuXG4gICAgICAgICAgIShwcmV2aW91c1NjaGVkdWxlZFJvb3QgIT09IG51bGwgJiYgbGFzdFNjaGVkdWxlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChyb290ID09PSByb290Lm5leHRTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gZmlyc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmspIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHksIGlmIGl0J3MgaGlnaGVyXG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlSb290ID0gcm9vdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIHZhciBwcmV2aW91c0ZsdXNoZWRSb290ID0gbmV4dEZsdXNoZWRSb290O1xuICAgIGlmIChwcmV2aW91c0ZsdXNoZWRSb290ICE9PSBudWxsICYmIHByZXZpb3VzRmx1c2hlZFJvb3QgPT09IGhpZ2hlc3RQcmlvcml0eVJvb3QpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHdoZW5ldmVyIHdlIHN3aXRjaCByb290cy5cbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICB9XG4gICAgbmV4dEZsdXNoZWRSb290ID0gaGlnaGVzdFByaW9yaXR5Um9vdDtcbiAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Bc3luY1dvcmsoZGwpIHtcbiAgICBwZXJmb3JtV29yayhOb1dvcmssIGRsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lLCBkbCkge1xuICAgIGRlYWRsaW5lID0gZGw7XG5cbiAgICAvLyBLZWVwIHdvcmtpbmcgb24gcm9vdHMgdW50aWwgdGhlcmUncyBubyBtb3JlIHdvcmssIG9yIHVudGlsIHRoZSB3ZSByZWFjaFxuICAgIC8vIHRoZSBkZWFkbGluZS5cbiAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gICAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkgJiYgZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDwgcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8PSBtaW5FeHBpcmF0aW9uVGltZSkgJiYgIWRlYWRsaW5lRGlkRXhwaXJlKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBoaWdoZXN0IHByaW9yaXR5IHdvcmsuXG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIH1cblxuICAgIC8vIFdlJ3JlIGRvbmUgZmx1c2hpbmcgd29yay4gRWl0aGVyIHdlIHJhbiBvdXQgb2YgdGltZSBpbiB0aGlzIGNhbGxiYWNrLFxuICAgIC8vIG9yIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGxlZnQgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICAgIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgIGNhbGxiYWNrSUQgPSAtMTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gICAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIC8vIENsZWFuLXVwLlxuICAgIGRlYWRsaW5lID0gbnVsbDtcbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIF9lcnJvcjQgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgICB0aHJvdyBfZXJyb3I0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gICAgLy8gVE9ETzogUGFzcyBjdXJyZW50IHRpbWUgYXMgYXJndW1lbnQgdG8gcmVuZGVyUm9vdCwgY29tbWl0Um9vdFxuICAgIGlmIChleHBpcmF0aW9uVGltZSA8PSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENvbW1pdCBpdC5cbiAgICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KF9maW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gTWFyayB0aGlzIHJvb3QgYXMgY29tcGxldGUuIFdlJ2xsIGNvbWVcbiAgICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gV2hlbiB3b3JraW5nIG9uIGFzeW5jIHdvcmssIHRoZSByZWNvbmNpbGVyIGFza3MgdGhlIHJlbmRlcmVyIGlmIGl0IHNob3VsZFxuICAvLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbiAgZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gICAgaWYgKGRlYWRsaW5lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yaykge1xuICAgICAgLy8gRGlzcmVnYXJkIGRlYWRsaW5lLmRpZFRpbWVvdXQuIE9ubHkgZXhwaXJlZCB3b3JrIHNob3VsZCBiZSBmbHVzaGVkXG4gICAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRPRE86IE5vdCBoYXBweSBhYm91dCB0aGlzIGhvb2suIENvbmNlcHR1YWxseSwgcmVuZGVyUm9vdCBzaG91bGQgcmV0dXJuIGFcbiAgLy8gdHVwbGUgb2YgKGlzUmVhZHlGb3JDb21taXQsIGRpZEVycm9yLCBlcnJvcilcbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbikge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgc2NoZWR1bGVXb3JrOiBzY2hlZHVsZVdvcmssXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXNcbiAgfTtcbn07XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcbiAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbn1cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgICAgc2NoZWR1bGVXb3JrID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuc2NoZWR1bGVXb3JrLFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB7XG4gICAgICBpZiAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9PT0gJ3JlbmRlcicgJiYgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICB7XG4gICAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICAvLyBDaGVjayBpZiB0aGUgdG9wLWxldmVsIGVsZW1lbnQgaXMgYW4gYXN5bmMgd3JhcHBlciBjb21wb25lbnQuIElmIHNvLFxuICAgIC8vIHRyZWF0IHVwZGF0ZXMgdG8gdGhlIHJvb3QgYXMgYXN5bmMuIFRoaXMgaXMgYSBiaXQgd2VpcmQgYnV0IGxldHMgdXNcbiAgICAvLyBhdm9pZCBhIHNlcGFyYXRlIGByZW5kZXJBc3luY2AgQVBJLlxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQudHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpO1xuICAgIH0sXG4gICAgdXBkYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgfSxcblxuXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzLFxuXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG5cbiAgICBnZXRQdWJsaWNSb290SW5zdGFuY2U6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9LFxuICAgIGluamVjdEludG9EZXZUb29sczogZnVuY3Rpb24gKGRldlRvb2xzQ29uZmlnKSB7XG4gICAgICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcblxuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RGaWJlclJlY29uY2lsZXIkMVxufSk7XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQzID0gKCBSZWFjdEZpYmVyUmVjb25jaWxlciQyICYmIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgKSB8fCBSZWFjdEZpYmVyUmVjb25jaWxlciQyO1xuXG4vLyBUT0RPOiBidW5kbGUgRmxvdyB0eXBlcyB3aXRoIHRoZSBwYWNrYWdlLlxuXG5cblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3RSZWNvbmNpbGVyID0gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddID8gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddIDogUmVhY3RGaWJlclJlY29uY2lsZXIkMztcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sXG4vLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydCBvZiB0aGUgZnJhbWUsIHRoZW5cbi8vIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC4gV2l0aGluIHRoZVxuLy8gcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lIHJhdGUuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbntcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG52YXIgaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbnZhciBub3cgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gY2FuY2VsLCBiZWNhdXNlIEZpYmVyIGRvZXNuJ3QgYXRtLlxudmFyIHJJQyA9IHZvaWQgMDtcbnZhciBjSUMgPSB2b2lkIDA7XG5cbmlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHJJQyA9IGZ1bmN0aW9uIChmcmFtZUNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgZnJhbWVDYWxsYmFjayh7XG4gICAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBjSUMgPSBmdW5jdGlvbiAodGltZW91dElEKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjayBhbmQgY2FuY2VsSWRsZUNhbGxiYWNrXG5cbiAgdmFyIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgdGltZW91dFRpbWUgPSAtMTtcblxuICB2YXIgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lID0gMDtcbiAgLy8gV2Ugc3RhcnQgb3V0IGFzc3VtaW5nIHRoYXQgd2UgcnVuIGF0IDMwZnBzIGJ1dCB0aGVuIHRoZSBoZXVyaXN0aWMgdHJhY2tpbmdcbiAgLy8gd2lsbCBhZGp1c3QgdGhpcyB2YWx1ZSB0byBhIGZhc3RlciBmcHMgaWYgd2UgZ2V0IG1vcmUgZnJlcXVlbnQgYW5pbWF0aW9uXG4gIC8vIGZyYW1lcy5cbiAgdmFyIHByZXZpb3VzRnJhbWVUaW1lID0gMzM7XG4gIHZhciBhY3RpdmVGcmFtZVRpbWUgPSAzMztcblxuICB2YXIgZnJhbWVEZWFkbGluZU9iamVjdDtcbiAgaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgICAgIC8vIGdldHMgYSBwZXJmb3JtYW5jZSB0aW1lciB2YWx1ZS4gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgdHJ1ZS5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBEYXRlLm5vdygpXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZyA+IDAgPyByZW1haW5pbmcgOiAwO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgICB2YXIgY3VycmVudFRpbWUgPSBub3coKTtcbiAgICBpZiAoZnJhbWVEZWFkbGluZSAtIGN1cnJlbnRUaW1lIDw9IDApIHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuIENoZWNrIGlmIHRoZSBjYWxsYmFjayBoYXNcbiAgICAgIC8vIGEgdGltZW91dCBhbmQgd2hldGhlciBpdCdzIGJlZW4gZXhjZWVkZWQuXG4gICAgICBpZiAodGltZW91dFRpbWUgIT09IC0xICYmIHRpbWVvdXRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgIC8vIEV4Y2VlZGVkIHRoZSB0aW1lb3V0LiBJbnZva2UgdGhlIGNhbGxiYWNrIGV2ZW4gdGhvdWdoIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gdGltZSBsZWZ0LlxuICAgICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gdGltZW91dC5cbiAgICAgICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW5vdGhlciBhbmltYXRpb24gY2FsbGJhY2sgc28gd2UgcmV0cnkgbGF0ZXIuXG4gICAgICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4aXQgd2l0aG91dCBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBzdGlsbCB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC5cbiAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBySUMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBvbmx5IHNjaGVkdWxlIG9uZSBjYWxsYmFjayBhdCBhIHRpbWUgYmVjYXVzZSB0aGF0J3NcbiAgICAvLyBob3cgRmliZXIgdXNlcyBpdC5cbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRpbWVvdXRUaW1lID0gbm93KCkgKyBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBjSUMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHRpbWVvdXRUaW1lID0gLTE7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjaztcbiAgY0lDID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxuLy8gaXNBdHRyaWJ1dGVOYW1lU2FmZSgpIGlzIGN1cnJlbnRseSBkdXBsaWNhdGVkIGluIERPTU1hcmt1cE9wZXJhdGlvbnMuXG4vLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHBsYWNlIGZvciB0aGlzLlxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbnZhciB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNob3VsZElnbm9yZVZhbHVlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xuXG5cblxuXG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCB8fCBwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcblxuICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBudWxsO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyBpbiBvdXIgY29uZmlnIGF0bS5cbiAgICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgZXhwZWN0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIGV4cGVjdGVkKSB7XG4gIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuXG4gIGlmIChwcm9wZXJ0eUluZm8gJiYgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSkge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSA/IHZhbHVlIDogbnVsbCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICB9XG5cbiAge1xuICAgIFxuICB9XG59XG5cbi8qKlxuICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSkge1xuICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbn1cblxuLyoqXG4gKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVbcHJvcE5hbWVdID0gJyc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzID0ge1xuICBjaGVja1Byb3BUeXBlczogbnVsbFxufTtcblxue1xuICB2YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICBidXR0b246IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIHJhZGlvOiB0cnVlLFxuICAgIHJlc2V0OiB0cnVlLFxuICAgIHN1Ym1pdDogdHJ1ZVxuICB9O1xuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICAgKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICAgKi9cbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIGdldFN0YWNrKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCB0YWdOYW1lLCBnZXRTdGFjayk7XG4gIH07XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAudHlwZSBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMgKHNldHRpbmcgLnZhbHVlXG4gICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5zdGVwIGJlZm9yZSAudmFsdWUgKHNldHRpbmcgLnZhbHVlIGJlZm9yZSAuc3RlcFxuICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC5taW4gJiAubWF4IGJlZm9yZSAudmFsdWUgKHRvIGVuc3VyZSBwcm9wZXIgb3JkZXJcbiAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgbWluOiB1bmRlZmluZWQsXG4gICAgbWF4OiB1bmRlZmluZWRcbiAgfSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWRcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICBub2RlLnZhbHVlID0gJzAnO1xuICAgICAgLy8gTm90ZTogSUU5IHJlcG9ydHMgYSBudW1iZXIgaW5wdXRzIGFzICd0ZXh0Jywgc28gY2hlY2sgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBTaW11bGF0ZSBgaW5wdXQudmFsdWVBc051bWJlcmAuIElFOSBkb2VzIG5vdCBzdXBwb3J0IGl0XG4gICAgICB2YXIgdmFsdWVBc051bWJlciA9IHBhcnNlRmxvYXQobm9kZS52YWx1ZSkgfHwgMDtcblxuICAgICAgaWYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB2YWx1ZSAhPSB2YWx1ZUFzTnVtYmVyIHx8XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlID09IHZhbHVlQXNOdW1iZXIgJiYgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgIC8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbiAgICAgIC8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4gICAgICAvL1xuICAgICAgLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbiAgICAgIC8vXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgLy8gcHJvdmlkZWQuXG5cbiAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgY2FzZSAnc3VibWl0JzpcbiAgICBjYXNlICdyZXNldCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb2xvcic6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgY2FzZSAndGltZSc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgLy8gV2UgY2FuIHNpbGVudGx5IHNraXAgdGhlbSBiZWNhdXNlIGludmFsaWQgRE9NIG5lc3Rpbmcgd2FybmluZ1xuICAvLyBjYXRjaGVzIHRoZXNlIGNhc2VzIGluIEZpYmVyLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAge1xuICAgIHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG57XG4gIHZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMygpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLm11bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gIC8vIHRoaXMgdmFsdWUgZG93blxuICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLiVzJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgZ2V0U3RhY2spIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCQxIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLiVzJywgZ2V0U3RhY2soKSk7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0oKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgY29ycmVjdE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQxKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgd2hpdGVsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gICdkZWZhdWx0JzogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gICdpbic6ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gICd0eXBlb2YnOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMigpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuICAgIGlmIChjYW5Vc2VFdmVudFN5c3RlbSkge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuICcgKyAnUmVhY3QgZXZlbnRzIHVzZSB0aGUgY2FtZWxDYXNlIG5hbWluZyBjb252ZW50aW9uLCBmb3IgZXhhbXBsZSBgb25DbGlja2AuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCB0eXBlb2YgdmFsdWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IGlzUmVzZXJ2ZWRQcm9wKG5hbWUpO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LiVzJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgIXNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKCFzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pO1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gTmFtZXNwYWNlcy5odG1sO1xuXG5cbnZhciBnZXRTdGFjayA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoJycpO1xuXG57XG4gIGdldFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyO1xuXG4gIHZhciB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBDaHJvbWUgaXMgdGhlIG9ubHkgbWFqb3IgYnJvd3NlciBub3Qgc2hpcHBpbmcgPHRpbWU+LiBCdXQgYXMgb2YgSnVseVxuICAgIC8vIDIwMTcgaXQgaW50ZW5kcyB0byBzaGlwIGl0IGR1ZSB0byB3aWRlc3ByZWFkIHVzYWdlLiBXZSBpbnRlbnRpb25hbGx5XG4gICAgLy8gKmRvbid0KiB3YXJuIGZvciA8dGltZT4gZXZlbiBpZiBpdCdzIHVucmVjb2duaXplZCBieSBDaHJvbWUgYmVjYXVzZVxuICAgIC8vIGl0IHNvb24gd2lsbCBiZSwgYW5kIG1hbnkgYXBwcyBoYXZlIGJlZW4gdXNpbmcgaXQgYW55d2F5LlxuICAgIHRpbWU6IHRydWUsXG4gICAgLy8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG4gICAgZGlhbG9nOiB0cnVlXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgLyogY2FuVXNlRXZlbnRTeXN0ZW0gKi90cnVlKTtcbiAgfTtcblxuICAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cbiAgdmFyIE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCA9IC9cXHJcXG4/L2c7XG4gIHZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbiAgdmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB2YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVGV4dCBjb250ZW50IGRpZCBub3QgbWF0Y2guIFNlcnZlcjogXCIlc1wiIENsaWVudDogXCIlc1wiJywgbm9ybWFsaXplZFNlcnZlclRleHQsIG5vcm1hbGl6ZWRDbGllbnRUZXh0KTtcbiAgfTtcblxuICB2YXIgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB2YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJXMnLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuICB2YXIgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gV2UgcG9seWZpbGwgaXQgc2VwYXJhdGVseSBvbiB0aGUgY2xpZW50IGR1cmluZyBjb21taXQuXG4gICAgICAvLyBXZSBibGFja2xpc3QgaXQgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgcHJvcGVydHkgbGlzdCBiZWNhdXNlIHdlIGVtaXQgaXQgaW4gU1NSLlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgLy8gVE9ETzogSGFuZGxlIHdhc0N1c3RvbUNvbXBvbmVudFRhZ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZVBheWxvYWQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgcHJvcEtleSA9IHVwZGF0ZVBheWxvYWRbaV07XG4gICAgdmFyIHByb3BWYWx1ZSA9IHVwZGF0ZVBheWxvYWRbaSArIDFdO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICB3YXJuaW5nKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHR5cGUgPT09IHR5cGUudG9Mb3dlckNhc2UoKSwgJzwlcyAvPiBpcyB1c2luZyB1cHBlcmNhc2UgSFRNTC4gQWx3YXlzIHVzZSBsb3dlcmNhc2UgSFRNTCB0YWdzICcgKyAnaW4gUmVhY3QuJywgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHR5cGUpO1xuICB9XG5cbiAge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHZhciBwcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFRvZ2dsZScsICd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjayk7XG5cbiAgc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgcHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG5cbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMsIGdldFN0YWNrKTtcblxuICB2YXIgcHJvcEtleTtcbiAgdmFyIHN0eWxlTmFtZTtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gTm9vcC4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBjbGVhciB0ZXh0IG1lY2hhbmlzbS5cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIE5vb3AuIEl0IGRvZXNuJ3Qgd29yayBvbiB1cGRhdGVzIGFueXdheS5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEl0IG1pZ2h0IGJlIHRvbyBsYXRlIHRvIGNsZWFyIHRoaXMgaWYgd2UgaGF2ZSBjaGlsZHJlblxuICAgICAgICAvLyBpbnNlcnRlZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmIChsYXN0UHJvcCAhPT0gbmV4dFByb3AgJiYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4gICAgICAvLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSB3aGl0ZWxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMkMShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmLlxuICB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICB1cGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhciBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHtcbiAgICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IHJhd1Byb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09ICcnICsgbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbztcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkU2V0QXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wKSkge1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICBpZiAoZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplID4gMCAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgLy8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4gICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgIC8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3RcbiAgICAgIC8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cblxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxKHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxKHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUZpYmVyQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlJDEsXG5cdHNldEluaXRpYWxQcm9wZXJ0aWVzOiBzZXRJbml0aWFsUHJvcGVydGllcyQxLFxuXHRkaWZmUHJvcGVydGllczogZGlmZlByb3BlcnRpZXMkMSxcblx0dXBkYXRlUHJvcGVydGllczogdXBkYXRlUHJvcGVydGllcyQxLFxuXHRkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFRleHQ6IGRpZmZIeWRyYXRlZFRleHQkMSxcblx0d2FybkZvclVubWF0Y2hlZFRleHQ6IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDEsXG5cdHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxLFxuXHRyZXN0b3JlQ29udHJvbGxlZFN0YXRlOiByZXN0b3JlQ29udHJvbGxlZFN0YXRlXG59KTtcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvJDEgPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnLCBpbnN0YW5jZSkge1xuICAgIHZhciBhbmNlc3RvckluZm8gPSBfYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoY2hpbGRUYWcgPT0gbnVsbCwgJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIGFkZGVuZHVtID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2KCk7XG5cbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBhZGRlbmR1bTtcbiAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbywgYWRkZW5kdW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiB0dXJuIHRoaXMgaW50byBhIG5hbWVkIGV4cG9ydFxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8kMTtcblxuICAvLyBGb3IgdGVzdGluZ1xuICB2YWxpZGF0ZURPTU5lc3RpbmcuaXNUYWdWYWxpZEluQ29udGV4dCA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuICAgIHJldHVybiBpc1RhZ1ZhbGlkV2l0aFBhcmVudCh0YWcsIHBhcmVudFRhZykgJiYgIWZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcodGFnLCBhbmNlc3RvckluZm8pO1xuICB9O1xufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nJDEgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBjcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xudmFyIGNyZWF0ZVRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUkMTtcbnZhciBzZXRJbml0aWFsUHJvcGVydGllcyA9IHNldEluaXRpYWxQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZlByb3BlcnRpZXMgPSBkaWZmUHJvcGVydGllcyQxO1xudmFyIHVwZGF0ZVByb3BlcnRpZXMgPSB1cGRhdGVQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkUHJvcGVydGllcyA9IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRUZXh0ID0gZGlmZkh5ZHJhdGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JVbm1hdGNoZWRUZXh0ID0gd2FybkZvclVubWF0Y2hlZFRleHQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDE7XG52YXIgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0ID0gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDE7XG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZyQxLnVwZGF0ZWRBbmNlc3RvckluZm87XG52YXIgcHJlY2FjaGVGaWJlck5vZGUgPSBwcmVjYWNoZUZpYmVyTm9kZSQxO1xudmFyIHVwZGF0ZUZpYmVyUHJvcHMgPSB1cGRhdGVGaWJlclByb3BzJDE7XG5cblxue1xuICB2YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fCBTZXQucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG5pbmplY3Rpb24kMy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KFJlYWN0RE9NRmliZXJDb21wb25lbnQpO1xuXG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGlzIGEgdmFsaWQgbm9kZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBpcyBhIHZhbGlkIERPTSBub2RlLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWxlbWVudCAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gISFwcm9wcy5hdXRvRm9jdXM7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRE9NUmVuZGVyZXIgPSByZWFjdFJlY29uY2lsZXIoe1xuICBnZXRSb290SG9zdENvbnRleHQ6IGZ1bmN0aW9uIChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgICB2YXIgbmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcbiAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgICBjYXNlIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICAgIHZhciByb290ID0gcm9vdENvbnRhaW5lckluc3RhbmNlLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBjb250YWluZXIubmFtZXNwYWNlVVJJIHx8IG51bGw7XG4gICAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgdmFyIHZhbGlkYXRlZFRhZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB2YWxpZGF0ZWRUYWcsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXNwYWNlO1xuICB9LFxuICBnZXRDaGlsZEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocGFyZW50SG9zdENvbnRleHQsIHR5cGUpIHtcbiAgICB7XG4gICAgICB2YXIgcGFyZW50SG9zdENvbnRleHREZXYgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICAgIHZhciBfbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50SG9zdENvbnRleHREZXYubmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgIHZhciBfYW5jZXN0b3JJbmZvMiA9IHVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogX25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvMiB9O1xuICAgIH1cbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgcmV0dXJuIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSk7XG4gIH0sXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0sXG4gIHByZXBhcmVGb3JDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBldmVudHNFbmFibGVkID0gaXNFbmFibGVkKCk7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO1xuICAgIHNldEVuYWJsZWQoZmFsc2UpO1xuICB9LFxuICByZXNldEFmdGVyQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbik7XG4gICAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuICAgIHNldEVuYWJsZWQoZXZlbnRzRW5hYmxlZCk7XG4gICAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIH0sXG4gIGNyZWF0ZUluc3RhbmNlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIHByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgfVxuICAgIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgIHJldHVybiBkb21FbGVtZW50O1xuICB9LFxuICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0sXG4gIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHJldHVybiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgfSxcbiAgcHJlcGFyZVVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIH0sXG4gIHNob3VsZFNldFRleHRDb250ZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sID09PSAnc3RyaW5nJztcbiAgfSxcbiAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuICEhcHJvcHMuaGlkZGVuO1xuICB9LFxuICBjcmVhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMShudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgICByZXR1cm4gdGV4dE5vZGU7XG4gIH0sXG5cblxuICBub3c6IG5vdyxcblxuICBtdXRhdGlvbjoge1xuICAgIGNvbW1pdE1vdW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gICAgICAvLyB3aXRoIGN1cnJlbnQgZXZlbnQgaGFuZGxlcnMuXG4gICAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIG5ld1Byb3BzKTtcbiAgICAgIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbiAgICB9LFxuICAgIHJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50KSB7XG4gICAgICBkb21FbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAgfSxcbiAgICBjb21taXRUZXh0VXBkYXRlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaHlkcmF0aW9uOiB7XG4gICAgY2FuSHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSB0ZXh0IG5vZGUuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5leHQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG4gICAgaHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7XG4gICAgICAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgICAgIC8vIGdldCBhdHRhY2hlZC5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICB9LFxuICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSkge1xuICAgICAge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcykge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazogcklDLFxuICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrOiBjSUMsXG5cbiAgdXNlU3luY1NjaGVkdWxpbmc6ICFlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NXG59KTtcblxuaW5qZWN0aW9uJDQuaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyhET01SZW5kZXJlci5iYXRjaGVkVXBkYXRlcyk7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybmluZyhob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyLCAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpKTtcblxuICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuXG4gICAgd2FybmluZyhjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIGlmICghc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHNob3VsZEh5ZHJhdGUpO1xuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG5ld1Jvb3Q7XG4gICAgLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgRE9NUmVuZGVyZXIudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIG5ld1Jvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIERPTVJlbmRlcmVyLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChjb250YWluZXIsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgdGhpcy5fcmVhY3RSb290Q29udGFpbmVyID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBjcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICBmaW5kRE9NTm9kZTogZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgd2FybmluZyh3YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSBnZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgcmV0dXJuIERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2UoaW5zdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlLiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXMocGFyZW50Q29tcG9uZW50KSkgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCk7XG4gICAgICAgIHdhcm5pbmcoIXJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKF9yb290RWwpKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICB3YXJuaW5nKCFoYXNOb25Sb290UmVhY3RDaGlsZCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIFRlbXBvcmFyeSBhbGlhcyBzaW5jZSB3ZSBhbHJlYWR5IHNoaXBwZWQgUmVhY3QgMTYgUkMgd2l0aCBpdC5cbiAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LlxuICB1bnN0YWJsZV9jcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBET01SZW5kZXJlci5kZWZlcnJlZFVwZGF0ZXMsXG5cbiAgZmx1c2hTeW5jOiBET01SZW5kZXJlci5mbHVzaFN5bmMsXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICAvLyBGb3IgVGFwRXZlbnRQbHVnaW4gd2hpY2ggaXMgcG9wdWxhciBpbiBvcGVuIHNvdXJjZVxuICAgIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1YixcbiAgICAvLyBVc2VkIGJ5IHRlc3QtdXRpbHNcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudFBsdWdpblJlZ2lzdHJ5LFxuICAgIEV2ZW50UHJvcGFnYXRvcnM6IEV2ZW50UHJvcGFnYXRvcnMsXG4gICAgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OiBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQsXG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUsXG4gICAgUmVhY3RET01FdmVudExpc3RlbmVyOiBSZWFjdERPTUV2ZW50TGlzdGVuZXJcbiAgfVxufTtcblxuaWYgKGVuYWJsZUNyZWF0ZVJvb3QpIHtcbiAgUmVhY3RET00uY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICAgIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSk7XG4gIH07XG59XG5cbnZhciBmb3VuZERldlRvb2xzID0gRE9NUmVuZGVyZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBidW5kbGVUeXBlOiAxLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgLy8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycgKyAocHJvdG9jb2wgPT09ICdmaWxlOicgPyAnXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scy1mYXEnIDogJycpLCAnZm9udC13ZWlnaHQ6Ym9sZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxudmFyIFJlYWN0RE9NJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RET01cbn0pO1xuXG52YXIgUmVhY3RET00kMyA9ICggUmVhY3RET00kMiAmJiBSZWFjdERPTSApIHx8IFJlYWN0RE9NJDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0RG9tID0gUmVhY3RET00kM1snZGVmYXVsdCddID8gUmVhY3RET00kM1snZGVmYXVsdCddIDogUmVhY3RET00kMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdERvbTtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdChlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lLmRlZmF1bHQ6ZX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgUmVhY3Q9X2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSksY2xhc3NDYWxsQ2hlY2s9ZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSxpbmhlcml0cz1mdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiB0KTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZihlLHQpOmUuX19wcm90b19fPXQpfSxwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuPWZ1bmN0aW9uKGUsdCl7aWYoIWUpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiF0fHxcIm9iamVjdFwiIT10eXBlb2YgdCYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9lOnR9LEFwcENvbnRhaW5lcj1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7cmV0dXJuIGNsYXNzQ2FsbENoZWNrKHRoaXMsdCkscG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLGUuYXBwbHkodGhpcyxhcmd1bWVudHMpKX1yZXR1cm4gaW5oZXJpdHModCxlKSx0LnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gUmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKX0sdH0oUmVhY3QuQ29tcG9uZW50KSxob3RfcHJvZD1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZX19LGFyZUNvbXBvbmVudHNFcXVhbD1mdW5jdGlvbihlLHQpe3JldHVybiBlPT09dH0sc2V0Q29uZmlnPWZ1bmN0aW9uKCl7fTtleHBvcnRzLkFwcENvbnRhaW5lcj1BcHBDb250YWluZXIsZXhwb3J0cy5ob3Q9aG90X3Byb2QsZXhwb3J0cy5hcmVDb21wb25lbnRzRXF1YWw9YXJlQ29tcG9uZW50c0VxdWFsLGV4cG9ydHMuc2V0Q29uZmlnPXNldENvbmZpZztcbiIsIid1c2Ugc3RyaWN0J1xuXG5pZiAoIW1vZHVsZS5ob3QgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9yZWFjdC1ob3QtbG9hZGVyLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9yZWFjdC1ob3QtbG9hZGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5mdW5jdGlvbiBBc3luY0NvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIGFzeW5jQ29tcG9uZW50UHJvdG90eXBlID0gQXN5bmNDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzeW5jQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKGFzeW5jQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTtcbiAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZmFjdG9yeVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxue1xuICAvLyBDb21wb25lbnQgdGhhdCBpcyBiZWluZyB3b3JrZWQgb25cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICByZXR1cm4gaW1wbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG57XG4gIHZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgdmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbiAgdmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIpKTtcbiAgICB9XG4gICAgc3RhY2sgKz0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBWQUxJRF9GUkFHTUVOVF9QUk9QUyA9IG5ldyBNYXAoW1snY2hpbGRyZW4nLCB0cnVlXSwgWydrZXknLCB0cnVlXV0pO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIHZhciBwcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXM7XG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0pO1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRDbGFzcy5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZnJhZ21lbnQ7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIVZBTElEX0ZSQUdNRU5UX1BST1BTLmhhcyhrZXkpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB0eXBlID09PSAnbnVtYmVyJztcbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyAmJiB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcbiAgdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6IEFzeW5jQ29tcG9uZW50LFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJpbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICdpcy1wbGFpbi1vYmplY3QnO1xuaW1wb3J0IFN0eWxpcyBmcm9tICdzdHlsaXMnO1xuaW1wb3J0IF9pbnNlcnRSdWxlUGx1Z2luIGZyb20gJ3N0eWxpcy1ydWxlLXNoZWV0JztcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIGNsb25lRWxlbWVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUkMihzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxudmFyIGh5cGhlbmF0ZV8xID0gaHlwaGVuYXRlJDI7XG5cbnZhciBoeXBoZW5hdGUgPSBoeXBoZW5hdGVfMTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZV8xID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuXG4vLyBcbnZhciBvYmpUb0NzcyA9IGZ1bmN0aW9uIG9ialRvQ3NzKG9iaiwgcHJldktleSkge1xuICB2YXIgY3NzID0gT2JqZWN0LmtleXMob2JqKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjaHVuayA9IG9ialtrZXldO1xuICAgIHJldHVybiBjaHVuayAhPT0gdW5kZWZpbmVkICYmIGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSBmYWxzZSAmJiBjaHVuayAhPT0gJyc7XG4gIH0pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3Qob2JqW2tleV0pKSByZXR1cm4gb2JqVG9Dc3Mob2JqW2tleV0sIGtleSk7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZV8xKGtleSkgKyAnOiAnICsgb2JqW2tleV0gKyAnOyc7XG4gIH0pLmpvaW4oJyAnKTtcbiAgcmV0dXJuIHByZXZLZXkgPyBwcmV2S2V5ICsgJyB7XFxuICAnICsgY3NzICsgJ1xcbn0nIDogY3NzO1xufTtcblxudmFyIGZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuKGNodW5rcywgZXhlY3V0aW9uQ29udGV4dCkge1xuICByZXR1cm4gY2h1bmtzLnJlZHVjZShmdW5jdGlvbiAocnVsZVNldCwgY2h1bmspIHtcbiAgICAvKiBSZW1vdmUgZmFsc2V5IHZhbHVlcyAqL1xuICAgIGlmIChjaHVuayA9PT0gdW5kZWZpbmVkIHx8IGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSBmYWxzZSB8fCBjaHVuayA9PT0gJycpIHtcbiAgICAgIHJldHVybiBydWxlU2V0O1xuICAgIH1cbiAgICAvKiBGbGF0dGVuIHJ1bGVTZXQgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaHVuaykpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQocnVsZVNldCwgZmxhdHRlbihjaHVuaywgZXhlY3V0aW9uQ29udGV4dCkpO1xuICAgIH1cblxuICAgIC8qIEhhbmRsZSBvdGhlciBjb21wb25lbnRzICovXG4gICAgaWYgKGNodW5rLmhhc093blByb3BlcnR5KCdzdHlsZWRDb21wb25lbnRJZCcpKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIG5vdCBzdXJlIGhvdyB0byBtYWtlIHRoaXMgcGFzc1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChydWxlU2V0LCBbJy4nICsgY2h1bmsuc3R5bGVkQ29tcG9uZW50SWRdKTtcbiAgICB9XG5cbiAgICAvKiBFaXRoZXIgZXhlY3V0ZSBvciBkZWZlciB0aGUgZnVuY3Rpb24gKi9cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZXhlY3V0aW9uQ29udGV4dCA/IHJ1bGVTZXQuY29uY2F0LmFwcGx5KHJ1bGVTZXQsIGZsYXR0ZW4oW2NodW5rKGV4ZWN1dGlvbkNvbnRleHQpXSwgZXhlY3V0aW9uQ29udGV4dCkpIDogcnVsZVNldC5jb25jYXQoY2h1bmspO1xuICAgIH1cblxuICAgIC8qIEhhbmRsZSBvYmplY3RzICovXG4gICAgcmV0dXJuIHJ1bGVTZXQuY29uY2F0KFxuICAgIC8vICRGbG93Rml4TWUgaGF2ZSB0byBhZGQgJWNoZWNrcyBzb21laG93IHRvIGlzUGxhaW5PYmplY3RcbiAgICBpc1BsYWluT2JqZWN0KGNodW5rKSA/IG9ialRvQ3NzKGNodW5rKSA6IGNodW5rLnRvU3RyaW5nKCkpO1xuICB9LCBbXSk7XG59O1xuXG4vLyBcbi8vIE5PVEU6IFRoaXMgc3R5bGlzIGluc3RhbmNlIGlzIG9ubHkgdXNlZCB0byBzcGxpdCBydWxlcyBmcm9tIFNTUidkIHN0eWxlIHRhZ3NcbnZhciBzdHlsaXNTcGxpdHRlciA9IG5ldyBTdHlsaXMoe1xuICBnbG9iYWw6IGZhbHNlLFxuICBjYXNjYWRlOiBmYWxzZSxcbiAga2V5ZnJhbWU6IGZhbHNlLFxuICBwcmVmaXg6IGZhbHNlLFxuICBjb21wcmVzczogZmFsc2UsXG4gIHNlbWljb2xvbjogdHJ1ZVxufSk7XG5cbnZhciBzdHlsaXMgPSBuZXcgU3R5bGlzKHtcbiAgZ2xvYmFsOiBmYWxzZSxcbiAgY2FzY2FkZTogdHJ1ZSxcbiAga2V5ZnJhbWU6IGZhbHNlLFxuICBwcmVmaXg6IHRydWUsXG4gIGNvbXByZXNzOiBmYWxzZSxcbiAgc2VtaWNvbG9uOiBmYWxzZSAvLyBOT1RFOiBUaGlzIG1lYW5zIFwiYXV0b2NvbXBsZXRlIG1pc3Npbmcgc2VtaWNvbG9uc1wiXG59KTtcblxuLy8gV3JhcCBgaW5zZXJ0UnVsZVBsdWdpbiB0byBidWlsZCBhIGxpc3Qgb2YgcnVsZXMsXG4vLyBhbmQgdGhlbiBtYWtlIG91ciBvd24gcGx1Z2luIHRvIHJldHVybiB0aGUgcnVsZXMuIFRoaXNcbi8vIG1ha2VzIGl0IGVhc2llciB0byBob29rIGludG8gdGhlIGV4aXN0aW5nIFNTUiBhcmNoaXRlY3R1cmVcblxudmFyIHBhcnNpbmdSdWxlcyA9IFtdO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgcmV0dXJuUnVsZXNQbHVnaW4gPSBmdW5jdGlvbiByZXR1cm5SdWxlc1BsdWdpbihjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0ID09PSAtMikge1xuICAgIHZhciBwYXJzZWRSdWxlcyA9IHBhcnNpbmdSdWxlcztcbiAgICBwYXJzaW5nUnVsZXMgPSBbXTtcbiAgICByZXR1cm4gcGFyc2VkUnVsZXM7XG4gIH1cbn07XG5cbnZhciBwYXJzZVJ1bGVzUGx1Z2luID0gX2luc2VydFJ1bGVQbHVnaW4oZnVuY3Rpb24gKHJ1bGUpIHtcbiAgcGFyc2luZ1J1bGVzLnB1c2gocnVsZSk7XG59KTtcblxuc3R5bGlzLnVzZShbcGFyc2VSdWxlc1BsdWdpbiwgcmV0dXJuUnVsZXNQbHVnaW5dKTtcbnN0eWxpc1NwbGl0dGVyLnVzZShbcGFyc2VSdWxlc1BsdWdpbiwgcmV0dXJuUnVsZXNQbHVnaW5dKTtcblxudmFyIHN0cmluZ2lmeVJ1bGVzID0gZnVuY3Rpb24gc3RyaW5naWZ5UnVsZXMocnVsZXMsIHNlbGVjdG9yLCBwcmVmaXgpIHtcbiAgdmFyIGZsYXRDU1MgPSBydWxlcy5qb2luKCcnKS5yZXBsYWNlKC9eXFxzKlxcL1xcLy4qJC9nbSwgJycpOyAvLyByZXBsYWNlIEpTIGNvbW1lbnRzXG5cbiAgdmFyIGNzc1N0ciA9IHNlbGVjdG9yICYmIHByZWZpeCA/IHByZWZpeCArICcgJyArIHNlbGVjdG9yICsgJyB7ICcgKyBmbGF0Q1NTICsgJyB9JyA6IGZsYXRDU1M7XG5cbiAgcmV0dXJuIHN0eWxpcyhwcmVmaXggfHwgIXNlbGVjdG9yID8gJycgOiBzZWxlY3RvciwgY3NzU3RyKTtcbn07XG5cbnZhciBzcGxpdEJ5UnVsZXMgPSBmdW5jdGlvbiBzcGxpdEJ5UnVsZXMoY3NzKSB7XG4gIHJldHVybiBzdHlsaXNTcGxpdHRlcignJywgY3NzKTtcbn07XG5cbi8vIFxuXG5mdW5jdGlvbiBpc1N0eWxlZENvbXBvbmVudCh0YXJnZXQpIC8qIDogJWNoZWNrcyAqL3tcbiAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHRhcmdldC5zdHlsZWRDb21wb25lbnRJZCA9PT0gJ3N0cmluZyc7XG59XG5cbi8vIFxuXG4vKiBUaGlzIGZ1bmN0aW9uIGlzIERFUFJFQ0FURUQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBvbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIHJlbGVhc2UuXG4gKiBJdCB3YXMgbmVlZGVkIHRvIHJlaHlkcmF0ZSBhbGwgc3R5bGUgYmxvY2tzIHByZXBlbmRlZCB0byBjaHVua3MgYmVmb3JlIFJlYWN0XG4gKiB0cmllcyB0byByZWh5ZHJhdGUgaXRzIEhUTUwgc3RyZWFtLiBTaW5jZSB0aGUgbWFzdGVyIFN0eWxlU2hlZXQgd2lsbCBub3cgZGV0ZWN0XG4gKiB0aGUgdXNlIG9mIHN0cmVhbWVkIHN0eWxlIHRhZ3MgYW5kIHdpbGwgcGVyZm9ybSB0aGUgcmVoeWRyYXRpb24gZWFybGllciB3aGVuIG5lZWRlZFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCBiZSBuZWVkZWQgYW55bW9yZSAqL1xuZnVuY3Rpb24gY29uc29saWRhdGVTdHJlYW1lZFN0eWxlcygpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2Fybignc3R5bGVkLWNvbXBvbmVudHMgYXV0b21hdGljYWxseSBkb2VzIHN0cmVhbWluZyBTU1IgcmVoeWRyYXRpb24gbm93LlxcbicgKyAnQ2FsbGluZyBjb25zb2xpZGF0ZVN0cmVhbWVkU3R5bGVzIG1hbnVhbGx5IGlzIG5vIGxvbmdlciBuZWNlc3NhcnkgYW5kIGEgbm9vcCBub3cuXFxuJyArICctIFBsZWFzZSByZW1vdmUgdGhlIGNvbnNvbGlkYXRlU3RyZWFtZWRTdHlsZXMgY2FsbCBmcm9tIHlvdXIgY2xpZW50LicpO1xuICB9XG59XG5cbi8vIFxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKiBUaGlzIGlzIHRoZSBcImNhcGFjaXR5XCIgb2Ygb3VyIGFscGhhYmV0IGkuZS4gMngyNiBmb3IgYWxsIGxldHRlcnMgcGx1cyB0aGVpciBjYXBpdGFsaXNlZFxuICogY291bnRlcnBhcnRzICovXG52YXIgY2hhcnNMZW5ndGggPSA1MjtcblxuLyogc3RhcnQgYXQgNzUgZm9yICdhJyB1bnRpbCAneicgKDI1KSBhbmQgdGhlbiBzdGFydCBhdCA2NSBmb3IgY2FwaXRhbGlzZWQgbGV0dGVycyAqL1xudmFyIGdldEFscGhhYmV0aWNDaGFyID0gZnVuY3Rpb24gZ2V0QWxwaGFiZXRpY0NoYXIoY29kZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlICsgKGNvZGUgPiAyNSA/IDM5IDogOTcpKTtcbn07XG5cbi8qIGlucHV0IGEgbnVtYmVyLCB1c3VhbGx5IGEgaGFzaCBhbmQgY29udmVydCBpdCB0byBiYXNlLTUyICovXG52YXIgZ2VuZXJhdGVBbHBoYWJldGljTmFtZSA9IGZ1bmN0aW9uIGdlbmVyYXRlQWxwaGFiZXRpY05hbWUoY29kZSkge1xuICB2YXIgbmFtZSA9ICcnO1xuICB2YXIgeCA9IHZvaWQgMDtcblxuICAvKiBnZXQgYSBjaGFyIGFuZCBkaXZpZGUgYnkgYWxwaGFiZXQtbGVuZ3RoICovXG4gIGZvciAoeCA9IGNvZGU7IHggPiBjaGFyc0xlbmd0aDsgeCA9IE1hdGguZmxvb3IoeCAvIGNoYXJzTGVuZ3RoKSkge1xuICAgIG5hbWUgPSBnZXRBbHBoYWJldGljQ2hhcih4ICUgY2hhcnNMZW5ndGgpICsgbmFtZTtcbiAgfVxuXG4gIHJldHVybiBnZXRBbHBoYWJldGljQ2hhcih4ICUgY2hhcnNMZW5ndGgpICsgbmFtZTtcbn07XG5cbi8vIFxuXG52YXIgaW50ZXJsZWF2ZSA9IChmdW5jdGlvbiAoc3RyaW5ncywgaW50ZXJwb2xhdGlvbnMpIHtcbiAgcmV0dXJuIGludGVycG9sYXRpb25zLnJlZHVjZShmdW5jdGlvbiAoYXJyYXksIGludGVycCwgaSkge1xuICAgIHJldHVybiBhcnJheS5jb25jYXQoaW50ZXJwLCBzdHJpbmdzW2kgKyAxXSk7XG4gIH0sIFtzdHJpbmdzWzBdXSk7XG59KTtcblxuLy8gXG52YXIgY3NzID0gKGZ1bmN0aW9uIChzdHJpbmdzKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpbnRlcnBvbGF0aW9ucyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBpbnRlcnBvbGF0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZmxhdHRlbihpbnRlcmxlYXZlKHN0cmluZ3MsIGludGVycG9sYXRpb25zKSk7XG59KTtcblxudmFyIHN0cmVhbSA9IHt9XG5cbi8vIFxuXG5cbnZhciBTQ19BVFRSID0gJ2RhdGEtc3R5bGVkLWNvbXBvbmVudHMnO1xudmFyIFNDX1NUUkVBTV9BVFRSID0gJ2RhdGEtc3R5bGVkLXN0cmVhbWVkJztcbnZhciBDT05URVhUX0tFWSA9ICdfX3N0eWxlZC1jb21wb25lbnRzLXN0eWxlc2hlZXRfXyc7XG5cbnZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ0hUTUxFbGVtZW50JyBpbiB3aW5kb3c7XG5cbnZhciBESVNBQkxFX1NQRUVEWSA9IHR5cGVvZiBmYWxzZSA9PT0gJ2Jvb2xlYW4nICYmIGZhbHNlIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5cbi8vIFxudmFyIFNDX0NPTVBPTkVOVF9JRCA9IC9eW15cXFNcXG5dKj9cXC9cXCogc2MtY29tcG9uZW50LWlkOlxccyooXFxTKylcXHMrXFwqXFwvL2dtO1xuXG52YXIgZXh0cmFjdENvbXBzID0gKGZ1bmN0aW9uIChtYXliZUNTUykge1xuICB2YXIgY3NzID0gJycgKyAobWF5YmVDU1MgfHwgJycpOyAvLyBEZWZpbml0ZWx5IGEgc3RyaW5nLCBhbmQgYSBjbG9uZVxuICB2YXIgZXhpc3RpbmdDb21wb25lbnRzID0gW107XG4gIGNzcy5yZXBsYWNlKFNDX0NPTVBPTkVOVF9JRCwgZnVuY3Rpb24gKG1hdGNoLCBjb21wb25lbnRJZCwgbWF0Y2hJbmRleCkge1xuICAgIGV4aXN0aW5nQ29tcG9uZW50cy5wdXNoKHsgY29tcG9uZW50SWQ6IGNvbXBvbmVudElkLCBtYXRjaEluZGV4OiBtYXRjaEluZGV4IH0pO1xuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG4gIHJldHVybiBleGlzdGluZ0NvbXBvbmVudHMubWFwKGZ1bmN0aW9uIChfcmVmLCBpKSB7XG4gICAgdmFyIGNvbXBvbmVudElkID0gX3JlZi5jb21wb25lbnRJZCxcbiAgICAgICAgbWF0Y2hJbmRleCA9IF9yZWYubWF0Y2hJbmRleDtcblxuICAgIHZhciBuZXh0Q29tcCA9IGV4aXN0aW5nQ29tcG9uZW50c1tpICsgMV07XG4gICAgdmFyIGNzc0Zyb21ET00gPSBuZXh0Q29tcCA/IGNzcy5zbGljZShtYXRjaEluZGV4LCBuZXh0Q29tcC5tYXRjaEluZGV4KSA6IGNzcy5zbGljZShtYXRjaEluZGV4KTtcbiAgICByZXR1cm4geyBjb21wb25lbnRJZDogY29tcG9uZW50SWQsIGNzc0Zyb21ET006IGNzc0Zyb21ET00gfTtcbiAgfSk7XG59KTtcblxuLy8gXG4vKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UsIG5vLXVuZGVmICovXG5cbnZhciBnZXROb25jZSA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xufSk7XG5cbi8vIFxuLy8gSGVscGVyIHRvIGNhbGwgYSBnaXZlbiBmdW5jdGlvbiwgb25seSBvbmNlXG52YXIgb25jZSA9IChmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfTtcbn0pO1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuXG5cblxuXG5cblxuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7XG4gICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG4vLyBcbi8qIFRoZXNlIGFyZSBoZWxwZXJzIGZvciB0aGUgU3R5bGVUYWdzIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGluamVjdGVkXG4gKiBydWxlIG5hbWVzIGZvciBlYWNoIChjb21wb25lbnQpIElEIHRoYXQgdGhleSdyZSBrZWVwaW5nIHRyYWNrIG9mLlxuICogVGhleSdyZSBjcnVjaWFsIGZvciBkZXRlY3Rpbmcgd2hldGhlciBhIG5hbWUgaGFzIGFscmVhZHkgYmVlblxuICogaW5qZWN0ZWQuXG4gKiAoVGhpcyBleGNsdWRlcyByZWh5ZHJhdGVkIG5hbWVzKSAqL1xuXG4vKiBhZGRzIGEgbmV3IElEOm5hbWUgcGFpcmluZyB0byBhIG5hbWVzIGRpY3Rpb25hcnkgKi9cbnZhciBhZGROYW1lRm9ySWQgPSBmdW5jdGlvbiBhZGROYW1lRm9ySWQobmFtZXMsIGlkLCBuYW1lKSB7XG4gIGlmIChuYW1lKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdmFyIG5hbWVzRm9ySWQgPSBuYW1lc1tpZF0gfHwgKG5hbWVzW2lkXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIG5hbWVzRm9ySWRbbmFtZV0gPSB0cnVlO1xuICB9XG59O1xuXG4vKiByZXNldHMgYW4gSUQgZW50aXJlbHkgYnkgb3ZlcndyaXRpbmcgaXQgaW4gdGhlIGRpY3Rpb25hcnkgKi9cbnZhciByZXNldElkTmFtZXMgPSBmdW5jdGlvbiByZXNldElkTmFtZXMobmFtZXMsIGlkKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBuYW1lc1tpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufTtcblxuLyogZmFjdG9yeSBmb3IgYSBuYW1lcyBkaWN0aW9uYXJ5IGNoZWNraW5nIHRoZSBleGlzdGFuY2Ugb2YgYW4gSUQ6bmFtZSBwYWlyaW5nICovXG52YXIgaGFzTmFtZUZvcklkID0gZnVuY3Rpb24gaGFzTmFtZUZvcklkKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaWQsIG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZXNbaWRdICE9PSB1bmRlZmluZWQgJiYgbmFtZXNbaWRdW25hbWVdO1xuICB9O1xufTtcblxuLyogc3RyaW5naWZpZXMgbmFtZXMgZm9yIHRoZSBodG1sL2VsZW1lbnQgb3V0cHV0ICovXG52YXIgc3RyaW5naWZ5TmFtZXMgPSBmdW5jdGlvbiBzdHJpbmdpZnlOYW1lcyhuYW1lcykge1xuICB2YXIgc3RyID0gJyc7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgZm9yICh2YXIgaWQgaW4gbmFtZXMpIHtcbiAgICBzdHIgKz0gT2JqZWN0LmtleXMobmFtZXNbaWRdKS5qb2luKCcgJykgKyAnICc7XG4gIH1cbiAgcmV0dXJuIHN0ci50cmltKCk7XG59O1xuXG4vKiBjbG9uZXMgdGhlIG5lc3RlZCBuYW1lcyBkaWN0aW9uYXJ5ICovXG52YXIgY2xvbmVOYW1lcyA9IGZ1bmN0aW9uIGNsb25lTmFtZXMobmFtZXMpIHtcbiAgdmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICBmb3IgKHZhciBpZCBpbiBuYW1lcykge1xuICAgIGNsb25lW2lkXSA9IF9leHRlbmRzKHt9LCBuYW1lc1tpZF0pO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8vIFxuLyogVGhlc2UgYXJlIGhlbHBlcnMgdGhhdCBkZWFsIHdpdGggdGhlIGluc2VydFJ1bGUgKGFrYSBzcGVlZHkpIEFQSVxuICogVGhleSBhcmUgdXNlZCBpbiB0aGUgU3R5bGVUYWdzIGFuZCBzcGVjaWZpY2FsbHkgdGhlIHNwZWVkeSB0YWdcbiAqL1xuXG4vKiByZXRyaWV2ZSBhIHNoZWV0IGZvciBhIGdpdmVuIHN0eWxlIHRhZyAqL1xudmFyIHNoZWV0Rm9yVGFnID0gZnVuY3Rpb24gc2hlZXRGb3JUYWcodGFnKSB7XG4gIC8vICRGbG93Rml4TWVcbiAgaWYgKHRhZy5zaGVldCkgcmV0dXJuIHRhZy5zaGVldDtcblxuICAvKiBGaXJlZm94IHF1aXJrIHJlcXVpcmVzIHVzIHRvIHN0ZXAgdGhyb3VnaCBhbGwgc3R5bGVzaGVldHMgdG8gZmluZCBvbmUgb3duZWQgYnkgdGhlIGdpdmVuIHRhZyAqL1xuICB2YXIgc2l6ZSA9IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpICs9IDEpIHtcbiAgICB2YXIgc2hlZXQgPSBkb2N1bWVudC5zdHlsZVNoZWV0c1tpXTtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgaWYgKHNoZWV0Lm93bmVyTm9kZSA9PT0gdGFnKSByZXR1cm4gc2hlZXQ7XG4gIH1cblxuICAvKiB3ZSBzaG91bGQgYWx3YXlzIGJlIGFibGUgdG8gZmluZCBhIHRhZyAqL1xuICB0aHJvdyBuZXcgRXJyb3IoKTtcbn07XG5cbi8qIGluc2VydCBhIHJ1bGUgc2FmZWx5IGFuZCByZXR1cm4gd2hldGhlciBpdCB3YXMgYWN0dWFsbHkgaW5qZWN0ZWQgKi9cbnZhciBzYWZlSW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIHNhZmVJbnNlcnRSdWxlKHNoZWV0LCBjc3NSdWxlLCBpbmRleCkge1xuICAvKiBhYm9ydCBlYXJseSBpZiBjc3NSdWxlIHN0cmluZyBpcyBmYWxzeSAqL1xuICBpZiAoIWNzc1J1bGUpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4SW5kZXggPSBzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG5cbiAgdHJ5IHtcbiAgICAvKiB1c2UgaW5zZXJ0UnVsZSBhbmQgY2FwIHBhc3NlZCBpbmRleCB3aXRoIG1heEluZGV4IChubyBvZiBjc3NSdWxlcykgKi9cbiAgICBzaGVldC5pbnNlcnRSdWxlKGNzc1J1bGUsIGluZGV4IDw9IG1heEluZGV4ID8gaW5kZXggOiBtYXhJbmRleCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8qIGFueSBlcnJvciBpbmRpY2F0ZXMgYW4gaW52YWxpZCBydWxlICovXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKiBkZWxldGVzIGBzaXplYCBydWxlcyBzdGFydGluZyBmcm9tIGByZW1vdmFsSW5kZXhgICovXG52YXIgZGVsZXRlUnVsZXMgPSBmdW5jdGlvbiBkZWxldGVSdWxlcyhzaGVldCwgcmVtb3ZhbEluZGV4LCBzaXplKSB7XG4gIHZhciBsb3dlckJvdW5kID0gcmVtb3ZhbEluZGV4IC0gc2l6ZTtcbiAgZm9yICh2YXIgaSA9IHJlbW92YWxJbmRleDsgaSA+PSBsb3dlckJvdW5kOyBpIC09IDEpIHtcbiAgICBzaGVldC5kZWxldGVSdWxlKGkpO1xuICB9XG59O1xuXG4vLyBcbi8qIGVzbGludC1kaXNhYmxlIGZsb3d0eXBlL29iamVjdC10eXBlLWRlbGltaXRlciAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJvcC10eXBlcyAqL1xuXG4vKiB0aGlzIGVycm9yIGlzIHVzZWQgZm9yIG1ha2VTdHlsZVRhZyAqL1xudmFyIHBhcmVudE5vZGVVbm1vdW50ZWRFcnIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gJ1xcblRyeWluZyB0byBpbnNlcnQgYSBuZXcgc3R5bGUgdGFnLCBidXQgdGhlIGdpdmVuIE5vZGUgaXMgdW5tb3VudGVkIVxcbi0gQXJlIHlvdSB1c2luZyBhIGN1c3RvbSB0YXJnZXQgdGhhdCBpc25cXCd0IG1vdW50ZWQ/XFxuLSBEb2VzIHlvdXIgZG9jdW1lbnQgbm90IGhhdmUgYSB2YWxpZCBoZWFkIGVsZW1lbnQ/XFxuLSBIYXZlIHlvdSBhY2NpZGVudGFsbHkgcmVtb3ZlZCBhIHN0eWxlIHRhZyBtYW51YWxseT9cXG4nLnRyaW0oKSA6ICcnO1xuXG4vKiB0aGlzIGVycm9yIGlzIHVzZWQgZm9yIHRhZ3MgKi9cbnZhciB0aHJvd0Nsb25lVGFnRXJyID0gZnVuY3Rpb24gdGhyb3dDbG9uZVRhZ0VycigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAnXFxuVGhlIGNsb25lIG1ldGhvZCBjYW5ub3QgYmUgdXNlZCBvbiB0aGUgY2xpZW50IVxcbi0gQXJlIHlvdSBydW5uaW5nIGluIGEgY2xpZW50LWxpa2UgZW52aXJvbm1lbnQgb24gdGhlIHNlcnZlcj9cXG4tIEFyZSB5b3UgdHJ5aW5nIHRvIHJ1biBTU1Igb24gdGhlIGNsaWVudD9cXG4nLnRyaW0oKSA6ICcnKTtcbn07XG5cbi8qIHRoaXMgbWFya2VyIHNlcGFyYXRlcyBjb21wb25lbnQgc3R5bGVzIGFuZCBpcyBpbXBvcnRhbnQgZm9yIHJlaHlkcmF0aW9uICovXG52YXIgbWFrZVRleHRNYXJrZXIgPSBmdW5jdGlvbiBtYWtlVGV4dE1hcmtlcihpZCkge1xuICByZXR1cm4gJ1xcbi8qIHNjLWNvbXBvbmVudC1pZDogJyArIGlkICsgJyAqL1xcbic7XG59O1xuXG4vKiBhZGQgdXAgYWxsIG51bWJlcnMgaW4gYXJyYXkgdXAgdW50aWwgYW5kIGluY2x1ZGluZyB0aGUgaW5kZXggKi9cbnZhciBhZGRVcFVudGlsSW5kZXggPSBmdW5jdGlvbiBhZGRVcFVudGlsSW5kZXgoc2l6ZXMsIGluZGV4KSB7XG4gIHZhciB0b3RhbFVwVG9JbmRleCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IGluZGV4OyBpICs9IDEpIHtcbiAgICB0b3RhbFVwVG9JbmRleCArPSBzaXplc1tpXTtcbiAgfVxuXG4gIHJldHVybiB0b3RhbFVwVG9JbmRleDtcbn07XG5cbi8qIGNyZWF0ZSBhIG5ldyBzdHlsZSB0YWcgYWZ0ZXIgbGFzdEVsICovXG52YXIgbWFrZVN0eWxlVGFnID0gZnVuY3Rpb24gbWFrZVN0eWxlVGFnKHRhcmdldCwgdGFnRWwsIGluc2VydEJlZm9yZSkge1xuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBlbC5zZXRBdHRyaWJ1dGUoU0NfQVRUUiwgJycpO1xuXG4gIHZhciBub25jZSA9IGdldE5vbmNlKCk7XG4gIGlmIChub25jZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gIH1cblxuICAvKiBXb3JrIGFyb3VuZCBpbnNlcnRSdWxlIHF1aXJrIGluIEVkZ2VIVE1MICovXG4gIGVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKSk7XG5cbiAgaWYgKHRhcmdldCAmJiAhdGFnRWwpIHtcbiAgICAvKiBBcHBlbmQgdG8gdGFyZ2V0IHdoZW4gbm8gcHJldmlvdXMgZWxlbWVudCB3YXMgcGFzc2VkICovXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXRhZ0VsIHx8ICF0YXJnZXQgfHwgIXRhZ0VsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwYXJlbnROb2RlVW5tb3VudGVkRXJyKTtcbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgbmV3IHN0eWxlIHRhZyBhZnRlciB0aGUgcHJldmlvdXMgb25lICovXG4gICAgdGFnRWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIGluc2VydEJlZm9yZSA/IHRhZ0VsIDogdGFnRWwubmV4dFNpYmxpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGVsO1xufTtcblxuLyogdGFrZXMgYSBjc3MgZmFjdG9yeSBmdW5jdGlvbiBhbmQgb3V0cHV0cyBhbiBodG1sIHN0eWxlZCB0YWcgZmFjdG9yeSAqL1xudmFyIHdyYXBBc0h0bWxUYWcgPSBmdW5jdGlvbiB3cmFwQXNIdG1sVGFnKGNzcywgbmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhZGRpdGlvbmFsQXR0cnMpIHtcbiAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgIHZhciBhdHRycyA9IFtub25jZSAmJiAnbm9uY2U9XCInICsgbm9uY2UgKyAnXCInLCBTQ19BVFRSICsgJz1cIicgKyBzdHJpbmdpZnlOYW1lcyhuYW1lcykgKyAnXCInLCBhZGRpdGlvbmFsQXR0cnNdO1xuXG4gICAgdmFyIGh0bWxBdHRyID0gYXR0cnMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKTtcbiAgICByZXR1cm4gJzxzdHlsZSAnICsgaHRtbEF0dHIgKyAnPicgKyBjc3MoKSArICc8L3N0eWxlPic7XG4gIH07XG59O1xuXG4vKiB0YWtlcyBhIGNzcyBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBvdXRwdXRzIGFuIGVsZW1lbnQgZmFjdG9yeSAqL1xudmFyIHdyYXBBc0VsZW1lbnQgPSBmdW5jdGlvbiB3cmFwQXNFbGVtZW50KGNzcywgbmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3Byb3BzO1xuXG4gICAgdmFyIHByb3BzID0gKF9wcm9wcyA9IHt9LCBfcHJvcHNbU0NfQVRUUl0gPSBzdHJpbmdpZnlOYW1lcyhuYW1lcyksIF9wcm9wcyk7XG5cbiAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgIGlmIChub25jZSkge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgcHJvcHMubm9uY2UgPSBub25jZTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGFuZ2VyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJywgX2V4dGVuZHMoe30sIHByb3BzLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogY3NzKCkgfSB9KSk7XG4gIH07XG59O1xuXG52YXIgZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5KG1hcmtlcnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobWFya2Vycyk7XG4gIH07XG59O1xuXG4vKiBzcGVlZHkgdGFncyB1dGlsaXNlIGluc2VydFJ1bGUgKi9cbnZhciBtYWtlU3BlZWR5VGFnID0gZnVuY3Rpb24gbWFrZVNwZWVkeVRhZyhlbCwgZ2V0SW1wb3J0UnVsZVRhZykge1xuICB2YXIgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbWFya2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBzaXplcyA9IFtdO1xuXG4gIHZhciBleHRyYWN0SW1wb3J0ID0gZ2V0SW1wb3J0UnVsZVRhZyAhPT0gdW5kZWZpbmVkO1xuICAvKiBpbmRpY2F0ZXMgd2h0aGVyIGdldEltcG9ydFJ1bGVUYWcgd2FzIGNhbGxlZCAqL1xuICB2YXIgdXNlZEltcG9ydFJ1bGVUYWcgPSBmYWxzZTtcblxuICB2YXIgaW5zZXJ0TWFya2VyID0gZnVuY3Rpb24gaW5zZXJ0TWFya2VyKGlkKSB7XG4gICAgdmFyIHByZXYgPSBtYXJrZXJzW2lkXTtcbiAgICBpZiAocHJldiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG5cbiAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpZF0gPSBzaXplcy5sZW5ndGg7XG4gICAgc2l6ZXMucHVzaCgwKTtcbiAgICByZXNldElkTmFtZXMobmFtZXMsIGlkKTtcbiAgICByZXR1cm4gbWFya2VyO1xuICB9O1xuXG4gIHZhciBpbnNlcnRSdWxlcyA9IGZ1bmN0aW9uIGluc2VydFJ1bGVzKGlkLCBjc3NSdWxlcywgbmFtZSkge1xuICAgIHZhciBtYXJrZXIgPSBpbnNlcnRNYXJrZXIoaWQpO1xuICAgIHZhciBzaGVldCA9IHNoZWV0Rm9yVGFnKGVsKTtcbiAgICB2YXIgaW5zZXJ0SW5kZXggPSBhZGRVcFVudGlsSW5kZXgoc2l6ZXMsIG1hcmtlcik7XG5cbiAgICB2YXIgaW5qZWN0ZWRSdWxlcyA9IDA7XG4gICAgdmFyIGltcG9ydFJ1bGVzID0gW107XG4gICAgdmFyIGNzc1J1bGVzU2l6ZSA9IGNzc1J1bGVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzUnVsZXNTaXplOyBpICs9IDEpIHtcbiAgICAgIHZhciBjc3NSdWxlID0gY3NzUnVsZXNbaV07XG4gICAgICB2YXIgbWF5SGF2ZUltcG9ydCA9IGV4dHJhY3RJbXBvcnQ7IC8qIEBpbXBvcnQgcnVsZXMgYXJlIHJlb3JkZXJlZCB0byBhcHBlYXIgZmlyc3QgKi9cbiAgICAgIGlmIChtYXlIYXZlSW1wb3J0ICYmIGNzc1J1bGUuaW5kZXhPZignQGltcG9ydCcpICE9PSAtMSkge1xuICAgICAgICBpbXBvcnRSdWxlcy5wdXNoKGNzc1J1bGUpO1xuICAgICAgfSBlbHNlIGlmIChzYWZlSW5zZXJ0UnVsZShzaGVldCwgY3NzUnVsZSwgaW5zZXJ0SW5kZXggKyBpbmplY3RlZFJ1bGVzKSkge1xuICAgICAgICBtYXlIYXZlSW1wb3J0ID0gZmFsc2U7XG4gICAgICAgIGluamVjdGVkUnVsZXMgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0cmFjdEltcG9ydCAmJiBpbXBvcnRSdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB1c2VkSW1wb3J0UnVsZVRhZyA9IHRydWU7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBnZXRJbXBvcnRSdWxlVGFnKCkuaW5zZXJ0UnVsZXMoaWQgKyAnLWltcG9ydCcsIGltcG9ydFJ1bGVzKTtcbiAgICB9XG5cbiAgICBzaXplc1ttYXJrZXJdICs9IGluamVjdGVkUnVsZXM7IC8qIGFkZCB1cCBubyBvZiBpbmplY3RlZCBydWxlcyAqL1xuICAgIGFkZE5hbWVGb3JJZChuYW1lcywgaWQsIG5hbWUpO1xuICB9O1xuXG4gIHZhciByZW1vdmVSdWxlcyA9IGZ1bmN0aW9uIHJlbW92ZVJ1bGVzKGlkKSB7XG4gICAgdmFyIG1hcmtlciA9IG1hcmtlcnNbaWRdO1xuICAgIGlmIChtYXJrZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdmFyIHNpemUgPSBzaXplc1ttYXJrZXJdO1xuICAgIHZhciBzaGVldCA9IHNoZWV0Rm9yVGFnKGVsKTtcbiAgICB2YXIgcmVtb3ZhbEluZGV4ID0gYWRkVXBVbnRpbEluZGV4KHNpemVzLCBtYXJrZXIpO1xuICAgIGRlbGV0ZVJ1bGVzKHNoZWV0LCByZW1vdmFsSW5kZXgsIHNpemUpO1xuICAgIHNpemVzW21hcmtlcl0gPSAwO1xuICAgIHJlc2V0SWROYW1lcyhuYW1lcywgaWQpO1xuXG4gICAgaWYgKGV4dHJhY3RJbXBvcnQgJiYgdXNlZEltcG9ydFJ1bGVUYWcpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGdldEltcG9ydFJ1bGVUYWcoKS5yZW1vdmVSdWxlcyhpZCArICctaW1wb3J0Jyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjc3MgPSBmdW5jdGlvbiBjc3MoKSB7XG4gICAgdmFyIF9zaGVldEZvclRhZyA9IHNoZWV0Rm9yVGFnKGVsKSxcbiAgICAgICAgY3NzUnVsZXMgPSBfc2hlZXRGb3JUYWcuY3NzUnVsZXM7XG5cbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIHN0ciArPSBtYWtlVGV4dE1hcmtlcihpZCk7XG4gICAgICB2YXIgZW5kID0gbWFya2Vyc1tpZF0gKyBpO1xuICAgICAgZm9yICg7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gY3NzUnVsZXNbaV0uY3NzVGV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc3R5bGVUYWc6IGVsLFxuICAgIGdldElkczogZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5KG1hcmtlcnMpLFxuICAgIGhhc05hbWVGb3JJZDogaGFzTmFtZUZvcklkKG5hbWVzKSxcbiAgICBpbnNlcnRNYXJrZXI6IGluc2VydE1hcmtlcixcbiAgICBpbnNlcnRSdWxlczogaW5zZXJ0UnVsZXMsXG4gICAgcmVtb3ZlUnVsZXM6IHJlbW92ZVJ1bGVzLFxuICAgIGNzczogY3NzLFxuICAgIHRvSFRNTDogd3JhcEFzSHRtbFRhZyhjc3MsIG5hbWVzKSxcbiAgICB0b0VsZW1lbnQ6IHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcyksXG4gICAgY2xvbmU6IHRocm93Q2xvbmVUYWdFcnJcbiAgfTtcbn07XG5cbnZhciBtYWtlQnJvd3NlclRhZyA9IGZ1bmN0aW9uIG1ha2VCcm93c2VyVGFnKGVsLCBnZXRJbXBvcnRSdWxlVGFnKSB7XG4gIHZhciBuYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBtYXJrZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB2YXIgZXh0cmFjdEltcG9ydCA9IGdldEltcG9ydFJ1bGVUYWcgIT09IHVuZGVmaW5lZDtcbiAgdmFyIG1ha2VUZXh0Tm9kZSA9IGZ1bmN0aW9uIG1ha2VUZXh0Tm9kZShpZCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtYWtlVGV4dE1hcmtlcihpZCkpO1xuICB9O1xuXG4gIC8qIGluZGljYXRlcyB3aHRoZXIgZ2V0SW1wb3J0UnVsZVRhZyB3YXMgY2FsbGVkICovXG4gIHZhciB1c2VkSW1wb3J0UnVsZVRhZyA9IGZhbHNlO1xuXG4gIHZhciBpbnNlcnRNYXJrZXIgPSBmdW5jdGlvbiBpbnNlcnRNYXJrZXIoaWQpIHtcbiAgICB2YXIgcHJldiA9IG1hcmtlcnNbaWRdO1xuICAgIGlmIChwcmV2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cblxuICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2lkXSA9IG1ha2VUZXh0Tm9kZShpZCk7XG4gICAgZWwuYXBwZW5kQ2hpbGQobWFya2VyKTtcbiAgICBuYW1lc1tpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBtYXJrZXI7XG4gIH07XG5cbiAgdmFyIGluc2VydFJ1bGVzID0gZnVuY3Rpb24gaW5zZXJ0UnVsZXMoaWQsIGNzc1J1bGVzLCBuYW1lKSB7XG4gICAgdmFyIG1hcmtlciA9IGluc2VydE1hcmtlcihpZCk7XG4gICAgdmFyIGltcG9ydFJ1bGVzID0gW107XG4gICAgdmFyIGNzc1J1bGVzU2l6ZSA9IGNzc1J1bGVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3NzUnVsZXNTaXplOyBpICs9IDEpIHtcbiAgICAgIHZhciBydWxlID0gY3NzUnVsZXNbaV07XG4gICAgICB2YXIgbWF5SGF2ZUltcG9ydCA9IGV4dHJhY3RJbXBvcnQ7XG4gICAgICBpZiAobWF5SGF2ZUltcG9ydCAmJiBydWxlLmluZGV4T2YoJ0BpbXBvcnQnKSAhPT0gLTEpIHtcbiAgICAgICAgaW1wb3J0UnVsZXMucHVzaChydWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heUhhdmVJbXBvcnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGkgPT09IGNzc1J1bGVzU2l6ZSAtIDEgPyAnJyA6ICcgJztcbiAgICAgICAgbWFya2VyLmFwcGVuZERhdGEoJycgKyBydWxlICsgc2VwYXJhdG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhZGROYW1lRm9ySWQobmFtZXMsIGlkLCBuYW1lKTtcblxuICAgIGlmIChleHRyYWN0SW1wb3J0ICYmIGltcG9ydFJ1bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVzZWRJbXBvcnRSdWxlVGFnID0gdHJ1ZTtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGdldEltcG9ydFJ1bGVUYWcoKS5pbnNlcnRSdWxlcyhpZCArICctaW1wb3J0JywgaW1wb3J0UnVsZXMpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlUnVsZXMgPSBmdW5jdGlvbiByZW1vdmVSdWxlcyhpZCkge1xuICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2lkXTtcbiAgICBpZiAobWFya2VyID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIC8qIGNyZWF0ZSBuZXcgZW1wdHkgdGV4dCBub2RlIGFuZCByZXBsYWNlIHRoZSBjdXJyZW50IG9uZSAqL1xuICAgIHZhciBuZXdNYXJrZXIgPSBtYWtlVGV4dE5vZGUoaWQpO1xuICAgIGVsLnJlcGxhY2VDaGlsZChuZXdNYXJrZXIsIG1hcmtlcik7XG4gICAgbWFya2Vyc1tpZF0gPSBuZXdNYXJrZXI7XG4gICAgcmVzZXRJZE5hbWVzKG5hbWVzLCBpZCk7XG5cbiAgICBpZiAoZXh0cmFjdEltcG9ydCAmJiB1c2VkSW1wb3J0UnVsZVRhZykge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgZ2V0SW1wb3J0UnVsZVRhZygpLnJlbW92ZVJ1bGVzKGlkICsgJy1pbXBvcnQnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNzcyA9IGZ1bmN0aW9uIGNzcygpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIHN0ciArPSBtYXJrZXJzW2lkXS5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc3R5bGVUYWc6IGVsLFxuICAgIGdldElkczogZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5KG1hcmtlcnMpLFxuICAgIGhhc05hbWVGb3JJZDogaGFzTmFtZUZvcklkKG5hbWVzKSxcbiAgICBpbnNlcnRNYXJrZXI6IGluc2VydE1hcmtlcixcbiAgICBpbnNlcnRSdWxlczogaW5zZXJ0UnVsZXMsXG4gICAgcmVtb3ZlUnVsZXM6IHJlbW92ZVJ1bGVzLFxuICAgIGNzczogY3NzLFxuICAgIHRvSFRNTDogd3JhcEFzSHRtbFRhZyhjc3MsIG5hbWVzKSxcbiAgICB0b0VsZW1lbnQ6IHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcyksXG4gICAgY2xvbmU6IHRocm93Q2xvbmVUYWdFcnJcbiAgfTtcbn07XG5cbnZhciBtYWtlU2VydmVyVGFnSW50ZXJuYWwgPSBmdW5jdGlvbiBtYWtlU2VydmVyVGFnSW50ZXJuYWwobmFtZXNBcmcsIG1hcmtlcnNBcmcpIHtcbiAgdmFyIG5hbWVzID0gbmFtZXNBcmcgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBuYW1lc0FyZztcbiAgdmFyIG1hcmtlcnMgPSBtYXJrZXJzQXJnID09PSB1bmRlZmluZWQgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbWFya2Vyc0FyZztcblxuICB2YXIgaW5zZXJ0TWFya2VyID0gZnVuY3Rpb24gaW5zZXJ0TWFya2VyKGlkKSB7XG4gICAgdmFyIHByZXYgPSBtYXJrZXJzW2lkXTtcbiAgICBpZiAocHJldiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya2Vyc1tpZF0gPSBbJyddO1xuICB9O1xuXG4gIHZhciBpbnNlcnRSdWxlcyA9IGZ1bmN0aW9uIGluc2VydFJ1bGVzKGlkLCBjc3NSdWxlcywgbmFtZSkge1xuICAgIHZhciBtYXJrZXIgPSBpbnNlcnRNYXJrZXIoaWQpO1xuICAgIG1hcmtlclswXSArPSBjc3NSdWxlcy5qb2luKCcgJyk7XG4gICAgYWRkTmFtZUZvcklkKG5hbWVzLCBpZCwgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHJlbW92ZVJ1bGVzID0gZnVuY3Rpb24gcmVtb3ZlUnVsZXMoaWQpIHtcbiAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKG1hcmtlciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgbWFya2VyWzBdID0gJyc7XG4gICAgcmVzZXRJZE5hbWVzKG5hbWVzLCBpZCk7XG4gIH07XG5cbiAgdmFyIGNzcyA9IGZ1bmN0aW9uIGNzcygpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIHZhciBjc3NGb3JJZCA9IG1hcmtlcnNbaWRdWzBdO1xuICAgICAgaWYgKGNzc0ZvcklkKSB7XG4gICAgICAgIHN0ciArPSBtYWtlVGV4dE1hcmtlcihpZCkgKyBjc3NGb3JJZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICB2YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICB2YXIgbmFtZXNDbG9uZSA9IGNsb25lTmFtZXMobmFtZXMpO1xuICAgIHZhciBtYXJrZXJzQ2xvbmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIG1hcmtlcnNDbG9uZVtpZF0gPSBbbWFya2Vyc1tpZF1bMF1dO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlU2VydmVyVGFnSW50ZXJuYWwobmFtZXNDbG9uZSwgbWFya2Vyc0Nsb25lKTtcbiAgfTtcblxuICB2YXIgdGFnID0ge1xuICAgIHN0eWxlVGFnOiBudWxsLFxuICAgIGdldElkczogZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5KG1hcmtlcnMpLFxuICAgIGhhc05hbWVGb3JJZDogaGFzTmFtZUZvcklkKG5hbWVzKSxcbiAgICBpbnNlcnRNYXJrZXI6IGluc2VydE1hcmtlcixcbiAgICBpbnNlcnRSdWxlczogaW5zZXJ0UnVsZXMsXG4gICAgcmVtb3ZlUnVsZXM6IHJlbW92ZVJ1bGVzLFxuICAgIGNzczogY3NzLFxuICAgIHRvSFRNTDogd3JhcEFzSHRtbFRhZyhjc3MsIG5hbWVzKSxcbiAgICB0b0VsZW1lbnQ6IHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcyksXG4gICAgY2xvbmU6IGNsb25lXG4gIH07XG5cbiAgcmV0dXJuIHRhZztcbn07XG5cbnZhciBtYWtlU2VydmVyVGFnID0gZnVuY3Rpb24gbWFrZVNlcnZlclRhZygpIHtcbiAgcmV0dXJuIG1ha2VTZXJ2ZXJUYWdJbnRlcm5hbCgpO1xufTtcblxudmFyIG1ha2VUYWcgPSBmdW5jdGlvbiBtYWtlVGFnKHRhcmdldCwgdGFnRWwsIGZvcmNlU2VydmVyLCBpbnNlcnRCZWZvcmUsIGdldEltcG9ydFJ1bGVUYWcpIHtcbiAgaWYgKElTX0JST1dTRVIgJiYgIWZvcmNlU2VydmVyKSB7XG4gICAgdmFyIGVsID0gbWFrZVN0eWxlVGFnKHRhcmdldCwgdGFnRWwsIGluc2VydEJlZm9yZSk7XG4gICAgaWYgKERJU0FCTEVfU1BFRURZKSB7XG4gICAgICByZXR1cm4gbWFrZUJyb3dzZXJUYWcoZWwsIGdldEltcG9ydFJ1bGVUYWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWFrZVNwZWVkeVRhZyhlbCwgZ2V0SW1wb3J0UnVsZVRhZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ha2VTZXJ2ZXJUYWcoKTtcbn07XG5cbi8qIHdyYXBzIGEgZ2l2ZW4gdGFnIHNvIHRoYXQgcmVoeWRyYXRpb24gaXMgcGVyZm9ybWVkIG9uY2Ugd2hlbiBuZWNlc3NhcnkgKi9cbnZhciBtYWtlUmVoeWRyYXRpb25UYWcgPSBmdW5jdGlvbiBtYWtlUmVoeWRyYXRpb25UYWcodGFnLCBlbHMsIGV4dHJhY3RlZCwgbmFtZXMsIGltbWVkaWF0ZVJlaHlkcmF0aW9uKSB7XG4gIC8qIHJlaHlkcmF0aW9uIGZ1bmN0aW9uIHRoYXQgYWRkcyBhbGwgcnVsZXMgdG8gdGhlIG5ldyB0YWcgKi9cbiAgdmFyIHJlaHlkcmF0ZSA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIC8qIGFkZCBhbGwgZXh0cmFjdGVkIGNvbXBvbmVudHMgdG8gdGhlIG5ldyB0YWcgKi9cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dHJhY3RlZC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIF9leHRyYWN0ZWQkaSA9IGV4dHJhY3RlZFtpXSxcbiAgICAgICAgICBjb21wb25lbnRJZCA9IF9leHRyYWN0ZWQkaS5jb21wb25lbnRJZCxcbiAgICAgICAgICBjc3NGcm9tRE9NID0gX2V4dHJhY3RlZCRpLmNzc0Zyb21ET007XG5cbiAgICAgIHZhciBjc3NSdWxlcyA9IHNwbGl0QnlSdWxlcyhjc3NGcm9tRE9NKTtcbiAgICAgIHRhZy5pbnNlcnRSdWxlcyhjb21wb25lbnRJZCwgY3NzUnVsZXMpO1xuICAgIH1cblxuICAgIC8qIHJlbW92ZSBvbGQgSFRNTFN0eWxlRWxlbWVudHMsIHNpbmNlIHRoZXkgaGF2ZSBiZWVuIHJlaHlkcmF0ZWQgKi9cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxzLmxlbmd0aDsgX2kgKz0gMSkge1xuICAgICAgdmFyIGVsID0gZWxzW19pXTtcbiAgICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGltbWVkaWF0ZVJlaHlkcmF0aW9uKSByZWh5ZHJhdGUoKTtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHRhZywge1xuICAgIC8qIGFkZCByZWh5ZHJhdGlvbiBob29rIHRvIGluc2VydGlvbiBtZXRob2RzICovXG4gICAgaW5zZXJ0TWFya2VyOiBmdW5jdGlvbiBpbnNlcnRNYXJrZXIoaWQpIHtcbiAgICAgIHJlaHlkcmF0ZSgpO1xuICAgICAgcmV0dXJuIHRhZy5pbnNlcnRNYXJrZXIoaWQpO1xuICAgIH0sXG4gICAgaW5zZXJ0UnVsZXM6IGZ1bmN0aW9uIGluc2VydFJ1bGVzKGlkLCBjc3NSdWxlcywgbmFtZSkge1xuICAgICAgcmVoeWRyYXRlKCk7XG4gICAgICByZXR1cm4gdGFnLmluc2VydFJ1bGVzKGlkLCBjc3NSdWxlcywgbmFtZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIFxuXG4vKiBkZXRlcm1pbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBvbmVudHMgYmVmb3JlIHRhZ3MgYXJlIHNoYXJkZWQgKi9cbnZhciBNQVhfU0laRSA9IHZvaWQgMDtcbmlmIChJU19CUk9XU0VSKSB7XG4gIC8qIGluIHNwZWVkeSBtb2RlIHdlIGNhbiBrZWVwIGEgbG90IG1vcmUgcnVsZXMgaW4gYSBzaGVldCBiZWZvcmUgYSBzbG93ZG93biBjYW4gYmUgZXhwZWN0ZWQgKi9cbiAgTUFYX1NJWkUgPSBESVNBQkxFX1NQRUVEWSA/IDQwIDogMTAwMDtcbn0gZWxzZSB7XG4gIC8qIGZvciBzZXJ2ZXJzIHdlIGRvIG5vdCBuZWVkIHRvIHNoYXJkIGF0IGFsbCAqL1xuICBNQVhfU0laRSA9IC0xO1xufVxuXG52YXIgc2hlZXRSdW5uaW5nSWQgPSAwO1xudmFyIG1hc3RlciA9IHZvaWQgMDtcblxudmFyIFN0eWxlU2hlZXQgPSBmdW5jdGlvbiAoKSB7XG4gIC8qIGEgbWFwIGZyb20gaWRzIHRvIHRhZ3MgKi9cbiAgLyogZGVmZXJyZWQgcnVsZXMgZm9yIGEgZ2l2ZW4gaWQgKi9cbiAgLyogdGhpcyBpcyB1c2VkIGZvciBub3QgcmVpbmplY3RpbmcgcnVsZXMgdmlhIGhhc05hbWVGb3JJZCgpICovXG4gIC8qIHdoZW4gcnVsZXMgZm9yIGFuIGlkIGFyZSByZW1vdmVkIHVzaW5nIHJlbW92ZSgpIHdlIGhhdmUgdG8gaWdub3JlIHJlaHlkcmF0ZWROYW1lcyBmb3IgaXQgKi9cbiAgLyogYSBsaXN0IG9mIHRhZ3MgYmVsb25naW5nIHRvIHRoaXMgU3R5bGVTaGVldCAqL1xuICAvKiBhIHRhZyBmb3IgaW1wb3J0IHJ1bGVzICovXG4gIC8qIGN1cnJlbnQgY2FwYWNpdHkgdW50aWwgYSBuZXcgdGFnIG11c3QgYmUgY3JlYXRlZCAqL1xuICAvKiBjaGlsZHJlbiAoYWthIGNsb25lcykgb2YgdGhpcyBTdHlsZVNoZWV0IGluaGVyaXRpbmcgYWxsIGFuZCBmdXR1cmUgaW5qZWN0aW9ucyAqL1xuXG4gIGZ1bmN0aW9uIFN0eWxlU2hlZXQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IElTX0JST1dTRVIgPyBkb2N1bWVudC5oZWFkIDogbnVsbDtcbiAgICB2YXIgZm9yY2VTZXJ2ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlU2hlZXQpO1xuXG4gICAgdGhpcy5nZXRJbXBvcnRSdWxlVGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGltcG9ydFJ1bGVUYWcgPSBfdGhpcy5pbXBvcnRSdWxlVGFnO1xuXG4gICAgICBpZiAoaW1wb3J0UnVsZVRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRSdWxlVGFnO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RUYWcgPSBfdGhpcy50YWdzWzBdO1xuICAgICAgdmFyIGluc2VydEJlZm9yZSA9IHRydWU7XG5cbiAgICAgIHJldHVybiBfdGhpcy5pbXBvcnRSdWxlVGFnID0gbWFrZVRhZyhfdGhpcy50YXJnZXQsIGZpcnN0VGFnID8gZmlyc3RUYWcuc3R5bGVUYWcgOiBudWxsLCBfdGhpcy5mb3JjZVNlcnZlciwgaW5zZXJ0QmVmb3JlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5pZCA9IHNoZWV0UnVubmluZ0lkICs9IDE7XG4gICAgdGhpcy5zZWFsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZvcmNlU2VydmVyID0gZm9yY2VTZXJ2ZXI7XG4gICAgdGhpcy50YXJnZXQgPSBmb3JjZVNlcnZlciA/IG51bGwgOiB0YXJnZXQ7XG4gICAgdGhpcy50YWdNYXAgPSB7fTtcbiAgICB0aGlzLmRlZmVycmVkID0ge307XG4gICAgdGhpcy5yZWh5ZHJhdGVkTmFtZXMgPSB7fTtcbiAgICB0aGlzLmlnbm9yZVJlaHlkcmF0ZWROYW1lcyA9IHt9O1xuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIHRoaXMuY2FwYWNpdHkgPSAxO1xuICAgIHRoaXMuY2xvbmVzID0gW107XG4gIH1cblxuICAvKiByZWh5ZHJhdGUgYWxsIFNTUidkIHN0eWxlIHRhZ3MgKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLnJlaHlkcmF0ZSA9IGZ1bmN0aW9uIHJlaHlkcmF0ZSgpIHtcbiAgICBpZiAoIUlTX0JST1dTRVIgfHwgdGhpcy5mb3JjZVNlcnZlcikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGVscyA9IFtdO1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIHZhciBleHRyYWN0ZWQgPSBbXTtcbiAgICB2YXIgaXNTdHJlYW1lZCA9IGZhbHNlO1xuXG4gICAgLyogcmV0cmlldmUgYWxsIG9mIG91ciBTU1Igc3R5bGUgZWxlbWVudHMgZnJvbSB0aGUgRE9NICovXG4gICAgdmFyIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbJyArIFNDX0FUVFIgKyAnXScpO1xuICAgIHZhciBub2Rlc1NpemUgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAvKiBhYm9ydCByZWh5ZHJhdGlvbiBpZiBubyBwcmV2aW91cyBzdHlsZSB0YWdzIHdlcmUgZm91bmQgKi9cbiAgICBpZiAobm9kZXNTaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzU2l6ZTsgaSArPSAxKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lOiBXZSBjYW4gdHJ1c3QgdGhhdCBhbGwgZWxlbWVudHMgaW4gdGhpcyBxdWVyeSBhcmUgc3R5bGUgZWxlbWVudHNcbiAgICAgIHZhciBlbCA9IG5vZGVzW2ldO1xuXG4gICAgICAvKiBjaGVjayBpZiBzdHlsZSB0YWcgaXMgYSBzdHJlYW1lZCB0YWcgKi9cbiAgICAgIGlzU3RyZWFtZWQgPSAhIWVsLmdldEF0dHJpYnV0ZShTQ19TVFJFQU1fQVRUUikgfHwgaXNTdHJlYW1lZDtcblxuICAgICAgLyogcmV0cmlldmUgYWxsIGNvbXBvbmVudCBuYW1lcyAqL1xuICAgICAgdmFyIGVsTmFtZXMgPSAoZWwuZ2V0QXR0cmlidXRlKFNDX0FUVFIpIHx8ICcnKS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgIHZhciBlbE5hbWVzU2l6ZSA9IGVsTmFtZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbE5hbWVzU2l6ZTsgaiArPSAxKSB7XG4gICAgICAgIHZhciBuYW1lID0gZWxOYW1lc1tqXTtcbiAgICAgICAgLyogYWRkIHJlaHlkcmF0ZWQgbmFtZSB0byBzaGVldCB0byBhdm9pZCByZWFkZGluZyBzdHlsZXMgKi9cbiAgICAgICAgdGhpcy5yZWh5ZHJhdGVkTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvKiBleHRyYWN0IGFsbCBjb21wb25lbnRzIGFuZCB0aGVpciBDU1MgKi9cbiAgICAgIGV4dHJhY3RlZCA9IGV4dHJhY3RlZC5jb25jYXQoZXh0cmFjdENvbXBzKGVsLnRleHRDb250ZW50KSk7XG4gICAgICAvKiBzdG9yZSBvcmlnaW5hbCBIVE1MU3R5bGVFbGVtZW50ICovXG4gICAgICBlbHMucHVzaChlbCk7XG4gICAgfVxuXG4gICAgLyogYWJvcnQgcmVoeWRyYXRpb24gaWYgbm90aGluZyB3YXMgZXh0cmFjdGVkICovXG4gICAgdmFyIGV4dHJhY3RlZFNpemUgPSBleHRyYWN0ZWQubGVuZ3RoO1xuICAgIGlmIChleHRyYWN0ZWRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgYSB0YWcgdG8gYmUgdXNlZCBmb3IgcmVoeWRyYXRpb24gKi9cbiAgICB2YXIgdGFnID0gdGhpcy5tYWtlVGFnKG51bGwpO1xuICAgIHZhciByZWh5ZHJhdGlvblRhZyA9IG1ha2VSZWh5ZHJhdGlvblRhZyh0YWcsIGVscywgZXh0cmFjdGVkLCBuYW1lcywgaXNTdHJlYW1lZCk7XG5cbiAgICAvKiByZXNldCBjYXBhY2l0eSBhbmQgYWRqdXN0IE1BWF9TSVpFIGJ5IHRoZSBpbml0aWFsIHNpemUgb2YgdGhlIHJlaHlkcmF0aW9uICovXG4gICAgdGhpcy5jYXBhY2l0eSA9IE1hdGgubWF4KDEsIE1BWF9TSVpFIC0gZXh0cmFjdGVkU2l6ZSk7XG4gICAgdGhpcy50YWdzLnB1c2gocmVoeWRyYXRpb25UYWcpO1xuXG4gICAgLyogcmV0cmlldmUgYWxsIGNvbXBvbmVudCBpZHMgKi9cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgZXh0cmFjdGVkU2l6ZTsgX2ogKz0gMSkge1xuICAgICAgdGhpcy50YWdNYXBbZXh0cmFjdGVkW19qXS5jb21wb25lbnRJZF0gPSByZWh5ZHJhdGlvblRhZztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKiByZXRyaWV2ZSBhIFwibWFzdGVyXCIgaW5zdGFuY2Ugb2YgU3R5bGVTaGVldCB3aGljaCBpcyB0eXBpY2FsbHkgdXNlZCB3aGVuIG5vIG90aGVyIGlzIGF2YWlsYWJsZVxuICAgKiBUaGUgbWFzdGVyIFN0eWxlU2hlZXQgaXMgdGFyZ2V0ZWQgYnkgaW5qZWN0R2xvYmFsLCBrZXlmcmFtZXMsIGFuZCBjb21wb25lbnRzIG91dHNpZGUgb2YgYW55XG4gICAgKiBTdHlsZVNoZWV0TWFuYWdlcidzIGNvbnRleHQgKi9cblxuXG4gIC8qIHJlc2V0IHRoZSBpbnRlcm5hbCBcIm1hc3RlclwiIGluc3RhbmNlICovXG4gIFN0eWxlU2hlZXQucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB2YXIgZm9yY2VTZXJ2ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgbWFzdGVyID0gbmV3IFN0eWxlU2hlZXQodW5kZWZpbmVkLCBmb3JjZVNlcnZlcikucmVoeWRyYXRlKCk7XG4gIH07XG5cbiAgLyogYWRkcyBcImNoaWxkcmVuXCIgdG8gdGhlIFN0eWxlU2hlZXQgdGhhdCBpbmhlcml0IGFsbCBvZiB0aGUgcGFyZW50cycgcnVsZXNcbiAgICogd2hpbGUgdGhlaXIgb3duIHJ1bGVzIGRvIG5vdCBhZmZlY3QgdGhlIHBhcmVudCAqL1xuXG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICB2YXIgc2hlZXQgPSBuZXcgU3R5bGVTaGVldCh0aGlzLnRhcmdldCwgdGhpcy5mb3JjZVNlcnZlcik7XG4gICAgLyogYWRkIHRvIGNsb25lIGFycmF5ICovXG4gICAgdGhpcy5jbG9uZXMucHVzaChzaGVldCk7XG5cbiAgICAvKiBjbG9uZSBhbGwgdGFncyAqL1xuICAgIHNoZWV0LnRhZ3MgPSB0aGlzLnRhZ3MubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgIHZhciBpZHMgPSB0YWcuZ2V0SWRzKCk7XG4gICAgICB2YXIgbmV3VGFnID0gdGFnLmNsb25lKCk7XG5cbiAgICAgIC8qIHJlY29uc3RydWN0IHRhZ01hcCAqL1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc2hlZXQudGFnTWFwW2lkc1tpXV0gPSBuZXdUYWc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdUYWc7XG4gICAgfSk7XG5cbiAgICAvKiBjbG9uZSBvdGhlciBtYXBzICovXG4gICAgc2hlZXQucmVoeWRyYXRlZE5hbWVzID0gX2V4dGVuZHMoe30sIHRoaXMucmVoeWRyYXRlZE5hbWVzKTtcbiAgICBzaGVldC5kZWZlcnJlZCA9IF9leHRlbmRzKHt9LCB0aGlzLmRlZmVycmVkKTtcblxuICAgIHJldHVybiBzaGVldDtcbiAgfTtcblxuICAvKiBmb3JjZSBTdHlsZVNoZWV0IHRvIGNyZWF0ZSBhIG5ldyB0YWcgb24gdGhlIG5leHQgaW5qZWN0aW9uICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5zZWFsQWxsVGFncyA9IGZ1bmN0aW9uIHNlYWxBbGxUYWdzKCkge1xuICAgIHRoaXMuY2FwYWNpdHkgPSAxO1xuICAgIHRoaXMuc2VhbGVkID0gdHJ1ZTtcbiAgfTtcblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5tYWtlVGFnID0gZnVuY3Rpb24gbWFrZVRhZyQkMSh0YWcpIHtcbiAgICB2YXIgbGFzdEVsID0gdGFnID8gdGFnLnN0eWxlVGFnIDogbnVsbDtcbiAgICB2YXIgaW5zZXJ0QmVmb3JlID0gZmFsc2U7XG5cbiAgICByZXR1cm4gbWFrZVRhZyh0aGlzLnRhcmdldCwgbGFzdEVsLCB0aGlzLmZvcmNlU2VydmVyLCBpbnNlcnRCZWZvcmUsIHRoaXMuZ2V0SW1wb3J0UnVsZVRhZyk7XG4gIH07XG5cbiAgLyogZ2V0IGEgdGFnIGZvciBhIGdpdmVuIGNvbXBvbmVudElkLCBhc3NpZ24gdGhlIGNvbXBvbmVudElkIHRvIG9uZSwgb3Igc2hhcmQgKi9cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUuZ2V0VGFnRm9ySWQgPSBmdW5jdGlvbiBnZXRUYWdGb3JJZChpZCkge1xuICAgIC8qIHNpbXBseSByZXR1cm4gYSB0YWcsIHdoZW4gdGhlIGNvbXBvbmVudElkIHdhcyBhbHJlYWR5IGFzc2lnbmVkIG9uZSAqL1xuICAgIHZhciBwcmV2ID0gdGhpcy50YWdNYXBbaWRdO1xuICAgIGlmIChwcmV2ICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuc2VhbGVkKSB7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gdGhpcy50YWdzW3RoaXMudGFncy5sZW5ndGggLSAxXTtcblxuICAgIC8qIHNoYXJkIChjcmVhdGUgYSBuZXcgdGFnKSBpZiB0aGUgdGFnIGlzIGV4aGF1c3RlZCAoU2VlIE1BWF9TSVpFKSAqL1xuICAgIHRoaXMuY2FwYWNpdHkgLT0gMTtcbiAgICBpZiAodGhpcy5jYXBhY2l0eSA9PT0gMCkge1xuICAgICAgdGhpcy5jYXBhY2l0eSA9IE1BWF9TSVpFO1xuICAgICAgdGhpcy5zZWFsZWQgPSBmYWxzZTtcbiAgICAgIHRhZyA9IHRoaXMubWFrZVRhZyh0YWcpO1xuICAgICAgdGhpcy50YWdzLnB1c2godGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50YWdNYXBbaWRdID0gdGFnO1xuICB9O1xuXG4gIC8qIG1haW5seSBmb3IgaW5qZWN0R2xvYmFsIHRvIGNoZWNrIGZvciBpdHMgaWQgKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLmhhc0lkID0gZnVuY3Rpb24gaGFzSWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy50YWdNYXBbaWRdICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgLyogY2FjaGluZyBsYXllciBjaGVja2luZyBpZCtuYW1lIHRvIGFscmVhZHkgaGF2ZSBhIGNvcnJlc3BvbmRpbmcgdGFnIGFuZCBpbmplY3RlZCBydWxlcyAqL1xuXG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUuaGFzTmFtZUZvcklkID0gZnVuY3Rpb24gaGFzTmFtZUZvcklkKGlkLCBuYW1lKSB7XG4gICAgLyogZXhjZXB0aW9uIGZvciByZWh5ZHJhdGVkIG5hbWVzIHdoaWNoIGFyZSBjaGVja2VkIHNlcGFyYXRlbHkgKi9cbiAgICBpZiAodGhpcy5pZ25vcmVSZWh5ZHJhdGVkTmFtZXNbaWRdID09PSB1bmRlZmluZWQgJiYgdGhpcy5yZWh5ZHJhdGVkTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciB0YWcgPSB0aGlzLnRhZ01hcFtpZF07XG4gICAgcmV0dXJuIHRhZyAhPT0gdW5kZWZpbmVkICYmIHRhZy5oYXNOYW1lRm9ySWQoaWQsIG5hbWUpO1xuICB9O1xuXG4gIC8qIHJlZ2lzdGVycyBhIGNvbXBvbmVudElkIGFuZCByZWdpc3RlcnMgaXQgb24gaXRzIHRhZyAqL1xuXG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUuZGVmZXJyZWRJbmplY3QgPSBmdW5jdGlvbiBkZWZlcnJlZEluamVjdChpZCwgY3NzUnVsZXMpIHtcbiAgICAvKiBkb24ndCBpbmplY3Qgd2hlbiB0aGUgaWQgaXMgYWxyZWFkeSByZWdpc3RlcmVkICovXG4gICAgaWYgKHRoaXMudGFnTWFwW2lkXSAhPT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICB2YXIgY2xvbmVzID0gdGhpcy5jbG9uZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2xvbmVzW2ldLmRlZmVycmVkSW5qZWN0KGlkLCBjc3NSdWxlcyk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRUYWdGb3JJZChpZCkuaW5zZXJ0TWFya2VyKGlkKTtcbiAgICB0aGlzLmRlZmVycmVkW2lkXSA9IGNzc1J1bGVzO1xuICB9O1xuXG4gIC8qIGluamVjdHMgcnVsZXMgZm9yIGEgZ2l2ZW4gaWQgd2l0aCBhIG5hbWUgdGhhdCB3aWxsIG5lZWQgdG8gYmUgY2FjaGVkICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbiBpbmplY3QoaWQsIGNzc1J1bGVzLCBuYW1lKSB7XG4gICAgdmFyIGNsb25lcyA9IHRoaXMuY2xvbmVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNsb25lc1tpXS5pbmplY3QoaWQsIGNzc1J1bGVzLCBuYW1lKTtcbiAgICB9XG5cbiAgICAvKiBhZGQgZGVmZXJyZWQgcnVsZXMgZm9yIGNvbXBvbmVudCAqL1xuICAgIHZhciBpbmplY3RSdWxlcyA9IGNzc1J1bGVzO1xuICAgIHZhciBkZWZlcnJlZFJ1bGVzID0gdGhpcy5kZWZlcnJlZFtpZF07XG4gICAgaWYgKGRlZmVycmVkUnVsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5qZWN0UnVsZXMgPSBkZWZlcnJlZFJ1bGVzLmNvbmNhdChpbmplY3RSdWxlcyk7XG4gICAgICBkZWxldGUgdGhpcy5kZWZlcnJlZFtpZF07XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IHRoaXMuZ2V0VGFnRm9ySWQoaWQpO1xuICAgIHRhZy5pbnNlcnRSdWxlcyhpZCwgaW5qZWN0UnVsZXMsIG5hbWUpO1xuICB9O1xuXG4gIC8qIHJlbW92ZXMgYWxsIHJ1bGVzIGZvciBhIGdpdmVuIGlkLCB3aGljaCBkb2Vzbid0IHJlbW92ZSBpdHMgbWFya2VyIGJ1dCByZXNldHMgaXQgKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShpZCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZ01hcFtpZF07XG4gICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICB2YXIgY2xvbmVzID0gdGhpcy5jbG9uZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2xvbmVzW2ldLnJlbW92ZShpZCk7XG4gICAgfVxuXG4gICAgLyogcmVtb3ZlIGFsbCBydWxlcyBmcm9tIHRoZSB0YWcgKi9cbiAgICB0YWcucmVtb3ZlUnVsZXMoaWQpO1xuICAgIC8qIGlnbm9yZSBwb3NzaWJsZSByZWh5ZHJhdGVkIG5hbWVzICovXG4gICAgdGhpcy5pZ25vcmVSZWh5ZHJhdGVkTmFtZXNbaWRdID0gdHJ1ZTtcbiAgICAvKiBkZWxldGUgcG9zc2libGUgZGVmZXJyZWQgcnVsZXMgKi9cbiAgICBkZWxldGUgdGhpcy5kZWZlcnJlZFtpZF07XG4gIH07XG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUudG9IVE1MID0gZnVuY3Rpb24gdG9IVE1MKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgIHJldHVybiB0YWcudG9IVE1MKCk7XG4gICAgfSkuam9pbignJyk7XG4gIH07XG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUudG9SZWFjdEVsZW1lbnRzID0gZnVuY3Rpb24gdG9SZWFjdEVsZW1lbnRzKCkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG5cblxuICAgIHJldHVybiB0aGlzLnRhZ3MubWFwKGZ1bmN0aW9uICh0YWcsIGkpIHtcbiAgICAgIHZhciBrZXkgPSAnc2MtJyArIGlkICsgJy0nICsgaTtcbiAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQodGFnLnRvRWxlbWVudCgpLCB7IGtleToga2V5IH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGNyZWF0ZUNsYXNzKFN0eWxlU2hlZXQsIG51bGwsIFt7XG4gICAga2V5OiAnbWFzdGVyJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBtYXN0ZXIgfHwgKG1hc3RlciA9IG5ldyBTdHlsZVNoZWV0KCkucmVoeWRyYXRlKCkpO1xuICAgIH1cblxuICAgIC8qIE5PVEU6IFRoaXMgaXMganVzdCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCBqZXN0LXN0eWxlZC1jb21wb25lbnRzICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luc3RhbmNlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBTdHlsZVNoZWV0Lm1hc3RlcjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbnZhciBfU3R5bGVTaGVldE1hbmFnZXIkY2g7XG5cbi8vIFxuLyogdGhpcyBlcnJvciBpcyB1c2VkIGZvciBtYWtlU3R5bGVUYWcgKi9cbnZhciB0YXJnZXRQcm9wRXJyID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICdcXG5UaGUgU3R5bGVTaGVldE1hbmFnZXIgZXhwZWN0cyBhIHZhbGlkIHRhcmdldCBvciBzaGVldCBwcm9wIVxcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBjbGllbnQgYW5kIGlzIHlvdXIgdGFyZ2V0IGZhbHN5P1xcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBzZXJ2ZXIgYW5kIGlzIHRoZSBzaGVldCBmYWxzeT9cXG4nLnRyaW0oKSA6ICcnO1xuXG52YXIgU3R5bGVTaGVldE1hbmFnZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhTdHlsZVNoZWV0TWFuYWdlciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3R5bGVTaGVldE1hbmFnZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVTaGVldE1hbmFnZXIpO1xuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBTdHlsZVNoZWV0TWFuYWdlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltDT05URVhUX0tFWV0gPSB0aGlzLnNoZWV0SW5zdGFuY2UsIF9yZWY7XG4gIH07XG5cbiAgU3R5bGVTaGVldE1hbmFnZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5zaGVldCkge1xuICAgICAgdGhpcy5zaGVldEluc3RhbmNlID0gdGhpcy5wcm9wcy5zaGVldDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMudGFyZ2V0KSB7XG4gICAgICB0aGlzLnNoZWV0SW5zdGFuY2UgPSBuZXcgU3R5bGVTaGVldCh0aGlzLnByb3BzLnRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih0YXJnZXRQcm9wRXJyKTtcbiAgICB9XG4gIH07XG5cbiAgU3R5bGVTaGVldE1hbmFnZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcm9wLXR5cGVzICovXG4gICAgLy8gRmxvdyB2MC40My4xIHdpbGwgcmVwb3J0IGFuIGVycm9yIGFjY2Vzc2luZyB0aGUgYGNoaWxkcmVuYCBwcm9wZXJ0eSxcbiAgICAvLyBidXQgdjAuNDcuMCB3aWxsIG5vdC4gSXQgaXMgbmVjZXNzYXJ5IHRvIHVzZSBhIHR5cGUgY2FzdCBpbnN0ZWFkIG9mXG4gICAgLy8gYSBcImZpeG1lXCIgY29tbWVudCB0byBzYXRpc2Z5IGJvdGggRmxvdyB2ZXJzaW9ucy5cbiAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfTtcblxuICByZXR1cm4gU3R5bGVTaGVldE1hbmFnZXI7XG59KENvbXBvbmVudCk7XG5cblN0eWxlU2hlZXRNYW5hZ2VyLmNoaWxkQ29udGV4dFR5cGVzID0gKF9TdHlsZVNoZWV0TWFuYWdlciRjaCA9IHt9LCBfU3R5bGVTaGVldE1hbmFnZXIkY2hbQ09OVEVYVF9LRVldID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmluc3RhbmNlT2YoU3R5bGVTaGVldCksIFByb3BUeXBlcy5pbnN0YW5jZU9mKFNlcnZlclN0eWxlU2hlZXQpXSkuaXNSZXF1aXJlZCwgX1N0eWxlU2hlZXRNYW5hZ2VyJGNoKTtcblxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU3R5bGVTaGVldE1hbmFnZXIucHJvcFR5cGVzID0ge1xuICBzaGVldDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmluc3RhbmNlT2YoU3R5bGVTaGVldCksIFByb3BUeXBlcy5pbnN0YW5jZU9mKFNlcnZlclN0eWxlU2hlZXQpXSksXG4gIHRhcmdldDogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBhcHBlbmRDaGlsZDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9KVxufSA6IHZvaWQgMDtcblxuLy8gXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuLyogdGhpcyBlcnJvciBpcyB1c2VkIGZvciBtYWtlU3R5bGVUYWcgKi9cbnZhciBzaGVldENsb3NlZEVyciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAnXFxuQ2FuXFwndCBjb2xsZWN0IHN0eWxlcyBvbmNlIHlvdVxcJ3ZlIGNvbnN1bWVkIGEgU2VydmVyU3R5bGVTaGVldFxcJ3Mgc3R5bGVzIVxcblNlcnZlclN0eWxlU2hlZXQgaXMgYSBvbmUgb2ZmIGluc3RhbmNlIGZvciBlYWNoIHNlcnZlci1zaWRlIHJlbmRlciBjeWNsZS5cXG4tIEFyZSB5b3UgdHJ5aW5nIHRvIHJldXNlIGl0IGFjcm9zcyByZW5kZXJzP1xcbi0gQXJlIHlvdSBhY2NpZGVudGFsbHkgY2FsbGluZyBjb2xsZWN0U3R5bGVzIHR3aWNlP1xcbicudHJpbSgpIDogJyc7XG5cbnZhciBzdHJlYW1Ccm93c2VyRXJyID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICdTdHJlYW1pbmcgU1NSIGlzIG9ubHkgc3VwcG9ydGVkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudDsgUGxlYXNlIGRvIG5vdCB0cnkgdG8gY2FsbCB0aGlzIG1ldGhvZCBpbiB0aGUgYnJvd3Nlci4nIDogJyc7XG5cbnZhciBTZXJ2ZXJTdHlsZVNoZWV0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTZXJ2ZXJTdHlsZVNoZWV0KCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNlcnZlclN0eWxlU2hlZXQpO1xuXG4gICAgLyogVGhlIG1hc3RlciBzaGVldCBtaWdodCBiZSByZXNldCwgc28ga2VlcCBhIHJlZmVyZW5jZSBoZXJlICovXG4gICAgdGhpcy5tYXN0ZXJTaGVldCA9IFN0eWxlU2hlZXQubWFzdGVyO1xuICAgIHRoaXMuaW5zdGFuY2UgPSB0aGlzLm1hc3RlclNoZWV0LmNsb25lKCk7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgfVxuXG4gIFNlcnZlclN0eWxlU2hlZXQucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgLyogUmVtb3ZlIGNsb3NlZCBTdHlsZVNoZWV0cyBmcm9tIHRoZSBtYXN0ZXIgc2hlZXQgKi9cbiAgICAgIHZhciBpbmRleCA9IHRoaXMubWFzdGVyU2hlZXQuY2xvbmVzLmluZGV4T2YodGhpcy5pbnN0YW5jZSk7XG4gICAgICB0aGlzLm1hc3RlclNoZWV0LmNsb25lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBTZXJ2ZXJTdHlsZVNoZWV0LnByb3RvdHlwZS5jb2xsZWN0U3R5bGVzID0gZnVuY3Rpb24gY29sbGVjdFN0eWxlcyhjaGlsZHJlbikge1xuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHNoZWV0Q2xvc2VkRXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFN0eWxlU2hlZXRNYW5hZ2VyLFxuICAgICAgeyBzaGVldDogdGhpcy5pbnN0YW5jZSB9LFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9O1xuXG4gIFNlcnZlclN0eWxlU2hlZXQucHJvdG90eXBlLmdldFN0eWxlVGFncyA9IGZ1bmN0aW9uIGdldFN0eWxlVGFncygpIHtcbiAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UudG9IVE1MKCk7XG4gIH07XG5cbiAgU2VydmVyU3R5bGVTaGVldC5wcm90b3R5cGUuZ2V0U3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gZ2V0U3R5bGVFbGVtZW50KCkge1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS50b1JlYWN0RWxlbWVudHMoKTtcbiAgfTtcblxuICBTZXJ2ZXJTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnRlcmxlYXZlV2l0aE5vZGVTdHJlYW0gPSBmdW5jdGlvbiBpbnRlcmxlYXZlV2l0aE5vZGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmVhbUJyb3dzZXJFcnIpO1xuICAgIH1cblxuICAgIC8qIHRoZSB0YWcgaW5kZXgga2VlcHMgdHJhY2sgb2Ygd2hpY2ggdGFncyBoYXZlIGFscmVhZHkgYmVlbiBlbWl0dGVkICovXG4gICAgdmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblxuICAgIHZhciBpbnN0YW5jZVRhZ0luZGV4ID0gMDtcblxuICAgIHZhciBzdHJlYW1BdHRyID0gU0NfU1RSRUFNX0FUVFIgKyAnPVwidHJ1ZVwiJztcbiAgICB2YXIgb3VyU3RyZWFtID0gbmV3IHN0cmVhbS5SZWFkYWJsZSgpO1xuICAgIC8vICRGbG93Rml4TWVcbiAgICBvdXJTdHJlYW0uX3JlYWQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIHJlYWRhYmxlU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB2YXIgdGFncyA9IGluc3RhbmNlLnRhZ3M7XG5cbiAgICAgIHZhciBodG1sID0gJyc7XG5cbiAgICAgIC8qIHJldHJpZXZlIGh0bWwgZm9yIGVhY2ggbmV3IHN0eWxlIHRhZyAqL1xuICAgICAgZm9yICg7IGluc3RhbmNlVGFnSW5kZXggPCB0YWdzLmxlbmd0aDsgaW5zdGFuY2VUYWdJbmRleCArPSAxKSB7XG4gICAgICAgIHZhciB0YWcgPSB0YWdzW2luc3RhbmNlVGFnSW5kZXhdO1xuICAgICAgICBodG1sICs9IHRhZy50b0hUTUwoc3RyZWFtQXR0cik7XG4gICAgICB9XG5cbiAgICAgIC8qIGZvcmNlIG91ciBTdHlsZVNoZWV0cyB0byBlbWl0IGVudGlyZWx5IG5ldyB0YWdzICovXG4gICAgICBpbnN0YW5jZS5zZWFsQWxsVGFncygpO1xuICAgICAgLyogcHJlcGVuZCBzdHlsZSBodG1sIHRvIGNodW5rICovXG4gICAgICBvdXJTdHJlYW0ucHVzaChodG1sICsgY2h1bmspO1xuICAgIH0pO1xuXG4gICAgcmVhZGFibGVTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmNvbXBsZXRlKCk7XG4gICAgICBvdXJTdHJlYW0ucHVzaChudWxsKTtcbiAgICB9KTtcblxuICAgIHJlYWRhYmxlU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIF90aGlzLmNvbXBsZXRlKCk7XG4gICAgICBvdXJTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG91clN0cmVhbTtcbiAgfTtcblxuICByZXR1cm4gU2VydmVyU3R5bGVTaGVldDtcbn0oKTtcblxuLy8gXG5cbnZhciBMSU1JVCA9IDIwMDtcblxudmFyIGNyZWF0ZVdhcm5Ub29NYW55Q2xhc3NlcyA9IChmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgdmFyIGdlbmVyYXRlZENsYXNzZXMgPSB7fTtcbiAgdmFyIHdhcm5pbmdTZWVuID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICBpZiAoIXdhcm5pbmdTZWVuKSB7XG4gICAgICBnZW5lcmF0ZWRDbGFzc2VzW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGdlbmVyYXRlZENsYXNzZXMpLmxlbmd0aCA+PSBMSU1JVCkge1xuICAgICAgICAvLyBVbmFibGUgdG8gZmluZCBsYXRlc3RSdWxlIGluIHRlc3QgZW52aXJvbm1lbnQuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUsIHByZWZlci10ZW1wbGF0ZSAqL1xuICAgICAgICBjb25zb2xlLndhcm4oJ092ZXIgJyArIExJTUlUICsgJyBjbGFzc2VzIHdlcmUgZ2VuZXJhdGVkIGZvciBjb21wb25lbnQgJyArIGRpc3BsYXlOYW1lICsgJy4gXFxuJyArICdDb25zaWRlciB1c2luZyB0aGUgYXR0cnMgbWV0aG9kLCB0b2dldGhlciB3aXRoIGEgc3R5bGUgb2JqZWN0IGZvciBmcmVxdWVudGx5IGNoYW5nZWQgc3R5bGVzLlxcbicgKyAnRXhhbXBsZTpcXG4nICsgJyAgY29uc3QgQ29tcG9uZW50ID0gc3R5bGVkLmRpdi5hdHRycyh7XFxuJyArICcgICAgc3R5bGU6ICh7IGJhY2tncm91bmQgfSkgPT4gKHtcXG4nICsgJyAgICAgIGJhY2tncm91bmQsXFxuJyArICcgICAgfSksXFxuJyArICcgIH0pYHdpZHRoOiAxMDAlO2BcXG5cXG4nICsgJyAgPENvbXBvbmVudCAvPicpO1xuICAgICAgICB3YXJuaW5nU2VlbiA9IHRydWU7XG4gICAgICAgIGdlbmVyYXRlZENsYXNzZXMgPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KTtcblxuLy8gXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4vKipcbiAqIFRyeWluZyB0byBhdm9pZCB0aGUgdW5rbm93bi1wcm9wIGVycm9ycyBvbiBzdHlsZWQgY29tcG9uZW50cyBieSBmaWx0ZXJpbmcgYnlcbiAqIFJlYWN0J3MgYXR0cmlidXRlIHdoaXRlbGlzdC5cbiAqXG4gKiBUbyByZWdlbmVyYXRlIHRoaXMgcmVnZXg6XG4gKlxuICogMS4gYG5wbSBpIC1nIHJlZ2V4Z2VuYCAoaHR0cHM6Ly9naXRodWIuY29tL2Rldm9uZ292ZXR0L3JlZ2V4Z2VuKVxuICogMi4gUnVuIGByZWdleGdlbmAgd2l0aCB0aGUgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgd29yZHMgYmVsb3cgYXMgaW5wdXRcbiAqIDMuIFN1cnJvdW5kIHRoZSBlbWl0dGVkIHJlZ2V4IHdpdGggdGhpczogYC9eKEdFTkVSQVRFRF9SRUdFWCkkL2AgLS0gdGhpcyB3aWxsIGVuc3VyZSBhIGZ1bGwgc3RyaW5nIG1hdGNoXG4gKiAgICBhbmQgbm8gZmFsc2UgcG9zaXRpdmVzIGZyb20gcGFydGlhbHNcbiAqKi9cbi8qXG5jaGlsZHJlbiBkYW5nZXJvdXNseVNldElubmVySFRNTCBrZXkgcmVmIGF1dG9Gb2N1cyBkZWZhdWx0VmFsdWUgdmFsdWVMaW5rIGRlZmF1bHRDaGVja2VkIGNoZWNrZWRMaW5rIGlubmVySFRNTCBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgb25Gb2N1c0luIG9uRm9jdXNPdXQgY2xhc3NOYW1lIG9uQ29weSBvbkN1dCBvblBhc3RlIG9uQ29tcG9zaXRpb25FbmQgb25Db21wb3NpdGlvblN0YXJ0IG9uQ29tcG9zaXRpb25VcGRhdGUgb25LZXlEb3duIG9uS2V5UHJlc3Mgb25LZXlVcCBvbkZvY3VzIG9uQmx1ciBvbkNoYW5nZSBvbklucHV0IG9uU3VibWl0IG9uUmVzZXQgb25DbGljayBvbkNvbnRleHRNZW51IG9uRG91YmxlQ2xpY2sgb25EcmFnIG9uRHJhZ0VuZCBvbkRyYWdFbnRlciBvbkRyYWdFeGl0IG9uRHJhZ0xlYXZlIG9uRHJhZ092ZXIgb25EcmFnU3RhcnQgb25Ecm9wIG9uTW91c2VEb3duIG9uTW91c2VFbnRlciBvbk1vdXNlTGVhdmUgb25Nb3VzZU1vdmUgb25Nb3VzZU91dCBvbk1vdXNlT3ZlciBvbk1vdXNlVXAgb25TZWxlY3Qgb25Ub3VjaENhbmNlbCBvblRvdWNoRW5kIG9uVG91Y2hNb3ZlIG9uVG91Y2hTdGFydCBvblNjcm9sbCBvbldoZWVsIG9uQWJvcnQgb25DYW5QbGF5IG9uQ2FuUGxheVRocm91Z2ggb25EdXJhdGlvbkNoYW5nZSBvbkVtcHRpZWQgb25FbmNyeXB0ZWQgb25FbmRlZCBvbkVycm9yIG9uTG9hZGVkRGF0YSBvbkxvYWRlZE1ldGFkYXRhIG9uTG9hZFN0YXJ0IG9uUGF1c2Ugb25QbGF5IG9uUGxheWluZyBvblByb2dyZXNzIG9uUmF0ZUNoYW5nZSBvblNlZWtlZCBvblNlZWtpbmcgb25TdGFsbGVkIG9uU3VzcGVuZCBvblRpbWVVcGRhdGUgb25Wb2x1bWVDaGFuZ2Ugb25XYWl0aW5nIG9uTG9hZCBvbkFuaW1hdGlvblN0YXJ0IG9uQW5pbWF0aW9uRW5kIG9uQW5pbWF0aW9uSXRlcmF0aW9uIG9uVHJhbnNpdGlvbkVuZCBvbkNvcHlDYXB0dXJlIG9uQ3V0Q2FwdHVyZSBvblBhc3RlQ2FwdHVyZSBvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSBvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlIG9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlIG9uS2V5RG93bkNhcHR1cmUgb25LZXlQcmVzc0NhcHR1cmUgb25LZXlVcENhcHR1cmUgb25Gb2N1c0NhcHR1cmUgb25CbHVyQ2FwdHVyZSBvbkNoYW5nZUNhcHR1cmUgb25JbnB1dENhcHR1cmUgb25TdWJtaXRDYXB0dXJlIG9uUmVzZXRDYXB0dXJlIG9uQ2xpY2tDYXB0dXJlIG9uQ29udGV4dE1lbnVDYXB0dXJlIG9uRG91YmxlQ2xpY2tDYXB0dXJlIG9uRHJhZ0NhcHR1cmUgb25EcmFnRW5kQ2FwdHVyZSBvbkRyYWdFbnRlckNhcHR1cmUgb25EcmFnRXhpdENhcHR1cmUgb25EcmFnTGVhdmVDYXB0dXJlIG9uRHJhZ092ZXJDYXB0dXJlIG9uRHJhZ1N0YXJ0Q2FwdHVyZSBvbkRyb3BDYXB0dXJlIG9uTW91c2VEb3duQ2FwdHVyZSBvbk1vdXNlRW50ZXJDYXB0dXJlIG9uTW91c2VMZWF2ZUNhcHR1cmUgb25Nb3VzZU1vdmVDYXB0dXJlIG9uTW91c2VPdXRDYXB0dXJlIG9uTW91c2VPdmVyQ2FwdHVyZSBvbk1vdXNlVXBDYXB0dXJlIG9uU2VsZWN0Q2FwdHVyZSBvblRvdWNoQ2FuY2VsQ2FwdHVyZSBvblRvdWNoRW5kQ2FwdHVyZSBvblRvdWNoTW92ZUNhcHR1cmUgb25Ub3VjaFN0YXJ0Q2FwdHVyZSBvblNjcm9sbENhcHR1cmUgb25XaGVlbENhcHR1cmUgb25BYm9ydENhcHR1cmUgb25DYW5QbGF5Q2FwdHVyZSBvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZSBvbkR1cmF0aW9uQ2hhbmdlQ2FwdHVyZSBvbkVtcHRpZWRDYXB0dXJlIG9uRW5jcnlwdGVkQ2FwdHVyZSBvbkVuZGVkQ2FwdHVyZSBvbkVycm9yQ2FwdHVyZSBvbkxvYWRlZERhdGFDYXB0dXJlIG9uTG9hZGVkTWV0YWRhdGFDYXB0dXJlIG9uTG9hZFN0YXJ0Q2FwdHVyZSBvblBhdXNlQ2FwdHVyZSBvblBsYXlDYXB0dXJlIG9uUGxheWluZ0NhcHR1cmUgb25Qcm9ncmVzc0NhcHR1cmUgb25SYXRlQ2hhbmdlQ2FwdHVyZSBvblNlZWtlZENhcHR1cmUgb25TZWVraW5nQ2FwdHVyZSBvblN0YWxsZWRDYXB0dXJlIG9uU3VzcGVuZENhcHR1cmUgb25UaW1lVXBkYXRlQ2FwdHVyZSBvblZvbHVtZUNoYW5nZUNhcHR1cmUgb25XYWl0aW5nQ2FwdHVyZSBvbkxvYWRDYXB0dXJlIG9uQW5pbWF0aW9uU3RhcnRDYXB0dXJlIG9uQW5pbWF0aW9uRW5kQ2FwdHVyZSBvbkFuaW1hdGlvbkl0ZXJhdGlvbkNhcHR1cmUgb25UcmFuc2l0aW9uRW5kQ2FwdHVyZSBhY2NlcHQgYWNjZXB0Q2hhcnNldCBhY2Nlc3NLZXkgYWN0aW9uIGFsbG93RnVsbFNjcmVlbiBhbGxvd1RyYW5zcGFyZW5jeSBhbHQgYXMgYXN5bmMgYXV0b0NvbXBsZXRlIGF1dG9QbGF5IGNhcHR1cmUgY2VsbFBhZGRpbmcgY2VsbFNwYWNpbmcgY2hhclNldCBjaGFsbGVuZ2UgY2hlY2tlZCBjaXRlIGNsYXNzSUQgY2xhc3NOYW1lIGNvbHMgY29sU3BhbiBjb250ZW50IGNvbnRlbnRFZGl0YWJsZSBjb250ZXh0TWVudSBjb250cm9sc0xpc3QgY29udHJvbHMgY29vcmRzIGNyb3NzT3JpZ2luIGRhdGEgZGF0ZVRpbWUgZGVmYXVsdCBkZWZlciBkaXIgZGlzYWJsZWQgZG93bmxvYWQgZHJhZ2dhYmxlIGVuY1R5cGUgZm9ybSBmb3JtQWN0aW9uIGZvcm1FbmNUeXBlIGZvcm1NZXRob2QgZm9ybU5vVmFsaWRhdGUgZm9ybVRhcmdldCBmcmFtZUJvcmRlciBoZWFkZXJzIGhlaWdodCBoaWRkZW4gaGlnaCBocmVmIGhyZWZMYW5nIGh0bWxGb3IgaHR0cEVxdWl2IGljb24gaWQgaW5wdXRNb2RlIGludGVncml0eSBpcyBrZXlQYXJhbXMga2V5VHlwZSBraW5kIGxhYmVsIGxhbmcgbGlzdCBsb29wIGxvdyBtYW5pZmVzdCBtYXJnaW5IZWlnaHQgbWFyZ2luV2lkdGggbWF4IG1heExlbmd0aCBtZWRpYSBtZWRpYUdyb3VwIG1ldGhvZCBtaW4gbWluTGVuZ3RoIG11bHRpcGxlIG11dGVkIG5hbWUgbm9uY2Ugbm9WYWxpZGF0ZSBvcGVuIG9wdGltdW0gcGF0dGVybiBwbGFjZWhvbGRlciBwbGF5c0lubGluZSBwb3N0ZXIgcHJlbG9hZCBwcm9maWxlIHJhZGlvR3JvdXAgcmVhZE9ubHkgcmVmZXJyZXJQb2xpY3kgcmVsIHJlcXVpcmVkIHJldmVyc2VkIHJvbGUgcm93cyByb3dTcGFuIHNhbmRib3ggc2NvcGUgc2NvcGVkIHNjcm9sbGluZyBzZWFtbGVzcyBzZWxlY3RlZCBzaGFwZSBzaXplIHNpemVzIHNwYW4gc3BlbGxDaGVjayBzcmMgc3JjRG9jIHNyY0xhbmcgc3JjU2V0IHN0YXJ0IHN0ZXAgc3R5bGUgc3VtbWFyeSB0YWJJbmRleCB0YXJnZXQgdGl0bGUgdHlwZSB1c2VNYXAgdmFsdWUgd2lkdGggd21vZGUgd3JhcCBhYm91dCBkYXRhdHlwZSBpbmxpc3QgcHJlZml4IHByb3BlcnR5IHJlc291cmNlIHR5cGVvZiB2b2NhYiBhdXRvQ2FwaXRhbGl6ZSBhdXRvQ29ycmVjdCBhdXRvU2F2ZSBjb2xvciBpdGVtUHJvcCBpdGVtU2NvcGUgaXRlbVR5cGUgaXRlbUlEIGl0ZW1SZWYgcmVzdWx0cyBzZWN1cml0eSB1bnNlbGVjdGFibGUgYWNjZW50SGVpZ2h0IGFjY3VtdWxhdGUgYWRkaXRpdmUgYWxpZ25tZW50QmFzZWxpbmUgYWxsb3dSZW9yZGVyIGFscGhhYmV0aWMgYW1wbGl0dWRlIGFyYWJpY0Zvcm0gYXNjZW50IGF0dHJpYnV0ZU5hbWUgYXR0cmlidXRlVHlwZSBhdXRvUmV2ZXJzZSBhemltdXRoIGJhc2VGcmVxdWVuY3kgYmFzZVByb2ZpbGUgYmFzZWxpbmVTaGlmdCBiYm94IGJlZ2luIGJpYXMgYnkgY2FsY01vZGUgY2FwSGVpZ2h0IGNsaXAgY2xpcFBhdGggY2xpcFJ1bGUgY2xpcFBhdGhVbml0cyBjb2xvckludGVycG9sYXRpb24gY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycyBjb2xvclByb2ZpbGUgY29sb3JSZW5kZXJpbmcgY29udGVudFNjcmlwdFR5cGUgY29udGVudFN0eWxlVHlwZSBjdXJzb3IgY3ggY3kgZCBkZWNlbGVyYXRlIGRlc2NlbnQgZGlmZnVzZUNvbnN0YW50IGRpcmVjdGlvbiBkaXNwbGF5IGRpdmlzb3IgZG9taW5hbnRCYXNlbGluZSBkdXIgZHggZHkgZWRnZU1vZGUgZWxldmF0aW9uIGVuYWJsZUJhY2tncm91bmQgZW5kIGV4cG9uZW50IGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQgZmlsbCBmaWxsT3BhY2l0eSBmaWxsUnVsZSBmaWx0ZXIgZmlsdGVyUmVzIGZpbHRlclVuaXRzIGZsb29kQ29sb3IgZmxvb2RPcGFjaXR5IGZvY3VzYWJsZSBmb250RmFtaWx5IGZvbnRTaXplIGZvbnRTaXplQWRqdXN0IGZvbnRTdHJldGNoIGZvbnRTdHlsZSBmb250VmFyaWFudCBmb250V2VpZ2h0IGZvcm1hdCBmcm9tIGZ4IGZ5IGcxIGcyIGdseXBoTmFtZSBnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCBnbHlwaE9yaWVudGF0aW9uVmVydGljYWwgZ2x5cGhSZWYgZ3JhZGllbnRUcmFuc2Zvcm0gZ3JhZGllbnRVbml0cyBoYW5naW5nIGhvcml6QWR2WCBob3Jpek9yaWdpblggaWRlb2dyYXBoaWMgaW1hZ2VSZW5kZXJpbmcgaW4gaW4yIGludGVyY2VwdCBrIGsxIGsyIGszIGs0IGtlcm5lbE1hdHJpeCBrZXJuZWxVbml0TGVuZ3RoIGtlcm5pbmcga2V5UG9pbnRzIGtleVNwbGluZXMga2V5VGltZXMgbGVuZ3RoQWRqdXN0IGxldHRlclNwYWNpbmcgbGlnaHRpbmdDb2xvciBsaW1pdGluZ0NvbmVBbmdsZSBsb2NhbCBtYXJrZXJFbmQgbWFya2VyTWlkIG1hcmtlclN0YXJ0IG1hcmtlckhlaWdodCBtYXJrZXJVbml0cyBtYXJrZXJXaWR0aCBtYXNrIG1hc2tDb250ZW50VW5pdHMgbWFza1VuaXRzIG1hdGhlbWF0aWNhbCBtb2RlIG51bU9jdGF2ZXMgb2Zmc2V0IG9wYWNpdHkgb3BlcmF0b3Igb3JkZXIgb3JpZW50IG9yaWVudGF0aW9uIG9yaWdpbiBvdmVyZmxvdyBvdmVybGluZVBvc2l0aW9uIG92ZXJsaW5lVGhpY2tuZXNzIHBhaW50T3JkZXIgcGFub3NlMSBwYXRoTGVuZ3RoIHBhdHRlcm5Db250ZW50VW5pdHMgcGF0dGVyblRyYW5zZm9ybSBwYXR0ZXJuVW5pdHMgcG9pbnRlckV2ZW50cyBwb2ludHMgcG9pbnRzQXRYIHBvaW50c0F0WSBwb2ludHNBdFogcHJlc2VydmVBbHBoYSBwcmVzZXJ2ZUFzcGVjdFJhdGlvIHByaW1pdGl2ZVVuaXRzIHIgcmFkaXVzIHJlZlggcmVmWSByZW5kZXJpbmdJbnRlbnQgcmVwZWF0Q291bnQgcmVwZWF0RHVyIHJlcXVpcmVkRXh0ZW5zaW9ucyByZXF1aXJlZEZlYXR1cmVzIHJlc3RhcnQgcmVzdWx0IHJvdGF0ZSByeCByeSBzY2FsZSBzZWVkIHNoYXBlUmVuZGVyaW5nIHNsb3BlIHNwYWNpbmcgc3BlY3VsYXJDb25zdGFudCBzcGVjdWxhckV4cG9uZW50IHNwZWVkIHNwcmVhZE1ldGhvZCBzdGFydE9mZnNldCBzdGREZXZpYXRpb24gc3RlbWggc3RlbXYgc3RpdGNoVGlsZXMgc3RvcENvbG9yIHN0b3BPcGFjaXR5IHN0cmlrZXRocm91Z2hQb3NpdGlvbiBzdHJpa2V0aHJvdWdoVGhpY2tuZXNzIHN0cmluZyBzdHJva2Ugc3Ryb2tlRGFzaGFycmF5IHN0cm9rZURhc2hvZmZzZXQgc3Ryb2tlTGluZWNhcCBzdHJva2VMaW5lam9pbiBzdHJva2VNaXRlcmxpbWl0IHN0cm9rZU9wYWNpdHkgc3Ryb2tlV2lkdGggc3VyZmFjZVNjYWxlIHN5c3RlbUxhbmd1YWdlIHRhYmxlVmFsdWVzIHRhcmdldFggdGFyZ2V0WSB0ZXh0QW5jaG9yIHRleHREZWNvcmF0aW9uIHRleHRSZW5kZXJpbmcgdGV4dExlbmd0aCB0byB0cmFuc2Zvcm0gdTEgdTIgdW5kZXJsaW5lUG9zaXRpb24gdW5kZXJsaW5lVGhpY2tuZXNzIHVuaWNvZGUgdW5pY29kZUJpZGkgdW5pY29kZVJhbmdlIHVuaXRzUGVyRW0gdkFscGhhYmV0aWMgdkhhbmdpbmcgdklkZW9ncmFwaGljIHZNYXRoZW1hdGljYWwgdmFsdWVzIHZlY3RvckVmZmVjdCB2ZXJzaW9uIHZlcnRBZHZZIHZlcnRPcmlnaW5YIHZlcnRPcmlnaW5ZIHZpZXdCb3ggdmlld1RhcmdldCB2aXNpYmlsaXR5IHdpZHRocyB3b3JkU3BhY2luZyB3cml0aW5nTW9kZSB4IHhIZWlnaHQgeDEgeDIgeENoYW5uZWxTZWxlY3RvciB4bGlua0FjdHVhdGUgeGxpbmtBcmNyb2xlIHhsaW5rSHJlZiB4bGlua1JvbGUgeGxpbmtTaG93IHhsaW5rVGl0bGUgeGxpbmtUeXBlIHhtbEJhc2UgeG1sbnMgeG1sbnNYbGluayB4bWxMYW5nIHhtbFNwYWNlIHkgeTEgeTIgeUNoYW5uZWxTZWxlY3RvciB6IHpvb21BbmRQYW5cbiovXG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9SRUdFWCA9IC9eKCg/OnMoPzp1cHByZXNzQ29udGVudEVkaXRhYmxlV2Fybnxjcm9sbHxwYWMpfCg/OnNoYXBlfGltYWdlfHRleHQpUmVuZGVyfCg/OmxldHRlcnx3b3JkKVNwYWN8dkhhbmd8aGFuZylpbmd8KD86b24oPzpBbmltYXRpb25JdGVyYXRpb258Qyg/Om8oPzptcG9zaXRpb24oPzpVcGRhdGV8U3RhcnR8RW5kKXxudGV4dE1lbnV8cHkpfGFuUGxheVRocm91Z2h8YW5QbGF5fGhhbmdlfGxpY2t8dXQpfCg/Oig/OkR1cmF0aW9ufFZvbHVtZXxSYXRlKUNoYW5nfCg/Ok1vdXNlTGVhfCg/OlRvdWNofE1vdXNlKU1vfERyYWdMZWEpdnxQYXVzKWV8TG9hZGVkKD86TWV0YWR8RClhdGF8KD86QW5pbWF0aW9ufFRvdWNofExvYWR8RHJhZylTdGFydHwoPzooPzpUKD86cmFuc2l0aW9ufG91Y2gpfEFuaW1hdGlvbilFfFN1c3BlKW5kfERvdWJsZUNsaWNrfCg/OlRvdWNoQ2FuY3xXaGUpZWx8KD86TW91c2UoPzpFbnR8T3YpZXxEcmFnKD86RW50fE92KWV8RXJybylyfFRpbWVVcGRhdGV8KD86RSg/Om4oPzpjcnlwdHxkKXxtcHRpKXxTKD86dGFsbHxlZWspKWVkfE1vdXNlRG93bnxQKD86cm9ncmVzc3xsYXlpbmcpfCg/Ok1vdXNlT3V8RHJhZ0V4aXxTKD86ZWxlY3x1Ym1pKXxSZXNlfElucHUpdHxLZXlQcmVzc3xEcmFnRW5kfEtleSg/OkRvd258VXApfCg/OldhaXR8U2Vlaylpbmd8KD86TW91c2VVfERybylwfFNjcm9sbHxQYXN0ZXxGb2N1c3xBYm9ydHxEcmFnfFBsYXl8TG9hZHxCbHVyKUNhcHR1cnxhbGlnbm1lbnRCYXNlbGlufCg/OmxpbWl0aW5nQ29uZUFuZ3x4bGluayg/Oig/OkFyY3J8UilvfFRpdCl8cyg/OnVyZmFjZVNjYXx0eXxjYSl8dW5zZWxlY3RhYnxiYXNlUHJvZml8Zm9udFN0eXwoPzpmb2N1c3xkcmFnZylhYnxtdWx0aXB8cHJvZml8dGl0KWx8ZCg/Om9taW5hbnRCYXNlbGlufGVmYXVsdFZhbHUpfGEoPzp1dG8oPzpDYXBpdGFsaXp8UmV2ZXJzfFNhdil8ZGRpdGl2KXwoPzooPzpmb3JtTm9WYWxpZHx4bGlua0FjdHV8bm9WYWxpZHxhY2N1bXVsfHJvdClhfGF1dG9Db21wbGV8ZGVjZWxlcmEpdHwoPzooPzphdHRyaWJ1dGV8aXRlbSlUfGRhdGF0KXlwfCg/OmF0dHJpYnV0ZXxnbHlwaClOYW18cGxheXNJbmxpbnwoPzpmb3JtRXxlKW5jVHlwfCg/OndyaXRpbmd8aW5wdXR8ZWRnZSlNb2R8KD86eGxpbmtUeXxpdGVtU2NvfGtleVR5fHNsbylwfCg/OmFtcGxpdHV8bW8pZHwoPzp4bWxTcGF8bm9uKWN8ZmlsbFJ1bHwoPzpkYXRlVGl8bmEpbXxyKD86ZXNvdXJjfG9sKXx4bWxCYXN8d21vZCllfCg/OmdseXBoT3JpZW50YXRpb25Ib3Jpem9udHxsb2MpYWx8KD86ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJ8c2VsZWN0fHJldmVyc3xtdXQpZWR8Yyg/Om8oPzpsb3JJbnRlcnBvbGF0aW9uRmlsdGVyfG9yZClzfG8oPzpsb3IoPzpJbnRlcnBvbGF0aW9uKT98bnQoPzpyb2xzfGVudCkpfCg/Om9udGVudFMoPzpjcmlwdHx0eWxlKVR5cHxvKD86bnRlbnRFZGl0YWJ8bG9yUHJvZmkpbHxsKD86YXNzTmFtfGlwUnVsKXxhKD86bGNNb2R8cHR1cil8aXQpZXxvbG9yUmVuZGVyaW5nfGwoPzppcFBhdGhVbml0c3xhc3NJRCl8KD86b250cm9sc0xpc3xhcEhlaWdoKXR8aCg/OmVja2VkTGlua3xhKD86bGxlbmdlfHJTZXQpfGlsZHJlbnxlY2tlZCl8ZWxsKD86U3BhY3xQYWRkKWluZ3xvKD86bnRleHRNZW51fGxzKXwoPzpyb3NzT3JpZ2l8b2xTcGEpbnxsaXAoPzpQYXRoKT98dXJzb3J8W3h5XSl8Z2x5cGhPcmllbnRhdGlvblZlcnRpY2FsfGQoPzphbmdlcm91c2x5U2V0SW5uZXJIVE1MfGVmYXVsdENoZWNrZWR8b3dubG9hZHxpc2FibGVkfGlzcGxheXxbeHldKXwoPzpzKD86dHJpa2V0aHJvdWdoVGhpY2tufGVhbWwpZXN8KD86dW5kfG92KWVybGluZVRoaWNrbmVzfHIoPzplcXVpcmVkRXh0ZW5zaW9ufGFkaXUpfCg/OnJlcXVpcmVkRmVhdHVyfHRhYmxlVmFsdXxzdGl0Y2hUaWx8bnVtT2N0YXZ8ZmlsdGVyUillfGtleSg/Oig/OlNwbGlufFRpbSllfFBhcmFtKXxhdXRvRm9jdXxoZWFkZXJ8YmlhKXN8KD86KD86c3QoPzpyaWtldGhyb3VnaFBvc2l8ZERldmlhKXwoPzp1bmR8b3YpZXJsaW5lUG9zaXwoPzp0ZXh0RGVjb3J8ZWxldilhfG9yaWVudGEpdGlvfCg/OnN0cm9rZUxpbmVqb3xvcmlnKWl8Zm9ybUFjdGlvfHpvb21BbmRQYXxvbkZvY3VzSXxkaXJlY3Rpb3woPzp2ZXJzfGFjdClpb3xyb3dTcGF8YmVnaXxpY28pbnxvKD86big/OkFuaW1hdGlvbkl0ZXJhdGlvbnxDKD86byg/Om1wb3NpdGlvbig/OlVwZGF0ZXxTdGFydHxFbmQpfG50ZXh0TWVudXxweSl8YW5QbGF5VGhyb3VnaHxhblBsYXl8aGFuZ2V8bGlja3x1dCl8KD86KD86RHVyYXRpb258Vm9sdW1lfFJhdGUpQ2hhbmd8KD86TW91c2VMZWF8KD86VG91Y2h8TW91c2UpTW98RHJhZ0xlYSl2fFBhdXMpZXxMb2FkZWQoPzpNZXRhZHxEKWF0YXwoPzpBbmltYXRpb258VG91Y2h8TG9hZHxEcmFnKVN0YXJ0fCg/Oig/OlQoPzpyYW5zaXRpb258b3VjaCl8QW5pbWF0aW9uKUV8U3VzcGUpbmR8RG91YmxlQ2xpY2t8KD86VG91Y2hDYW5jfFdoZSllbHwoPzpNb3VzZSg/OkVudHxPdillfERyYWcoPzpFbnR8T3YpZXxFcnJvKXJ8VGltZVVwZGF0ZXwoPzpFKD86big/OmNyeXB0fGQpfG1wdGkpfFMoPzp0YWxsfGVlaykpZWR8TW91c2VEb3dufFAoPzpyb2dyZXNzfGxheWluZyl8KD86TW91c2VPdXxEcmFnRXhpfFMoPzplbGVjfHVibWkpfFJlc2V8SW5wdSl0fEtleVByZXNzfERyYWdFbmR8S2V5KD86RG93bnxVcCl8KD86V2FpdHxTZWVrKWluZ3woPzpNb3VzZVV8RHJvKXB8U2Nyb2xsfFBhc3RlfEZvY3VzfEFib3J0fERyYWd8UGxheXxMb2FkfEJsdXIpfHJpZW50KXxwKD86cmVzZXJ2ZUEoPzpzcGVjdFJhdGlvfGxwaGEpfG9pbnRzQXRbWC1aXXxhbm9zZTEpfCg/OnBhdHRlcm5Db250ZW50fG1hKD86c2soPzpDb250ZW50KT98cmtlcil8cHJpbWl0aXZlfGdyYWRpZW50fHBhdHRlcm58ZmlsdGVyKVVuaXRzfCg/OmdyYWRpZW50VHxwYXR0ZXJuVHx0KXJhbnNmb3JtfCg/Oig/OmFsbG93VHJhbnNwYXJ8YmFzZUZyZXF1KWVuY3xyZSg/OmZlcnJlclBvbGljfGFkT25sKXwoPzooPzpzdCg/OnJva2V8b3ApT3xmbG9vZE98ZmlsbE98bylwYWN8aW50ZWdyfHNlY3VyKWl0fHZpc2liaWxpdHxmb250RmFtaWx8YWNjZXNzS2V8cHJvcGVydHxzdW1tYXIpeXwoPzpzdHJva2VNaXRlcmxpbWl8KD86c3BlY3VsYXJDb25zdGF8cmVwZWF0Q291fGZvbnRWYXJpYSlufCg/Oig/OnNwZWN1bGFyRXxlKXhwb258cmVuZGVyaW5nSW50fGFzYyllbnxkKD86aWZmdXNlQ29uc3RhfGVzY2UpbnwoPzpmb250U2l6ZUFkanV8bGVuZ3RoQWRqdXxtYW5pZmUpc3xiYXNlbGluZVNoaWZ8dmVjdG9yRWZmZWN8KD86KD86bWFyKD86a2VyfGdpbil8eClIfGFjY2VudEh8Zm9udFcpZWlnaHxhKD86dXRvQ29ycmVjfGJvdSl8bWFya2VyU3RhcnxvbkZvY3VzT3V8aW50ZXJjZXB8cmVzdGFyfGZvcm1hfGlubGlzfGhlaWdofGxpcyl0fCg/Oig/OnN0KD86cm9rZURhc2hvfGFydE8pfG8pZmZzfGFjY2VwdENoYXJzfGZvcm1UYXJnfHZpZXdUYXJnfHNyY1MpZXR8KD86KD86ZW5hYmxlQmFja2dyb3V8bWFya2VyRSlufHMoPzpwKD86cmVhZE1ldGhvfGVlKXxlZSl8Zm9ybU1ldGhvfG0oPzphcmtlck1pfGV0aG8pfHByZWxvYXxraW4pZHxrKD86ZXJuZWwoPzpVbml0TGVuZ3RofE1hdHJpeCl8WzEtNF0pfCg/Olt4eV1DaGFubmVsU2VsZWN0fGxpZ2h0aW5nQ29sfHRleHRBbmNofGZsb29kQ29sfHN0b3BDb2x8b3BlcmF0fGh0bWxGKW9yfCg/OmFsbG93RnVsbFNjcmV8aGlkZCllbnxzdHJva2VEYXNoYXJyYXl8c3lzdGVtTGFuZ3VhZ2V8KD86c3Ryb2tlTGluZWNhfGl0ZW1Qcm98dXNlTWF8d3JhfGxvbylwfHYoPzpNYXRoZW1hdGljYWx8ZXJ0KD86T3JpZ2luW1hZXXxBZHZZKXxhbHVlc3xvY2FiKXwoPzpwb2ludGVyRXZlfGtleVBvaSludHN8dW5pY29kZVJhbmdlfCg/Oig/OmFsbG93UmVvcmR8cGxhY2Vob2xkfGZyYW1lQm9yZHxwYWludE9yZHxwb3N0fG9yZCllfHJlcGVhdER1fGQoPzplZmV8dSkpcnxtYXRoZW1hdGljYWx8KD86dkl8aSlkZW9ncmFwaGljfGgoPzpvcml6KD86T3JpZ2lufEFkdilYfHR0cEVxdWl2KXx1KD86bmljb2RlQmlkaXxbMTJdKXwoPzpmb250U3RyZXRjfGhpZylofCg/Oig/Om1hcig/OmtlcnxnaW4pV3xzdHJva2VXKWlkfGF6aW11KXRofHZBbHBoYWJldGljfG1lZGlhR3JvdXB8c3BlbGxDaGVja3woPzp1bml0c1BlckV8b3B0aW11fGZybyltfHIoPzphZGlvR3JvdXB8ZSg/OnN1bHRzfGZbWFldfGwpfG93c3xbeHldKXwoPzp4bWxuc1hsfHZhbHVlTClpbmt8YSg/OnJhYmljRm9ybXxsKD86cGhhYmV0aWN8dCl8c3luYyl8cGF0aExlbmd0aHwoPzp0ZXh0fG0oPzppbnxheCkpTGVuZ3RofGlubmVySFRNTHx4bGlua1Nob3d8KD86eGxpbmtIcnxnbHlwaFIpZWZ8cig/OmUoPzpxdWlyZWR8c3VsdHxmKSk/fG8oPzp2ZXJmbG93fHBlbil8KD86dGFiSW5kZXwoPzpzYW5kfGIpYm98dmlld0JvKXh8KD86KD86aHJlZnx4bWx8c3JjKUxhfGtlcm5pKW5nfGYoPzpvKD86bnRTaXplfHJtKXxpbCg/OnRlcnxsKSl8YXV0b1BsYXl8dW5pY29kZXxwKD86YXR0ZXJufG9pbnRzKXx0KD86YXJnZXRbWFldfG8pfGkoPzp0ZW1SZWZ8bjJ8cyl8ZGl2aXNvcnxkKD86ZWZhdWx0fGF0YXxpcik/fHNyY0RvY3xzKD86Y29wZWR8dGUoPzptW2h2XXxwKXxwYW4pfCg/OndpZHRofHNpemUpc3woPzpzdHJpfGxhKW5nfHByZWZpeHxpdGVtSUR8cyg/OnQoPzpyb2tlfGFydCl8aGFwZXxjb3BlfHJjKXxhKD86Y2NlcHR8cyl8dCg/OmFyZ2V0fHlwZSl8dHlwZW9mfHdpZHRofHZhbHVlfHgoPzptbG5zKT98bGFiZWx8bSg/OmVkaWF8YSg/OnNrfHgpfGluKXxzaXplfGhyZWZ8ayg/OmV5KT98ZW5kfGxvd3x4WzEyXXxpW2RuXXx5WzEyXXxnWzEyXXxieXxmW3h5XXxbeXpdKSQvO1xuXG4vKiBGcm9tIERPTVByb3BlcnR5ICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9ICc6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEJztcbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCc7XG52YXIgaXNDdXN0b21BdHRyaWJ1dGUgPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZChuZXcgUmVnRXhwKCdeKGRhdGF8YXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpKTtcblxudmFyIHZhbGlkQXR0ciA9IChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gQVRUUklCVVRFX1JFR0VYLnRlc3QobmFtZSkgfHwgaXNDdXN0b21BdHRyaWJ1dGUobmFtZS50b0xvd2VyQ2FzZSgpKTtcbn0pO1xuXG4vLyBcblxuZnVuY3Rpb24gaXNUYWcodGFyZ2V0KSAvKiA6ICVjaGVja3MgKi97XG4gIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJztcbn1cblxuLy8gXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0LmRpc3BsYXlOYW1lIHx8IHRhcmdldC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG4vLyBcblxudmFyIGRldGVybWluZVRoZW1lID0gKGZ1bmN0aW9uIChwcm9wcywgZmFsbGJhY2tUaGVtZSwgZGVmYXVsdFByb3BzKSB7XG4gIC8vIFByb3BzIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBUaGVtZVByb3ZpZGVyLCB3aGljaCBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXJcbiAgLy8gZGVmYXVsdFByb3BzLCBidXQgUmVhY3QgYXV0b21hdGljYWxseSBwdXRzIGRlZmF1bHRQcm9wcyBvbiBwcm9wcy5cblxuICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9wcm9wLXR5cGVzICovXG4gIHZhciBpc0RlZmF1bHRUaGVtZSA9IGRlZmF1bHRQcm9wcyAmJiBwcm9wcy50aGVtZSA9PT0gZGVmYXVsdFByb3BzLnRoZW1lO1xuICB2YXIgdGhlbWUgPSBwcm9wcy50aGVtZSAmJiAhaXNEZWZhdWx0VGhlbWUgPyBwcm9wcy50aGVtZSA6IGZhbGxiYWNrVGhlbWU7XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICByZXR1cm4gdGhlbWU7XG59KTtcblxuLy8gXG52YXIgZXNjYXBlUmVnZXggPSAvW1tcXF0uIyokPjwrfj18XjooKSxcIidgLV0rL2c7XG52YXIgZGFzaGVzQXRFbmRzID0gLyheLXwtJCkvZztcblxuLyoqXG4gKiBUT0RPOiBFeHBsb3JlIHVzaW5nIENTUy5lc2NhcGUgd2hlbiBpdCBiZWNvbWVzIG1vcmUgYXZhaWxhYmxlXG4gKiBpbiBldmVyZ3JlZW4gYnJvd3NlcnMuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAvLyBSZXBsYWNlIGFsbCBwb3NzaWJsZSBDU1Mgc2VsZWN0b3JzXG4gIC5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnLScpXG5cbiAgLy8gUmVtb3ZlIGV4dHJhbmVvdXMgaHlwaGVucyBhdCB0aGUgc3RhcnQgYW5kIGVuZFxuICAucmVwbGFjZShkYXNoZXNBdEVuZHMsICcnKTtcbn1cblxuLy8gXG4vKipcbiAqIENyZWF0ZXMgYSBicm9hZGNhc3QgdGhhdCBjYW4gYmUgbGlzdGVuZWQgdG8sIGkuZS4gc2ltcGxlIGV2ZW50IGVtaXR0ZXJcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL3JlYWN0LWJyb2FkY2FzdFxuICovXG5cbnZhciBjcmVhdGVCcm9hZGNhc3QgPSBmdW5jdGlvbiBjcmVhdGVCcm9hZGNhc3QoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcbiAgdmFyIGlkID0gMDtcbiAgdmFyIHN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gIGZ1bmN0aW9uIHB1Ymxpc2gobmV4dFN0YXRlKSB7XG4gICAgc3RhdGUgPSBuZXh0U3RhdGU7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluLCBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIGZvciAodmFyIGtleSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1trZXldO1xuICAgICAgaWYgKGxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcihzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgdmFyIGN1cnJlbnRJZCA9IGlkO1xuICAgIGxpc3RlbmVyc1tjdXJyZW50SWRdID0gbGlzdGVuZXI7XG4gICAgaWQgKz0gMTtcbiAgICBsaXN0ZW5lcihzdGF0ZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRJZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKHVuc3ViSUQpIHtcbiAgICBsaXN0ZW5lcnNbdW5zdWJJRF0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4geyBwdWJsaXNoOiBwdWJsaXNoLCBzdWJzY3JpYmU6IHN1YnNjcmliZSwgdW5zdWJzY3JpYmU6IHVuc3Vic2NyaWJlIH07XG59O1xuXG52YXIgX1RoZW1lUHJvdmlkZXIkY2hpbGRDO1xudmFyIF9UaGVtZVByb3ZpZGVyJGNvbnRleDtcblxuLy8gXG4vKiBnbG9iYWxzIFJlYWN0JEVsZW1lbnQgKi9cbi8vIE5PVEU6IERPIE5PVCBDSEFOR0UsIGNoYW5naW5nIHRoaXMgaXMgYSBzZW12ZXIgbWFqb3IgY2hhbmdlIVxudmFyIENIQU5ORUwgPSAnX19zdHlsZWQtY29tcG9uZW50c19fJztcbnZhciBDSEFOTkVMX05FWFQgPSBDSEFOTkVMICsgJ25leHRfXyc7XG5cbnZhciBDT05URVhUX0NIQU5ORUxfU0hBUEUgPSBQcm9wVHlwZXMuc2hhcGUoe1xuICBnZXRUaGVtZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHVuc3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuY1xufSk7XG5cbnZhciB3YXJuQ2hhbm5lbERlcHJlY2F0ZWQgPSB2b2lkIDA7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuQ2hhbm5lbERlcHJlY2F0ZWQgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUuZXJyb3IoJ1dhcm5pbmc6IFVzYWdlIG9mIGBjb250ZXh0LicgKyBDSEFOTkVMICsgJ2AgYXMgYSBmdW5jdGlvbiBpcyBkZXByZWNhdGVkLiBJdCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIG9iamVjdCBvbiBgLmNvbnRleHQuJyArIENIQU5ORUxfTkVYVCArICdgIGluIGEgZnV0dXJlIHZlcnNpb24uJyk7XG4gIH0pO1xufVxuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24odGVzdCkge1xuICByZXR1cm4gdHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbic7XG59O1xuXG4vKipcbiAqIFByb3ZpZGUgYSB0aGVtZSB0byBhbiBlbnRpcmUgcmVhY3QgY29tcG9uZW50IHRyZWUgdmlhIGNvbnRleHQgYW5kIGV2ZW50IGxpc3RlbmVycyAoaGF2ZSB0byBkb1xuICogYm90aCBjb250ZXh0IGFuZCBldmVudCBlbWl0dGVyIGFzIHB1cmUgY29tcG9uZW50cyBibG9jayBjb250ZXh0IHVwZGF0ZXMpXG4gKi9cblxudmFyIFRoZW1lUHJvdmlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUaGVtZVByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaGVtZVByb3ZpZGVyKCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRoZW1lUHJvdmlkZXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMudW5zdWJzY3JpYmVUb091dGVySWQgPSAtMTtcblxuICAgIF90aGlzLmdldFRoZW1lID0gX3RoaXMuZ2V0VGhlbWUuYmluZChfdGhpcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVGhlbWVQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBUaGVtZVByb3ZpZGVyIHdyYXBwZXIgYW55d2hlcmUgYXJvdW5kIHRoaXMgdGhlbWUgcHJvdmlkZXIsIG1lcmdlIHRoaXMgdGhlbWVcbiAgICAvLyB3aXRoIHRoZSBvdXRlciB0aGVtZVxuICAgIHZhciBvdXRlckNvbnRleHQgPSB0aGlzLmNvbnRleHRbQ0hBTk5FTF9ORVhUXTtcbiAgICBpZiAob3V0ZXJDb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmVUb091dGVySWQgPSBvdXRlckNvbnRleHQuc3Vic2NyaWJlKGZ1bmN0aW9uICh0aGVtZSkge1xuICAgICAgICBfdGhpczIub3V0ZXJUaGVtZSA9IHRoZW1lO1xuXG4gICAgICAgIGlmIChfdGhpczIuYnJvYWRjYXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpczIucHVibGlzaChfdGhpczIucHJvcHMudGhlbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmJyb2FkY2FzdCA9IGNyZWF0ZUJyb2FkY2FzdCh0aGlzLmdldFRoZW1lKCkpO1xuICB9O1xuXG4gIFRoZW1lUHJvdmlkZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcyxcbiAgICAgICAgX2JhYmVsSGVscGVycyRleHRlbmRzO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCB0aGlzLmNvbnRleHQsIChfYmFiZWxIZWxwZXJzJGV4dGVuZHMgPSB7fSwgX2JhYmVsSGVscGVycyRleHRlbmRzW0NIQU5ORUxfTkVYVF0gPSB7XG4gICAgICBnZXRUaGVtZTogdGhpcy5nZXRUaGVtZSxcbiAgICAgIHN1YnNjcmliZTogdGhpcy5icm9hZGNhc3Quc3Vic2NyaWJlLFxuICAgICAgdW5zdWJzY3JpYmU6IHRoaXMuYnJvYWRjYXN0LnVuc3Vic2NyaWJlXG4gICAgfSwgX2JhYmVsSGVscGVycyRleHRlbmRzW0NIQU5ORUxdID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5DaGFubmVsRGVwcmVjYXRlZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXRjaCB0aGUgb2xkIGBzdWJzY3JpYmVgIHByb3ZpZGUgdmlhIGBDSEFOTkVMYCBmb3Igb2xkZXIgY2xpZW50cy5cbiAgICAgIHZhciB1bnN1YnNjcmliZUlkID0gX3RoaXMzLmJyb2FkY2FzdC5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLmJyb2FkY2FzdC51bnN1YnNjcmliZSh1bnN1YnNjcmliZUlkKTtcbiAgICAgIH07XG4gICAgfSwgX2JhYmVsSGVscGVycyRleHRlbmRzKSk7XG4gIH07XG5cbiAgVGhlbWVQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKHRoaXMucHJvcHMudGhlbWUgIT09IG5leHRQcm9wcy50aGVtZSkge1xuICAgICAgdGhpcy5wdWJsaXNoKG5leHRQcm9wcy50aGVtZSk7XG4gICAgfVxuICB9O1xuXG4gIFRoZW1lUHJvdmlkZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMudW5zdWJzY3JpYmVUb091dGVySWQgIT09IC0xKSB7XG4gICAgICB0aGlzLmNvbnRleHRbQ0hBTk5FTF9ORVhUXS51bnN1YnNjcmliZSh0aGlzLnVuc3Vic2NyaWJlVG9PdXRlcklkKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gR2V0IHRoZSB0aGVtZSBmcm9tIHRoZSBwcm9wcywgc3VwcG9ydGluZyBib3RoIChvdXRlclRoZW1lKSA9PiB7fSBhcyB3ZWxsIGFzIG9iamVjdCBub3RhdGlvblxuXG5cbiAgVGhlbWVQcm92aWRlci5wcm90b3R5cGUuZ2V0VGhlbWUgPSBmdW5jdGlvbiBnZXRUaGVtZShwYXNzZWRUaGVtZSkge1xuICAgIHZhciB0aGVtZSA9IHBhc3NlZFRoZW1lIHx8IHRoaXMucHJvcHMudGhlbWU7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhlbWUpKSB7XG4gICAgICB2YXIgbWVyZ2VkVGhlbWUgPSB0aGVtZSh0aGlzLm91dGVyVGhlbWUpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzUGxhaW5PYmplY3QobWVyZ2VkVGhlbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gJ1tUaGVtZVByb3ZpZGVyXSBQbGVhc2UgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHlvdXIgdGhlbWUgZnVuY3Rpb24sIGkuZS4gdGhlbWU9eygpID0+ICh7fSl9IScgOiAnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkVGhlbWU7XG4gICAgfVxuICAgIGlmICghaXNQbGFpbk9iamVjdCh0aGVtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gJ1tUaGVtZVByb3ZpZGVyXSBQbGVhc2UgbWFrZSB5b3VyIHRoZW1lIHByb3AgYSBwbGFpbiBvYmplY3QnIDogJycpO1xuICAgIH1cbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIHRoaXMub3V0ZXJUaGVtZSwgdGhlbWUpO1xuICB9O1xuXG4gIFRoZW1lUHJvdmlkZXIucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiBwdWJsaXNoKHRoZW1lKSB7XG4gICAgdGhpcy5icm9hZGNhc3QucHVibGlzaCh0aGlzLmdldFRoZW1lKHRoZW1lKSk7XG4gIH07XG5cbiAgVGhlbWVQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9O1xuXG4gIHJldHVybiBUaGVtZVByb3ZpZGVyO1xufShDb21wb25lbnQpO1xuXG5UaGVtZVByb3ZpZGVyLmNoaWxkQ29udGV4dFR5cGVzID0gKF9UaGVtZVByb3ZpZGVyJGNoaWxkQyA9IHt9LCBfVGhlbWVQcm92aWRlciRjaGlsZENbQ0hBTk5FTF0gPSBQcm9wVHlwZXMuZnVuYywgX1RoZW1lUHJvdmlkZXIkY2hpbGRDW0NIQU5ORUxfTkVYVF0gPSBDT05URVhUX0NIQU5ORUxfU0hBUEUsIF9UaGVtZVByb3ZpZGVyJGNoaWxkQyk7XG5UaGVtZVByb3ZpZGVyLmNvbnRleHRUeXBlcyA9IChfVGhlbWVQcm92aWRlciRjb250ZXggPSB7fSwgX1RoZW1lUHJvdmlkZXIkY29udGV4W0NIQU5ORUxfTkVYVF0gPSBDT05URVhUX0NIQU5ORUxfU0hBUEUsIF9UaGVtZVByb3ZpZGVyJGNvbnRleCk7XG5cbi8vIFxuXG4vLyBIQUNLIGZvciBnZW5lcmF0aW5nIGFsbCBzdGF0aWMgc3R5bGVzIHdpdGhvdXQgbmVlZGluZyB0byBhbGxvY2F0ZVxuLy8gYW4gZW1wdHkgZXhlY3V0aW9uIGNvbnRleHQgZXZlcnkgc2luZ2xlIHRpbWUuLi5cbnZhciBTVEFUSUNfRVhFQ1VUSU9OX0NPTlRFWFQgPSB7fTtcblxudmFyIF9TdHlsZWRDb21wb25lbnQgPSAoZnVuY3Rpb24gKENvbXBvbmVudFN0eWxlLCBjb25zdHJ1Y3RXaXRoT3B0aW9ucykge1xuICB2YXIgaWRlbnRpZmllcnMgPSB7fTtcblxuICAvKiBXZSBkZXBlbmQgb24gY29tcG9uZW50cyBoYXZpbmcgdW5pcXVlIElEcyAqL1xuICB2YXIgZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIGdlbmVyYXRlSWQoX2Rpc3BsYXlOYW1lLCBwYXJlbnRDb21wb25lbnRJZCkge1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiBfZGlzcGxheU5hbWUgIT09ICdzdHJpbmcnID8gJ3NjJyA6IGVzY2FwZShfZGlzcGxheU5hbWUpO1xuXG4gICAgdmFyIGNvbXBvbmVudElkID0gdm9pZCAwO1xuXG4gICAgLyoqXG4gICAgICogb25seSBmYWxsIGJhY2sgdG8gaGFzaGluZyB0aGUgY29tcG9uZW50IGluamVjdGlvbiBvcmRlciBpZlxuICAgICAqIGEgcHJvcGVyIGRpc3BsYXlOYW1lIGlzbid0IHByb3ZpZGVkIGJ5IHRoZSBiYWJlbCBwbHVnaW5cbiAgICAgKi9cbiAgICBpZiAoIV9kaXNwbGF5TmFtZSkge1xuICAgICAgdmFyIG5yID0gKGlkZW50aWZpZXJzW2Rpc3BsYXlOYW1lXSB8fCAwKSArIDE7XG4gICAgICBpZGVudGlmaWVyc1tkaXNwbGF5TmFtZV0gPSBucjtcblxuICAgICAgY29tcG9uZW50SWQgPSBkaXNwbGF5TmFtZSArICctJyArIENvbXBvbmVudFN0eWxlLmdlbmVyYXRlTmFtZShkaXNwbGF5TmFtZSArIG5yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50SWQgPSBkaXNwbGF5TmFtZSArICctJyArIENvbXBvbmVudFN0eWxlLmdlbmVyYXRlTmFtZShkaXNwbGF5TmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudENvbXBvbmVudElkICE9PSB1bmRlZmluZWQgPyBwYXJlbnRDb21wb25lbnRJZCArICctJyArIGNvbXBvbmVudElkIDogY29tcG9uZW50SWQ7XG4gIH07XG5cbiAgdmFyIEJhc2VTdHlsZWRDb21wb25lbnQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIGluaGVyaXRzKEJhc2VTdHlsZWRDb21wb25lbnQsIF9Db21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gQmFzZVN0eWxlZENvbXBvbmVudCgpIHtcbiAgICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VTdHlsZWRDb21wb25lbnQpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsLmFwcGx5KF9Db21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5hdHRycyA9IHt9LCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgdGhlbWU6IG51bGwsXG4gICAgICAgIGdlbmVyYXRlZENsYXNzTmFtZTogJydcbiAgICAgIH0sIF90aGlzLnVuc3Vic2NyaWJlSWQgPSAtMSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICB9XG5cbiAgICBCYXNlU3R5bGVkQ29tcG9uZW50LnByb3RvdHlwZS51bnN1YnNjcmliZUZyb21Db250ZXh0ID0gZnVuY3Rpb24gdW5zdWJzY3JpYmVGcm9tQ29udGV4dCgpIHtcbiAgICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlSWQgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFtDSEFOTkVMX05FWFRdLnVuc3Vic2NyaWJlKHRoaXMudW5zdWJzY3JpYmVJZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEJhc2VTdHlsZWRDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkRXhlY3V0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIGJ1aWxkRXhlY3V0aW9uQ29udGV4dCh0aGVtZSwgcHJvcHMpIHtcbiAgICAgIHZhciBhdHRycyA9IHRoaXMuY29uc3RydWN0b3IuYXR0cnM7XG5cbiAgICAgIHZhciBjb250ZXh0ID0gX2V4dGVuZHMoe30sIHByb3BzLCB7IHRoZW1lOiB0aGVtZSB9KTtcbiAgICAgIGlmIChhdHRycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgICAgdmFyIGF0dHIgPSBhdHRyc1trZXldO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgYWNjW2tleV0gPSB0eXBlb2YgYXR0ciA9PT0gJ2Z1bmN0aW9uJyA/IGF0dHIoY29udGV4dCkgOiBhdHRyO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRleHQsIHRoaXMuYXR0cnMpO1xuICAgIH07XG5cbiAgICBCYXNlU3R5bGVkQ29tcG9uZW50LnByb3RvdHlwZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyA9IGZ1bmN0aW9uIGdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKHRoZW1lLCBwcm9wcykge1xuICAgICAgdmFyIF9jb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0b3IsXG4gICAgICAgICAgYXR0cnMgPSBfY29uc3RydWN0b3IuYXR0cnMsXG4gICAgICAgICAgY29tcG9uZW50U3R5bGUgPSBfY29uc3RydWN0b3IuY29tcG9uZW50U3R5bGUsXG4gICAgICAgICAgd2FyblRvb01hbnlDbGFzc2VzID0gX2NvbnN0cnVjdG9yLndhcm5Ub29NYW55Q2xhc3NlcztcblxuICAgICAgdmFyIHN0eWxlU2hlZXQgPSB0aGlzLmNvbnRleHRbQ09OVEVYVF9LRVldIHx8IFN0eWxlU2hlZXQubWFzdGVyO1xuXG4gICAgICAvLyBzdGF0aWNhbHkgc3R5bGVkLWNvbXBvbmVudHMgZG9uJ3QgbmVlZCB0byBidWlsZCBhbiBleGVjdXRpb24gY29udGV4dCBvYmplY3QsXG4gICAgICAvLyBhbmQgc2hvdWxkbid0IGJlIGluY3JlYXNpbmcgdGhlIG51bWJlciBvZiBjbGFzcyBuYW1lc1xuICAgICAgaWYgKGNvbXBvbmVudFN0eWxlLmlzU3RhdGljICYmIGF0dHJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFN0eWxlLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKFNUQVRJQ19FWEVDVVRJT05fQ09OVEVYVCwgc3R5bGVTaGVldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhlY3V0aW9uQ29udGV4dCA9IHRoaXMuYnVpbGRFeGVjdXRpb25Db250ZXh0KHRoZW1lLCBwcm9wcyk7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBjb21wb25lbnRTdHlsZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0KTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuVG9vTWFueUNsYXNzZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHdhcm5Ub29NYW55Q2xhc3NlcyhjbGFzc05hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQmFzZVN0eWxlZENvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjb21wb25lbnRTdHlsZSA9IHRoaXMuY29uc3RydWN0b3IuY29tcG9uZW50U3R5bGU7XG5cbiAgICAgIHZhciBzdHlsZWRDb250ZXh0ID0gdGhpcy5jb250ZXh0W0NIQU5ORUxfTkVYVF07XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBzdGF0aWNhbHktc3R5bGVkIGNvbXBvbmVudCwgd2UgZG9uJ3QgbmVlZCB0byB0aGUgdGhlbWVcbiAgICAgIC8vIHRvIGdlbmVyYXRlIG9yIGJ1aWxkIHN0eWxlcy5cbiAgICAgIGlmIChjb21wb25lbnRTdHlsZS5pc1N0YXRpYykge1xuICAgICAgICB2YXIgZ2VuZXJhdGVkQ2xhc3NOYW1lID0gdGhpcy5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhTVEFUSUNfRVhFQ1VUSU9OX0NPTlRFWFQsIHRoaXMucHJvcHMpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZ2VuZXJhdGVkQ2xhc3NOYW1lOiBnZW5lcmF0ZWRDbGFzc05hbWUgfSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdGhlbWUgaW4gdGhlIGNvbnRleHQsIHN1YnNjcmliZSB0byB0aGUgZXZlbnQgZW1pdHRlci4gVGhpc1xuICAgICAgICAvLyBpcyBuZWNlc3NhcnkgZHVlIHRvIHB1cmUgY29tcG9uZW50cyBibG9ja2luZyBjb250ZXh0IHVwZGF0ZXMsIHRoaXMgY2lyY3VtdmVudHNcbiAgICAgICAgLy8gdGhhdCBieSB1cGRhdGluZyB3aGVuIGFuIGV2ZW50IGlzIGVtaXR0ZWRcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVkQ29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmUgPSBzdHlsZWRDb250ZXh0LnN1YnNjcmliZTtcblxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlSWQgPSBzdWJzY3JpYmUoZnVuY3Rpb24gKG5leHRUaGVtZSkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgb25jZSBpbW1lZGlhdGVseVxuICAgICAgICAgIHZhciB0aGVtZSA9IGRldGVybWluZVRoZW1lKF90aGlzMi5wcm9wcywgbmV4dFRoZW1lLCBfdGhpczIuY29uc3RydWN0b3IuZGVmYXVsdFByb3BzKTtcbiAgICAgICAgICB2YXIgZ2VuZXJhdGVkQ2xhc3NOYW1lID0gX3RoaXMyLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKHRoZW1lLCBfdGhpczIucHJvcHMpO1xuXG4gICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHsgdGhlbWU6IHRoZW1lLCBnZW5lcmF0ZWRDbGFzc05hbWU6IGdlbmVyYXRlZENsYXNzTmFtZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJvcC10eXBlc1xuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnByb3BzLnRoZW1lIHx8IHt9O1xuICAgICAgICB2YXIgX2dlbmVyYXRlZENsYXNzTmFtZSA9IHRoaXMuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXModGhlbWUsIHRoaXMucHJvcHMpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgdGhlbWU6IHRoZW1lLCBnZW5lcmF0ZWRDbGFzc05hbWU6IF9nZW5lcmF0ZWRDbGFzc05hbWUgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIEJhc2VTdHlsZWRDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBzdGF0aWNhbHktc3R5bGVkIGNvbXBvbmVudCwgd2UgZG9uJ3QgbmVlZCB0byBsaXN0ZW4gdG9cbiAgICAgIC8vIHByb3BzIGNoYW5nZXMgdG8gdXBkYXRlIHN0eWxlc1xuICAgICAgdmFyIGNvbXBvbmVudFN0eWxlID0gdGhpcy5jb25zdHJ1Y3Rvci5jb21wb25lbnRTdHlsZTtcblxuICAgICAgaWYgKGNvbXBvbmVudFN0eWxlLmlzU3RhdGljKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAob2xkU3RhdGUpIHtcbiAgICAgICAgdmFyIHRoZW1lID0gZGV0ZXJtaW5lVGhlbWUobmV4dFByb3BzLCBvbGRTdGF0ZS50aGVtZSwgX3RoaXMzLmNvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyk7XG4gICAgICAgIHZhciBnZW5lcmF0ZWRDbGFzc05hbWUgPSBfdGhpczMuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXModGhlbWUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgcmV0dXJuIHsgdGhlbWU6IHRoZW1lLCBnZW5lcmF0ZWRDbGFzc05hbWU6IGdlbmVyYXRlZENsYXNzTmFtZSB9O1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIEJhc2VTdHlsZWRDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbUNvbnRleHQoKTtcbiAgICB9O1xuXG4gICAgQmFzZVN0eWxlZENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcm9wLXR5cGVzXG4gICAgICB2YXIgaW5uZXJSZWYgPSB0aGlzLnByb3BzLmlubmVyUmVmO1xuICAgICAgdmFyIGdlbmVyYXRlZENsYXNzTmFtZSA9IHRoaXMuc3RhdGUuZ2VuZXJhdGVkQ2xhc3NOYW1lO1xuICAgICAgdmFyIF9jb25zdHJ1Y3RvcjIgPSB0aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHN0eWxlZENvbXBvbmVudElkID0gX2NvbnN0cnVjdG9yMi5zdHlsZWRDb21wb25lbnRJZCxcbiAgICAgICAgICB0YXJnZXQgPSBfY29uc3RydWN0b3IyLnRhcmdldDtcblxuXG4gICAgICB2YXIgaXNUYXJnZXRUYWcgPSBpc1RhZyh0YXJnZXQpO1xuXG4gICAgICB2YXIgY2xhc3NOYW1lID0gW1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3Byb3AtdHlwZXNcbiAgICAgIHRoaXMucHJvcHMuY2xhc3NOYW1lLCBzdHlsZWRDb21wb25lbnRJZCwgdGhpcy5hdHRycy5jbGFzc05hbWUsIGdlbmVyYXRlZENsYXNzTmFtZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKTtcblxuICAgICAgdmFyIGJhc2VQcm9wcyA9IF9leHRlbmRzKHt9LCB0aGlzLmF0dHJzLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzU3R5bGVkQ29tcG9uZW50KHRhcmdldCkpIHtcbiAgICAgICAgYmFzZVByb3BzLmlubmVyUmVmID0gaW5uZXJSZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlUHJvcHMucmVmID0gaW5uZXJSZWY7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wc0ZvckVsZW1lbnQgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcHJvcE5hbWUpIHtcbiAgICAgICAgLy8gRG9uJ3QgcGFzcyB0aHJvdWdoIG5vbiBIVE1MIHRhZ3MgdGhyb3VnaCB0byBIVE1MIGVsZW1lbnRzXG4gICAgICAgIC8vIGFsd2F5cyBvbWl0IGlubmVyUmVmXG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ2lubmVyUmVmJyAmJiBwcm9wTmFtZSAhPT0gJ2NsYXNzTmFtZScgJiYgKCFpc1RhcmdldFRhZyB8fCB2YWxpZEF0dHIocHJvcE5hbWUpKSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIGFjY1twcm9wTmFtZV0gPSBfdGhpczQucHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIGJhc2VQcm9wcyk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhcmdldCwgcHJvcHNGb3JFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEJhc2VTdHlsZWRDb21wb25lbnQ7XG4gIH0oQ29tcG9uZW50KTtcblxuICB2YXIgY3JlYXRlU3R5bGVkQ29tcG9uZW50ID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVkQ29tcG9uZW50KHRhcmdldCwgb3B0aW9ucywgcnVsZXMpIHtcbiAgICB2YXIgX1N0eWxlZENvbXBvbmVudCRjb250O1xuXG4gICAgdmFyIF9vcHRpb25zJGRpc3BsYXlOYW1lID0gb3B0aW9ucy5kaXNwbGF5TmFtZSxcbiAgICAgICAgZGlzcGxheU5hbWUgPSBfb3B0aW9ucyRkaXNwbGF5TmFtZSA9PT0gdW5kZWZpbmVkID8gaXNUYWcodGFyZ2V0KSA/ICdzdHlsZWQuJyArIHRhcmdldCA6ICdTdHlsZWQoJyArIGdldENvbXBvbmVudE5hbWUodGFyZ2V0KSArICcpJyA6IF9vcHRpb25zJGRpc3BsYXlOYW1lLFxuICAgICAgICBfb3B0aW9ucyRjb21wb25lbnRJZCA9IG9wdGlvbnMuY29tcG9uZW50SWQsXG4gICAgICAgIGNvbXBvbmVudElkID0gX29wdGlvbnMkY29tcG9uZW50SWQgPT09IHVuZGVmaW5lZCA/IGdlbmVyYXRlSWQob3B0aW9ucy5kaXNwbGF5TmFtZSwgb3B0aW9ucy5wYXJlbnRDb21wb25lbnRJZCkgOiBfb3B0aW9ucyRjb21wb25lbnRJZCxcbiAgICAgICAgX29wdGlvbnMkUGFyZW50Q29tcG9uID0gb3B0aW9ucy5QYXJlbnRDb21wb25lbnQsXG4gICAgICAgIFBhcmVudENvbXBvbmVudCA9IF9vcHRpb25zJFBhcmVudENvbXBvbiA9PT0gdW5kZWZpbmVkID8gQmFzZVN0eWxlZENvbXBvbmVudCA6IF9vcHRpb25zJFBhcmVudENvbXBvbixcbiAgICAgICAgZXh0ZW5kaW5nUnVsZXMgPSBvcHRpb25zLnJ1bGVzLFxuICAgICAgICBhdHRycyA9IG9wdGlvbnMuYXR0cnM7XG5cblxuICAgIHZhciBzdHlsZWRDb21wb25lbnRJZCA9IG9wdGlvbnMuZGlzcGxheU5hbWUgJiYgb3B0aW9ucy5jb21wb25lbnRJZCA/IGVzY2FwZShvcHRpb25zLmRpc3BsYXlOYW1lKSArICctJyArIG9wdGlvbnMuY29tcG9uZW50SWQgOiBjb21wb25lbnRJZDtcblxuICAgIHZhciBjb21wb25lbnRTdHlsZSA9IG5ldyBDb21wb25lbnRTdHlsZShleHRlbmRpbmdSdWxlcyA9PT0gdW5kZWZpbmVkID8gcnVsZXMgOiBleHRlbmRpbmdSdWxlcy5jb25jYXQocnVsZXMpLCBhdHRycywgc3R5bGVkQ29tcG9uZW50SWQpO1xuXG4gICAgdmFyIFN0eWxlZENvbXBvbmVudCA9IGZ1bmN0aW9uIChfUGFyZW50Q29tcG9uZW50KSB7XG4gICAgICBpbmhlcml0cyhTdHlsZWRDb21wb25lbnQsIF9QYXJlbnRDb21wb25lbnQpO1xuXG4gICAgICBmdW5jdGlvbiBTdHlsZWRDb21wb25lbnQoKSB7XG4gICAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlZENvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9QYXJlbnRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICB9XG5cbiAgICAgIFN0eWxlZENvbXBvbmVudC53aXRoQ29tcG9uZW50ID0gZnVuY3Rpb24gd2l0aENvbXBvbmVudCh0YWcpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzQ29tcG9uZW50SWQgPSBvcHRpb25zLmNvbXBvbmVudElkLFxuICAgICAgICAgICAgb3B0aW9uc1RvQ29weSA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9wdGlvbnMsIFsnY29tcG9uZW50SWQnXSk7XG5cblxuICAgICAgICB2YXIgbmV3Q29tcG9uZW50SWQgPSBwcmV2aW91c0NvbXBvbmVudElkICYmIHByZXZpb3VzQ29tcG9uZW50SWQgKyAnLScgKyAoaXNUYWcodGFnKSA/IHRhZyA6IGVzY2FwZShnZXRDb21wb25lbnROYW1lKHRhZykpKTtcblxuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zVG9Db3B5LCB7XG4gICAgICAgICAgY29tcG9uZW50SWQ6IG5ld0NvbXBvbmVudElkLFxuICAgICAgICAgIFBhcmVudENvbXBvbmVudDogU3R5bGVkQ29tcG9uZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVTdHlsZWRDb21wb25lbnQodGFnLCBuZXdPcHRpb25zLCBydWxlcyk7XG4gICAgICB9O1xuXG4gICAgICBjcmVhdGVDbGFzcyhTdHlsZWRDb21wb25lbnQsIG51bGwsIFt7XG4gICAgICAgIGtleTogJ2V4dGVuZCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xuICAgICAgICAgIHZhciBydWxlc0Zyb21PcHRpb25zID0gb3B0aW9ucy5ydWxlcyxcbiAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50SWQgPSBvcHRpb25zLmNvbXBvbmVudElkLFxuICAgICAgICAgICAgICBvcHRpb25zVG9Db3B5ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgWydydWxlcycsICdjb21wb25lbnRJZCddKTtcblxuXG4gICAgICAgICAgdmFyIG5ld1J1bGVzID0gcnVsZXNGcm9tT3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gcnVsZXMgOiBydWxlc0Zyb21PcHRpb25zLmNvbmNhdChydWxlcyk7XG5cbiAgICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zVG9Db3B5LCB7XG4gICAgICAgICAgICBydWxlczogbmV3UnVsZXMsXG4gICAgICAgICAgICBwYXJlbnRDb21wb25lbnRJZDogcGFyZW50Q29tcG9uZW50SWQsXG4gICAgICAgICAgICBQYXJlbnRDb21wb25lbnQ6IFN0eWxlZENvbXBvbmVudFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFdpdGhPcHRpb25zKGNyZWF0ZVN0eWxlZENvbXBvbmVudCwgdGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuICAgICAgcmV0dXJuIFN0eWxlZENvbXBvbmVudDtcbiAgICB9KFBhcmVudENvbXBvbmVudCk7XG5cbiAgICBTdHlsZWRDb21wb25lbnQuY29udGV4dFR5cGVzID0gKF9TdHlsZWRDb21wb25lbnQkY29udCA9IHt9LCBfU3R5bGVkQ29tcG9uZW50JGNvbnRbQ0hBTk5FTF0gPSBQcm9wVHlwZXMuZnVuYywgX1N0eWxlZENvbXBvbmVudCRjb250W0NIQU5ORUxfTkVYVF0gPSBDT05URVhUX0NIQU5ORUxfU0hBUEUsIF9TdHlsZWRDb21wb25lbnQkY29udFtDT05URVhUX0tFWV0gPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuaW5zdGFuY2VPZihTdHlsZVNoZWV0KSwgUHJvcFR5cGVzLmluc3RhbmNlT2YoU2VydmVyU3R5bGVTaGVldCldKSwgX1N0eWxlZENvbXBvbmVudCRjb250KTtcbiAgICBTdHlsZWRDb21wb25lbnQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICBTdHlsZWRDb21wb25lbnQuc3R5bGVkQ29tcG9uZW50SWQgPSBzdHlsZWRDb21wb25lbnRJZDtcbiAgICBTdHlsZWRDb21wb25lbnQuYXR0cnMgPSBhdHRycztcbiAgICBTdHlsZWRDb21wb25lbnQuY29tcG9uZW50U3R5bGUgPSBjb21wb25lbnRTdHlsZTtcbiAgICBTdHlsZWRDb21wb25lbnQudGFyZ2V0ID0gdGFyZ2V0O1xuXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgU3R5bGVkQ29tcG9uZW50Lndhcm5Ub29NYW55Q2xhc3NlcyA9IGNyZWF0ZVdhcm5Ub29NYW55Q2xhc3NlcyhkaXNwbGF5TmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0eWxlZENvbXBvbmVudDtcbiAgfTtcblxuICByZXR1cm4gY3JlYXRlU3R5bGVkQ29tcG9uZW50O1xufSk7XG5cbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2dhcnljb3VydC9tdXJtdXJoYXNoLWpzL2Jsb2IvbWFzdGVyL211cm11cmhhc2gyX2djLmpzXG5mdW5jdGlvbiBtdXJtdXJoYXNoKHN0cikge1xuICB2YXIgbCA9IHN0ci5sZW5ndGggfCAwLFxuICAgICAgaCA9IGwgfCAwLFxuICAgICAgaSA9IDAsXG4gICAgICBrO1xuXG4gIHdoaWxlIChsID49IDQpIHtcbiAgICBrID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCA4IHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAxNiB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMjQ7XG5cbiAgICBrID0gKGsgJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoKGsgPj4+IDE2KSAqIDB4NWJkMWU5OTUgJiAweGZmZmYpIDw8IDE2KTtcbiAgICBrIF49IGsgPj4+IDI0O1xuICAgIGsgPSAoayAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKCgoayA+Pj4gMTYpICogMHg1YmQxZTk5NSAmIDB4ZmZmZikgPDwgMTYpO1xuXG4gICAgaCA9IChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKChoID4+PiAxNikgKiAweDViZDFlOTk1ICYgMHhmZmZmKSA8PCAxNikgXiBrO1xuXG4gICAgbCAtPSA0O1xuICAgICsraTtcbiAgfVxuXG4gIHN3aXRjaCAobCkge1xuICAgIGNhc2UgMzpcbiAgICAgIGggXj0gKHN0ci5jaGFyQ29kZUF0KGkgKyAyKSAmIDB4ZmYpIDw8IDE2O1xuICAgIGNhc2UgMjpcbiAgICAgIGggXj0gKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmYpIDw8IDg7XG4gICAgY2FzZSAxOlxuICAgICAgaCBePSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gICAgICBoID0gKGggJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoKGggPj4+IDE2KSAqIDB4NWJkMWU5OTUgJiAweGZmZmYpIDw8IDE2KTtcbiAgfVxuXG4gIGggXj0gaCA+Pj4gMTM7XG4gIGggPSAoaCAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKCgoaCA+Pj4gMTYpICogMHg1YmQxZTk5NSAmIDB4ZmZmZikgPDwgMTYpO1xuICBoIF49IGggPj4+IDE1O1xuXG4gIHJldHVybiBoID4+PiAwO1xufVxuXG4vLyBcbnZhciBhcmVTdHlsZXNDYWNoZWFibGUgPSBJU19CUk9XU0VSO1xuXG52YXIgaXNTdGF0aWNSdWxlcyA9IGZ1bmN0aW9uIGlzU3RhdGljUnVsZXMocnVsZXMsIGF0dHJzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldO1xuXG4gICAgLy8gcmVjdXJzaXZlIGNhc2VcbiAgICBpZiAoQXJyYXkuaXNBcnJheShydWxlKSAmJiAhaXNTdGF0aWNSdWxlcyhydWxlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJ1bGUgPT09ICdmdW5jdGlvbicgJiYgIWlzU3R5bGVkQ29tcG9uZW50KHJ1bGUpKSB7XG4gICAgICAvLyBmdW5jdGlvbnMgYXJlIGFsbG93ZWQgdG8gYmUgc3RhdGljIGlmIHRoZXkncmUganVzdCBiZWluZ1xuICAgICAgLy8gdXNlZCB0byBnZXQgdGhlIGNsYXNzbmFtZSBvZiBhIG5lc3RlZCBzdHlsZWQgY29wbW9uZW50XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGF0dHJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluLCBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGlzSFJNRW5hYmxlZCA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5ob3QgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxuLypcbiBDb21wb25lbnRTdHlsZSBpcyBhbGwgdGhlIENTUy1zcGVjaWZpYyBzdHVmZiwgbm90XG4gdGhlIFJlYWN0LXNwZWNpZmljIHN0dWZmLlxuICovXG52YXIgX0NvbXBvbmVudFN0eWxlID0gKGZ1bmN0aW9uIChuYW1lR2VuZXJhdG9yLCBmbGF0dGVuLCBzdHJpbmdpZnlSdWxlcykge1xuICAvKiBjb21iaW5lcyBoYXNoU3RyIChtdXJtdXJoYXNoKSBhbmQgbmFtZUdlbmVyYXRvciBmb3IgY29udmVuaWVuY2UgKi9cbiAgdmFyIGdlbmVyYXRlUnVsZUhhc2ggPSBmdW5jdGlvbiBnZW5lcmF0ZVJ1bGVIYXNoKHN0cikge1xuICAgIHJldHVybiBuYW1lR2VuZXJhdG9yKG11cm11cmhhc2goc3RyKSk7XG4gIH07XG5cbiAgdmFyIENvbXBvbmVudFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudFN0eWxlKHJ1bGVzLCBhdHRycywgY29tcG9uZW50SWQpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBvbmVudFN0eWxlKTtcblxuICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgdGhpcy5pc1N0YXRpYyA9ICFpc0hSTUVuYWJsZWQgJiYgaXNTdGF0aWNSdWxlcyhydWxlcywgYXR0cnMpO1xuICAgICAgdGhpcy5jb21wb25lbnRJZCA9IGNvbXBvbmVudElkO1xuXG4gICAgICBpZiAoIVN0eWxlU2hlZXQubWFzdGVyLmhhc0lkKGNvbXBvbmVudElkKSkge1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gWycuJyArIGNvbXBvbmVudElkICsgJyB7fSddIDogW107XG5cbiAgICAgICAgU3R5bGVTaGVldC5tYXN0ZXIuZGVmZXJyZWRJbmplY3QoY29tcG9uZW50SWQsIHBsYWNlaG9sZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEZsYXR0ZW5zIGEgcnVsZSBzZXQgaW50byB2YWxpZCBDU1NcbiAgICAgKiBIYXNoZXMgaXQsIHdyYXBzIHRoZSB3aG9sZSBjaHVuayBpbiBhIC5oYXNoMTIzNCB7fVxuICAgICAqIFJldHVybnMgdGhlIGhhc2ggdG8gYmUgaW5qZWN0ZWQgb24gcmVuZGVyKClcbiAgICAgKiAqL1xuXG5cbiAgICBDb21wb25lbnRTdHlsZS5wcm90b3R5cGUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMgPSBmdW5jdGlvbiBnZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0KSB7XG4gICAgICB2YXIgaXNTdGF0aWMgPSB0aGlzLmlzU3RhdGljLFxuICAgICAgICAgIGNvbXBvbmVudElkID0gdGhpcy5jb21wb25lbnRJZCxcbiAgICAgICAgICBsYXN0Q2xhc3NOYW1lID0gdGhpcy5sYXN0Q2xhc3NOYW1lO1xuXG4gICAgICBpZiAoYXJlU3R5bGVzQ2FjaGVhYmxlICYmIGlzU3RhdGljICYmIGxhc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGFzdENsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZsYXRDU1MgPSBmbGF0dGVuKHRoaXMucnVsZXMsIGV4ZWN1dGlvbkNvbnRleHQpO1xuICAgICAgdmFyIG5hbWUgPSBnZW5lcmF0ZVJ1bGVIYXNoKHRoaXMuY29tcG9uZW50SWQgKyBmbGF0Q1NTLmpvaW4oJycpKTtcblxuICAgICAgaWYgKCFzdHlsZVNoZWV0Lmhhc05hbWVGb3JJZChjb21wb25lbnRJZCwgbmFtZSkpIHtcbiAgICAgICAgdmFyIGNzcyA9IHN0cmluZ2lmeVJ1bGVzKGZsYXRDU1MsICcuJyArIG5hbWUpO1xuICAgICAgICBzdHlsZVNoZWV0LmluamVjdCh0aGlzLmNvbXBvbmVudElkLCBjc3MsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3RDbGFzc05hbWUgPSBuYW1lO1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfTtcblxuICAgIENvbXBvbmVudFN0eWxlLmdlbmVyYXRlTmFtZSA9IGZ1bmN0aW9uIGdlbmVyYXRlTmFtZShzdHIpIHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZVJ1bGVIYXNoKHN0cik7XG4gICAgfTtcblxuICAgIHJldHVybiBDb21wb25lbnRTdHlsZTtcbiAgfSgpO1xuXG4gIHJldHVybiBDb21wb25lbnRTdHlsZTtcbn0pO1xuXG4vLyBcbi8vIFRoYW5rcyB0byBSZWFjdERPTUZhY3RvcmllcyBmb3IgdGhpcyBoYW5keSBsaXN0IVxuXG52YXIgZG9tRWxlbWVudHMgPSBbJ2EnLCAnYWJicicsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2Jhc2UnLCAnYmRpJywgJ2JkbycsICdiaWcnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2FwdGlvbicsICdjaXRlJywgJ2NvZGUnLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGQnLCAnZGVsJywgJ2RldGFpbHMnLCAnZGZuJywgJ2RpYWxvZycsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW0nLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaScsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAna2V5Z2VuJywgJ2xhYmVsJywgJ2xlZ2VuZCcsICdsaScsICdsaW5rJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbWV0ZXInLCAnbmF2JywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdvcHRncm91cCcsICdvcHRpb24nLCAnb3V0cHV0JywgJ3AnLCAncGFyYW0nLCAncGljdHVyZScsICdwcmUnLCAncHJvZ3Jlc3MnLCAncScsICdycCcsICdydCcsICdydWJ5JywgJ3MnLCAnc2FtcCcsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc21hbGwnLCAnc291cmNlJywgJ3NwYW4nLCAnc3Ryb25nJywgJ3N0eWxlJywgJ3N1YicsICdzdW1tYXJ5JywgJ3N1cCcsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aW1lJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3UnLCAndWwnLCAndmFyJywgJ3ZpZGVvJywgJ3dicicsXG5cbi8vIFNWR1xuJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZm9yZWlnbk9iamVjdCcsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAnc3ZnJywgJ3RleHQnLCAndHNwYW4nXTtcblxuLy8gXG52YXIgX3N0eWxlZCA9IChmdW5jdGlvbiAoc3R5bGVkQ29tcG9uZW50LCBjb25zdHJ1Y3RXaXRoT3B0aW9ucykge1xuICB2YXIgc3R5bGVkID0gZnVuY3Rpb24gc3R5bGVkKHRhZykge1xuICAgIHJldHVybiBjb25zdHJ1Y3RXaXRoT3B0aW9ucyhzdHlsZWRDb21wb25lbnQsIHRhZyk7XG4gIH07XG5cbiAgLy8gU2hvcnRoYW5kcyBmb3IgYWxsIHZhbGlkIEhUTUwgRWxlbWVudHNcbiAgZG9tRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZG9tRWxlbWVudCkge1xuICAgIHN0eWxlZFtkb21FbGVtZW50XSA9IHN0eWxlZChkb21FbGVtZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHN0eWxlZDtcbn0pO1xuXG4vLyBcbnZhciByZXBsYWNlV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2VXaGl0ZXNwYWNlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcc3xcXFxcbi9nLCAnJyk7XG59O1xuXG52YXIgX2tleWZyYW1lcyA9IChmdW5jdGlvbiAobmFtZUdlbmVyYXRvciwgc3RyaW5naWZ5UnVsZXMsIGNzcykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZVNoZWV0ID0gU3R5bGVTaGVldC5tYXN0ZXI7XG4gICAgdmFyIHJ1bGVzID0gY3NzLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB2YXIgbmFtZSA9IG5hbWVHZW5lcmF0b3IobXVybXVyaGFzaChyZXBsYWNlV2hpdGVzcGFjZShKU09OLnN0cmluZ2lmeShydWxlcykpKSk7XG4gICAgdmFyIGlkID0gJ3NjLWtleWZyYW1lcy0nICsgbmFtZTtcblxuICAgIGlmICghc3R5bGVTaGVldC5oYXNOYW1lRm9ySWQoaWQsIG5hbWUpKSB7XG4gICAgICBzdHlsZVNoZWV0LmluamVjdChpZCwgc3RyaW5naWZ5UnVsZXMocnVsZXMsIG5hbWUsICdAa2V5ZnJhbWVzJyksIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9O1xufSk7XG5cbi8vIFxudmFyIF9pbmplY3RHbG9iYWwgPSAoZnVuY3Rpb24gKHN0cmluZ2lmeVJ1bGVzLCBjc3MpIHtcbiAgdmFyIGluamVjdEdsb2JhbCA9IGZ1bmN0aW9uIGluamVjdEdsb2JhbCgpIHtcbiAgICB2YXIgc3R5bGVTaGVldCA9IFN0eWxlU2hlZXQubWFzdGVyO1xuICAgIHZhciBydWxlcyA9IGNzcy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGhhc2ggPSBtdXJtdXJoYXNoKEpTT04uc3RyaW5naWZ5KHJ1bGVzKSk7XG4gICAgdmFyIGlkID0gJ3NjLWdsb2JhbC0nICsgaGFzaDtcblxuICAgIGlmICghc3R5bGVTaGVldC5oYXNJZChpZCkpIHtcbiAgICAgIHN0eWxlU2hlZXQuaW5qZWN0KGlkLCBzdHJpbmdpZnlSdWxlcyhydWxlcykpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gaW5qZWN0R2xvYmFsO1xufSk7XG5cbi8vIFxuXG52YXIgX2NvbnN0cnVjdFdpdGhPcHRpb25zID0gKGZ1bmN0aW9uIChjc3MpIHtcbiAgdmFyIGNvbnN0cnVjdFdpdGhPcHRpb25zID0gZnVuY3Rpb24gY29uc3RydWN0V2l0aE9wdGlvbnMoY29tcG9uZW50Q29uc3RydWN0b3IsIHRhZykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGlmICh0eXBlb2YgdGFnICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdGFnICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICdDYW5ub3QgY3JlYXRlIHN0eWxlZC1jb21wb25lbnQgZm9yIGNvbXBvbmVudDogJyArIFN0cmluZyh0YWcpIDogJycpO1xuICAgIH1cblxuICAgIC8qIFRoaXMgaXMgY2FsbGFibGUgZGlyZWN0bHkgYXMgYSB0ZW1wbGF0ZSBmdW5jdGlvbiAqL1xuICAgIC8vICRGbG93Rml4TWU6IE5vdCB0eXBlZCB0byBhdm9pZCBkZXN0cnVjdHVyaW5nIGFyZ3VtZW50c1xuICAgIHZhciB0ZW1wbGF0ZUZ1bmN0aW9uID0gZnVuY3Rpb24gdGVtcGxhdGVGdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRDb25zdHJ1Y3Rvcih0YWcsIG9wdGlvbnMsIGNzcy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICAvKiBJZiBjb25maWcgbWV0aG9kcyBhcmUgY2FsbGVkLCB3cmFwIHVwIGEgbmV3IHRlbXBsYXRlIGZ1bmN0aW9uIGFuZCBtZXJnZSBvcHRpb25zICovXG4gICAgdGVtcGxhdGVGdW5jdGlvbi53aXRoQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdFdpdGhPcHRpb25zKGNvbXBvbmVudENvbnN0cnVjdG9yLCB0YWcsIF9leHRlbmRzKHt9LCBvcHRpb25zLCBjb25maWcpKTtcbiAgICB9O1xuICAgIHRlbXBsYXRlRnVuY3Rpb24uYXR0cnMgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICAgIHJldHVybiBjb25zdHJ1Y3RXaXRoT3B0aW9ucyhjb21wb25lbnRDb25zdHJ1Y3RvciwgdGFnLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgICBhdHRyczogX2V4dGVuZHMoe30sIG9wdGlvbnMuYXR0cnMgfHwge30sIGF0dHJzKVxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGVtcGxhdGVGdW5jdGlvbjtcbiAgfTtcblxuICByZXR1cm4gY29uc3RydWN0V2l0aE9wdGlvbnM7XG59KTtcblxuLy8gXG4vKiBnbG9iYWxzIFJlYWN0Q2xhc3MgKi9cblxudmFyIHdyYXBXaXRoVGhlbWUgPSBmdW5jdGlvbiB3cmFwV2l0aFRoZW1lKENvbXBvbmVudCQkMSkge1xuICB2YXIgX1dpdGhUaGVtZSRjb250ZXh0VHlwO1xuXG4gIHZhciBjb21wb25lbnROYW1lID0gQ29tcG9uZW50JCQxLmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudCQkMS5uYW1lIHx8ICdDb21wb25lbnQnO1xuICB2YXIgaXNTdGF0ZWxlc3NGdW5jdGlvbmFsQ29tcG9uZW50ID0gdHlwZW9mIENvbXBvbmVudCQkMSA9PT0gJ2Z1bmN0aW9uJyAmJiAhKENvbXBvbmVudCQkMS5wcm90b3R5cGUgJiYgJ2lzUmVhY3RDb21wb25lbnQnIGluIENvbXBvbmVudCQkMS5wcm90b3R5cGUpO1xuXG4gIC8vIE5PVEU6IFdlIGNhbid0IHBhc3MgYSByZWYgdG8gYSBzdGF0ZWxlc3MgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgdmFyIHNob3VsZFNldElubmVyUmVmID0gaXNTdHlsZWRDb21wb25lbnQoQ29tcG9uZW50JCQxKSB8fCBpc1N0YXRlbGVzc0Z1bmN0aW9uYWxDb21wb25lbnQ7XG5cbiAgdmFyIFdpdGhUaGVtZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgaW5oZXJpdHMoV2l0aFRoZW1lLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFdpdGhUaGVtZSgpIHtcbiAgICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFdpdGhUaGVtZSk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge30sIF90aGlzLnVuc3Vic2NyaWJlSWQgPSAtMSwgX3RlbXApLCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBUaGlzIGlzIHNvIHRoYXQgaXNTdHlsZWRDb21wb25lbnQgcGFzc2VzIGZvciB0aGUgaW5uZXJSZWYgdW53cmFwcGluZ1xuXG5cbiAgICBXaXRoVGhlbWUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIHZhciBzdHlsZWRDb250ZXh0ID0gdGhpcy5jb250ZXh0W0NIQU5ORUxfTkVYVF07XG4gICAgICB2YXIgdGhlbWVQcm9wID0gZGV0ZXJtaW5lVGhlbWUodGhpcy5wcm9wcywgdW5kZWZpbmVkLCBkZWZhdWx0UHJvcHMpO1xuICAgICAgaWYgKHN0eWxlZENvbnRleHQgPT09IHVuZGVmaW5lZCAmJiB0aGVtZVByb3AgPT09IHVuZGVmaW5lZCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybignW3dpdGhUaGVtZV0gWW91IGFyZSBub3QgdXNpbmcgYSBUaGVtZVByb3ZpZGVyIG5vciBwYXNzaW5nIGEgdGhlbWUgcHJvcCBvciBhIHRoZW1lIGluIGRlZmF1bHRQcm9wcycpO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZWRDb250ZXh0ID09PSB1bmRlZmluZWQgJiYgdGhlbWVQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRoZW1lOiB0aGVtZVByb3AgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3Vic2NyaWJlID0gc3R5bGVkQ29udGV4dC5zdWJzY3JpYmU7XG5cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUlkID0gc3Vic2NyaWJlKGZ1bmN0aW9uIChuZXh0VGhlbWUpIHtcbiAgICAgICAgICB2YXIgdGhlbWUgPSBkZXRlcm1pbmVUaGVtZShfdGhpczIucHJvcHMsIG5leHRUaGVtZSwgZGVmYXVsdFByb3BzKTtcbiAgICAgICAgICBfdGhpczIuc2V0U3RhdGUoeyB0aGVtZTogdGhlbWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBXaXRoVGhlbWUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFByb3BzO1xuXG4gICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChvbGRTdGF0ZSkge1xuICAgICAgICB2YXIgdGhlbWUgPSBkZXRlcm1pbmVUaGVtZShuZXh0UHJvcHMsIG9sZFN0YXRlLnRoZW1lLCBkZWZhdWx0UHJvcHMpO1xuXG4gICAgICAgIHJldHVybiB7IHRoZW1lOiB0aGVtZSB9O1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFdpdGhUaGVtZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlSWQgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFtDSEFOTkVMX05FWFRdLnVuc3Vic2NyaWJlKHRoaXMudW5zdWJzY3JpYmVJZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFdpdGhUaGVtZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe1xuICAgICAgICB0aGVtZTogdGhpcy5zdGF0ZS50aGVtZVxuICAgICAgfSwgdGhpcy5wcm9wcyk7XG5cbiAgICAgIGlmICghc2hvdWxkU2V0SW5uZXJSZWYpIHtcbiAgICAgICAgcHJvcHMucmVmID0gcHJvcHMuaW5uZXJSZWY7XG4gICAgICAgIGRlbGV0ZSBwcm9wcy5pbm5lclJlZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50JCQxLCBwcm9wcyk7XG4gICAgfTtcblxuICAgIHJldHVybiBXaXRoVGhlbWU7XG4gIH0oUmVhY3QuQ29tcG9uZW50KTtcblxuICBXaXRoVGhlbWUuZGlzcGxheU5hbWUgPSAnV2l0aFRoZW1lKCcgKyBjb21wb25lbnROYW1lICsgJyknO1xuICBXaXRoVGhlbWUuc3R5bGVkQ29tcG9uZW50SWQgPSAnd2l0aFRoZW1lJztcbiAgV2l0aFRoZW1lLmNvbnRleHRUeXBlcyA9IChfV2l0aFRoZW1lJGNvbnRleHRUeXAgPSB7fSwgX1dpdGhUaGVtZSRjb250ZXh0VHlwW0NIQU5ORUxdID0gUHJvcFR5cGVzLmZ1bmMsIF9XaXRoVGhlbWUkY29udGV4dFR5cFtDSEFOTkVMX05FWFRdID0gQ09OVEVYVF9DSEFOTkVMX1NIQVBFLCBfV2l0aFRoZW1lJGNvbnRleHRUeXApO1xuXG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhXaXRoVGhlbWUsIENvbXBvbmVudCQkMSk7XG59O1xuXG4vLyBcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfSEFVTlRFRF9CWV9TUE9PS1lfR0hPU1RTID0ge1xuICBTdHlsZVNoZWV0OiBTdHlsZVNoZWV0XG59O1xuXG4vLyBcblxuLyogSW1wb3J0IHNpbmdsZXRvbnMgKi9cbi8qIEltcG9ydCBzaW5nbGV0b24gY29uc3RydWN0b3JzICovXG4vKiBJbXBvcnQgY29tcG9uZW50cyAqL1xuLyogSW1wb3J0IEhpZ2hlciBPcmRlciBDb21wb25lbnRzICovXG4vKiBXYXJuaW5nIGlmIHlvdSd2ZSBpbXBvcnRlZCB0aGlzIGZpbGUgb24gUmVhY3QgTmF0aXZlICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLndhcm4oXCJJdCBsb29rcyBsaWtlIHlvdSd2ZSBpbXBvcnRlZCAnc3R5bGVkLWNvbXBvbmVudHMnIG9uIFJlYWN0IE5hdGl2ZS5cXG5cIiArIFwiUGVyaGFwcyB5b3UncmUgbG9va2luZyB0byBpbXBvcnQgJ3N0eWxlZC1jb21wb25lbnRzL25hdGl2ZSc/XFxuXCIgKyAnUmVhZCBtb3JlIGFib3V0IHRoaXMgYXQgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYmFzaWNzI3JlYWN0LW5hdGl2ZScpO1xufVxuXG4vKiBXYXJuaW5nIGlmIHRoZXJlIGFyZSBzZXZlcmFsIGluc3RhbmNlcyBvZiBzdHlsZWQtY29tcG9uZW50cyAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luZG93WydfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfXyddID0gd2luZG93WydfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfXyddIHx8IDA7XG5cbiAgaWYgKHdpbmRvd1snX19zdHlsZWQtY29tcG9uZW50cy1pbml0X18nXSA9PT0gMSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFwiSXQgbG9va3MgbGlrZSB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2YgJ3N0eWxlZC1jb21wb25lbnRzJyBpbml0aWFsaXplZCBpbiB0aGlzIGFwcGxpY2F0aW9uLiBcIiArICdUaGlzIG1heSBjYXVzZSBkeW5hbWljIHN0eWxlcyBub3QgcmVuZGVyaW5nIHByb3Blcmx5LCBlcnJvcnMgaGFwcGVuaW5nIGR1cmluZyByZWh5ZHJhdGlvbiBwcm9jZXNzICcgKyAnYW5kIG1ha2VzIHlvdSBhcHBsaWNhdGlvbiBiaWdnZXIgd2l0aG91dCBhIGdvb2QgcmVhc29uLlxcblxcbicgKyAnU2VlIGh0dHBzOi8vcy1jLnNoLzJCQVh6ZWQgZm9yIG1vcmUgaW5mby4nKTtcbiAgfVxuXG4gIHdpbmRvd1snX19zdHlsZWQtY29tcG9uZW50cy1pbml0X18nXSArPSAxO1xufVxuXG4vKiBJbnN0YW50aWF0ZSBzaW5nbGV0b25zICovXG52YXIgQ29tcG9uZW50U3R5bGUgPSBfQ29tcG9uZW50U3R5bGUoZ2VuZXJhdGVBbHBoYWJldGljTmFtZSwgZmxhdHRlbiwgc3RyaW5naWZ5UnVsZXMpO1xudmFyIGNvbnN0cnVjdFdpdGhPcHRpb25zID0gX2NvbnN0cnVjdFdpdGhPcHRpb25zKGNzcyk7XG52YXIgU3R5bGVkQ29tcG9uZW50ID0gX1N0eWxlZENvbXBvbmVudChDb21wb25lbnRTdHlsZSwgY29uc3RydWN0V2l0aE9wdGlvbnMpO1xuXG4vKiBJbnN0YW50aWF0ZSBleHBvcnRlZCBzaW5nbGV0b25zICovXG52YXIga2V5ZnJhbWVzID0gX2tleWZyYW1lcyhnZW5lcmF0ZUFscGhhYmV0aWNOYW1lLCBzdHJpbmdpZnlSdWxlcywgY3NzKTtcbnZhciBpbmplY3RHbG9iYWwgPSBfaW5qZWN0R2xvYmFsKHN0cmluZ2lmeVJ1bGVzLCBjc3MpO1xudmFyIHN0eWxlZCA9IF9zdHlsZWQoU3R5bGVkQ29tcG9uZW50LCBjb25zdHJ1Y3RXaXRoT3B0aW9ucyk7XG5cbmV4cG9ydCB7IGNzcywga2V5ZnJhbWVzLCBpbmplY3RHbG9iYWwsIGlzU3R5bGVkQ29tcG9uZW50LCBjb25zb2xpZGF0ZVN0cmVhbWVkU3R5bGVzLCBUaGVtZVByb3ZpZGVyLCB3cmFwV2l0aFRoZW1lIGFzIHdpdGhUaGVtZSwgU2VydmVyU3R5bGVTaGVldCwgU3R5bGVTaGVldE1hbmFnZXIsIF9fRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9IQVVOVEVEX0JZX1NQT09LWV9HSE9TVFMgfTtcbmV4cG9ydCBkZWZhdWx0IHN0eWxlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlZC1jb21wb25lbnRzLmJyb3dzZXIuZXMuanMubWFwXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBjdXN0b21TdGF0aWNzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5c1tpXV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5c1tpXV0gJiYgKCFjdXN0b21TdGF0aWNzIHx8ICFjdXN0b21TdGF0aWNzW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENvbXBvbmVudFtrZXlzW2ldXSA9IHNvdXJjZUNvbXBvbmVudFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG4iLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gKG1vZHVsZVsnZXhwb3J0cyddID0gZmFjdG9yeSgpKSA6XG5cdFx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddID8gZGVmaW5lKGZhY3RvcnkoKSkgOlxuXHRcdFx0KHdpbmRvd1snc3R5bGlzUnVsZVNoZWV0J10gPSBmYWN0b3J5KCkpXG59KGZ1bmN0aW9uICgpIHtcblxuXHQndXNlIHN0cmljdCdcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluc2VydFJ1bGUpIHtcblx0XHR2YXIgZGVsaW1pdGVyID0gJy8qfCovJ1xuXHRcdHZhciBuZWVkbGUgPSBkZWxpbWl0ZXIrJ30nXG5cblx0XHRmdW5jdGlvbiB0b1NoZWV0IChibG9jaykge1xuXHRcdFx0aWYgKGJsb2NrKVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGluc2VydFJ1bGUoYmxvY2sgKyAnfScpXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJ1bGVTaGVldCAoY29udGV4dCwgY29udGVudCwgc2VsZWN0b3JzLCBwYXJlbnRzLCBsaW5lLCBjb2x1bW4sIGxlbmd0aCwgbnMsIGRlcHRoLCBhdCkge1xuXHRcdFx0c3dpdGNoIChjb250ZXh0KSB7XG5cdFx0XHRcdC8vIHByb3BlcnR5XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHQvLyBAaW1wb3J0XG5cdFx0XHRcdFx0aWYgKGRlcHRoID09PSAwICYmIGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gNjQpXG5cdFx0XHRcdFx0XHRyZXR1cm4gaW5zZXJ0UnVsZShjb250ZW50Kyc7JyksICcnXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Ly8gc2VsZWN0b3Jcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdGlmIChucyA9PT0gMClcblx0XHRcdFx0XHRcdHJldHVybiBjb250ZW50ICsgZGVsaW1pdGVyXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Ly8gYXQtcnVsZVxuXHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0c3dpdGNoIChucykge1xuXHRcdFx0XHRcdFx0Ly8gQGZvbnQtZmFjZSwgQHBhZ2Vcblx0XHRcdFx0XHRcdGNhc2UgMTAyOlxuXHRcdFx0XHRcdFx0Y2FzZSAxMTI6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpbnNlcnRSdWxlKHNlbGVjdG9yc1swXStjb250ZW50KSwgJydcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjb250ZW50ICsgKGF0ID09PSAwID8gZGVsaW1pdGVyIDogJycpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIC0yOlxuXHRcdFx0XHRcdGNvbnRlbnQuc3BsaXQobmVlZGxlKS5mb3JFYWNoKHRvU2hlZXQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KSlcbiIsIi8qXG4gKiAgICAgICAgICBfXyAgICAgICAgX19fXG4gKiAgICBfX19fXy8gL19fXyAgX18vIChfKV9fX19cbiAqICAgLyBfX18vIF9fLyAvIC8gLyAvIC8gX19fL1xuICogIChfXyAgKSAvXy8gL18vIC8gLyAoX18gIClcbiAqIC9fX19fL1xcX18vXFxfXywgL18vXy9fX19fL1xuICogICAgICAgICAgL19fX18vXG4gKlxuICogbGlnaHQgLSB3ZWlnaHQgY3NzIHByZXByb2Nlc3NvciBAbGljZW5jZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChmYWN0b3J5KSB7LyogZXNsaW50LWRpc2FibGUgKi9cblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gKG1vZHVsZVsnZXhwb3J0cyddID0gZmFjdG9yeShudWxsKSkgOlxuXHRcdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSA/IGRlZmluZShmYWN0b3J5KG51bGwpKSA6XG5cdFx0XHQod2luZG93WydzdHlsaXMnXSA9IGZhY3RvcnkobnVsbCkpXG59KC8qKiBAcGFyYW0geyo9fSBvcHRpb25zICovZnVuY3Rpb24gZmFjdG9yeSAob3B0aW9ucykgey8qIGVzbGludC1kaXNhYmxlICovXG5cblx0J3VzZSBzdHJpY3QnXG5cblx0LyoqXG5cdCAqIE5vdGVzXG5cdCAqXG5cdCAqIFRoZSBbJzxtZXRob2QgbmFtZT4nXSBwYXR0ZXJuIGlzIHVzZWQgdG8gc3VwcG9ydCBjbG9zdXJlIGNvbXBpbGVyXG5cdCAqIHRoZSBqc2RvYyBzaWduYXR1cmVzIGFyZSBhbHNvIHVzZWQgdG8gdGhlIHNhbWUgZWZmZWN0XG5cdCAqXG5cdCAqIC0tLS1cblx0ICpcblx0ICogaW50ICsgaW50ICsgaW50ID09PSBuNCBbZmFzdGVyXVxuXHQgKlxuXHQgKiB2c1xuXHQgKlxuXHQgKiBpbnQgPT09IG4xICYmIGludCA9PT0gbjIgJiYgaW50ID09PSBuM1xuXHQgKlxuXHQgKiAtLS0tXG5cdCAqXG5cdCAqIHN3aXRjaCAoaW50KSB7IGNhc2UgaW50cy4uLn0gW2Zhc3Rlcl1cblx0ICpcblx0ICogdnNcblx0ICpcblx0ICogaWYgKGludCA9PSAxICYmIGludCA9PT0gMiAuLi4pXG5cdCAqXG5cdCAqIC0tLS1cblx0ICpcblx0ICogVGhlIChmaXJzdCpuMSArIHNlY29uZCpuMiArIHRoaXJkKm4zKSBmb3JtYXQgdXNlZCBpbiB0aGUgcHJvcGVydHkgcGFyc2VyXG5cdCAqIGlzIGEgc2ltcGxlIHdheSB0byBoYXNoIHRoZSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzXG5cdCAqIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGluZGV4IHRoZXkgb2NjdXIgaW5cblx0ICogc2luY2UgYW55IG51bWJlciBvZiAzIGNoYXJhY3RlciBzZXF1ZW5jZXMgY291bGQgcHJvZHVjZSBkdXBsaWNhdGVzLlxuXHQgKlxuXHQgKiBPbiB0aGUgb3RoZXIgaGFuZCBzZXF1ZW5jZXMgdGhhdCBhcmUgZGlyZWN0bHkgdGllZCB0byB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlclxuXHQgKiByZXNvbHZlIGEgZmFyIG1vcmUgYWNjdXJhdGUgbWVhc3VyZSwgaXQncyBhbHNvIGZhc3RlclxuXHQgKiB0byBldmFsdWF0ZSBvbmUgY29uZGl0aW9uIGluIGEgc3dpdGNoIHN0YXRlbWVudFxuXHQgKiB0aGFuIHRocmVlIGluIGFuIGlmIHN0YXRlbWVudCByZWdhcmRsZXNzIG9mIHRoZSBhZGRlZCBtYXRoLlxuXHQgKlxuXHQgKiBUaGlzIGFsbG93cyB0aGUgdmVuZG9yIHByZWZpeGVyIHRvIGJlIGJvdGggc21hbGwgYW5kIGZhc3QuXG5cdCAqL1xuXG5cdHZhciBudWxscHRuID0gL15cXDArL2cgLyogbWF0Y2hlcyBsZWFkaW5nIG51bGwgY2hhcmFjdGVycyAqL1xuXHR2YXIgZm9ybWF0cHRuID0gL1tcXDBcXHJcXGZdL2cgLyogbWF0Y2hlcyBuZXcgbGluZSwgbnVsbCBhbmQgZm9ybWZlZWQgY2hhcmFjdGVycyAqL1xuXHR2YXIgY29sb25wdG4gPSAvOiAqL2cgLyogc3BsaXRzIGFuaW1hdGlvbiBydWxlcyAqL1xuXHR2YXIgY3Vyc29ycHRuID0gL3pvb3xncmEvIC8qIGFzc2VydCBjdXJzb3IgdmFyaWVudCAqL1xuXHR2YXIgdHJhbnNmb3JtcHRuID0gLyhbLDogXSkodHJhbnNmb3JtKS9nIC8qIHZlbmRvciBwcmVmaXggdHJhbnNmb3JtLCBvbGRlciB3ZWJraXQgKi9cblx0dmFyIGFuaW1hdGlvbnB0biA9IC8sK1xccyooPyFbXihdKlspXSkvZyAvKiBzcGxpdHMgbXVsdGlwbGUgc2hvcnRoYW5kIG5vdGF0aW9uIGFuaW1hdGlvbnMgKi9cblx0dmFyIHByb3BlcnRpZXNwdG4gPSAvICtcXHMqKD8hW14oXSpbKV0pL2cgLyogYW5pbWF0aW9uIHByb3BlcnRpZXMgKi9cblx0dmFyIGVsZW1lbnRwdG4gPSAvICpbXFwwXSAqL2cgLyogc2VsZWN0b3IgZWxlbWVudHMgKi9cblx0dmFyIHNlbGVjdG9ycHRuID0gLyxcXHIrPy9nIC8qIHNwbGl0cyBzZWxlY3RvcnMgKi9cblx0dmFyIGFuZHB0biA9IC8oW1xcdFxcclxcbiBdKSpcXGY/Ji9nIC8qIG1hdGNoICYgKi9cblx0dmFyIGVzY2FwZXB0biA9IC86Z2xvYmFsXFwoKCg/OlteXFwoXFwpXFxbXFxdXSp8XFxbLipcXF18XFwoW15cXChcXCldKlxcKSkqKVxcKS9nIC8qIG1hdGNoZXMgOmdsb2JhbCguKikgKi9cblx0dmFyIGludmFsaWRwdG4gPSAvXFxXKy9nIC8qIHJlbW92ZXMgaW52YWxpZCBjaGFyYWN0ZXJzIGZyb20ga2V5ZnJhbWVzICovXG5cdHZhciBrZXlmcmFtZXB0biA9IC9AKGtcXHcrKVxccyooXFxTKilcXHMqLyAvKiBtYXRjaGVzIEBrZXlmcmFtZXMgJDEgKi9cblx0dmFyIHBsY2hvbGRycHRuID0gLzo6KHBsYWNlKS9nIC8qIG1hdGNoIDo6cGxhY2Vob2xkZXIgdmFyaWVudCAqL1xuXHR2YXIgcmVhZG9ubHlwdG4gPSAvOihyZWFkLW9ubHkpL2cgLyogbWF0Y2ggOnJlYWQtb25seSB2YXJpZW50ICovXG5cdHZhciBiZWZvcmVwdG4gPSAvXFxzKyg/PVt7XFxdOz06Pl0pL2cgLyogbWF0Y2hlcyBcXHMgYmVmb3JlIF0gOyA9IDogKi9cblx0dmFyIGFmdGVycHRuID0gLyhbW309Oj5dKVxccysvZyAvKiBtYXRjaGVzIFxccyBhZnRlciBjaGFyYWN0ZXJzIFsgfSA9IDogKi9cblx0dmFyIHRhaWxwdG4gPSAvKFxce1tee10rPyk7KD89XFx9KS9nIC8qIG1hdGNoZXMgdGFpbCBzZW1pLWNvbG9ucyA7fSAqL1xuXHR2YXIgd2hpdGVwdG4gPSAvXFxzezIsfS9nIC8qIG1hdGNoZXMgcmVwZWF0aW5nIHdoaXRlc3BhY2UgKi9cblx0dmFyIHBzZXVkb3B0biA9IC8oW15cXChdKSg6KykgKi9nIC8qIHBzZXVkbyBlbGVtZW50ICovXG5cdHZhciB3cml0aW5ncHRuID0gL1tzdmhdXFx3Ky1bdGJscl17Mn0vIC8qIG1hdGNoIHdyaXRpbmcgbW9kZSBwcm9wZXJ0eSB2YWx1ZXMgKi9cblx0dmFyIGdyYWRpZW50cHRuID0gLyhbXFx3LV0rdFxcKCkvZyAvKiBtYXRjaCAqZ3JhZGllbnQgcHJvcGVydHkgKi9cblx0dmFyIHN1cHBvcnRzcHRuID0gL1xcKFxccyooLiopXFxzKlxcKS9nIC8qIG1hdGNoIHN1cHBvcnRzIChncm91cHMpICovXG5cdHZhciBwcm9wZXJ0eXB0biA9IC8oW1xcc1xcU10qPyk7L2cgLyogbWF0Y2ggcHJvcGVydGllcyBsZWFkaW5nIHNlbWljb2xvbiAqL1xuXHR2YXIgc2VsZnB0biA9IC8tc2VsZnxmbGV4LS9nIC8qIG1hdGNoIGZsZXgtIGFuZCAtc2VsZiBpbiBhbGlnbi1zZWxmOiBmbGV4LSo7ICovXG5cdHZhciBwc2V1ZG9mbXQgPSAvW15dKj8oOltycF1bZWxdYVtcXHctXSspW15dKi8gLyogZXh0cmF0cyA6cmVhZG9ubHkgb3IgOnBsYWNob2xkZXIgZnJvbSBzZWxlY3RvciAqL1xuXHR2YXIgdHJpbXB0biA9IC9bIFxcdF0rJC8gLyogbWF0Y2ggdGFpbCB3aGl0c3BhY2UgKi9cblx0dmFyIGRpbWVuc2lvbnB0biA9IC9zdHJldGNofDpcXHMqXFx3K1xcLSg/OmNvbnRlfGF2YWlsKS8gLyogbWF0Y2ggbWF4L21pbi9maXQtY29udGVudCwgZmlsbC1hdmFpbGFibGVcblxuXHQvKiB2ZW5kb3JzICovXG5cdHZhciB3ZWJraXQgPSAnLXdlYmtpdC0nXG5cdHZhciBtb3ogPSAnLW1vei0nXG5cdHZhciBtcyA9ICctbXMtJ1xuXG5cdC8qIGNoYXJhY3RlciBjb2RlcyAqL1xuXHR2YXIgU0VNSUNPTE9OID0gNTkgLyogOyAqL1xuXHR2YXIgQ0xPU0VCUkFDRVMgPSAxMjUgLyogfSAqL1xuXHR2YXIgT1BFTkJSQUNFUyA9IDEyMyAvKiB7ICovXG5cdHZhciBPUEVOUEFSRU5USEVTRVMgPSA0MCAvKiAoICovXG5cdHZhciBDTE9TRVBBUkVOVEhFU0VTID0gNDEgLyogKSAqL1xuXHR2YXIgT1BFTkJSQUNLRVQgPSA5MSAvKiBbICovXG5cdHZhciBDTE9TRUJSQUNLRVQgPSA5MyAvKiBdICovXG5cdHZhciBORVdMSU5FID0gMTAgLyogXFxuICovXG5cdHZhciBDQVJSSUFHRSA9IDEzIC8qIFxcciAqL1xuXHR2YXIgVEFCID0gOSAvKiBcXHQgKi9cblx0dmFyIEFUID0gNjQgLyogQCAqL1xuXHR2YXIgU1BBQ0UgPSAzMiAvKiAgICovXG5cdHZhciBBTkQgPSAzOCAvKiAmICovXG5cdHZhciBEQVNIID0gNDUgLyogLSAqL1xuXHR2YXIgVU5ERVJTQ09SRSA9IDk1IC8qIF8gKi9cblx0dmFyIFNUQVIgPSA0MiAvKiAqICovXG5cdHZhciBDT01NQSA9IDQ0IC8qICwgKi9cblx0dmFyIENPTE9OID0gNTggLyogOiAqL1xuXHR2YXIgU0lOR0xFUVVPVEUgPSAzOSAvKiAnICovXG5cdHZhciBET1VCTEVRVU9URSA9IDM0IC8qIFwiICovXG5cdHZhciBGT1dBUkRTTEFTSCA9IDQ3IC8qIC8gKi9cblx0dmFyIEdSRUFURVJUSEFOID0gNjIgLyogPiAqL1xuXHR2YXIgUExVUyA9IDQzIC8qICsgKi9cblx0dmFyIFRJTERFID0gMTI2IC8qIH4gKi9cblx0dmFyIE5VTEwgPSAwIC8qIFxcMCAqL1xuXHR2YXIgRk9STUZFRUQgPSAxMiAvKiBcXGYgKi9cblx0dmFyIFZFUlRJQ0FMVEFCID0gMTEgLyogXFx2ICovXG5cblx0Lyogc3BlY2lhbCBpZGVudGlmaWVycyAqL1xuXHR2YXIgS0VZRlJBTUUgPSAxMDcgLyogayAqL1xuXHR2YXIgTUVESUEgPSAxMDkgLyogbSAqL1xuXHR2YXIgU1VQUE9SVFMgPSAxMTUgLyogcyAqL1xuXHR2YXIgUExBQ0VIT0xERVIgPSAxMTIgLyogcCAqL1xuXHR2YXIgUkVBRE9OTFkgPSAxMTEgLyogbyAqL1xuXHR2YXIgSU1QT1JUID0gMTY5IC8qIDxhdD5pICovXG5cdHZhciBDSEFSU0VUID0gMTYzIC8qIDxhdD5jICovXG5cdHZhciBET0NVTUVOVCA9IDEwMCAvKiA8YXQ+ZCAqL1xuXHR2YXIgUEFHRSA9IDExMiAvKiA8YXQ+cCAqL1xuXG5cdHZhciBjb2x1bW4gPSAxIC8qIGN1cnJlbnQgY29sdW1uICovXG5cdHZhciBsaW5lID0gMSAvKiBjdXJyZW50IGxpbmUgbnVtZWJyICovXG5cdHZhciBwYXR0ZXJuID0gMCAvKiA6cGF0dGVybiAqL1xuXG5cdHZhciBjYXNjYWRlID0gMSAvKiAjaWQgaDEgaDIgdnMgaDEjaWQgaDIjaWQgICovXG5cdHZhciBwcmVmaXggPSAxIC8qIHZlbmRvciBwcmVmaXggKi9cblx0dmFyIGVzY2FwZSA9IDEgLyogZXNjYXBlIDpnbG9iYWwoKSBwYXR0ZXJuICovXG5cdHZhciBjb21wcmVzcyA9IDAgLyogY29tcHJlc3Mgb3V0cHV0ICovXG5cdHZhciBzZW1pY29sb24gPSAwIC8qIG5vL3NlbWljb2xvbiBvcHRpb24gKi9cblx0dmFyIHByZXNlcnZlID0gMCAvKiBwcmVzZXJ2ZSBlbXB0eSBzZWxlY3RvcnMgKi9cblxuXHQvKiBlbXB0eSByZWZlcmVuY2UgKi9cblx0dmFyIGFycmF5ID0gW11cblxuXHQvKiBwbHVnaW5zICovXG5cdHZhciBwbHVnaW5zID0gW11cblx0dmFyIHBsdWdnZWQgPSAwXG5cdHZhciBzaG91bGQgPSBudWxsXG5cblx0LyogcGx1Z2luIGNvbnRleHQgKi9cblx0dmFyIFBPU1RTID0gLTJcblx0dmFyIFBSRVBTID0gLTFcblx0dmFyIFVOS1dOID0gMFxuXHR2YXIgUFJPUFMgPSAxXG5cdHZhciBCTENLUyA9IDJcblx0dmFyIEFUUlVMID0gM1xuXG5cdC8qIHBsdWdpbiBuZXdsaW5lIGNvbnRleHQgKi9cblx0dmFyIHVua3duID0gMFxuXG5cdC8qIGtleWZyYW1lIGFuaW1hdGlvbiAqL1xuXHR2YXIga2V5ZWQgPSAxXG5cdHZhciBrZXkgPSAnJ1xuXG5cdC8qIHNlbGVjdG9yIG5hbWVzcGFjZSAqL1xuXHR2YXIgbnNjb3BlYWx0ID0gJydcblx0dmFyIG5zY29wZSA9ICcnXG5cblx0LyoqXG5cdCAqIENvbXBpbGVcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwYXJlbnRcblx0ICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBjdXJyZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBib2R5XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGVwdGhcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cblx0ZnVuY3Rpb24gY29tcGlsZSAocGFyZW50LCBjdXJyZW50LCBib2R5LCBpZCwgZGVwdGgpIHtcblx0XHR2YXIgYnJhY2tldCA9IDAgLyogYnJhY2tldHMgW10gKi9cblx0XHR2YXIgY29tbWVudCA9IDAgLyogY29tbWVudHMgLyogLy8gb3IgLyogKi9cblx0XHR2YXIgcGFyZW50aGVzZXMgPSAwIC8qIGZ1bmN0aW9ucyAoKSAqL1xuXHRcdHZhciBxdW90ZSA9IDAgLyogcXVvdGVzICcnLCBcIlwiICovXG5cblx0XHR2YXIgZmlyc3QgPSAwIC8qIGZpcnN0IGNoYXJhY3RlciBjb2RlICovXG5cdFx0dmFyIHNlY29uZCA9IDAgLyogc2Vjb25kIGNoYXJhY3RlciBjb2RlICovXG5cdFx0dmFyIGNvZGUgPSAwIC8qIGN1cnJlbnQgY2hhcmFjdGVyIGNvZGUgKi9cblx0XHR2YXIgdGFpbCA9IDAgLyogcHJldmlvdXMgY2hhcmFjdGVyIGNvZGUgKi9cblx0XHR2YXIgdHJhaWwgPSAwIC8qIGNoYXJhY3RlciBiZWZvcmUgcHJldmlvdXMgY29kZSAqL1xuXHRcdHZhciBwZWFrID0gMCAvKiBwcmV2aW91cyBub24td2hpdGVzcGFjZSBjb2RlICovXG5cblx0XHR2YXIgY291bnRlciA9IDAgLyogY291bnQgc2VxdWVuY2UgdGVybWluYXRpb24gKi9cblx0XHR2YXIgY29udGV4dCA9IDAgLyogdHJhY2sgY3VycmVudCBjb250ZXh0ICovXG5cdFx0dmFyIGF0cnVsZSA9IDAgLyogdHJhY2sgQGF0LXJ1bGUgY29udGV4dCAqL1xuXHRcdHZhciBwc2V1ZG8gPSAwIC8qIHRyYWNrIHBzZXVkbyB0b2tlbiBpbmRleCAqL1xuXHRcdHZhciBjYXJldCA9IDAgLyogY3VycmVudCBjaGFyYWN0ZXIgaW5kZXggKi9cblx0XHR2YXIgZm9ybWF0ID0gMCAvKiBjb250cm9sIGNoYXJhY3RlciBmb3JtYXRpbmcgY29udGV4dCAqL1xuXHRcdHZhciBpbnNlcnQgPSAwIC8qIGF1dG8gc2VtaWNvbG9uIGluc2VydGlvbiAqL1xuXHRcdHZhciBpbnZlcnQgPSAwIC8qIGludmVydGVkIHNlbGVjdG9yIHBhdHRlcm4gKi9cblx0XHR2YXIgbGVuZ3RoID0gMCAvKiBnZW5lcmljIGxlbmd0aCBhZGRyZXNzICovXG5cdFx0dmFyIGVvZiA9IGJvZHkubGVuZ3RoIC8qIGVuZCBvZiBmaWxlKGxlbmd0aCkgKi9cblx0XHR2YXIgZW9sID0gZW9mIC0gMSAvKiBlbmQgb2YgZmlsZShjaGFyYWN0ZXJzKSAqL1xuXG5cdFx0dmFyIGNoYXIgPSAnJyAvKiBjdXJyZW50IGNoYXJhY3RlciAqL1xuXHRcdHZhciBjaGFycyA9ICcnIC8qIGN1cnJlbnQgYnVmZmVyIG9mIGNoYXJhY3RlcnMgKi9cblx0XHR2YXIgY2hpbGQgPSAnJyAvKiBuZXh0IGJ1ZmZlciBvZiBjaGFyYWN0ZXJzICovXG5cdFx0dmFyIG91dCA9ICcnIC8qIGNvbXBpbGVkIGJvZHkgKi9cblx0XHR2YXIgY2hpbGRyZW4gPSAnJyAvKiBjb21waWxlZCBjaGlsZHJlbiAqL1xuXHRcdHZhciBmbGF0ID0gJycgLyogY29tcGlsZWQgbGVhZnMgKi9cblx0XHR2YXIgc2VsZWN0b3IgLyogZ2VuZXJpYyBzZWxlY3RvciBhZGRyZXNzICovXG5cdFx0dmFyIHJlc3VsdCAvKiBnZW5lcmljIGFkZHJlc3MgKi9cblxuXHRcdC8vIC4uLmJ1aWxkIGJvZHlcblx0XHR3aGlsZSAoY2FyZXQgPCBlb2YpIHtcblx0XHRcdGNvZGUgPSBib2R5LmNoYXJDb2RlQXQoY2FyZXQpXG5cblx0XHRcdC8vIGVvZiB2YXJpZW50XG5cdFx0XHRpZiAoY2FyZXQgPT09IGVvbCkge1xuXHRcdFx0XHQvLyBsYXN0IGNoYXJhY3RlciArIG5vb3AgY29udGV4dCwgYWRkIHN5bnRoZXRpYyBwYWRkaW5nIGZvciBub29wIGNvbnRleHQgdG8gdGVybWluYXRlXG5cdFx0XHRcdGlmIChjb21tZW50ICsgcXVvdGUgKyBwYXJlbnRoZXNlcyArIGJyYWNrZXQgIT09IDApIHtcblx0XHRcdFx0XHRpZiAoY29tbWVudCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0Y29kZSA9IGNvbW1lbnQgPT09IEZPV0FSRFNMQVNIID8gTkVXTElORSA6IEZPV0FSRFNMQVNIXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cXVvdGUgPSBwYXJlbnRoZXNlcyA9IGJyYWNrZXQgPSAwXG5cdFx0XHRcdFx0ZW9mKytcblx0XHRcdFx0XHRlb2wrK1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb21tZW50ICsgcXVvdGUgKyBwYXJlbnRoZXNlcyArIGJyYWNrZXQgPT09IDApIHtcblx0XHRcdFx0Ly8gZW9mIHZhcmllbnRcblx0XHRcdFx0aWYgKGNhcmV0ID09PSBlb2wpIHtcblx0XHRcdFx0XHRpZiAoZm9ybWF0ID4gMCkge1xuXHRcdFx0XHRcdFx0Y2hhcnMgPSBjaGFycy5yZXBsYWNlKGZvcm1hdHB0biwgJycpXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGNoYXJzLnRyaW0oKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKGNvZGUpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSBTUEFDRTpcblx0XHRcdFx0XHRcdFx0Y2FzZSBUQUI6XG5cdFx0XHRcdFx0XHRcdGNhc2UgU0VNSUNPTE9OOlxuXHRcdFx0XHRcdFx0XHRjYXNlIENBUlJJQUdFOlxuXHRcdFx0XHRcdFx0XHRjYXNlIE5FV0xJTkU6IHtcblx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRjaGFycyArPSBib2R5LmNoYXJBdChjYXJldClcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb2RlID0gU0VNSUNPTE9OXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYXV0byBzZW1pY29sb24gaW5zZXJ0aW9uXG5cdFx0XHRcdGlmIChpbnNlcnQgPT09IDEpIHtcblx0XHRcdFx0XHRzd2l0Y2ggKGNvZGUpIHtcblx0XHRcdFx0XHRcdC8vIGZhbHNlIGZsYWdzXG5cdFx0XHRcdFx0XHRjYXNlIE9QRU5CUkFDRVM6XG5cdFx0XHRcdFx0XHRjYXNlIENMT1NFQlJBQ0VTOlxuXHRcdFx0XHRcdFx0Y2FzZSBTRU1JQ09MT046XG5cdFx0XHRcdFx0XHRjYXNlIERPVUJMRVFVT1RFOlxuXHRcdFx0XHRcdFx0Y2FzZSBTSU5HTEVRVU9URTpcblx0XHRcdFx0XHRcdGNhc2UgT1BFTlBBUkVOVEhFU0VTOlxuXHRcdFx0XHRcdFx0Y2FzZSBDTE9TRVBBUkVOVEhFU0VTOlxuXHRcdFx0XHRcdFx0Y2FzZSBDT01NQToge1xuXHRcdFx0XHRcdFx0XHRpbnNlcnQgPSAwXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBpZ25vcmVcblx0XHRcdFx0XHRcdGNhc2UgVEFCOlxuXHRcdFx0XHRcdFx0Y2FzZSBDQVJSSUFHRTpcblx0XHRcdFx0XHRcdGNhc2UgTkVXTElORTpcblx0XHRcdFx0XHRcdGNhc2UgU1BBQ0U6IHtcblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIHZhbGlkXG5cdFx0XHRcdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdFx0XHRcdGluc2VydCA9IDBcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gY2FyZXRcblx0XHRcdFx0XHRcdFx0Zmlyc3QgPSBjb2RlXG5cdFx0XHRcdFx0XHRcdGNhcmV0LS1cblx0XHRcdFx0XHRcdFx0Y29kZSA9IFNFTUlDT0xPTlxuXG5cdFx0XHRcdFx0XHRcdHdoaWxlIChsZW5ndGggPCBlb2YpIHtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGJvZHkuY2hhckNvZGVBdChsZW5ndGgrKykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgTkVXTElORTpcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgQ0FSUklBR0U6XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFNFTUlDT0xPTjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2NhcmV0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvZGUgPSBmaXJzdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsZW5ndGggPSBlb2Zcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgQ09MT046IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGZvcm1hdCA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQrK2NhcmV0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29kZSA9IGZpcnN0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgT1BFTkJSQUNFUzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRsZW5ndGggPSBlb2Zcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyB0b2tlbiB2YXJpZW50XG5cdFx0XHRcdHN3aXRjaCAoY29kZSkge1xuXHRcdFx0XHRcdGNhc2UgT1BFTkJSQUNFUzoge1xuXHRcdFx0XHRcdFx0Y2hhcnMgPSBjaGFycy50cmltKClcblx0XHRcdFx0XHRcdGZpcnN0ID0gY2hhcnMuY2hhckNvZGVBdCgwKVxuXHRcdFx0XHRcdFx0Y291bnRlciA9IDFcblx0XHRcdFx0XHRcdGxlbmd0aCA9ICsrY2FyZXRcblxuXHRcdFx0XHRcdFx0d2hpbGUgKGNhcmV0IDwgZW9mKSB7XG5cdFx0XHRcdFx0XHRcdGNvZGUgPSBib2R5LmNoYXJDb2RlQXQoY2FyZXQpXG5cblx0XHRcdFx0XHRcdFx0c3dpdGNoIChjb2RlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBPUEVOQlJBQ0VTOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb3VudGVyKytcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgQ0xPU0VCUkFDRVM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvdW50ZXItLVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoY291bnRlciA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRjYXJldCsrXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNoaWxkID0gYm9keS5zdWJzdHJpbmcobGVuZ3RoLCBjYXJldClcblxuXHRcdFx0XHRcdFx0aWYgKGZpcnN0ID09PSBOVUxMKSB7XG5cdFx0XHRcdFx0XHRcdGZpcnN0ID0gKGNoYXJzID0gY2hhcnMucmVwbGFjZShudWxscHRuLCAnJykudHJpbSgpKS5jaGFyQ29kZUF0KDApXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN3aXRjaCAoZmlyc3QpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQGF0LXJ1bGVcblx0XHRcdFx0XHRcdFx0Y2FzZSBBVDoge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChmb3JtYXQgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGFycyA9IGNoYXJzLnJlcGxhY2UoZm9ybWF0cHRuLCAnJylcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRzZWNvbmQgPSBjaGFycy5jaGFyQ29kZUF0KDEpXG5cblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHNlY29uZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBET0NVTUVOVDpcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgTUVESUE6XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFNVUFBPUlRTOlxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBEQVNIOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdG9yID0gY3VycmVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RvciA9IGFycmF5XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGQgPSBjb21waWxlKGN1cnJlbnQsIHNlbGVjdG9yLCBjaGlsZCwgc2Vjb25kLCBkZXB0aCsxKVxuXHRcdFx0XHRcdFx0XHRcdGxlbmd0aCA9IGNoaWxkLmxlbmd0aFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gcHJlc2VydmUgZW1wdHkgQGF0LXJ1bGVcblx0XHRcdFx0XHRcdFx0XHRpZiAocHJlc2VydmUgPiAwICYmIGxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gY2hhcnMubGVuZ3RoXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXhlY3V0ZSBwbHVnaW5zLCBAYXQtcnVsZSBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHBsdWdnZWQgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdChhcnJheSwgY2hhcnMsIGludmVydClcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdCA9IHByb3h5KEFUUlVMLCBjaGlsZCwgc2VsZWN0b3IsIGN1cnJlbnQsIGxpbmUsIGNvbHVtbiwgbGVuZ3RoLCBzZWNvbmQsIGRlcHRoLCBpZClcblx0XHRcdFx0XHRcdFx0XHRcdGNoYXJzID0gc2VsZWN0b3Iuam9pbignJylcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICgobGVuZ3RoID0gKGNoaWxkID0gcmVzdWx0LnRyaW0oKSkubGVuZ3RoKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHNlY29uZCA9IDBcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjaGlsZCA9ICcnXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3dpdGNoIChzZWNvbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBTVVBQT1JUUzoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNoYXJzID0gY2hhcnMucmVwbGFjZShzdXBwb3J0c3B0biwgc3VwcG9ydHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBET0NVTUVOVDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBNRURJQTpcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBEQVNIOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2hpbGQgPSBjaGFycyArICd7JyArIGNoaWxkICsgJ30nXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIEtFWUZSQU1FOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2hhcnMgPSBjaGFycy5yZXBsYWNlKGtleWZyYW1lcHRuLCAnJDEgJDInICsgKGtleWVkID4gMCA/IGtleSA6ICcnKSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjaGlsZCA9IGNoYXJzICsgJ3snICsgY2hpbGQgKyAnfSdcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChwcmVmaXggPT09IDEgfHwgKHByZWZpeCA9PT0gMiAmJiB2ZW5kb3IoJ0AnK2NoaWxkLCAzKSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNoaWxkID0gJ0AnICsgd2Via2l0ICsgY2hpbGQgKyAnQCcgKyBjaGlsZFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjaGlsZCA9ICdAJyArIGNoaWxkXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNoaWxkID0gY2hhcnMgKyBjaGlsZFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGlkID09PSBQQUdFKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjaGlsZCA9IChvdXQgKz0gY2hpbGQsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGlsZCA9ICcnXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyBzZWxlY3RvclxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGQgPSBjb21waWxlKGN1cnJlbnQsIHNlbGVjdChjdXJyZW50LCBjaGFycywgaW52ZXJ0KSwgY2hpbGQsIGlkLCBkZXB0aCsxKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNoaWxkcmVuICs9IGNoaWxkXG5cblx0XHRcdFx0XHRcdC8vIHJlc2V0XG5cdFx0XHRcdFx0XHRjb250ZXh0ID0gMFxuXHRcdFx0XHRcdFx0aW5zZXJ0ID0gMFxuXHRcdFx0XHRcdFx0cHNldWRvID0gMFxuXHRcdFx0XHRcdFx0Zm9ybWF0ID0gMFxuXHRcdFx0XHRcdFx0aW52ZXJ0ID0gMFxuXHRcdFx0XHRcdFx0YXRydWxlID0gMFxuXHRcdFx0XHRcdFx0Y2hhcnMgPSAnJ1xuXHRcdFx0XHRcdFx0Y2hpbGQgPSAnJ1xuXHRcdFx0XHRcdFx0Y29kZSA9IGJvZHkuY2hhckNvZGVBdCgrK2NhcmV0KVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FzZSBDTE9TRUJSQUNFUzpcblx0XHRcdFx0XHRjYXNlIFNFTUlDT0xPTjoge1xuXHRcdFx0XHRcdFx0Y2hhcnMgPSAoZm9ybWF0ID4gMCA/IGNoYXJzLnJlcGxhY2UoZm9ybWF0cHRuLCAnJykgOiBjaGFycykudHJpbSgpXG5cblx0XHRcdFx0XHRcdGlmICgobGVuZ3RoID0gY2hhcnMubGVuZ3RoKSA+IDEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gbW9ua2V5LXBhdGNoIG1pc3NpbmcgY29sb25cblx0XHRcdFx0XHRcdFx0aWYgKHBzZXVkbyA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGZpcnN0ID0gY2hhcnMuY2hhckNvZGVBdCgwKVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZmlyc3QgY2hhcmFjdGVyIGlzIGEgbGV0dGVyIG9yIGRhc2gsIGJ1ZmZlciBoYXMgYSBzcGFjZSBjaGFyYWN0ZXJcblx0XHRcdFx0XHRcdFx0XHRpZiAoKGZpcnN0ID09PSBEQVNIIHx8IGZpcnN0ID4gOTYgJiYgZmlyc3QgPCAxMjMpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsZW5ndGggPSAoY2hhcnMgPSBjaGFycy5yZXBsYWNlKCcgJywgJzonKSkubGVuZ3RoXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gZXhlY3V0ZSBwbHVnaW5zLCBwcm9wZXJ0eSBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdGlmIChwbHVnZ2VkID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICgocmVzdWx0ID0gcHJveHkoUFJPUFMsIGNoYXJzLCBjdXJyZW50LCBwYXJlbnQsIGxpbmUsIGNvbHVtbiwgb3V0Lmxlbmd0aCwgaWQsIGRlcHRoLCBpZCkpICE9PSB2b2lkIDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICgobGVuZ3RoID0gKGNoYXJzID0gcmVzdWx0LnRyaW0oKSkubGVuZ3RoKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjaGFycyA9ICdcXDBcXDAnXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Zmlyc3QgPSBjaGFycy5jaGFyQ29kZUF0KDApXG5cdFx0XHRcdFx0XHRcdHNlY29uZCA9IGNoYXJzLmNoYXJDb2RlQXQoMSlcblxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGZpcnN0ICsgc2Vjb25kKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBOVUxMOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRjYXNlIElNUE9SVDpcblx0XHRcdFx0XHRcdFx0XHRjYXNlIENIQVJTRVQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGZsYXQgKz0gY2hhcnMgKyBib2R5LmNoYXJBdChjYXJldClcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChjaGFycy5jaGFyQ29kZUF0KGxlbmd0aC0xKSA9PT0gQ09MT04pXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cblx0XHRcdFx0XHRcdFx0XHRcdG91dCArPSBwcm9wZXJ0eShjaGFycywgZmlyc3QsIHNlY29uZCwgY2hhcnMuY2hhckNvZGVBdCgyKSlcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gcmVzZXRcblx0XHRcdFx0XHRcdGNvbnRleHQgPSAwXG5cdFx0XHRcdFx0XHRpbnNlcnQgPSAwXG5cdFx0XHRcdFx0XHRwc2V1ZG8gPSAwXG5cdFx0XHRcdFx0XHRmb3JtYXQgPSAwXG5cdFx0XHRcdFx0XHRpbnZlcnQgPSAwXG5cdFx0XHRcdFx0XHRjaGFycyA9ICcnXG5cdFx0XHRcdFx0XHRjb2RlID0gYm9keS5jaGFyQ29kZUF0KCsrY2FyZXQpXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBwYXJzZSBjaGFyYWN0ZXJzXG5cdFx0XHRzd2l0Y2ggKGNvZGUpIHtcblx0XHRcdFx0Y2FzZSBDQVJSSUFHRTpcblx0XHRcdFx0Y2FzZSBORVdMSU5FOiB7XG5cdFx0XHRcdFx0Ly8gYXV0byBpbnNlcnQgc2VtaWNvbG9uXG5cdFx0XHRcdFx0aWYgKGNvbW1lbnQgKyBxdW90ZSArIHBhcmVudGhlc2VzICsgYnJhY2tldCArIHNlbWljb2xvbiA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Ly8gdmFsaWQgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyB0aGF0XG5cdFx0XHRcdFx0XHQvLyBtYXkgcHJlY2VkZSBhIG5ld2xpbmVcblx0XHRcdFx0XHRcdHN3aXRjaCAocGVhaykge1xuXHRcdFx0XHRcdFx0XHRjYXNlIENMT1NFUEFSRU5USEVTRVM6XG5cdFx0XHRcdFx0XHRcdGNhc2UgU0lOR0xFUVVPVEU6XG5cdFx0XHRcdFx0XHRcdGNhc2UgRE9VQkxFUVVPVEU6XG5cdFx0XHRcdFx0XHRcdGNhc2UgQVQ6XG5cdFx0XHRcdFx0XHRcdGNhc2UgVElMREU6XG5cdFx0XHRcdFx0XHRcdGNhc2UgR1JFQVRFUlRIQU46XG5cdFx0XHRcdFx0XHRcdGNhc2UgU1RBUjpcblx0XHRcdFx0XHRcdFx0Y2FzZSBQTFVTOlxuXHRcdFx0XHRcdFx0XHRjYXNlIEZPV0FSRFNMQVNIOlxuXHRcdFx0XHRcdFx0XHRjYXNlIERBU0g6XG5cdFx0XHRcdFx0XHRcdGNhc2UgQ09MT046XG5cdFx0XHRcdFx0XHRcdGNhc2UgQ09NTUE6XG5cdFx0XHRcdFx0XHRcdGNhc2UgU0VNSUNPTE9OOlxuXHRcdFx0XHRcdFx0XHRjYXNlIE9QRU5CUkFDRVM6XG5cdFx0XHRcdFx0XHRcdGNhc2UgQ0xPU0VCUkFDRVM6IHtcblx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHQvLyBjdXJyZW50IGJ1ZmZlciBoYXMgYSBjb2xvblxuXHRcdFx0XHRcdFx0XHRcdGlmIChwc2V1ZG8gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbnNlcnQgPSAxXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdGVybWluYXRlIGxpbmUgY29tbWVudFxuXHRcdFx0XHRcdGlmIChjb21tZW50ID09PSBGT1dBUkRTTEFTSCkge1xuXHRcdFx0XHRcdFx0Y29tbWVudCA9IDBcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNhc2NhZGUgKyBjb250ZXh0ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRmb3JtYXQgPSAxXG5cdFx0XHRcdFx0XHRjaGFycyArPSAnXFwwJ1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGV4ZWN1dGUgcGx1Z2lucywgbmV3bGluZSBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKHBsdWdnZWQgKiB1bmt3biA+IDApIHtcblx0XHRcdFx0XHRcdHByb3h5KFVOS1dOLCBjaGFycywgY3VycmVudCwgcGFyZW50LCBsaW5lLCBjb2x1bW4sIG91dC5sZW5ndGgsIGlkLCBkZXB0aCwgaWQpXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gbmV4dCBsaW5lLCByZXNldCBjb2x1bW4gcG9zaXRpb25cblx0XHRcdFx0XHRjb2x1bW4gPSAxXG5cdFx0XHRcdFx0bGluZSsrXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFNFTUlDT0xPTjpcblx0XHRcdFx0Y2FzZSBDTE9TRUJSQUNFUzoge1xuXHRcdFx0XHRcdGlmIChjb21tZW50ICsgcXVvdGUgKyBwYXJlbnRoZXNlcyArIGJyYWNrZXQgPT09IDApIHtcblx0XHRcdFx0XHRcdGNvbHVtbisrXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdFx0Ly8gaW5jcmVtZW50IGNvbHVtbiBwb3NpdGlvblxuXHRcdFx0XHRcdGNvbHVtbisrXG5cblx0XHRcdFx0XHQvLyBjdXJyZW50IGNoYXJhY3RlclxuXHRcdFx0XHRcdGNoYXIgPSBib2R5LmNoYXJBdChjYXJldClcblxuXHRcdFx0XHRcdC8vIHJlbW92ZSBjb21tZW50cywgZXNjYXBlIGZ1bmN0aW9ucywgc3RyaW5ncywgYXR0cmlidXRlcyBhbmQgcHJlcGFyZSBzZWxlY3RvcnNcblx0XHRcdFx0XHRzd2l0Y2ggKGNvZGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgVEFCOlxuXHRcdFx0XHRcdFx0Y2FzZSBTUEFDRToge1xuXHRcdFx0XHRcdFx0XHRpZiAocXVvdGUgKyBicmFja2V0ICsgY29tbWVudCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAodGFpbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBDT01NQTpcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgQ09MT046XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFRBQjpcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgU1BBQ0U6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2hhciA9ICcnXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChjb2RlICE9PSBTUEFDRSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNoYXIgPSAnICdcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gZXNjYXBlIGJyZWFraW5nIGNvbnRyb2wgY2hhcmFjdGVyc1xuXHRcdFx0XHRcdFx0Y2FzZSBOVUxMOiB7XG5cdFx0XHRcdFx0XHRcdGNoYXIgPSAnXFxcXDAnXG5cdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYXNlIEZPUk1GRUVEOiB7XG5cdFx0XHRcdFx0XHRcdGNoYXIgPSAnXFxcXGYnXG5cdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYXNlIFZFUlRJQ0FMVEFCOiB7XG5cdFx0XHRcdFx0XHRcdGNoYXIgPSAnXFxcXHYnXG5cdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyAmXG5cdFx0XHRcdFx0XHRjYXNlIEFORDoge1xuXHRcdFx0XHRcdFx0XHQvLyBpbnZlcnRlZCBzZWxlY3RvciBwYXR0ZXJuIGkuZSBodG1sICZcblx0XHRcdFx0XHRcdFx0aWYgKHF1b3RlICsgY29tbWVudCArIGJyYWNrZXQgPT09IDAgJiYgY2FzY2FkZSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRpbnZlcnQgPSAxXG5cdFx0XHRcdFx0XHRcdFx0Zm9ybWF0ID0gMVxuXHRcdFx0XHRcdFx0XHRcdGNoYXIgPSAnXFxmJyArIGNoYXJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gOjpwPGw+YWNlaG9sZGVyLCBsXG5cdFx0XHRcdFx0XHQvLyA6cmVhZC1vbjxsPnksIGxcblx0XHRcdFx0XHRcdGNhc2UgMTA4OiB7XG5cdFx0XHRcdFx0XHRcdGlmIChxdW90ZSArIGNvbW1lbnQgKyBicmFja2V0ICsgcGF0dGVybiA9PT0gMCAmJiBwc2V1ZG8gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3dpdGNoIChjYXJldCAtIHBzZXVkbykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gOjpwbGFjZWhvbGRlclxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAyOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh0YWlsID09PSBQTEFDRUhPTERFUiAmJiBib2R5LmNoYXJDb2RlQXQoY2FyZXQtMykgPT09IENPTE9OKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVybiA9IHRhaWxcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gOnJlYWQtb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSA4OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh0cmFpbCA9PT0gUkVBRE9OTFkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuID0gdHJhaWxcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gOjxwYXR0ZXJuPlxuXHRcdFx0XHRcdFx0Y2FzZSBDT0xPTjoge1xuXHRcdFx0XHRcdFx0XHRpZiAocXVvdGUgKyBjb21tZW50ICsgYnJhY2tldCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHBzZXVkbyA9IGNhcmV0XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIHNlbGVjdG9yc1xuXHRcdFx0XHRcdFx0Y2FzZSBDT01NQToge1xuXHRcdFx0XHRcdFx0XHRpZiAoY29tbWVudCArIHBhcmVudGhlc2VzICsgcXVvdGUgKyBicmFja2V0ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9ybWF0ID0gMVxuXHRcdFx0XHRcdFx0XHRcdGNoYXIgKz0gJ1xccidcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gcXVvdGVzXG5cdFx0XHRcdFx0XHRjYXNlIERPVUJMRVFVT1RFOiB7XG5cdFx0XHRcdFx0XHRcdGlmIChjb21tZW50ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0cXVvdGUgPSBxdW90ZSA9PT0gY29kZSA/IDAgOiAocXVvdGUgPT09IDAgPyBjb2RlIDogcXVvdGUpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhc2UgU0lOR0xFUVVPVEU6IHtcblx0XHRcdFx0XHRcdFx0aWYgKGNvbW1lbnQgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRxdW90ZSA9IHF1b3RlID09PSBjb2RlID8gMCA6IChxdW90ZSA9PT0gMCA/IGNvZGUgOiBxdW90ZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0Y2FzZSBPUEVOQlJBQ0tFVDoge1xuXHRcdFx0XHRcdFx0XHRpZiAocXVvdGUgKyBjb21tZW50ICsgcGFyZW50aGVzZXMgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRicmFja2V0Kytcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FzZSBDTE9TRUJSQUNLRVQ6IHtcblx0XHRcdFx0XHRcdFx0aWYgKHF1b3RlICsgY29tbWVudCArIHBhcmVudGhlc2VzID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0YnJhY2tldC0tXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGZ1bmN0aW9uc1xuXHRcdFx0XHRcdFx0Y2FzZSBDTE9TRVBBUkVOVEhFU0VTOiB7XG5cdFx0XHRcdFx0XHRcdGlmIChxdW90ZSArIGNvbW1lbnQgKyBicmFja2V0ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGFyZW50aGVzZXMtLVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYXNlIE9QRU5QQVJFTlRIRVNFUzoge1xuXHRcdFx0XHRcdFx0XHRpZiAocXVvdGUgKyBjb21tZW50ICsgYnJhY2tldCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjb250ZXh0ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHRhaWwqMiArIHRyYWlsKjMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gOm1hdGNoZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSA1MzM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIDpnbG9iYWwsIDpub3QsIDpudGgtY2hpbGQgZXRjLi4uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb3VudGVyID0gMFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnRleHQgPSAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRwYXJlbnRoZXNlcysrXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhc2UgQVQ6IHtcblx0XHRcdFx0XHRcdFx0aWYgKGNvbW1lbnQgKyBwYXJlbnRoZXNlcyArIHF1b3RlICsgYnJhY2tldCArIHBzZXVkbyArIGF0cnVsZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGF0cnVsZSA9IDFcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gYmxvY2svbGluZSBjb21tZW50c1xuXHRcdFx0XHRcdFx0Y2FzZSBTVEFSOlxuXHRcdFx0XHRcdFx0Y2FzZSBGT1dBUkRTTEFTSDoge1xuXHRcdFx0XHRcdFx0XHRpZiAocXVvdGUgKyBicmFja2V0ICsgcGFyZW50aGVzZXMgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoY29tbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGluaXRpYWxpemUgbGluZS9ibG9jayBjb21tZW50IGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRjYXNlIDA6IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoY29kZSoyICsgYm9keS5jaGFyQ29kZUF0KGNhcmV0KzEpKjMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLy9cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAyMzU6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb21tZW50ID0gRk9XQVJEU0xBU0hcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC8qXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgMjIwOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gY2FyZXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb21tZW50ID0gU1RBUlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIGVuZCBibG9jayBjb21tZW50IGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFNUQVI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChjb2RlID09PSBGT1dBUkRTTEFTSCAmJiB0YWlsID09PSBTVEFSKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC8qPCE+IC4uLiAqLywgIVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoYm9keS5jaGFyQ29kZUF0KGxlbmd0aCsyKSA9PT0gMzMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXQgKz0gYm9keS5zdWJzdHJpbmcobGVuZ3RoLCBjYXJldCsxKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNoYXIgPSAnJ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb21tZW50ID0gMFxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGlnbm9yZSBjb21tZW50IGJsb2Nrc1xuXHRcdFx0XHRcdGlmIChjb21tZW50ID09PSAwKSB7XG5cdFx0XHRcdFx0XHQvLyBhZ2dyZXNzaXZlIGlzb2xhdGlvbiBtb2RlLCBkaXZpZGUgZWFjaCBpbmRpdmlkdWFsIHNlbGVjdG9yXG5cdFx0XHRcdFx0XHQvLyBpbmNsdWRpbmcgc2VsZWN0b3JzIGluIDpub3QgZnVuY3Rpb24gYnV0IGV4Y2x1ZGluZyBzZWxlY3RvcnMgaW4gOmdsb2JhbCBmdW5jdGlvblxuXHRcdFx0XHRcdFx0aWYgKGNhc2NhZGUgKyBxdW90ZSArIGJyYWNrZXQgKyBhdHJ1bGUgPT09IDAgJiYgaWQgIT09IEtFWUZSQU1FICYmIGNvZGUgIT09IFNFTUlDT0xPTikge1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGNvZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIENPTU1BOlxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgVElMREU6XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBHUkVBVEVSVEhBTjpcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFBMVVM6XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBDTE9TRVBBUkVOVEhFU0VTOlxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgT1BFTlBBUkVOVEhFU0VTOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoY29udGV4dCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBvdXRzaWRlIG9mIGFuIGlzb2xhdGVkIGNvbnRleHQgaS5lIG50aC1jaGlsZCg8Li4uPilcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3dpdGNoICh0YWlsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBUQUI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBTUEFDRTpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIE5FV0xJTkU6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBDQVJSSUFHRToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2hhciA9IGNoYXIgKyAnXFwwJ1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2hhciA9ICdcXDAnICsgY2hhciArIChjb2RlID09PSBDT01NQSA/ICcnIDogJ1xcMCcpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvcm1hdCA9IDFcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHdpdGhpbiBhbiBpc29sYXRlZCBjb250ZXh0LCBzbGVlcCB1bnRpbGwgaXQncyB0ZXJtaW5hdGVkXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoY29kZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgT1BFTlBBUkVOVEhFU0VTOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb250ZXh0ID0gKytjb3VudGVyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIENMT1NFUEFSRU5USEVTRVM6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICgoY29udGV4dCA9IC0tY291bnRlcikgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9ybWF0ID0gMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjaGFyICs9ICdcXDAnXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBUQUI6XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBTUEFDRToge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3dpdGNoICh0YWlsKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgTlVMTDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBPUEVOQlJBQ0VTOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIENMT1NFQlJBQ0VTOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFNFTUlDT0xPTjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBDT01NQTpcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBGT1JNRkVFRDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBUQUI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgU1BBQ0U6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgTkVXTElORTpcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBDQVJSSUFHRToge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGlnbm9yZSBpbiBpc29sYXRlZCBjb250ZXh0c1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChjb250ZXh0ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3JtYXQgPSAxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjaGFyICs9ICdcXDAnXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGNvbmNhdCBidWZmZXIgb2YgY2hhcmFjdGVyc1xuXHRcdFx0XHRcdFx0Y2hhcnMgKz0gY2hhclxuXG5cdFx0XHRcdFx0XHQvLyBwcmV2aW91cyBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIgY29kZVxuXHRcdFx0XHRcdFx0aWYgKGNvZGUgIT09IFNQQUNFICYmIGNvZGUgIT09IFRBQikge1xuXHRcdFx0XHRcdFx0XHRwZWFrID0gY29kZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyB0YWlsIGNoYXJhY3RlciBjb2Rlc1xuXHRcdFx0dHJhaWwgPSB0YWlsXG5cdFx0XHR0YWlsID0gY29kZVxuXG5cdFx0XHQvLyB2aXNpdCBldmVyeSBjaGFyYWN0ZXJcblx0XHRcdGNhcmV0Kytcblx0XHR9XG5cblx0XHRsZW5ndGggPSBvdXQubGVuZ3RoXG5cblx0XHQvLyBwcmVzZXJ2ZSBlbXB0eSBzZWxlY3RvclxuIFx0XHRpZiAocHJlc2VydmUgPiAwKSB7XG4gXHRcdFx0aWYgKGxlbmd0aCA9PT0gMCAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgKGN1cnJlbnRbMF0ubGVuZ3RoID09PSAwKSA9PT0gZmFsc2UpIHtcbiBcdFx0XHRcdGlmIChpZCAhPT0gTUVESUEgfHwgKGN1cnJlbnQubGVuZ3RoID09PSAxICYmIChjYXNjYWRlID4gMCA/IG5zY29wZWFsdCA6IG5zY29wZSkgPT09IGN1cnJlbnRbMF0pKSB7XG5cdFx0XHRcdFx0bGVuZ3RoID0gY3VycmVudC5qb2luKCcsJykubGVuZ3RoICsgMlxuIFx0XHRcdFx0fVxuIFx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0Ly8gY2FzY2FkZSBpc29sYXRpb24gbW9kZT9cblx0XHRcdHNlbGVjdG9yID0gY2FzY2FkZSA9PT0gMCAmJiBpZCAhPT0gS0VZRlJBTUUgPyBpc29sYXRlKGN1cnJlbnQpIDogY3VycmVudFxuXG5cdFx0XHQvLyBleGVjdXRlIHBsdWdpbnMsIGJsb2NrIGNvbnRleHRcblx0XHRcdGlmIChwbHVnZ2VkID4gMCkge1xuXHRcdFx0XHRyZXN1bHQgPSBwcm94eShCTENLUywgb3V0LCBzZWxlY3RvciwgcGFyZW50LCBsaW5lLCBjb2x1bW4sIGxlbmd0aCwgaWQsIGRlcHRoLCBpZClcblxuXHRcdFx0XHRpZiAocmVzdWx0ICE9PSB2b2lkIDAgJiYgKG91dCA9IHJlc3VsdCkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZsYXQgKyBvdXQgKyBjaGlsZHJlblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IHNlbGVjdG9yLmpvaW4oJywnKSArICd7JyArIG91dCArICd9J1xuXG5cdFx0XHRpZiAocHJlZml4KnBhdHRlcm4gIT09IDApIHtcblx0XHRcdFx0aWYgKHByZWZpeCA9PT0gMiAmJiAhdmVuZG9yKG91dCwgMikpXG5cdFx0XHRcdFx0cGF0dGVybiA9IDBcblxuXHRcdFx0XHRzd2l0Y2ggKHBhdHRlcm4pIHtcblx0XHRcdFx0XHQvLyA6OnJlYWQtb25seVxuXHRcdFx0XHRcdGNhc2UgUkVBRE9OTFk6IHtcblx0XHRcdFx0XHRcdG91dCA9IG91dC5yZXBsYWNlKHJlYWRvbmx5cHRuLCAnOicrbW96KyckMScpK291dFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gOjpwbGFjZWhvbGRlclxuXHRcdFx0XHRcdGNhc2UgUExBQ0VIT0xERVI6IHtcblx0XHRcdFx0XHRcdG91dCA9IChcblx0XHRcdFx0XHRcdFx0b3V0LnJlcGxhY2UocGxjaG9sZHJwdG4sICc6OicgKyB3ZWJraXQgKyAnaW5wdXQtJDEnKSArXG5cdFx0XHRcdFx0XHRcdG91dC5yZXBsYWNlKHBsY2hvbGRycHRuLCAnOjonICsgbW96ICsgJyQxJykgK1xuXHRcdFx0XHRcdFx0XHRvdXQucmVwbGFjZShwbGNob2xkcnB0biwgJzonICsgbXMgKyAnaW5wdXQtJDEnKSArIG91dFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXR0ZXJuID0gMFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmbGF0ICsgb3V0ICsgY2hpbGRyZW5cblx0fVxuXG5cdC8qKlxuXHQgKiBTZWxlY3Rcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwYXJlbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGludmVydFxuXHQgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fVxuXHQgKi9cblx0ZnVuY3Rpb24gc2VsZWN0IChwYXJlbnQsIGN1cnJlbnQsIGludmVydCkge1xuXHRcdHZhciBzZWxlY3RvcnMgPSBjdXJyZW50LnRyaW0oKS5zcGxpdChzZWxlY3RvcnB0bilcblx0XHR2YXIgb3V0ID0gc2VsZWN0b3JzXG5cblx0XHR2YXIgbGVuZ3RoID0gc2VsZWN0b3JzLmxlbmd0aFxuXHRcdHZhciBsID0gcGFyZW50Lmxlbmd0aFxuXG5cdFx0c3dpdGNoIChsKSB7XG5cdFx0XHQvLyAwLTEgcGFyZW50IHNlbGVjdG9yc1xuXHRcdFx0Y2FzZSAwOlxuXHRcdFx0Y2FzZSAxOiB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBzZWxlY3RvciA9IGwgPT09IDAgPyAnJyA6IHBhcmVudFswXSArICcgJzsgaSA8IGxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0b3V0W2ldID0gc2NvcGUoc2VsZWN0b3IsIG91dFtpXSwgaW52ZXJ0LCBsKS50cmltKClcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Ly8gPjIgcGFyZW50IHNlbGVjdG9ycywgbmVzdGVkXG5cdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBqID0gMCwgb3V0ID0gW107IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgbDsgKytrKSB7XG5cdFx0XHRcdFx0XHRvdXRbaisrXSA9IHNjb3BlKHBhcmVudFtrXSArICcgJywgc2VsZWN0b3JzW2ldLCBpbnZlcnQsIGwpLnRyaW0oKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRcblx0fVxuXG5cdC8qKlxuXHQgKiBTY29wZVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbnZlcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIHNjb3BlIChwYXJlbnQsIGN1cnJlbnQsIGludmVydCwgbGV2ZWwpIHtcblx0XHR2YXIgc2VsZWN0b3IgPSBjdXJyZW50XG5cdFx0dmFyIGNvZGUgPSBzZWxlY3Rvci5jaGFyQ29kZUF0KDApXG5cblx0XHQvLyB0cmltIGxlYWRpbmcgd2hpdGVzcGFjZVxuXHRcdGlmIChjb2RlIDwgMzMpIHtcblx0XHRcdGNvZGUgPSAoc2VsZWN0b3IgPSBzZWxlY3Rvci50cmltKCkpLmNoYXJDb2RlQXQoMClcblx0XHR9XG5cblx0XHRzd2l0Y2ggKGNvZGUpIHtcblx0XHRcdC8vICZcblx0XHRcdGNhc2UgQU5EOiB7XG5cdFx0XHRcdHN3aXRjaCAoY2FzY2FkZSArIGxldmVsKSB7XG5cdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdGNhc2UgMToge1xuXHRcdFx0XHRcdFx0aWYgKHBhcmVudC50cmltKCkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHRcdHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKGFuZHB0biwgJyQxJytwYXJlbnQudHJpbSgpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Ly8gOlxuXHRcdFx0Y2FzZSBDT0xPTjoge1xuXHRcdFx0XHRzd2l0Y2ggKHNlbGVjdG9yLmNoYXJDb2RlQXQoMSkpIHtcblx0XHRcdFx0XHQvLyBnIGluIDpnbG9iYWxcblx0XHRcdFx0XHRjYXNlIDEwMzoge1xuXHRcdFx0XHRcdFx0aWYgKGVzY2FwZSA+IDAgJiYgY2FzY2FkZSA+IDApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoZXNjYXBlcHRuLCAnJDEnKS5yZXBsYWNlKGFuZHB0biwgJyQxJytuc2NvcGUpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdFx0XHQvLyA6aG92ZXJcblx0XHRcdFx0XHRcdHJldHVybiBwYXJlbnQudHJpbSgpICsgc2VsZWN0b3IucmVwbGFjZShhbmRwdG4sICckMScrcGFyZW50LnRyaW0oKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0Ly8gaHRtbCAmXG5cdFx0XHRcdGlmIChpbnZlcnQqY2FzY2FkZSA+IDAgJiYgc2VsZWN0b3IuaW5kZXhPZignXFxmJykgPiAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoYW5kcHRuLCAocGFyZW50LmNoYXJDb2RlQXQoMCkgPT09IENPTE9OID8gJycgOiAnJDEnKStwYXJlbnQudHJpbSgpKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcmVudCArIHNlbGVjdG9yXG5cdH1cblxuXHQvKipcblx0ICogUHJvcGVydHlcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmaXJzdFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2Vjb25kXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aGlyZFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBwcm9wZXJ0eSAoaW5wdXQsIGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG5cdFx0dmFyIGluZGV4ID0gMFxuXHRcdHZhciBvdXQgPSBpbnB1dCArICc7J1xuXHRcdHZhciBoYXNoID0gKGZpcnN0KjIpICsgKHNlY29uZCozKSArICh0aGlyZCo0KVxuXHRcdHZhciBjYWNoZVxuXG5cdFx0Ly8gYW5pbWF0aW9uOiBhLCBuLCBpIGNoYXJhY3RlcnNcblx0XHRpZiAoaGFzaCA9PT0gOTQ0KSB7XG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uKG91dClcblx0XHR9IGVsc2UgaWYgKHByZWZpeCA9PT0gMCB8fCAocHJlZml4ID09PSAyICYmICF2ZW5kb3Iob3V0LCAxKSkpIHtcblx0XHRcdHJldHVybiBvdXRcblx0XHR9XG5cblx0XHQvLyB2ZW5kb3IgcHJlZml4XG5cdFx0c3dpdGNoIChoYXNoKSB7XG5cdFx0XHQvLyB0ZXh0LWRlY29yYXRpb24vdGV4dC1zaXplLWFkanVzdC90ZXh0LXNoYWRvdy90ZXh0LWFsaWduL3RleHQtdHJhbnNmb3JtOiB0LCBlLCB4XG5cdFx0XHRjYXNlIDEwMTU6IHtcblx0XHRcdFx0Ly8gdGV4dC1zaGFkb3cvdGV4dC1hbGlnbi90ZXh0LXRyYW5zZm9ybSwgYVxuXHRcdFx0XHRyZXR1cm4gb3V0LmNoYXJDb2RlQXQoMTApID09PSA5NyA/IHdlYmtpdCArIG91dCArIG91dCA6IG91dFxuXHRcdFx0fVxuXHRcdFx0Ly8gZmlsdGVyL2ZpbGwgZiwgaSwgbFxuXHRcdFx0Y2FzZSA5NTE6IHtcblx0XHRcdFx0Ly8gZmlsdGVyLCB0XG5cdFx0XHRcdHJldHVybiBvdXQuY2hhckNvZGVBdCgzKSA9PT0gMTE2ID8gd2Via2l0ICsgb3V0ICsgb3V0IDogb3V0XG5cdFx0XHR9XG5cdFx0XHQvLyBjb2xvci9jb2x1bW4sIGMsIG8sIGxcblx0XHRcdGNhc2UgOTYzOiB7XG5cdFx0XHRcdC8vIGNvbHVtbiwgblxuXHRcdFx0XHRyZXR1cm4gb3V0LmNoYXJDb2RlQXQoNSkgPT09IDExMCA/IHdlYmtpdCArIG91dCArIG91dCA6IG91dFxuXHRcdFx0fVxuXHRcdFx0Ly8gYm94LWRlY29yYXRpb24tYnJlYWssIGIsIG8sIHhcblx0XHRcdGNhc2UgMTAwOToge1xuXHRcdFx0XHRpZiAob3V0LmNoYXJDb2RlQXQoNCkgIT09IDEwMCkge1xuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIG1hc2ssIG0sIGEsIHNcblx0XHRcdC8vIGNsaXAtcGF0aCwgYywgbCwgaVxuXHRcdFx0Y2FzZSA5Njk6XG5cdFx0XHRjYXNlIDk0Mjoge1xuXHRcdFx0XHRyZXR1cm4gd2Via2l0ICsgb3V0ICsgb3V0XG5cdFx0XHR9XG5cdFx0XHQvLyBhcHBlYXJhbmNlOiBhLCBwLCBwXG5cdFx0XHRjYXNlIDk3ODoge1xuXHRcdFx0XHRyZXR1cm4gd2Via2l0ICsgb3V0ICsgbW96ICsgb3V0ICsgb3V0XG5cdFx0XHR9XG5cdFx0XHQvLyBoeXBoZW5zOiBoLCB5LCBwXG5cdFx0XHQvLyB1c2VyLXNlbGVjdDogdSwgcywgZVxuXHRcdFx0Y2FzZSAxMDE5OlxuXHRcdFx0Y2FzZSA5ODM6IHtcblx0XHRcdFx0cmV0dXJuIHdlYmtpdCArIG91dCArIG1veiArIG91dCArIG1zICsgb3V0ICsgb3V0XG5cdFx0XHR9XG5cdFx0XHQvLyBiYWNrZ3JvdW5kL2JhY2tmYWNlLXZpc2liaWxpdHksIGIsIGEsIGNcblx0XHRcdGNhc2UgODgzOiB7XG5cdFx0XHRcdC8vIGJhY2tmYWNlLXZpc2liaWxpdHksIC1cblx0XHRcdFx0cmV0dXJuIG91dC5jaGFyQ29kZUF0KDgpID09PSBEQVNIID8gd2Via2l0ICsgb3V0ICsgb3V0IDogb3V0XG5cdFx0XHR9XG5cdFx0XHQvLyBmbGV4OiBmLCBsLCBlXG5cdFx0XHRjYXNlIDkzMjoge1xuXHRcdFx0XHRpZiAob3V0LmNoYXJDb2RlQXQoNCkgPT09IERBU0gpIHtcblx0XHRcdFx0XHRzd2l0Y2ggKG91dC5jaGFyQ29kZUF0KDUpKSB7XG5cdFx0XHRcdFx0XHQvLyBmbGV4LWdyb3csIGdcblx0XHRcdFx0XHRcdGNhc2UgMTAzOiB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB3ZWJraXQgKyAnYm94LScgKyBvdXQucmVwbGFjZSgnLWdyb3cnLCAnJykgKyB3ZWJraXQgKyBvdXQgKyBtcyArIG91dC5yZXBsYWNlKCdncm93JywgJ3Bvc2l0aXZlJykgKyBvdXRcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGZsZXgtc2hyaW5rLCBzXG5cdFx0XHRcdFx0XHRjYXNlIDExNToge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gd2Via2l0ICsgb3V0ICsgbXMgKyBvdXQucmVwbGFjZSgnc2hyaW5rJywgJ25lZ2F0aXZlJykgKyBvdXRcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGZsZXgtYmFzaXMsIGJcblx0XHRcdFx0XHRcdGNhc2UgOTg6IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHdlYmtpdCArIG91dCArIG1zICsgb3V0LnJlcGxhY2UoJ2Jhc2lzJywgJ3ByZWZlcnJlZC1zaXplJykgKyBvdXRcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gd2Via2l0ICsgb3V0ICsgbXMgKyBvdXQgKyBvdXRcblx0XHRcdH1cblx0XHRcdC8vIG9yZGVyOiBvLCByLCBkXG5cdFx0XHRjYXNlIDk2NDoge1xuXHRcdFx0XHRyZXR1cm4gd2Via2l0ICsgb3V0ICsgbXMgKyAnZmxleCcgKyAnLScgKyBvdXQgKyBvdXRcblx0XHRcdH1cblx0XHRcdC8vIGp1c3RpZnktaXRlbXMvanVzdGlmeS1jb250ZW50LCBqLCB1LCBzXG5cdFx0XHRjYXNlIDEwMjM6IHtcblx0XHRcdFx0Ly8ganVzdGlmeS1jb250ZW50LCBjXG5cdFx0XHRcdGlmIChvdXQuY2hhckNvZGVBdCg4KSAhPT0gOTkpIHtcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FjaGUgPSBvdXQuc3Vic3RyaW5nKG91dC5pbmRleE9mKCc6JywgMTUpKS5yZXBsYWNlKCdmbGV4LScsICcnKS5yZXBsYWNlKCdzcGFjZS1iZXR3ZWVuJywgJ2p1c3RpZnknKVxuXHRcdFx0XHRyZXR1cm4gd2Via2l0ICsgJ2JveC1wYWNrJyArIGNhY2hlICsgd2Via2l0ICsgb3V0ICsgbXMgKyAnZmxleC1wYWNrJyArIGNhY2hlICsgb3V0XG5cdFx0XHR9XG5cdFx0XHQvLyBjdXJzb3IsIGMsIHUsIHJcblx0XHRcdGNhc2UgMTAwNToge1xuXHRcdFx0XHRyZXR1cm4gY3Vyc29ycHRuLnRlc3Qob3V0KSA/IG91dC5yZXBsYWNlKGNvbG9ucHRuLCAnOicgKyB3ZWJraXQpICsgb3V0LnJlcGxhY2UoY29sb25wdG4sICc6JyArIG1veikgKyBvdXQgOiBvdXRcblx0XHRcdH1cblx0XHRcdC8vIHdyaXRpbmctbW9kZSwgdywgciwgaVxuXHRcdFx0Y2FzZSAxMDAwOiB7XG5cdFx0XHRcdGNhY2hlID0gb3V0LnN1YnN0cmluZygxMykudHJpbSgpXG5cdFx0XHRcdGluZGV4ID0gY2FjaGUuaW5kZXhPZignLScpICsgMVxuXG5cdFx0XHRcdHN3aXRjaCAoY2FjaGUuY2hhckNvZGVBdCgwKStjYWNoZS5jaGFyQ29kZUF0KGluZGV4KSkge1xuXHRcdFx0XHRcdC8vIHZlcnRpY2FsLWxyXG5cdFx0XHRcdFx0Y2FzZSAyMjY6IHtcblx0XHRcdFx0XHRcdGNhY2hlID0gb3V0LnJlcGxhY2Uod3JpdGluZ3B0biwgJ3RiJylcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHZlcnRpY2FsLXJsXG5cdFx0XHRcdFx0Y2FzZSAyMzI6IHtcblx0XHRcdFx0XHRcdGNhY2hlID0gb3V0LnJlcGxhY2Uod3JpdGluZ3B0biwgJ3RiLXJsJylcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIGhvcml6b250YWwtdGJcblx0XHRcdFx0XHRjYXNlIDIyMDoge1xuXHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXQucmVwbGFjZSh3cml0aW5ncHRuLCAnbHInKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG91dFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB3ZWJraXQgKyBvdXQgKyBtcyArIGNhY2hlICsgb3V0XG5cdFx0XHR9XG5cdFx0XHQvLyBwb3NpdGlvbjogc3RpY2t5XG5cdFx0XHRjYXNlIDEwMTc6IHtcblx0XHRcdFx0aWYgKG91dC5pbmRleE9mKCdzdGlja3knLCA5KSA9PT0gLTEpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3V0XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGRpc3BsYXkoZmxleC9pbmxpbmUtZmxleC9pbmxpbmUtYm94KTogZCwgaSwgc1xuXHRcdFx0Y2FzZSA5NzU6IHtcblx0XHRcdFx0aW5kZXggPSAob3V0ID0gaW5wdXQpLmxlbmd0aCAtIDEwXG5cdFx0XHRcdGNhY2hlID0gKG91dC5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMzMgPyBvdXQuc3Vic3RyaW5nKDAsIGluZGV4KSA6IG91dCkuc3Vic3RyaW5nKGlucHV0LmluZGV4T2YoJzonLCA3KSArIDEpLnRyaW0oKVxuXG5cdFx0XHRcdHN3aXRjaCAoaGFzaCA9IGNhY2hlLmNoYXJDb2RlQXQoMCkgKyAoY2FjaGUuY2hhckNvZGVBdCg3KXwwKSkge1xuXHRcdFx0XHRcdC8vIGlubGluZS1cblx0XHRcdFx0XHRjYXNlIDIwMzoge1xuXHRcdFx0XHRcdFx0Ly8gaW5saW5lLWJveFxuXHRcdFx0XHRcdFx0aWYgKGNhY2hlLmNoYXJDb2RlQXQoOCkgPCAxMTEpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gaW5saW5lLWJveC9zdGlja3lcblx0XHRcdFx0XHRjYXNlIDExNToge1xuXHRcdFx0XHRcdFx0b3V0ID0gb3V0LnJlcGxhY2UoY2FjaGUsIHdlYmtpdCtjYWNoZSkrJzsnK291dFxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gaW5saW5lLWZsZXhcblx0XHRcdFx0XHQvLyBmbGV4XG5cdFx0XHRcdFx0Y2FzZSAyMDc6XG5cdFx0XHRcdFx0Y2FzZSAxMDI6IHtcblx0XHRcdFx0XHRcdG91dCA9IChcblx0XHRcdFx0XHRcdFx0b3V0LnJlcGxhY2UoY2FjaGUsIHdlYmtpdCsoaGFzaCA+IDEwMiA/ICdpbmxpbmUtJyA6ICcnKSsnYm94JykrJzsnK1xuXHRcdFx0XHRcdFx0XHRvdXQucmVwbGFjZShjYWNoZSwgd2Via2l0K2NhY2hlKSsnOycrXG5cdFx0XHRcdFx0XHRcdG91dC5yZXBsYWNlKGNhY2hlLCBtcytjYWNoZSsnYm94JykrJzsnK1xuXHRcdFx0XHRcdFx0XHRvdXRcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb3V0ICsgJzsnXG5cdFx0XHR9XG5cdFx0XHQvLyBhbGlnbi1pdGVtcywgYWxpZ24tY2VudGVyLCBhbGlnbi1zZWxmOiBhLCBsLCBpLCAtXG5cdFx0XHRjYXNlIDkzODoge1xuXHRcdFx0XHRpZiAob3V0LmNoYXJDb2RlQXQoNSkgPT09IERBU0gpIHtcblx0XHRcdFx0XHRzd2l0Y2ggKG91dC5jaGFyQ29kZUF0KDYpKSB7XG5cdFx0XHRcdFx0XHQvLyBhbGlnbi1pdGVtcywgaVxuXHRcdFx0XHRcdFx0Y2FzZSAxMDU6IHtcblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSBvdXQucmVwbGFjZSgnLWl0ZW1zJywgJycpXG5cdFx0XHRcdFx0XHRcdHJldHVybiB3ZWJraXQgKyBvdXQgKyB3ZWJraXQgKyAnYm94LScgKyBjYWNoZSArIG1zICsgJ2ZsZXgtJyArIGNhY2hlICsgb3V0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBhbGlnbi1zZWxmLCBzXG5cdFx0XHRcdFx0XHRjYXNlIDExNToge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gd2Via2l0ICsgb3V0ICsgbXMgKyAnZmxleC1pdGVtLScgKyBvdXQucmVwbGFjZShzZWxmcHRuLCAnJykgKyBvdXRcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGFsaWduLWNvbnRlbnRcblx0XHRcdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHdlYmtpdCArIG91dCArIG1zICsgJ2ZsZXgtbGluZS1wYWNrJyArIG91dC5yZXBsYWNlKCdhbGlnbi1jb250ZW50JywgJycpLnJlcGxhY2Uoc2VsZnB0biwgJycpICsgb3V0XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHQvLyBtaW4vbWF4XG5cdFx0XHRjYXNlIDk3Mzpcblx0XHRcdGNhc2UgOTg5OiB7XG5cdFx0XHRcdC8vIG1pbi0vbWF4LSBoZWlnaHQvd2lkdGgvYmxvY2stc2l6ZS9pbmxpbmUtc2l6ZVxuXHRcdFx0XHRpZiAob3V0LmNoYXJDb2RlQXQoMykgIT09IERBU0ggfHwgb3V0LmNoYXJDb2RlQXQoNCkgPT09IDEyMikge1xuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGhlaWdodC93aWR0aDogbWluLWNvbnRlbnQgLyB3aWR0aDogbWF4LWNvbnRlbnRcblx0XHRcdGNhc2UgOTMxOlxuXHRcdFx0Y2FzZSA5NTM6IHtcblx0XHRcdFx0aWYgKGRpbWVuc2lvbnB0bi50ZXN0KGlucHV0KSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdC8vIHN0cmV0Y2hcblx0XHRcdFx0XHRpZiAoKGNhY2hlID0gaW5wdXQuc3Vic3RyaW5nKGlucHV0LmluZGV4T2YoJzonKSArIDEpKS5jaGFyQ29kZUF0KDApID09PSAxMTUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvcGVydHkoaW5wdXQucmVwbGFjZSgnc3RyZXRjaCcsICdmaWxsLWF2YWlsYWJsZScpLCBmaXJzdCwgc2Vjb25kLCB0aGlyZCkucmVwbGFjZSgnOmZpbGwtYXZhaWxhYmxlJywgJzpzdHJldGNoJylcblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRyZXR1cm4gb3V0LnJlcGxhY2UoY2FjaGUsIHdlYmtpdCArIGNhY2hlKSArIG91dC5yZXBsYWNlKGNhY2hlLCBtb3ogKyBjYWNoZS5yZXBsYWNlKCdmaWxsLScsICcnKSkgKyBvdXRcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Ly8gdHJhbnNmb3JtLCB0cmFuc2l0aW9uOiB0LCByLCBhXG5cdFx0XHRjYXNlIDk2Mjoge1xuXHRcdFx0XHRvdXQgPSB3ZWJraXQgKyBvdXQgKyAob3V0LmNoYXJDb2RlQXQoNSkgPT09IDEwMiA/IG1zICsgb3V0IDogJycpICsgb3V0XG5cblx0XHRcdFx0Ly8gdHJhbnNpdGlvbnNcblx0XHRcdFx0aWYgKHNlY29uZCArIHRoaXJkID09PSAyMTEgJiYgb3V0LmNoYXJDb2RlQXQoMTMpID09PSAxMDUgJiYgb3V0LmluZGV4T2YoJ3RyYW5zZm9ybScsIDEwKSA+IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3V0LnN1YnN0cmluZygwLCBvdXQuaW5kZXhPZignOycsIDI3KSArIDEpLnJlcGxhY2UodHJhbnNmb3JtcHRuLCAnJDEnICsgd2Via2l0ICsgJyQyJykgKyBvdXRcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dFxuXHR9XG5cblx0LyoqXG5cdCAqIFZlbmRvclxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY29udGV4dFxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gdmVuZG9yIChjb250ZW50LCBjb250ZXh0KSB7XG5cdFx0dmFyIGluZGV4ID0gY29udGVudC5pbmRleE9mKGNvbnRleHQgPT09IDEgPyAnOicgOiAneycpXG5cdFx0dmFyIGtleSA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIGNvbnRleHQgIT09IDMgPyBpbmRleCA6IDEwKVxuXHRcdHZhciB2YWx1ZSA9IGNvbnRlbnQuc3Vic3RyaW5nKGluZGV4ICsgMSwgY29udGVudC5sZW5ndGggLSAxKVxuXG5cdFx0cmV0dXJuIHNob3VsZChjb250ZXh0ICE9PSAyID8ga2V5IDoga2V5LnJlcGxhY2UocHNldWRvZm10LCAnJDEnKSwgdmFsdWUsIGNvbnRleHQpXG5cdH1cblxuXHQvKipcblx0ICogU3VwcG9ydHNcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBncm91cFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBzdXBwb3J0cyAobWF0Y2gsIGdyb3VwKSB7XG5cdFx0dmFyIG91dCA9IHByb3BlcnR5KGdyb3VwLCBncm91cC5jaGFyQ29kZUF0KDApLCBncm91cC5jaGFyQ29kZUF0KDEpLCBncm91cC5jaGFyQ29kZUF0KDIpKVxuXG5cdFx0cmV0dXJuIG91dCAhPT0gZ3JvdXArJzsnID8gb3V0LnJlcGxhY2UocHJvcGVydHlwdG4sICcgb3IgKCQxKScpLnN1YnN0cmluZyg0KSA6ICcoJytncm91cCsnKSdcblx0fVxuXG5cdC8qKlxuXHQgKiBBbmltYXRpb25cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIGFuaW1hdGlvbiAoaW5wdXQpIHtcblx0XHR2YXIgbGVuZ3RoID0gaW5wdXQubGVuZ3RoXG5cdFx0dmFyIGluZGV4ID0gaW5wdXQuaW5kZXhPZignOicsIDkpICsgMVxuXHRcdHZhciBkZWNsYXJlID0gaW5wdXQuc3Vic3RyaW5nKDAsIGluZGV4KS50cmltKClcblx0XHR2YXIgb3V0ID0gaW5wdXQuc3Vic3RyaW5nKGluZGV4LCBsZW5ndGgtMSkudHJpbSgpXG5cblx0XHRzd2l0Y2ggKGlucHV0LmNoYXJDb2RlQXQoOSkqa2V5ZWQpIHtcblx0XHRcdGNhc2UgMDoge1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Ly8gYW5pbWF0aW9uLSosIC1cblx0XHRcdGNhc2UgREFTSDoge1xuXHRcdFx0XHQvLyBhbmltYXRpb24tbmFtZSwgblxuXHRcdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdCgxMCkgIT09IDExMCkge1xuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGFuaW1hdGlvbi9hbmltYXRpb24tbmFtZVxuXHRcdFx0ZGVmYXVsdDoge1xuXHRcdFx0XHQvLyBzcGxpdCBpbiBjYXNlIG9mIG11bHRpcGxlIGFuaW1hdGlvbnNcblx0XHRcdFx0dmFyIGxpc3QgPSBvdXQuc3BsaXQoKG91dCA9ICcnLCBhbmltYXRpb25wdG4pKVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBpbmRleCA9IDAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpbmRleCA9IDAsICsraSkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IGxpc3RbaV1cblx0XHRcdFx0XHR2YXIgaXRlbXMgPSB2YWx1ZS5zcGxpdChwcm9wZXJ0aWVzcHRuKVxuXG5cdFx0XHRcdFx0d2hpbGUgKHZhbHVlID0gaXRlbXNbaW5kZXhdKSB7XG5cdFx0XHRcdFx0XHR2YXIgcGVhayA9IHZhbHVlLmNoYXJDb2RlQXQoMClcblxuXHRcdFx0XHRcdFx0aWYgKGtleWVkID09PSAxICYmIChcblx0XHRcdFx0XHRcdFx0Ly8gbGV0dGVyc1xuXHRcdFx0XHRcdFx0XHQocGVhayA+IEFUICYmIHBlYWsgPCA5MCkgfHwgKHBlYWsgPiA5NiAmJiBwZWFrIDwgMTIzKSB8fCBwZWFrID09PSBVTkRFUlNDT1JFIHx8XG5cdFx0XHRcdFx0XHRcdC8vIGRhc2ggYnV0IG5vdCBpbiBzZXF1ZW5jZSBpLmUgLS1cblx0XHRcdFx0XHRcdFx0KHBlYWsgPT09IERBU0ggJiYgdmFsdWUuY2hhckNvZGVBdCgxKSAhPT0gREFTSClcblx0XHRcdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRcdFx0Ly8gbm90IGEgbnVtYmVyL2Z1bmN0aW9uXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpICsgKHZhbHVlLmluZGV4T2YoJygnKSAhPT0gLTEpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAxOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIG5vdCBhIHZhbGlkIHJlc2VydmVkIGtleXdvcmRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnaW5maW5pdGUnOiBjYXNlICdhbHRlcm5hdGUnOiBjYXNlICdiYWNrd2FyZHMnOiBjYXNlICdydW5uaW5nJzpcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnbm9ybWFsJzogY2FzZSAnZm9yd2FyZHMnOiBjYXNlICdib3RoJzogY2FzZSAnbm9uZSc6IGNhc2UgJ2xpbmVhcic6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2Vhc2UnOiBjYXNlICdlYXNlLWluJzogY2FzZSAnZWFzZS1vdXQnOiBjYXNlICdlYXNlLWluLW91dCc6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3BhdXNlZCc6IGNhc2UgJ3JldmVyc2UnOiBjYXNlICdhbHRlcm5hdGUtcmV2ZXJzZSc6IGNhc2UgJ2luaGVyaXQnOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdpbml0aWFsJzogY2FzZSAndW5zZXQnOiBjYXNlICdzdGVwLXN0YXJ0JzogY2FzZSAnc3RlcC1lbmQnOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUgKz0ga2V5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aXRlbXNbaW5kZXgrK10gPSB2YWx1ZVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dCArPSAoaSA9PT0gMCA/ICcnIDogJywnKSArIGl0ZW1zLmpvaW4oJyAnKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b3V0ID0gZGVjbGFyZSArIG91dCArICc7J1xuXG5cdFx0aWYgKHByZWZpeCA9PT0gMSB8fCAocHJlZml4ID09PSAyICYmIHZlbmRvcihvdXQsIDEpKSlcblx0XHRcdHJldHVybiB3ZWJraXQgKyBvdXQgKyBvdXRcblxuXHRcdHJldHVybiBvdXRcblx0fVxuXG5cdC8qKlxuXHQgKiBJc29sYXRlXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gY3VycmVudFxuXHQgKi9cblx0ZnVuY3Rpb24gaXNvbGF0ZSAoY3VycmVudCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBjdXJyZW50Lmxlbmd0aCwgc2VsZWN0b3IgPSBBcnJheShsZW5ndGgpLCBwYWRkaW5nLCBlbGVtZW50OyBpIDwgbGVuZ3RoOyArK2kpIHtcblx0XHRcdC8vIHNwbGl0IGluZGl2aWR1YWwgZWxlbWVudHMgaW4gYSBzZWxlY3RvciBpLmUgaDEgaDIgPT09IFtoMSwgaDJdXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBjdXJyZW50W2ldLnNwbGl0KGVsZW1lbnRwdG4pXG5cdFx0XHR2YXIgb3V0ID0gJydcblxuXHRcdFx0Zm9yICh2YXIgaiA9IDAsIHNpemUgPSAwLCB0YWlsID0gMCwgY29kZSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGogPCBsOyArK2opIHtcblx0XHRcdFx0Ly8gZW1wdHkgZWxlbWVudFxuXHRcdFx0XHRpZiAoKHNpemUgPSAoZWxlbWVudCA9IGVsZW1lbnRzW2pdKS5sZW5ndGgpID09PSAwICYmIGwgPiAxKSB7XG5cdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhaWwgPSBvdXQuY2hhckNvZGVBdChvdXQubGVuZ3RoLTEpXG5cdFx0XHRcdGNvZGUgPSBlbGVtZW50LmNoYXJDb2RlQXQoMClcblx0XHRcdFx0cGFkZGluZyA9ICcnXG5cblx0XHRcdFx0aWYgKGogIT09IDApIHtcblx0XHRcdFx0XHQvLyBkZXRlcm1pbmUgaWYgd2UgbmVlZCBwYWRkaW5nXG5cdFx0XHRcdFx0c3dpdGNoICh0YWlsKSB7XG5cdFx0XHRcdFx0XHRjYXNlIFNUQVI6XG5cdFx0XHRcdFx0XHRjYXNlIFRJTERFOlxuXHRcdFx0XHRcdFx0Y2FzZSBHUkVBVEVSVEhBTjpcblx0XHRcdFx0XHRcdGNhc2UgUExVUzpcblx0XHRcdFx0XHRcdGNhc2UgU1BBQ0U6XG5cdFx0XHRcdFx0XHRjYXNlIE9QRU5QQVJFTlRIRVNFUzogIHtcblx0XHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHRcdFx0cGFkZGluZyA9ICcgJ1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN3aXRjaCAoY29kZSkge1xuXHRcdFx0XHRcdGNhc2UgQU5EOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50ID0gcGFkZGluZyArIG5zY29wZWFsdFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXNlIFRJTERFOlxuXHRcdFx0XHRcdGNhc2UgR1JFQVRFUlRIQU46XG5cdFx0XHRcdFx0Y2FzZSBQTFVTOlxuXHRcdFx0XHRcdGNhc2UgU1BBQ0U6XG5cdFx0XHRcdFx0Y2FzZSBDTE9TRVBBUkVOVEhFU0VTOlxuXHRcdFx0XHRcdGNhc2UgT1BFTlBBUkVOVEhFU0VTOiB7XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXNlIE9QRU5CUkFDS0VUOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50ID0gcGFkZGluZyArIGVsZW1lbnQgKyBuc2NvcGVhbHRcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhc2UgQ09MT046IHtcblx0XHRcdFx0XHRcdHN3aXRjaCAoZWxlbWVudC5jaGFyQ29kZUF0KDEpKjIgKyBlbGVtZW50LmNoYXJDb2RlQXQoMikqMykge1xuXHRcdFx0XHRcdFx0XHQvLyA6Z2xvYmFsXG5cdFx0XHRcdFx0XHRcdGNhc2UgNTMwOiB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVzY2FwZSA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQgPSBwYWRkaW5nICsgZWxlbWVudC5zdWJzdHJpbmcoOCwgc2l6ZSAtIDEpXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyA6aG92ZXIsIDpudGgtY2hpbGQoKSwgLi4uXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaiA8IDEgfHwgZWxlbWVudHNbai0xXS5sZW5ndGggPCAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50ID0gcGFkZGluZyArIG5zY29wZWFsdCArIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhc2UgQ09NTUE6IHtcblx0XHRcdFx0XHRcdHBhZGRpbmcgPSAnJ1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdFx0XHRpZiAoc2l6ZSA+IDEgJiYgZWxlbWVudC5pbmRleE9mKCc6JykgPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQgPSBwYWRkaW5nICsgZWxlbWVudC5yZXBsYWNlKHBzZXVkb3B0biwgJyQxJyArIG5zY29wZWFsdCArICckMicpXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50ID0gcGFkZGluZyArIGVsZW1lbnQgKyBuc2NvcGVhbHRcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvdXQgKz0gZWxlbWVudFxuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvcltpXSA9IG91dC5yZXBsYWNlKGZvcm1hdHB0biwgJycpLnRyaW0oKVxuXHRcdH1cblxuXHRcdHJldHVybiBzZWxlY3RvclxuXHR9XG5cblx0LyoqXG5cdCAqIFByb3h5XG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb250ZXh0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG5cdCAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc2VsZWN0b3JzXG5cdCAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcGFyZW50c1xuXHQgKiBAcGFyYW0ge251bWJlcn0gbGluZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGlkXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aFxuXHQgKiBAcGFyYW0ge251bWJlcn0gYXRcblx0ICogQHJldHVybiB7KHN0cmluZ3x2b2lkfCopfVxuXHQgKi9cblx0ZnVuY3Rpb24gcHJveHkgKGNvbnRleHQsIGNvbnRlbnQsIHNlbGVjdG9ycywgcGFyZW50cywgbGluZSwgY29sdW1uLCBsZW5ndGgsIGlkLCBkZXB0aCwgYXQpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgb3V0ID0gY29udGVudCwgbmV4dDsgaSA8IHBsdWdnZWQ7ICsraSkge1xuXHRcdFx0c3dpdGNoIChuZXh0ID0gcGx1Z2luc1tpXS5jYWxsKHN0eWxpcywgY29udGV4dCwgb3V0LCBzZWxlY3RvcnMsIHBhcmVudHMsIGxpbmUsIGNvbHVtbiwgbGVuZ3RoLCBpZCwgZGVwdGgsIGF0KSkge1xuXHRcdFx0XHRjYXNlIHZvaWQgMDpcblx0XHRcdFx0Y2FzZSBmYWxzZTpcblx0XHRcdFx0Y2FzZSB0cnVlOlxuXHRcdFx0XHRjYXNlIG51bGw6IHtcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZmF1bHQ6IHtcblx0XHRcdFx0XHRvdXQgPSBuZXh0XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzd2l0Y2ggKG91dCkge1xuXHRcdFx0Y2FzZSB2b2lkIDA6XG5cdFx0XHRjYXNlIGZhbHNlOlxuXHRcdFx0Y2FzZSB0cnVlOlxuXHRcdFx0Y2FzZSBudWxsOlxuXHRcdFx0Y2FzZSBjb250ZW50OiB7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdHJldHVybiBvdXRcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTWluaWZ5XG5cdCAqXG5cdCAqIEBwYXJhbSB7KHN0cmluZ3wqKX0gb3V0cHV0XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIG1pbmlmeSAob3V0cHV0KSB7XG5cdFx0cmV0dXJuIG91dHB1dFxuXHRcdFx0LnJlcGxhY2UoZm9ybWF0cHRuLCAnJylcblx0XHRcdC5yZXBsYWNlKGJlZm9yZXB0biwgJycpXG5cdFx0XHQucmVwbGFjZShhZnRlcnB0biwgJyQxJylcblx0XHRcdC5yZXBsYWNlKHRhaWxwdG4sICckMScpXG5cdFx0XHQucmVwbGFjZSh3aGl0ZXB0biwgJyAnKVxuXHR9XG5cblx0LyoqXG5cdCAqIFVzZVxuXHQgKlxuXHQgKiBAcGFyYW0geyhBcnJheTxmdW5jdGlvbiguLi4/KT58ZnVuY3Rpb24oLi4uPyl8bnVtYmVyfHZvaWQpP30gcGx1Z2luXG5cdCAqL1xuXHRmdW5jdGlvbiB1c2UgKHBsdWdpbikge1xuXHRcdHN3aXRjaCAocGx1Z2luKSB7XG5cdFx0XHRjYXNlIHZvaWQgMDpcblx0XHRcdGNhc2UgbnVsbDoge1xuXHRcdFx0XHRwbHVnZ2VkID0gcGx1Z2lucy5sZW5ndGggPSAwXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0XHRkZWZhdWx0OiB7XG5cdFx0XHRcdHN3aXRjaCAocGx1Z2luLmNvbnN0cnVjdG9yKSB7XG5cdFx0XHRcdFx0Y2FzZSBBcnJheToge1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHBsdWdpbi5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdFx0XHR1c2UocGx1Z2luW2ldKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FzZSBGdW5jdGlvbjoge1xuXHRcdFx0XHRcdFx0cGx1Z2luc1twbHVnZ2VkKytdID0gcGx1Z2luXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXNlIEJvb2xlYW46IHtcblx0XHRcdFx0XHRcdHVua3duID0gISFwbHVnaW58MFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0cmV0dXJuIHVzZVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldFxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IG9wdGlvbnNcblx0ICovXG5cdGZ1bmN0aW9uIHNldCAob3B0aW9ucykge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucykge1xuXHRcdFx0dmFyIHZhbHVlID0gb3B0aW9uc1tuYW1lXVxuXHRcdFx0c3dpdGNoIChuYW1lKSB7XG5cdFx0XHRcdGNhc2UgJ2tleWZyYW1lJzoga2V5ZWQgPSB2YWx1ZXwwOyBicmVha1xuXHRcdFx0XHRjYXNlICdnbG9iYWwnOiBlc2NhcGUgPSB2YWx1ZXwwOyBicmVha1xuXHRcdFx0XHRjYXNlICdjYXNjYWRlJzogY2FzY2FkZSA9IHZhbHVlfDA7IGJyZWFrXG5cdFx0XHRcdGNhc2UgJ2NvbXByZXNzJzogY29tcHJlc3MgPSB2YWx1ZXwwOyBicmVha1xuXHRcdFx0XHRjYXNlICdzZW1pY29sb24nOiBzZW1pY29sb24gPSB2YWx1ZXwwOyBicmVha1xuXHRcdFx0XHRjYXNlICdwcmVzZXJ2ZSc6IHByZXNlcnZlID0gdmFsdWV8MDsgYnJlYWtcblx0XHRcdFx0Y2FzZSAncHJlZml4Jzpcblx0XHRcdFx0XHRzaG91bGQgPSBudWxsXG5cblx0XHRcdFx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXggPSAwXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdHByZWZpeCA9IDFcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHJlZml4ID0gMlxuXHRcdFx0XHRcdFx0c2hvdWxkID0gdmFsdWVcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNldFxuXHR9XG5cblx0LyoqXG5cdCAqIFN0eWxpc1xuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3Jcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRmdW5jdGlvbiBzdHlsaXMgKHNlbGVjdG9yLCBpbnB1dCkge1xuXHRcdGlmICh0aGlzICE9PSB2b2lkIDAgJiYgdGhpcy5jb25zdHJ1Y3RvciA9PT0gc3R5bGlzKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeShzZWxlY3Rvcilcblx0XHR9XG5cblx0XHQvLyBzZXR1cFxuXHRcdHZhciBucyA9IHNlbGVjdG9yXG5cdFx0dmFyIGNvZGUgPSBucy5jaGFyQ29kZUF0KDApXG5cblx0XHQvLyB0cmltIGxlYWRpbmcgd2hpdGVzcGFjZVxuXHRcdGlmIChjb2RlIDwgMzMpIHtcblx0XHRcdGNvZGUgPSAobnMgPSBucy50cmltKCkpLmNoYXJDb2RlQXQoMClcblx0XHR9XG5cblx0XHQvLyBrZXlmcmFtZS9hbmltYXRpb24gbmFtZXNwYWNlXG5cdFx0aWYgKGtleWVkID4gMCkge1xuXHRcdFx0a2V5ID0gbnMucmVwbGFjZShpbnZhbGlkcHRuLCBjb2RlID09PSBPUEVOQlJBQ0tFVCA/ICcnIDogJy0nKVxuXHRcdH1cblxuXHRcdC8vIHJlc2V0LCB1c2VkIHRvIGFzc2VydCBpZiBhIHBsdWdpbiBpcyBtb25la3ktcGF0Y2hpbmcgdGhlIHJldHVybiB2YWx1ZVxuXHRcdGNvZGUgPSAxXG5cblx0XHQvLyBjYXNjYWRlL2lzb2xhdGVcblx0XHRpZiAoY2FzY2FkZSA9PT0gMSkge1xuXHRcdFx0bnNjb3BlID0gbnNcblx0XHR9IGVsc2Uge1xuXHRcdFx0bnNjb3BlYWx0ID0gbnNcblx0XHR9XG5cblx0XHR2YXIgc2VsZWN0b3JzID0gW25zY29wZV1cblx0XHR2YXIgcmVzdWx0XG5cblx0XHQvLyBleGVjdXRlIHBsdWdpbnMsIHByZS1wcm9jZXNzIGNvbnRleHRcblx0XHRpZiAocGx1Z2dlZCA+IDApIHtcblx0XHRcdHJlc3VsdCA9IHByb3h5KFBSRVBTLCBpbnB1dCwgc2VsZWN0b3JzLCBzZWxlY3RvcnMsIGxpbmUsIGNvbHVtbiwgMCwgMCwgMCwgMClcblxuXHRcdFx0aWYgKHJlc3VsdCAhPT0gdm9pZCAwICYmIHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlucHV0ID0gcmVzdWx0XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gYnVpbGRcblx0XHR2YXIgb3V0cHV0ID0gY29tcGlsZShhcnJheSwgc2VsZWN0b3JzLCBpbnB1dCwgMCwgMClcblxuXHRcdC8vIGV4ZWN1dGUgcGx1Z2lucywgcG9zdC1wcm9jZXNzIGNvbnRleHRcblx0XHRpZiAocGx1Z2dlZCA+IDApIHtcblx0XHRcdHJlc3VsdCA9IHByb3h5KFBPU1RTLCBvdXRwdXQsIHNlbGVjdG9ycywgc2VsZWN0b3JzLCBsaW5lLCBjb2x1bW4sIG91dHB1dC5sZW5ndGgsIDAsIDAsIDApXG5cblx0XHRcdC8vIGJ5cGFzcyBtaW5pZmljYXRpb25cblx0XHRcdGlmIChyZXN1bHQgIT09IHZvaWQgMCAmJiB0eXBlb2Yob3V0cHV0ID0gcmVzdWx0KSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Y29kZSA9IDBcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZXNldFxuXHRcdGtleSA9ICcnXG5cdFx0bnNjb3BlID0gJydcblx0XHRuc2NvcGVhbHQgPSAnJ1xuXHRcdHBhdHRlcm4gPSAwXG5cdFx0bGluZSA9IDFcblx0XHRjb2x1bW4gPSAxXG5cblx0XHRyZXR1cm4gY29tcHJlc3MqY29kZSA9PT0gMCA/IG91dHB1dCA6IG1pbmlmeShvdXRwdXQpXG5cdH1cblxuXHRzdHlsaXNbJ3VzZSddID0gdXNlXG5cdHN0eWxpc1snc2V0J10gPSBzZXRcblxuXHRpZiAob3B0aW9ucyAhPT0gdm9pZCAwKSB7XG5cdFx0c2V0KG9wdGlvbnMpXG5cdH1cblxuXHRyZXR1cm4gc3R5bGlzXG59KSk7XG4iLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXHJcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuIiwiKGZ1bmN0aW9uKHNlbGYpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmIChzZWxmLmZldGNoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3VwcG9ydCA9IHtcbiAgICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIHNlbGYsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIHNlbGYgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjogJ0ZpbGVSZWFkZXInIGluIHNlbGYgJiYgJ0Jsb2InIGluIHNlbGYgJiYgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gICAgZm9ybURhdGE6ICdGb3JtRGF0YScgaW4gc2VsZixcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBzZWxmXG4gIH1cblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF1cblxuICAgIHZhciBpc0RhdGFWaWV3ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXcgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLlxcXl9gfH5dL2kudGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWUnKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpXG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVyYXRvclxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fVxuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgICB9LCB0aGlzKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUrJywnK3ZhbHVlIDogdmFsdWVcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdXG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSkgfSlcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkgeyBpdGVtcy5wdXNoKHZhbHVlKSB9KVxuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXVxuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pIH0pXG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgICB9XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEJvZHkoKSB7XG4gICAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgQm9keUluaXQgdHlwZScpXG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKVxuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBjb25zdW1lZCh0aGlzKSB8fCBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2RcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dClcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdvbWl0J1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KVxuICB9XG5cbiAgUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywgeyBib2R5OiB0aGlzLl9ib2R5SW5pdCB9KVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAgIHJhd0hlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKClcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fVxuICAgIH1cblxuICAgIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICAgIHRoaXMuc3RhdHVzID0gJ3N0YXR1cycgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzIDogMjAwXG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICAgIHRoaXMuc3RhdHVzVGV4dCA9ICdzdGF0dXNUZXh0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogJ09LJ1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gICAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH1cblxuICBSZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfVxuXG4gIHZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH1cblxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzXG4gIHNlbGYuUmVxdWVzdCA9IFJlcXVlc3RcbiAgc2VsZi5SZXNwb25zZSA9IFJlc3BvbnNlXG5cbiAgc2VsZi5mZXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH1cblxuICAgICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIHJlcXVlc3QudXJsLCB0cnVlKVxuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIgJiYgc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICAgIH0pXG4gIH1cbiAgc2VsZi5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzKTtcbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFNsYWNrSWNvbiBmcm9tICcuL3NsYWNrLWljb24nO1xuaW1wb3J0IHtcbiAgU2xhY2tGZWVkYmFjayBhcyBTdHlsZWRTbGFja0ZlZWRiYWNrLFxuICBMb2FkZXIsXG4gIENvbnRhaW5lcixcbiAgSGVhZGVyLFxuICBDb250ZW50LFxuICBUcmlnZ2VyLFxuICBUYWJzLFxuICBMYWJlbCxcbiAgQ2hlY2tib3gsXG4gIENoZWNrYm94TGFiZWwsXG4gIEltYWdlVXBsb2FkLFxuICBJbWFnZVByZXZpZXcsXG4gIFByZXZpZXdPdmVybGF5LFxuICBVcGxvYWRCdXR0b24sXG4gIFN1Ym1pdEJ1dHRvbixcbiAgRm9ybUVsZW1lbnRcbn0gZnJvbSAnLi9zdHlsZXMnO1xuXG5jb25zdCBJbnB1dCA9IEZvcm1FbGVtZW50LndpdGhDb21wb25lbnQoJ2lucHV0Jyk7XG5jb25zdCBUZXh0YXJlYSA9IEZvcm1FbGVtZW50LndpdGhDb21wb25lbnQoJ3RleHRhcmVhJyk7XG5cbmNvbnN0IHR5cGVzID0gW1xuICB7IHZhbHVlOiAnYnVnJywgbGFiZWw6ICdCdWcnIH0sXG4gIHsgdmFsdWU6ICdpbXByb3ZlbWVudCcsIGxhYmVsOiAnSW1wcm92ZW1lbnQnIH0sXG4gIHsgdmFsdWU6ICdmZWF0dXJlJywgbGFiZWw6ICdGZWF0dXJlIFJlcXVlc3QnIH1cbl07XG5cbmNsYXNzIFNsYWNrRmVlZGJhY2sgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgc2VuZFVSTDogdHJ1ZSxcbiAgICAgIHNlbnQ6IGZhbHNlLFxuICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgdXBsb2FkaW5nSW1hZ2U6IGZhbHNlLFxuICAgICAgc2VsZWN0ZWRUeXBlOiAnQnVnJyxcbiAgICAgIGltYWdlOiB7fVxuICAgIH07XG4gIH1cblxuICB0b2dnbGUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgYWN0aXZhdGUgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoeyBhY3RpdmUgfSkgPT4gKHtcbiAgICAgIGFjdGl2ZTogIWFjdGl2ZVxuICAgIH0pKTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja091dHNpZGUpO1xuICB9O1xuXG4gIGhhbmRsZUNsaWNrT3V0c2lkZSA9IGV2ZW50ID0+IHtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgaWYgKCF0aGlzLlNsYWNrRmVlZGJhY2suY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICBjbG9zZSA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFjdGl2ZTogZmFsc2VcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja091dHNpZGUpO1xuICB9O1xuXG4gIHRvZ2dsZVNlbmRVUkwgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSgoeyBzZW5kVVJMIH0pID0+ICh7XG4gICAgICBzZW5kVVJMOiAhc2VuZFVSTFxuICAgIH0pKTtcbiAgfTtcblxuICBzZWxlY3RUeXBlID0gdHlwZSA9PiAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzZWxlY3RlZFR5cGU6IHR5cGVcbiAgICB9KTtcbiAgfTtcblxuICBzZW50ID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICB7XG4gICAgICAgIHNlbmRpbmc6IGZhbHNlLFxuICAgICAgICBzZW50OiB0cnVlLFxuICAgICAgICBpbWFnZToge30sXG4gICAgICAgIGVycm9yOiBmYWxzZVxuICAgICAgfSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgdGhpcy5tZXNzYWdlLnZhbHVlID0gJyc7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfSwgdGhpcy5wcm9wcy5zZW50VGltZW91dCk7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICBlcnJvciA9IGVyciA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgc2VuZGluZzogZmFsc2UsXG4gICAgICAgIGVycm9yOiB0aGlzLmRldGVybWluZUVycm9yVHlwZShlcnIpXG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgIH0sIHRoaXMucHJvcHMuZXJyb3JUaW1lb3V0KTtcbiAgICAgIH1cbiAgICApO1xuICB9O1xuXG4gIGRldGVybWluZUVycm9yVHlwZSA9IGVyciA9PiB7XG4gICAgaWYgKCFlcnIpIHJldHVybiAnVW5leHBlY3RlZCBFcnJvciEnO1xuICAgIGlmICh0eXBlb2YgZXJyID09PSAnc3RyaW5nJykgcmV0dXJuIGVycjtcblxuICAgIHN3aXRjaCAoZXJyLnN0YXR1cykge1xuICAgICAgY2FzZSA0MDA6XG4gICAgICAgIHJldHVybiAnQmFkIFJlcXVlc3QhJztcbiAgICAgIGNhc2UgNDAzOlxuICAgICAgICByZXR1cm4gJ0ZvcmJpZGRlbiEnO1xuICAgICAgY2FzZSA0MDQ6XG4gICAgICAgIHJldHVybiAnQ2hhbm5lbCBOb3QgRm91bmQhJztcbiAgICAgIGNhc2UgNDEwOlxuICAgICAgICByZXR1cm4gJ0NoYW5uZWwgaXMgQXJjaGl2ZWQhJztcbiAgICAgIGNhc2UgNTAwOlxuICAgICAgICByZXR1cm4gJ1NlcnZlciBFcnJvciEnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdVbmV4cGVjdGVkIEVycm9yISc7XG4gICAgfVxuICB9O1xuXG4gIHNlbmQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3RlZFR5cGUsIHNlbmRVUkwsIGltYWdlIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlLnZhbHVlO1xuICAgIGxldCBsZXZlbDtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2VuZGluZzogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLy8gQXR0YWNoIHRoZSBjdXJlbnQgVVJMXG4gICAgaWYgKHNlbmRVUkwpIG1lc3NhZ2UgKz0gYFxcbiA8JHtkb2N1bWVudC5sb2NhdGlvbi5ocmVmfT5gO1xuXG4gICAgLy8gU2xhY2sgYWNjZXB0cyAzIGNvbG9yIGxldmVsczogZGFuZ2VyIChyZWQpLCBnb29kIChncmVlbikgYW5kIHdhcm5pbmcgKG9yYW5nZSlcbiAgICBzd2l0Y2ggKHNlbGVjdGVkVHlwZSkge1xuICAgICAgY2FzZSAnQnVnJzpcbiAgICAgICAgbGV2ZWwgPSAnZGFuZ2VyJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgbGV2ZWwgPSAnZ29vZCc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSW1wcm92ZW1lbnQnOlxuICAgICAgICBsZXZlbCA9ICd3YXJuaW5nJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZXZlbCA9ICd3YXJuaW5nJztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIGNoYW5uZWw6IHRoaXMucHJvcHMuY2hhbm5lbCxcbiAgICAgIHVzZXJuYW1lOiB0aGlzLnByb3BzLnVzZXIsXG4gICAgICBpY29uX2Vtb2ppOiB0aGlzLnByb3BzLmVtb2ppLFxuICAgICAgYXR0YWNobWVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGZhbGxiYWNrOiBgRmVlZGJhY2sgKCR7c2VsZWN0ZWRUeXBlfSlgLFxuICAgICAgICAgIGF1dGhvcl9uYW1lOiB0aGlzLnByb3BzLnVzZXIsXG4gICAgICAgICAgY29sb3I6IGxldmVsLFxuICAgICAgICAgIHRpdGxlOiBzZWxlY3RlZFR5cGUsXG4gICAgICAgICAgdGl0bGVfbGluazogZG9jdW1lbnQubG9jYXRpb24uaHJlZixcbiAgICAgICAgICB0ZXh0OiBtZXNzYWdlLFxuICAgICAgICAgIGZvb3RlcjogJ1JlYWN0IFNsYWNrIEZlZWRiYWNrJ1xuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcblxuICAgIC8vIEF0dGFjaCB0aGUgaW1hZ2UgKGlmIGF2YWlsYWJsZSlcbiAgICBpZiAoaW1hZ2UudXJsKSBwYXlsb2FkLmF0dGFjaG1lbnRzWzBdLmltYWdlX3VybCA9IGltYWdlLnVybDtcblxuICAgIC8vIFN1Ym1pdCB0aGUgcGF5bG9hZFxuICAgIHRoaXMucHJvcHMub25TdWJtaXQuY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgfTtcblxuICBhdHRhY2hJbWFnZSA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCB7IGZpbGVzIH0gPSBldmVudC50YXJnZXQ7XG5cbiAgICBjb25zdCBmaWxlID0gZmlsZXNbMF07XG4gICAgZmlsZS5wcmV2aWV3ID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG5cbiAgICB0aGlzLnNldFN0YXRlKFxuICAgICAge1xuICAgICAgICBpbWFnZTogZmlsZSxcbiAgICAgICAgdXBsb2FkaW5nSW1hZ2U6IHRydWVcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMub25JbWFnZVVwbG9hZC5jYWxsKHRoaXMsIGZpbGUpO1xuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgdXBsb2FkRXJyb3IgPSBlcnIgPT4ge1xuICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnRXJyb3IgdXBsb2FkaW5nIGltYWdlISc7XG5cbiAgICBpZiAoZXJyICYmIHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBlcnI7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgIHtcbiAgICAgICAgdXBsb2FkaW5nSW1hZ2U6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlXG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUltYWdlKCk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9LCB0aGlzLnByb3BzLmVycm9yVGltZW91dCk7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICBpbWFnZVVwbG9hZGVkID0gdXJsID0+IHtcbiAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdbU2xhY2tGZWVkYmFja10gYHVybGAgYXJndW1lbnQgaW4gYGltYWdlVXBsb2FkZWRgIG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKTtcbiAgICAgIHRoaXMucmVtb3ZlSW1hZ2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNZXJnZSB0aGUgaW1hZ2UgVVJMIHdpdGggdGhlIGZpbGUgb2JqZWN0LFxuICAgIC8vIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgY29udGFpbiBvbmx5IHRoZSBwcmV2aWV3IGFuZCB0aGUgVVJMLlxuICAgIC8vIEFueSBmaWxlIGluZm9ybWF0aW9uIHdpbGwgYmUgbG9zdFxuICAgIHRoaXMuc2V0U3RhdGUoKHsgaW1hZ2UgfSkgPT4gKHtcbiAgICAgIHVwbG9hZGluZ0ltYWdlOiBmYWxzZSxcbiAgICAgIGltYWdlOiB7XG4gICAgICAgIC4uLmltYWdlLFxuICAgICAgICB1cmxcbiAgICAgIH1cbiAgICB9KSk7XG4gIH07XG5cbiAgcmVuZGVySW1hZ2VVcGxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaW1hZ2UucHJldmlldykge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW1hZ2VQcmV2aWV3KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxJbWFnZVVwbG9hZD5cbiAgICAgICAgPFVwbG9hZEJ1dHRvbiBmb3I9XCJpbWFnZVVwbG9hZFwiPlxuICAgICAgICAgIHt0aGlzLnByb3BzLmltYWdlVXBsb2FkVGV4dH1cbiAgICAgICAgPC9VcGxvYWRCdXR0b24+XG5cbiAgICAgICAgPElucHV0XG4gICAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICAgIGFjY2VwdD1cImltYWdlLypcIlxuICAgICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdub25lJyB9fVxuICAgICAgICAgIG9uQ2hhbmdlPXtldmVudCA9PiB0aGlzLmF0dGFjaEltYWdlKGV2ZW50KX1cbiAgICAgICAgLz5cbiAgICAgIDwvSW1hZ2VVcGxvYWQ+XG4gICAgKTtcbiAgfTtcblxuICByZW1vdmVJbWFnZSA9IGV2ZW50ID0+IHtcbiAgICBpZiAoZXZlbnQpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGltYWdlOiB7fSxcbiAgICAgIHVwbG9hZGluZ0ltYWdlOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuXG4gIHJlbmRlckltYWdlUHJldmlldyA9ICgpID0+IHtcbiAgICBjb25zdCB7IGltYWdlLCB1cGxvYWRpbmdJbWFnZSB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmICghaW1hZ2UucHJldmlldykgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEltYWdlUHJldmlld1xuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke2ltYWdlLnByZXZpZXd9KWBcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge3VwbG9hZGluZ0ltYWdlID8gKFxuICAgICAgICAgIDxMb2FkZXIgLz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8UHJldmlld092ZXJsYXk+XG4gICAgICAgICAgICA8c3BhbiBvbkNsaWNrPXt0aGlzLnJlbW92ZUltYWdlfT5SZW1vdmU8L3NwYW4+XG4gICAgICAgICAgPC9QcmV2aWV3T3ZlcmxheT5cbiAgICAgICAgKX1cbiAgICAgIDwvSW1hZ2VQcmV2aWV3PlxuICAgICk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIHNlbmRpbmcsXG4gICAgICBzZW50LFxuICAgICAgZXJyb3IsXG4gICAgICBzZW5kVVJMLFxuICAgICAgc2VsZWN0ZWRUeXBlLFxuICAgICAgdXBsb2FkaW5nSW1hZ2VcbiAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8vIERvIG5vdCBzaG93IGNoYW5uZWwgVUkgaWYgbm8gY2hhbm5lbCBkZWZpbmVkXG4gICAgY29uc3Qgc2hvd0NoYW5uZWwgPSBCb29sZWFuKHRoaXMucHJvcHMuY2hhbm5lbCkgJiYgdGhpcy5wcm9wcy5zaG93Q2hhbm5lbDtcblxuICAgIGxldCBzdWJtaXRUZXh0ID0gJ1NlbmQgRmVlZGJhY2snO1xuXG4gICAgaWYgKHNlbnQpIHN1Ym1pdFRleHQgPSAnU2VudCEnO1xuICAgIGlmIChzZW5kaW5nICYmICFzZW50KSBzdWJtaXRUZXh0ID0gJ1NlbmRpbmcgRmVlZGJhY2suLi4nO1xuICAgIGlmIChlcnJvcikgc3VibWl0VGV4dCA9IGVycm9yO1xuXG4gICAgLy8gUmV0dXJuIG5vdGhpbmcgaWYgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBkaXNhYmxlZFxuICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVkKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiAoXG4gICAgICA8U3R5bGVkU2xhY2tGZWVkYmFja1xuICAgICAgICByZWY9e2MgPT4ge1xuICAgICAgICAgIHRoaXMuU2xhY2tGZWVkYmFjayA9IGM7XG4gICAgICAgIH19XG4gICAgICAgIGNsYXNzTmFtZT17Y3goeyBhY3RpdmUgfSl9XG4gICAgICA+XG4gICAgICAgIDxDb250YWluZXJcbiAgICAgICAgICByZWY9e2MgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBjO1xuICAgICAgICAgIH19XG4gICAgICAgICAgY2xhc3NOYW1lPXtjeCgnZmFkZUluVXAnLCB7IGFjdGl2ZSB9KX1cbiAgICAgICAgICBzdHlsZT17dGhpcy5wcm9wcy5jb250ZW50U3R5bGVzfVxuICAgICAgICA+XG4gICAgICAgICAgPEhlYWRlcj5cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLnRpdGxlfVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjbG9zZVwiIG9uQ2xpY2s9e3RoaXMuY2xvc2V9PlxuICAgICAgICAgICAgICB7dGhpcy5wcm9wcy5jbG9zZUJ1dHRvbn1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvSGVhZGVyPlxuXG4gICAgICAgICAgPENvbnRlbnQ+XG4gICAgICAgICAgICB7c2hvd0NoYW5uZWwgJiYgPExhYmVsPkNoYW5uZWw8L0xhYmVsPn1cbiAgICAgICAgICAgIDxJbnB1dCB2YWx1ZT17dGhpcy5wcm9wcy5jaGFubmVsfSBkaXNhYmxlZCBoaWRkZW49eyFzaG93Q2hhbm5lbH0gLz5cblxuICAgICAgICAgICAgPExhYmVsPkZlZWRiYWNrIFR5cGU8L0xhYmVsPlxuICAgICAgICAgICAgPFRhYnM+XG4gICAgICAgICAgICAgIHt0eXBlcy5tYXAodHlwZSA9PiAoXG4gICAgICAgICAgICAgICAgPGxpXG4gICAgICAgICAgICAgICAgICBrZXk9e3R5cGUudmFsdWV9XG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXt0aGlzLnNlbGVjdFR5cGUodHlwZS5sYWJlbCl9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2N4KHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkVHlwZSA9PT0gdHlwZS5sYWJlbFxuICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge3R5cGUubGFiZWx9XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICA8L1RhYnM+XG5cbiAgICAgICAgICAgIDxMYWJlbD5Zb3VyIE1lc3NhZ2U8L0xhYmVsPlxuICAgICAgICAgICAgPFRleHRhcmVhXG4gICAgICAgICAgICAgIHJlZj17YyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gYztcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJNZXNzYWdlLi4uXCJcbiAgICAgICAgICAgIC8+XG5cbiAgICAgICAgICAgIHsvKiBPbmx5IHJlbmRlciB0aGUgaW1hZ2UgdXBsb2FkIGlmIHRoZXJlJ3MgY2FsbGJhY2sgYXZhaWxhYmxlICAqL31cbiAgICAgICAgICAgIHt0aGlzLnByb3BzLm9uSW1hZ2VVcGxvYWQgPyB0aGlzLnJlbmRlckltYWdlVXBsb2FkKCkgOiBudWxsfVxuXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6ICcwLjVlbSAwIDFlbScgfX0+XG4gICAgICAgICAgICAgIDxDaGVja2JveFxuICAgICAgICAgICAgICAgIGlkPVwic2VuZFVSTFwiXG4gICAgICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICBjaGVja2VkPXtzZW5kVVJMfVxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLnRvZ2dsZVNlbmRVUkx9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxDaGVja2JveExhYmVsIGZvcj1cInNlbmRVUkxcIj5cbiAgICAgICAgICAgICAgICBTZW5kIFVSTCB3aXRoIEZlZWRiYWNrXG4gICAgICAgICAgICAgIDwvQ2hlY2tib3hMYWJlbD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8U3VibWl0QnV0dG9uXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y3goe1xuICAgICAgICAgICAgICAgIHNlbnQsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHNlbmRpbmcgfHwgdXBsb2FkaW5nSW1hZ2VcbiAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuc2VuZH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3N1Ym1pdFRleHR9XG4gICAgICAgICAgICA8L1N1Ym1pdEJ1dHRvbj5cbiAgICAgICAgICA8L0NvbnRlbnQ+XG4gICAgICAgIDwvQ29udGFpbmVyPlxuXG4gICAgICAgIDxUcmlnZ2VyXG4gICAgICAgICAgc3R5bGU9e3RoaXMucHJvcHMudHJpZ2dlclN0eWxlc31cbiAgICAgICAgICBjbGFzc05hbWU9e2N4KHsgYWN0aXZlIH0pfVxuICAgICAgICAgIG9uQ2xpY2s9e3RoaXMudG9nZ2xlfVxuICAgICAgICA+XG4gICAgICAgICAge3RoaXMucHJvcHMuYnV0dG9uVGV4dH1cbiAgICAgICAgPC9UcmlnZ2VyPlxuICAgICAgPC9TdHlsZWRTbGFja0ZlZWRiYWNrPlxuICAgICk7XG4gIH1cbn1cblxuU2xhY2tGZWVkYmFjay5wcm9wVHlwZXMgPSB7XG4gIGNoYW5uZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHVzZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgZW1vamk6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGJ1dHRvblRleHQ6IFByb3BUeXBlcy5ub2RlLFxuICBpbWFnZVVwbG9hZFRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHRyaWdnZXJTdHlsZXM6IFByb3BUeXBlcy5vYmplY3QsXG4gIGNvbnRlbnRTdHlsZXM6IFByb3BUeXBlcy5vYmplY3QsXG4gIHNob3dDaGFubmVsOiBQcm9wVHlwZXMuYm9vbCxcbiAgdGl0bGU6IFByb3BUeXBlcy5ub2RlLFxuICBjbG9zZUJ1dHRvbjogUHJvcFR5cGVzLm5vZGUsXG4gIGVycm9yVGltZW91dDogUHJvcFR5cGVzLm51bWJlcixcbiAgc2VudFRpbWVvdXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIG9uU3VibWl0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBvbkltYWdlVXBsb2FkOiBQcm9wVHlwZXMuZnVuY1xufTtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5TbGFja0ZlZWRiYWNrLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2hhbm5lbDogJycsXG4gIHVzZXI6ICdVbmtub3duIFVzZXInLFxuICBkaXNhYmxlZDogZmFsc2UsXG4gIGVtb2ppOiAnOnNwZWFraW5nX2hlYWRfaW5fc2lsaG91ZXR0ZTonLFxuICBidXR0b25UZXh0OiAoXG4gICAgPHNwYW4+XG4gICAgICA8U2xhY2tJY29uIC8+IFNsYWNrIEZlZWRiYWNrXG4gICAgPC9zcGFuPlxuICApLFxuICBpbWFnZVVwbG9hZFRleHQ6ICdBdHRhY2ggSW1hZ2UnLFxuICB0cmlnZ2VyU3R5bGVzOiB7fSxcbiAgY29udGVudFN0eWxlczoge30sXG4gIHNob3dDaGFubmVsOiB0cnVlLFxuICB0aXRsZTogKFxuICAgIDxzcGFuPlxuICAgICAgPFNsYWNrSWNvbiAvPiBTZW5kIEZlZWRiYWNrIHRvIFNsYWNrXG4gICAgPC9zcGFuPlxuICApLFxuICBjbG9zZUJ1dHRvbjogJ2Nsb3NlJyxcbiAgZXJyb3JUaW1lb3V0OiA4ICogMTAwMCxcbiAgc2VudFRpbWVvdXQ6IDUgKiAxMDAwLFxuICBvbkltYWdlVXBsb2FkOiBub29wXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTbGFja0ZlZWRiYWNrO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBmZXRjaCBmcm9tICdpc29tb3JwaGljLWZldGNoJztcbmltcG9ydCBTbGFja0ZlZWRiYWNrIGZyb20gJy4vZmVlZGJhY2snO1xuXG5jb25zdCBBcHAgPSAoeyBjaGlsZHJlbiB9KSA9PiA8ZGl2PntjaGlsZHJlbn08L2Rpdj47XG5cbkFwcC5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkXG59O1xuXG4vKipcbiAqIFNlbmQgcGF5bG9hZCB0byBzZXJ2ZXJcbiAqIEBtZXRob2Qgc2VuZFRvU2xhY2tcbiAqIEBwYXJhbSAge09iamVjdH0gcGF5bG9hZFxuICogQHJldHVybiB7bnVsbH1cbiAqL1xuY29uc3Qgc2VuZFRvU2xhY2sgPSBwYXlsb2FkID0+IHtcbiAgZmV0Y2goJy9hcGkvc2xhY2snLCB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZClcbiAgfSlcbiAgICAudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbiAgICAudGhlbihyZXMgPT4ge1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgdGhpcy5zZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9yKHJlcyk7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFVwbG9hZCBpbWFnZSB0byBzZXJ2ZXJcbiAqIEBtZXRob2QgdXBsb2FkSW1hZ2VcbiAqIEBwYXJhbSAge0ZpbGV9IGZpbGVcbiAqIEByZXR1cm4ge251bGx9XG4gKi9cbmNvbnN0IHVwbG9hZEltYWdlID0gZmlsZSA9PiB7XG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9ybS5hcHBlbmQoJ2ltYWdlJywgZmlsZSk7XG5cbiAgZmV0Y2goJy9hcGkvdXBsb2FkJywge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGJvZHk6IGZvcm1cbiAgfSlcbiAgICAudGhlbihyZXMgPT4ge1xuICAgICAgY29uc29sZS5sb2cocmVzLnN0YXR1cywgcmVzLnN0YXR1c1RleHQpO1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPCAyMDAgfHwgcmVzLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgdGhpcy51cGxvYWRFcnJvcihyZXMuc3RhdHVzVGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXMuanNvbigpO1xuICAgIH0pXG4gICAgLnRoZW4odXJsID0+IHRoaXMuaW1hZ2VVcGxvYWRlZCh1cmwpKTtcbn07XG5cbmNvbnN0IHJvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpO1xuXG5SZWFjdERPTS5yZW5kZXIoXG4gIDxBcHA+XG4gICAgPFNsYWNrRmVlZGJhY2tcbiAgICAgIG9uU3VibWl0PXtzZW5kVG9TbGFja31cbiAgICAgIG9uSW1hZ2VVcGxvYWQ9e3VwbG9hZEltYWdlfVxuICAgICAgdXNlcj1cIm1hcmttdXJcIlxuICAgICAgZW1vamk9XCI6YnVnOlwiXG4gICAgICBjaGFubmVsPVwiI2ZlZWRiYWNrXCJcbiAgICAvPlxuICA8L0FwcD4sXG4gIHJvb3Rcbik7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTbGFja0ljb24oKSB7XG4gIHJldHVybiAoXG4gICAgPHN2ZyBpZD1cIlNsYWNrSWNvblwiIHdpZHRoPVwiMTZweFwiIGhlaWdodD1cIjE2cHhcIiB2aWV3Qm94PVwiMCAwIDI1NiAyNTZcIiB2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zWGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkXCI+PGc+PHBhdGggZD1cIk0xNjUuOTYzNTQxLDE1LjgzODQyNjIgQzE2Mi4wNzMxOCwzLjg2MzA4MTk3IDE0OS4yMTIzMjgsLTIuNjkwMDk4MzYgMTM3LjIzOTA4MiwxLjIwMjM2MDY2IEMxMjUuMjYzNzM4LDUuMDkyNzIxMzEgMTE4LjcxMDU1NywxNy45NTM1NzM4IDEyMi42MDMwMTYsMjkuOTI2ODE5NyBMMTgxLjU1MDE2NCwyMTEuMjkyMzI4IEMxODUuNTk3OTAyLDIyMi40Nzg2ODkgMTk3LjY4MjM2MSwyMjguNzY1Mzc3IDIwOS4yODIwOTgsMjI1LjQyNjg4NSBDMjIxLjM4MTI0NiwyMjEuOTQzNjA3IDIyOC43NTY5ODQsMjA5LjA5MzI0NiAyMjQuODk2LDE5Ny4yMTAyMyBDMjI0Ljc0OTExNSwxOTYuNzU2OTg0IDE2NS45NjM1NDEsMTUuODM4NDI2MiAxNjUuOTYzNTQxLDE1LjgzODQyNjJcIiBmaWxsPVwiI0RGQTIyRlwiPjwvcGF0aD48cGF0aCBkPVwiTTc0LjYyNjA5ODQsNDUuNTE1NTQxIEM3MC43MzM2MzkzLDMzLjU0MjI5NTEgNTcuODcyNzg2OSwyNi45ODkxMTQ4IDQ1Ljg5OTU0MSwzMC44Nzk0NzU0IEMzMy45MjQxOTY3LDM0Ljc2OTgzNjEgMjcuMzcxMDE2NCw0Ny42MzA2ODg1IDMxLjI2MzQ3NTQsNTkuNjA2MDMyOCBMOTAuMjEwNjIzLDI0MC45NzE1NDEgQzk0LjI1ODM2MDcsMjUyLjE1NzkwMiAxMDYuMzQyODIsMjU4LjQ0NDU5IDExNy45NDI1NTcsMjU1LjEwNCBDMTMwLjA0MTcwNSwyNTEuNjIyODIgMTM3LjQxNzQ0MywyMzguNzcyNDU5IDEzMy41NTY0NTksMjI2Ljg4NzM0NCBDMTMzLjQwOTU3NCwyMjYuNDM2MTk3IDc0LjYyNjA5ODQsNDUuNTE1NTQxIDc0LjYyNjA5ODQsNDUuNTE1NTQxXCIgZmlsbD1cIiMzQ0IxODdcIj48L3BhdGg+PHBhdGggZD1cIk0yNDAuMTYxNTc0LDE2Ni4wNDUzNzcgQzI1Mi4xMzY5MTgsMTYyLjE1NTAxNiAyNTguNjg4LDE0OS4yOTQxNjQgMjU0Ljc5NzYzOSwxMzcuMzE4ODIgQzI1MC45MDcyNzksMTI1LjM0NTU3NCAyMzguMDQ2NDI2LDExOC43OTIzOTMgMjI2LjA3MzE4LDEyMi42ODI3NTQgTDQ0LjcwNzY3MjEsMTgxLjYzMiBDMzMuNTIxMzExNSwxODUuNjc3NjM5IDI3LjIzNDYyMywxOTcuNzYyMDk4IDMwLjU3MzExNDgsMjA5LjM2MTgzNiBDMzQuMDU2MzkzNCwyMjEuNDYwOTg0IDQ2LjkwNjc1NDEsMjI4LjgzNjcyMSA1OC43ODk3NzA1LDIyNC45NzU3MzggQzU5LjI0MzAxNjQsMjI0LjgyODg1MiAyNDAuMTYxNTc0LDE2Ni4wNDUzNzcgMjQwLjE2MTU3NCwxNjYuMDQ1Mzc3XCIgZmlsbD1cIiNDRTFFNUJcIj48L3BhdGg+PHBhdGggZD1cIk04Mi41MDc1NDEsMjE3LjI3MDU1NyBDOTQuMzEyOTE4LDIxMy40MzQ3NTQgMTA5LjUyODEzMSwyMDguNDkxMDE2IDEyNS44NTU0NzUsMjAzLjE4NjM2MSBDMTIyLjAxOTY3MiwxOTEuMzgwOTg0IDExNy4wNzU5MzQsMTc2LjE2MzY3MiAxMTEuNzY5MTgsMTU5LjgzNDIzIEw2OC40MTkxNDc1LDE3My45MjQ3MjEgTDgyLjUwNzU0MSwyMTcuMjcwNTU3XCIgZmlsbD1cIiMzOTI1MzhcIj48L3BhdGg+PHBhdGggZD1cIk0xNzMuODQ3MDgyLDE4Ny41OTEzNDQgQzE5MC4yMzUyNzksMTgyLjI2NzgwMyAyMDUuNDY3Mjc5LDE3Ny4zMTc3NyAyMTcuMTk1MDE2LDE3My41MDcxNDggQzIxMy4zNTkyMTMsMTYxLjcwMTc3IDIwOC40MTMzNzcsMTQ2LjQ4MDI2MiAyMDMuMTA2NjIzLDEzMC4xNDY2MjMgTDE1OS43NTY1OSwxNDQuMjM3MTE1IEwxNzMuODQ3MDgyLDE4Ny41OTEzNDRcIiBmaWxsPVwiI0JCMjQyQVwiPjwvcGF0aD48cGF0aCBkPVwiTTIxMC40ODQ0NTksNzQuNzA1ODM2MSBDMjIyLjQ1NzcwNSw3MC44MTU0NzU0IDIyOS4wMTA4ODUsNTcuOTU0NjIzIDIyNS4xMjA1MjUsNDUuOTc5Mjc4NyBDMjIxLjIzMDE2NCwzNC4wMDYwMzI4IDIwOC4zNjkzMTEsMjcuNDUyODUyNSAxOTYuMzkzOTY3LDMxLjM0MzIxMzEgTDE1LjAyODQ1OSw5MC4yOTI0NTkgQzMuODQyMDk4MzYsOTQuMzM4MDk4NCAtMi40NDQ1OTAxNiwxMDYuNDIyNTU3IDAuODk2LDExOC4wMjIyOTUgQzQuMzc3MTgwMzMsMTMwLjEyMTQ0MyAxNy4yMjc1NDEsMTM3LjQ5NzE4IDI5LjExMjY1NTcsMTMzLjYzNjE5NyBDMjkuNTYzODAzMywxMzMuNDg5MzExIDIxMC40ODQ0NTksNzQuNzA1ODM2MSAyMTAuNDg0NDU5LDc0LjcwNTgzNjFcIiBmaWxsPVwiIzcyQzVDRFwiPjwvcGF0aD48cGF0aCBkPVwiTTUyLjgyMjAzMjgsMTI1LjkzMzExNSBDNjQuNjI3NDA5OCwxMjIuMDk3MzExIDc5Ljg0NjgxOTcsMTE3LjE1MTQ3NSA5Ni4xNzYyNjIzLDExMS44NDY4MiBDOTAuODUyNzIxMyw5NS40NTY1MjQ2IDg1LjkwMjY4ODUsODAuMjI0NTI0NiA4Mi4wOTIwNjU2LDY4LjQ5NDY4ODUgTDM4LjczMTU0MSw4Mi41ODcyNzg3IEw1Mi44MjIwMzI4LDEyNS45MzMxMTVcIiBmaWxsPVwiIzI0OEM3M1wiPjwvcGF0aD48cGF0aCBkPVwiTTE0NC4xNTk0NzUsOTYuMjU2IEMxNjAuNTUxODY5LDkwLjkzMDM2MDcgMTc1Ljc4NTk2Nyw4NS45ODAzMjc5IDE4Ny41MTU4MDMsODIuMTY3NjA2NiBDMTgyLjE5MDE2NCw2NS43NzUyMTMxIDE3Ny4yNDAxMzEsNTAuNTM5MDE2NCAxNzMuNDI3NDEsMzguODA3MDgyIEwxMzAuMDY4OTg0LDUyLjg5OTY3MjEgTDE0NC4xNTk0NzUsOTYuMjU2XCIgZmlsbD1cIiM2MjgwM0FcIj48L3BhdGg+PC9nPjwvc3ZnPlxuICApO1xufVxuIiwiaW1wb3J0IHN0eWxlZCwgeyBrZXlmcmFtZXMsIGNzcyB9IGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcblxuY29uc3QgZm9udFN0YWNrID1cbiAgJy1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgQXJpYWwsIEFyaWFsIFVuaWNvZGUsIFwiSGVsdmV0aWNhIE5ldWVcIiwgSGVsdmV0aWNhLCBcIkhpcmFnaW5vIFNhbnMgR0JcIiwgXCJNaWNyb3NvZnQgWWFIZWlcIiwgU2ltU3VuLCBzYW5zLXNlcmlmJztcblxuY29uc3QgdGhlbWUgPSB7XG4gIGZvbnQ6IGZvbnRTdGFjayxcbiAgYm9yZGVyOiAnI2QwZDhlMScsXG4gIHByaW1hcnk6ICcjMDA4OGZmJyxcbiAgc2Vjb25kYXJ5OiAnIzIyMmM0ZicsXG4gIGJhY2tncm91bmQ6ICcjZjRmNGY3JyxcbiAgc3VjY2VzczogJyMzZGM4NmYnLFxuICBlcnJvcjogJyNlYzNjM2MnLFxuICB0ZXh0OiAnIzg1OGJhMCcsXG4gIGxvYWRlcjoge1xuICAgIGNvbG9yOiAnI2ZmZmZmZicsXG4gICAgc2l6ZTogJzRlbScsXG4gICAgd2lkdGg6ICc3cHgnXG4gIH1cbn07XG5cbmNvbnN0IHJlc2V0cyA9IGNzc2BcbiAgYm94LXNoYWRvdzogbm9uZTtcbiAgY29sb3I6IGluaGVyaXQ7XG4gIG1hcmdpbjogaW5oZXJpdDtcbiAgcGFkZGluZzogaW5oZXJpdDtcbmA7XG5cbmNvbnN0IGZvcm1TdHlsZXMgPSBjc3NgXG4gICR7cmVzZXRzfTtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbmA7XG5cbmNvbnN0IGZhZGVJblVwID0ga2V5ZnJhbWVzYFxuICBmcm9tIHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMTAlLCAwKTtcbiAgfVxuXG4gIHRvIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRyYW5zZm9ybTogbm9uZTtcbiAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbkZhZGVJblVwID0gY3NzYFxuICBhbmltYXRpb246ICR7ZmFkZUluVXB9IDAuNHMgZWFzZTtcbiAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcbmA7XG5cbmNvbnN0IGZhZGVPdXREb3duID0ga2V5ZnJhbWVzYFxuICBmcm9tIHtcbiAgICBvcGFjaXR5OiAxO1xuICAgIHRyYW5zZm9ybTogbm9uZTtcbiAgfVxuXG4gIHRvIHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAxMCUsIDApO1xuICB9XG5gO1xuXG5leHBvcnQgY29uc3QgYW5pbWF0aW9uRmFkZU91dERvd24gPSBjc3NgXG4gIGFuaW1hdGlvbjogJHtmYWRlT3V0RG93bn0gMC40cyBlYXNlO1xuICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xuYDtcblxuY29uc3QgbG9hZCA9IGtleWZyYW1lc2BcbiAgMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICB9XG4gIDEwMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG4gIH1cbmA7XG5cbmNvbnN0IFNsYWNrRmVlZGJhY2sgPSBzdHlsZWQuZGl2YFxuICBwb3NpdGlvbjogZml4ZWQ7XG4gIGZvbnQtZmFtaWx5OiAke3RoZW1lLmZvbnR9O1xuICB6LWluZGV4OiA5OTk5OTk5ODtcbiAgYm90dG9tOiAxMnB4O1xuICByaWdodDogMDtcbiAgbWFyZ2luOiAxZW07XG5cbiAgJi5hY3RpdmUge1xuICAgIC5TbGFja0ZlZWRiYWNrLS1jb250YWluZXIge1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgfVxuICB9XG5cbiAgKixcbiAgKjpiZWZvcmUsXG4gICo6YWZ0ZXIge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIH1cbmA7XG5cbmNvbnN0IExvYWRlciA9IHN0eWxlZC5kaXZgXG4gIG1hcmdpbjogNTBweCBhdXRvO1xuICBmb250LXNpemU6IDEwcHg7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdGV4dC1pbmRlbnQ6IC05OTk5ZW07XG4gIGJvcmRlci10b3A6ICR7dGhlbWUubG9hZGVyLndpZHRofSBzb2xpZCByZ2JhKCNmZmZmZmYsIDAuMik7XG4gIGJvcmRlci1yaWdodDogJHt0aGVtZS5sb2FkZXIud2lkdGh9IHNvbGlkIHJnYmEoI2ZmZmZmZiwgMC4yKTtcbiAgYm9yZGVyLWJvdHRvbTogJHt0aGVtZS5sb2FkZXIud2lkdGh9IHNvbGlkIHJnYmEoI2ZmZmZmZiwgMC4yKTtcbiAgYm9yZGVyLWxlZnQ6ICR7dGhlbWUubG9hZGVyLndpZHRofSBzb2xpZCAke3RoZW1lLmxvYWRlci5jb2xvcn07XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgYW5pbWF0aW9uOiAke2xvYWR9IDAuNXMgaW5maW5pdGUgbGluZWFyO1xuICBib3JkZXItcmFkaXVzOiA1MCU7XG4gIHdpZHRoOiAke3RoZW1lLmxvYWRlci5zaXplfTtcbiAgaGVpZ2h0OiAke3RoZW1lLmxvYWRlci5zaXplfTtcblxuICAmOmFmdGVyIHtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgd2lkdGg6ICR7dGhlbWUubG9hZGVyLnNpemV9O1xuICAgIGhlaWdodDogJHt0aGVtZS5sb2FkZXIuc2l6ZX07XG4gIH1cbmA7XG5cbmNvbnN0IENvbnRhaW5lciA9IHN0eWxlZC5kaXZgXG4gIGJhY2tncm91bmQ6ICR7dGhlbWUuYmFja2dyb3VuZH07XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgei1pbmRleDogOTk5OTk5OTk5O1xuICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIG1hcmdpbi1ib3R0b206IDEuNWVtO1xuICB3aWR0aDogMzYwcHg7XG4gIHRvcDogLTIuNWVtO1xuICByaWdodDogMDtcbiAgYm94LXNoYWRvdzogMCA2cHggMzBweCAycHggcmdiYSgke3RoZW1lLnNlY29uZGFyeX0sIDAuMyk7XG5cbiAgLmFjdGl2ZSB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gIH1cbmA7XG5cbmNvbnN0IEhlYWRlciA9IHN0eWxlZC5kaXZgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGJhY2tncm91bmQ6ICR7dGhlbWUuc2Vjb25kYXJ5fTtcbiAgcGFkZGluZzogMC43NWVtIDFlbTtcbiAgYm9yZGVyLXJhZGl1czogM3B4IDNweCAwIDA7XG4gIGZvbnQtc2l6ZTogMTRweDtcbiAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgY29sb3I6ICNmZmZmZmY7XG5cbiAgPiBpbWcge1xuICAgIG1hcmdpbi1yaWdodDogMC41ZW07XG4gIH1cblxuICA+IC5jbG9zZSB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIG9wYWNpdHk6IDAuNztcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgICBmb250LXNpemU6IDExcHg7XG5cbiAgICAmOmhvdmVyIHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgfVxuICB9XG5gO1xuXG5jb25zdCBDb250ZW50ID0gc3R5bGVkLmRpdmBcbiAgcGFkZGluZzogMC41ZW07XG5gO1xuXG5jb25zdCBJY29uID0gc3R5bGVkLmRpdmBcbiAgbWFyZ2luLXJpZ2h0OiAwLjVlbTtcbmA7XG5cbmNvbnN0IFRyaWdnZXIgPSBzdHlsZWQuZGl2YFxuICBkaXNwbGF5OiBmbGV4O1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHJpZ2h0OiAwO1xuICBib3R0b206IDA7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGJhY2tncm91bmQ6ICNmZmZmZmY7XG4gIGNvbG9yOiAke3RoZW1lLnRleHR9O1xuICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lLmJvcmRlcn07XG4gICNmZmZmZmYtc3BhY2U6IG5vd3JhcDtcbiAgcGFkZGluZzogMTJweCAxLjI1ZW07XG4gIGJvcmRlci1yYWRpdXM6IDMwcHg7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBmb250LXdlaWdodDogNTAwO1xuICBib3gtc2hhZG93OiAwIDNweCAxMnB4IDFweCByZ2JhKCR7dGhlbWUuc2Vjb25kYXJ5fSwgMC4xKTtcbiAgdHJhbnNpdGlvbjogYm94LXNoYWRvdyAwLjNzLCB0cmFuc2Zvcm0gMC4ycyBlYXNlLWluLCBjb2xvciAwLjJzO1xuXG4gICY6aG92ZXIsXG4gICYuYWN0aXZlIHtcbiAgICBib3gtc2hhZG93OiAwIDZweCAxNnB4IDJweCByZ2JhKCMwMDAwMDAsIDAuMik7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0zcHgpO1xuICAgIGNvbG9yOiAjNWQ2MDZjO1xuICAgIGJvcmRlci1jb2xvcjogZGFya2VuKCR7dGhlbWUuYm9yZGVyfSwgMTAlKTtcbiAgfVxuXG4gIGltZyB7XG4gICAgbWFyZ2luLXJpZ2h0OiA4cHg7XG4gIH1cbmA7XG5cbmNvbnN0IFRhYnMgPSBzdHlsZWQudWxgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGxpc3Qtc3R5bGU6IG5vbmU7XG4gIHBhZGRpbmc6IDA7XG4gIG1hcmdpbjogMDtcbiAgbWFyZ2luLWJvdHRvbTogMWVtO1xuXG4gID4gbGkge1xuICAgIGZsZXg6IDE7XG4gICAgYmFja2dyb3VuZDogcmdiYSgjZmZmZmZmLCAwLjYpO1xuICAgIGNvbG9yOiAjNWQ2MDZjO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBwYWRkaW5nOiAwLjc1ZW07XG4gICAgZm9udC1zaXplOiAxM3B4O1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lLmJvcmRlcn07XG5cbiAgICAmLnNlbGVjdGVkIHtcbiAgICAgIGJvcmRlci1jb2xvcjogIzA4ZjtcbiAgICAgIGJhY2tncm91bmQ6ICNmZmZmZmY7XG4gICAgICBjb2xvcjogIzA4ZjtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIHRleHQtc2hhZG93OiAwIDFweCA2cHggcmdiYSgke3RoZW1lLnByaW1hcnl9LCAwLjEpO1xuICAgICAgYm94LXNoYWRvdzogMCAwIDhweCByZ2JhKCR7dGhlbWUucHJpbWFyeX0sIDAuMik7XG4gICAgfVxuXG4gICAgJjpob3Zlcjpub3QoLnNlbGVjdGVkKSB7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCBkYXJrZW4oJHt0aGVtZS5ib3JkZXJ9LCA4JSk7XG4gICAgfVxuXG4gICAgJjpmaXJzdC1vZi10eXBlIHtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDRweCAwIDAgNHB4O1xuICAgICAgbWFyZ2luLXJpZ2h0OiAtMXB4O1xuICAgIH1cblxuICAgICY6bGFzdC1vZi10eXBlIHtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDAgNHB4IDRweCAwO1xuICAgICAgbWFyZ2luLWxlZnQ6IC0xcHg7XG4gICAgfVxuICB9XG5gO1xuXG5jb25zdCBJbWFnZVVwbG9hZCA9IHN0eWxlZC5kaXZgXG4gID4gaW5wdXQge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cbmA7XG5cbmNvbnN0IFVwbG9hZEJ1dHRvbiA9IHN0eWxlZC5idXR0b25gXG4gIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWUuYm9yZGVyfTtcbiAgcGFkZGluZzogMC43NWVtIDNlbTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBmb250LXNpemU6IDEzcHg7XG4gIG1hcmdpbjogYXV0bztcbiAgd2lkdGg6IDEwMCU7XG4gIGRpc3BsYXk6IHRhYmxlO1xuICBjb2xvcjogZGFya2VuKCR7dGhlbWUudGV4dH0sIDUlKTtcbiAgYmFja2dyb3VuZDogI2ZmZmZmZjtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBib3JkZXItcmFkaXVzOiA0cHg7XG5cbiAgJjpob3ZlciB7XG4gICAgYm9yZGVyOiAxcHggc29saWQgZGFya2VuKCR7dGhlbWUuYm9yZGVyfSwgNyUpO1xuICAgIGJhY2tncm91bmQ6IHJnYmEoI2ZmZmZmZiwgMC42KTtcbiAgICBjb2xvcjogZGFya2VuKCR7dGhlbWUudGV4dH0sIDUlKTtcbiAgfVxuYDtcblxuY29uc3QgSW5wdXQgPSBzdHlsZWQuaW5wdXRgXG4gIG1hcmdpbi1ib3R0b206IDAuNzVlbTtcbiAgY29sb3I6ICR7dGhlbWUudGV4dH07XG5gO1xuXG5jb25zdCBUZXh0YXJlYSA9IHN0eWxlZC50ZXh0YXJlYWBcbiAgbWluLWhlaWdodDogMTUwcHg7XG5gO1xuXG5jb25zdCBMYWJlbCA9IHN0eWxlZC5sYWJlbGBcbiAgY29sb3I6ICR7dGhlbWUucHJpbWFyeX07XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBmb250LXNpemU6IDExcHg7XG4gIG1hcmdpbjogNXB4IDA7XG5gO1xuXG5jb25zdCBGb3JtRWxlbWVudCA9IHN0eWxlZC5pbnB1dGBcbiAgJHtmb3JtU3R5bGVzfTtcblxuICB3aWR0aDogMTAwJTtcbiAgY29sb3I6ICM0NDQ7XG4gIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWUuYm9yZGVyfTtcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xuICBwYWRkaW5nOiAwLjVlbTtcbiAgb3V0bGluZTogbm9uZTtcbiAgZm9udC1zaXplOiAxNHB4O1xuICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xuICBtYXJnaW4tYm90dG9tOiAwLjVlbTtcblxuICAmOmZvY3VzIHtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lLnByaW1hcnl9O1xuICAgIGJveC1zaGFkb3c6IDAgMCA4cHggcmdiYSgke3RoZW1lLnByaW1hcnl9LCAwLjMpO1xuICB9XG5cbiAgJltkaXNhYmxlZF0sXG4gICYuZGlzYWJsZWQge1xuICAgIG9wYWNpdHk6IDAuODtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICBjb2xvcjogZGFya2VuKCR7dGhlbWUudGV4dH0sIDEzJSk7XG4gIH1cbmA7XG5cbmNvbnN0IENoZWNrYm94ID0gc3R5bGVkLmlucHV0YFxuICAke2Zvcm1TdHlsZXN9O1xuICBhcHBlYXJhbmNlOiBjaGVja2JveDtcbiAgcG9zaXRpb246IHN0YXRpYztcbiAgZm9udC1zaXplOiAxLjFlbTtcblxuICAmOjpiZWZvcmUsXG4gICY6OmFmdGVyIHtcbiAgICBjb250ZW50OiBub25lO1xuICB9XG5gO1xuXG5jb25zdCBDaGVja2JveExhYmVsID0gc3R5bGVkLmxhYmVsYFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIG1hcmdpbi1sZWZ0OiAxMHB4O1xuICBjb2xvcjogaW5oZXJpdDtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBjb2xvcjogIzg1OGJhMDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICY6aG92ZXIge1xuICAgIGNvbG9yOiBkYXJrZW4oIzg1OGJhMCwgNSUpO1xuICB9XG5gO1xuXG5jb25zdCBTdWJtaXRCdXR0b24gPSBzdHlsZWQuYnV0dG9uYFxuICBkaXNwbGF5OiBibG9jaztcbiAgd2lkdGg6IDEwMCU7XG4gIHBhZGRpbmc6IDFlbSAwLjc1ZW07XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgYmFja2dyb3VuZDogJHt0aGVtZS5wcmltYXJ5fTtcbiAgY29sb3I6ICNmZmZmZmY7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG4gIG91dGxpbmU6IG5vbmU7XG4gIGJvcmRlcjogbm9uZTtcbiAgZm9udC1zaXplOiAxMXB4O1xuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICBsZXR0ZXItc3BhY2luZzogMC41cHg7XG4gIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMnMsIGJveC1zaGFkb3cgMC4ycztcblxuICAmW2Rpc2FibGVkXSxcbiAgJi5kaXNhYmxlZCB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgb3BhY2l0eTogMC40O1xuICB9XG5cbiAgJi5zZW50IHtcbiAgICBiYWNrZ3JvdW5kOiAke3RoZW1lLnN1Y2Nlc3N9O1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG5cbiAgJi5lcnJvciB7XG4gICAgYmFja2dyb3VuZDogJHt0aGVtZS5lcnJvcn07XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cblxuICAmOmhvdmVyIHtcbiAgICBiYWNrZ3JvdW5kOiBsaWdodGVuKCR7dGhlbWUucHJpbWFyeX0sIDclKTtcbiAgICBib3gtc2hhZG93OiAwIDJweCA4cHggMnB4IHJnYmEoJHt0aGVtZS5wcmltYXJ5fSwgMC4yKTtcbiAgfVxuYDtcblxuY29uc3QgUHJldmlld092ZXJsYXkgPSBzdHlsZWQuZGl2YFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgcmlnaHQ6IDA7XG4gIGJvdHRvbTogMDtcbiAgbGVmdDogMDtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBiYWNrZ3JvdW5kOiByZ2JhKCR7dGhlbWUuc2Vjb25kYXJ5fSwgMC40KTtcbiAgb3BhY2l0eTogMDtcblxuICBzcGFuIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiA1MCU7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgIHBhZGRpbmc6IDFlbSAzZW07XG4gICAgZm9udC1zaXplOiAxMnB4O1xuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgY29sb3I6ICNmZmZmZmY7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKCR7dGhlbWUuc2Vjb25kYXJ5fSwgMC42KTtcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDAuMTVzO1xuXG4gICAgJjpob3ZlciB7XG4gICAgICBiYWNrZ3JvdW5kOiAke3RoZW1lLnByaW1hcnl9O1xuICAgIH1cbiAgfVxuYDtcblxuY29uc3QgSW1hZ2VQcmV2aWV3ID0gc3R5bGVkLmRpdmBcbiAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyIGNlbnRlcjtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxNDBweDtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBtYXJnaW4tYm90dG9tOiA1cHg7XG4gIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWUuYm9yZGVyfTtcblxuICAmOmhvdmVyIHtcbiAgICAuU2xhY2tGZWVkYmFjay0tcHJldmlldy1vdmVybGF5IHtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgfVxuICB9XG5gO1xuXG5jb25zdCBTZWxlY3QgPSBzdHlsZWQuZGl2YFxuICBtYXJnaW4tYm90dG9tOiAwLjVlbTtcblxuICAuU2VsZWN0LWNvbnRyb2wge1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICR7dGhlbWUuYm9yZGVyfTtcbiAgfVxuYDtcblxuZXhwb3J0IHtcbiAgU2xhY2tGZWVkYmFjayxcbiAgTG9hZGVyLFxuICBDb250YWluZXIsXG4gIENvbnRlbnQsXG4gIEhlYWRlcixcbiAgSWNvbixcbiAgVHJpZ2dlcixcbiAgVGFicyxcbiAgQ2hlY2tib3gsXG4gIENoZWNrYm94TGFiZWwsXG4gIExhYmVsLFxuICBUZXh0YXJlYSxcbiAgU3VibWl0QnV0dG9uLFxuICBQcmV2aWV3T3ZlcmxheSxcbiAgSW1hZ2VVcGxvYWQsXG4gIEltYWdlUHJldmlldyxcbiAgU2VsZWN0LFxuICBVcGxvYWRCdXR0b24sXG4gIEZvcm1FbGVtZW50XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==
